/*
This file is part of Ext JS 6.2.0.981

Copyright (c) 2011-2016 Sencha Inc

Contact:  http://www.sencha.com/contact

GNU General Public License Usage
This file may be used under the terms of the GNU General Public License version 3.0 as
published by the Free Software Foundation and appearing in the file LICENSE included in the
packaging of this file.

Please review the following information to ensure the GNU General Public License version 3.0
requirements will be met: http://www.gnu.org/copyleft/gpl.html.

If you are unsure which license is appropriate for your use, please contact the sales department
at http://www.sencha.com/contact.

Version: 6.2.0.981 Build date: 2016-08-31 14:49:44 (08dbbd0ec0b8bc0e014d725fdb7d9650d510b343)

*/
var Ext = Ext || {}; if (!Ext.Toolbar) { Ext.Toolbar = {} } if (!Ext.app) { Ext.app = {} } if (!Ext.app.bind) { Ext.app.bind = {} } if (!Ext.app.domain) { Ext.app.domain = {} } if (!Ext.app.route) { Ext.app.route = {} } if (!Ext.button) { Ext.button = {} } if (!Ext.container) { Ext.container = {} } if (!Ext.core) { Ext.core = {} } if (!Ext.dashboard) { Ext.dashboard = {} } if (!Ext.data) { Ext.data = {} } if (!Ext.data.field) { Ext.data.field = {} } if (!Ext.data.flash) { Ext.data.flash = {} } if (!Ext.data.identifier) { Ext.data.identifier = {} } if (!Ext.data.matrix) { Ext.data.matrix = {} } if (!Ext.data.operation) { Ext.data.operation = {} } if (!Ext.data.proxy) { Ext.data.proxy = {} } if (!Ext.data.reader) { Ext.data.reader = {} } if (!Ext.data.request) { Ext.data.request = {} } if (!Ext.data.schema) { Ext.data.schema = {} } if (!Ext.data.session) { Ext.data.session = {} } if (!Ext.data.validator) { Ext.data.validator = {} } if (!Ext.data.writer) { Ext.data.writer = {} } if (!Ext.dd) { Ext.dd = {} } if (!Ext.direct) { Ext.direct = {} } if (!Ext.dom) { Ext.dom = {} } if (!Ext.dom.Element) { Ext.dom.Element = {} } if (!Ext.drag) { Ext.drag = {} } if (!Ext.drag.proxy) { Ext.drag.proxy = {} } if (!Ext.draw) { Ext.draw = {} } if (!Ext.event) { Ext.event = {} } if (!Ext.event.gesture) { Ext.event.gesture = {} } if (!Ext.event.publisher) { Ext.event.publisher = {} } if (!Ext.flash) { Ext.flash = {} } if (!Ext.form) { Ext.form = {} } if (!Ext.form.Action) { Ext.form.Action = {} } if (!Ext.form.action) { Ext.form.action = {} } if (!Ext.form.field) { Ext.form.field = {} } if (!Ext.form.trigger) { Ext.form.trigger = {} } if (!Ext.fx) { Ext.fx = {} } if (!Ext.fx.animation) { Ext.fx.animation = {} } if (!Ext.fx.easing) { Ext.fx.easing = {} } if (!Ext.fx.layout) { Ext.fx.layout = {} } if (!Ext.fx.layout.card) { Ext.fx.layout.card = {} } if (!Ext.fx.runner) { Ext.fx.runner = {} } if (!Ext.fx.target) { Ext.fx.target = {} } if (!Ext.grid) { Ext.grid = {} } if (!Ext.grid.column) { Ext.grid.column = {} } if (!Ext.grid.feature) { Ext.grid.feature = {} } if (!Ext.grid.filters) { Ext.grid.filters = {} } if (!Ext.grid.filters.filter) { Ext.grid.filters.filter = {} } if (!Ext.grid.header) { Ext.grid.header = {} } if (!Ext.grid.locking) { Ext.grid.locking = {} } if (!Ext.grid.plugin) { Ext.grid.plugin = {} } if (!Ext.grid.property) { Ext.grid.property = {} } if (!Ext.grid.selection) { Ext.grid.selection = {} } if (!Ext.layout) { Ext.layout = {} } if (!Ext.layout.boxOverflow) { Ext.layout.boxOverflow = {} } if (!Ext.layout.component) { Ext.layout.component = {} } if (!Ext.layout.component.field) { Ext.layout.component.field = {} } if (!Ext.layout.container) { Ext.layout.container = {} } if (!Ext.layout.container.border) { Ext.layout.container.border = {} } if (!Ext.layout.container.boxOverflow) { Ext.layout.container.boxOverflow = {} } if (!Ext.list) { Ext.list = {} } if (!Ext.menu) { Ext.menu = {} } if (!Ext.mixin) { Ext.mixin = {} } if (!Ext.override) { Ext.override = {} } if (!Ext.override.sparkline) { Ext.override.sparkline = {} } if (!Ext.overrides) { Ext.overrides = {} } if (!Ext.overrides.app) { Ext.overrides.app = {} } if (!Ext.overrides.app.domain) { Ext.overrides.app.domain = {} } if (!Ext.overrides.dom) { Ext.overrides.dom = {} } if (!Ext.overrides.event) { Ext.overrides.event = {} } if (!Ext.overrides.event.publisher) { Ext.overrides.event.publisher = {} } if (!Ext.overrides.list) { Ext.overrides.list = {} } if (!Ext.overrides.plugin) { Ext.overrides.plugin = {} } if (!Ext.overrides.util) { Ext.overrides.util = {} } if (!Ext.panel) { Ext.panel = {} } if (!Ext.parse) { Ext.parse = {} } if (!Ext.parse.symbol) { Ext.parse.symbol = {} } if (!Ext.perf) { Ext.perf = {} } if (!Ext.picker) { Ext.picker = {} } if (!Ext.plugin) { Ext.plugin = {} } if (!Ext.promise) { Ext.promise = {} } if (!Ext.resizer) { Ext.resizer = {} } if (!Ext.scroll) { Ext.scroll = {} } if (!Ext.selection) { Ext.selection = {} } if (!Ext.slider) { Ext.slider = {} } if (!Ext.sparkline) { Ext.sparkline = {} } if (!Ext.state) { Ext.state = {} } if (!Ext.tab) { Ext.tab = {} } if (!Ext.tip) { Ext.tip = {} } if (!Ext.toolbar) { Ext.toolbar = {} } if (!Ext.tree) { Ext.tree = {} } if (!Ext.tree.plugin) { Ext.tree.plugin = {} } if (!Ext.util) { Ext.util = {} } if (!Ext.util.paintmonitor) { Ext.util.paintmonitor = {} } if (!Ext.util.sizemonitor) { Ext.util.sizemonitor = {} } if (!Ext.util.translatable) { Ext.util.translatable = {} } if (!Ext.ux) { Ext.ux = {} } if (!Ext.ux.form) { Ext.ux.form = {} } if (!Ext.ux.layout) { Ext.ux.layout = {} } if (!Ext.view) { Ext.view = {} } if (!Ext.window) { Ext.window = {} } (function (e) { var b, m = ["constructor", "toString", "valueOf", "toLocaleString"], g = {}, q = {}, d = 0, n, k, s, i, a, h, o, c, j, r = function () { var v, u; k = Ext.Base; s = Ext.ClassManager; for (v = m.length; v-- > 0;) { u = (1 << v); q[g[u] = m[v]] = u } for (v in q) { d |= q[v] } d = ~d; Function.prototype.$isFunction = 1; j = !!(s && s.addAlias); i = Ext.Class.getPreprocessor("config").fn; a = Ext.Class.getPreprocessor("cachedConfig") && Ext.Class.getPreprocessor("cachedConfig").fn; h = Ext.Class.getPreprocessor("platformConfig") && Ext.Class.getPreprocessor("platformConfig").fn; c = Ext.Class.getPreprocessor("privates") && Ext.Class.getPreprocessor("privates").fn; o = Ext.ClassManager.postprocessors.deprecated && Ext.ClassManager.postprocessors.deprecated.fn; b = k.$staticMembers; if (!b) { b = []; for (n in k) { if (k.hasOwnProperty(n)) { b.push(n) } } } e.derive = l; return l.apply(this, arguments) }, t = function (D, z, C) { var w = C.enumerableMembers, A = D.prototype, y, B, x, v, u; if (!z) { return } if (j) { D.addMembers(z) } else { for (y in z) { v = z[y]; if (v && v.$isFunction && !v.$isClass && v !== Ext.emptyFn && v !== Ext.identityFn) { u = A.hasOwnProperty(y) && A[y]; if (u) { v.$previous = u } A[y] = B = v; B.$owner = D; B.$name = y } else { A[y] = v } } for (x = 1; w; x <<= 1) { if (w & x) { w &= ~x; y = g[x]; A[y] = B = z[y]; B.$owner = D; B.$name = y } } } }, p = function (y) { var u = function x() { return y.apply(this, arguments) || null }, w, v; u.prototype = Ext.Object.chain(y.prototype); for (w = b.length; w-- > 0;) { v = b[w]; u[v] = k[v] } return u }, l = function (z, C, X, u, B, L, A, U, x, N, G) { var v = function F() { return this.constructor.apply(this, arguments) || null }, W = v, w = { enumerableMembers: u & d, onCreated: G, onBeforeCreated: t, aliases: U }, J = X.alternateClassName || [], S = Ext.global, O, R, T, I, Q, aa, Z, y, P, E, V, M, H, Y, K = s.alternateToName || s.maps.alternateToName, D = s.nameToAlternates || s.maps.nameToAlternates; for (T = b.length; T-- > 0;) { Z = b[T]; v[Z] = k[Z] } if (X.$isFunction) { X = X(v) } w.data = X; E = X.statics; delete X.statics; X.$className = z; if ("$className" in X) { v.$className = X.$className } v.extend(C); P = v.prototype; if (B) { v.xtype = X.xtype = B[0]; P.xtypes = B } P.xtypesChain = L; P.xtypesMap = A; X.alias = U; W.triggerExtended(v, X, w); if (X.onClassExtended) { v.onExtended(X.onClassExtended, v); delete X.onClassExtended } if (X.privates && c) { c.call(Ext.Class, v, X) } if (E) { if (j) { v.addStatics(E) } else { for (V in E) { if (E.hasOwnProperty(V)) { Y = E[V]; if (Y && Y.$isFunction && !Y.$isClass && Y !== Ext.emptyFn && Y !== Ext.identityFn) { v[V] = H = Y; H.$owner = v; H.$name = V } v[V] = Y } } } } if (X.inheritableStatics) { v.addInheritableStatics(X.inheritableStatics); delete X.inheritableStatics } if (P.onClassExtended) { W.onExtended(P.onClassExtended, W); delete P.onClassExtended } if (X.platformConfig && h) { h.call(Ext.Class, v, X); delete X.platformConfig } if (X.config) { i.call(Ext.Class, v, X) } if (X.cachedConfig && a) { a.call(Ext.Class, v, X); delete X.cachedConfig } if (X.deprecated && o) { o.call(Ext.ClassManager, z, v, X) } w.onBeforeCreated(v, w.data, w); for (T = 0, Q = x && x.length; T < Q; ++T) { v.mixin.apply(v, x[T]) } for (T = 0, Q = U.length; T < Q; T++) { O = U[T]; s.setAlias ? s.setAlias(v, O) : s.addAlias(v, O) } if (X.singleton) { W = new v() } if (!(J instanceof Array)) { J = [J] } M = s.getName(W); for (T = 0, I = J.length; T < I; T++) { R = J[T]; s.classes[R] = W; if (j) { s.addAlternate(v, R) } else { if (M) { K[R] = M; J = D[M] || (D[M] = []); J.push(R) } } } for (T = 0, Q = N.length; T < Q; T += 2) { aa = N[T]; if (!aa) { aa = S } aa[N[T + 1]] = W } s.classes[z] = W; if (!j) { if (M && M !== z) { K[z] = M; J = D[M] || (D[M] = []); J.push(z) } } delete P.alternateClassName; if (w.onCreated) { w.onCreated.call(W, W) } if (z) { s.triggerCreated(z) } return W }; e.derive = r }(Ext.cmd = {})); var Ext = Ext || {}; Ext.Boot = Ext.Boot || (function (h) { var o = document, e = [], k = { disableCaching: (/[?&](?:cache|disableCacheBuster)\b/i.test(location.search) || !(/http[s]?\:/i.test(location.href)) || /(^|[ ;])ext-cache=1/.test(o.cookie)) ? false : true, disableCachingParam: "_dc", loadDelay: false, preserveScripts: true, charset: "UTF-8" }, q = {}, g = /\.css(?:\?|$)/i, n = o.createElement("a"), l = typeof window !== "undefined", i = { browser: l, node: !l && (typeof require === "function"), phantom: (window && (window._phantom || window.callPhantom)) || /PhantomJS/.test(window.navigator.userAgent) }, m = (Ext.platformTags = {}), a = function (s, r, u) { if (u) { a(s, u) } if (s && r && typeof r === "object") { for (var t in r) { s[t] = r[t] } } return s }, p = function () { var t = false, w = Array.prototype.shift.call(arguments), s, u, r, v; if (typeof arguments[arguments.length - 1] === "boolean") { t = Array.prototype.pop.call(arguments) } r = arguments.length; for (s = 0; s < r; s++) { v = arguments[s]; if (typeof v === "object") { for (u in v) { w[t ? u.toLowerCase() : u] = v[u] } } } return w }, c = (typeof Object.keys == "function") ? function (r) { if (!r) { return [] } return Object.keys(r) } : function (r) { var s = [], t; for (t in r) { if (r.hasOwnProperty(t)) { s.push(t) } } return s }, d = { loading: 0, loaded: 0, apply: a, env: i, config: k, assetConfig: q, scripts: {}, currentFile: null, suspendedQueue: [], currentRequest: null, syncMode: false, useElements: true, listeners: [], Request: b, Entry: j, allowMultipleBrowsers: false, browserNames: { ie: "IE", firefox: "Firefox", safari: "Safari", chrome: "Chrome", opera: "Opera", dolfin: "Dolfin", edge: "Edge", webosbrowser: "webOSBrowser", chromeMobile: "ChromeMobile", chromeiOS: "ChromeiOS", silk: "Silk", other: "Other" }, osNames: { ios: "iOS", android: "Android", windowsPhone: "WindowsPhone", webos: "webOS", blackberry: "BlackBerry", rimTablet: "RIMTablet", mac: "MacOS", win: "Windows", tizen: "Tizen", linux: "Linux", bada: "Bada", chromeOS: "ChromeOS", other: "Other" }, browserPrefixes: { ie: "MSIE ", edge: "Edge/", firefox: "Firefox/", chrome: "Chrome/", safari: "Version/", opera: "OPR/", dolfin: "Dolfin/", webosbrowser: "wOSBrowser/", chromeMobile: "CrMo/", chromeiOS: "CriOS/", silk: "Silk/" }, browserPriority: ["edge", "opera", "dolfin", "webosbrowser", "silk", "chromeiOS", "chromeMobile", "ie", "firefox", "safari", "chrome"], osPrefixes: { tizen: "(Tizen )", ios: "i(?:Pad|Phone|Pod)(?:.*)CPU(?: iPhone)? OS ", android: "(Android |HTC_|Silk/)", windowsPhone: "Windows Phone ", blackberry: "(?:BlackBerry|BB)(?:.*)Version/", rimTablet: "RIM Tablet OS ", webos: "(?:webOS|hpwOS)/", bada: "Bada/", chromeOS: "CrOS " }, fallbackOSPrefixes: { windows: "win", mac: "mac", linux: "linux" }, devicePrefixes: { iPhone: "iPhone", iPod: "iPod", iPad: "iPad" }, maxIEVersion: 12, detectPlatformTags: function () { var w = this, r = navigator.userAgent, x = /Mobile(\/|\s)/.test(r), v = document.createElement("div"), A = function (F, D) { if (D === undefined) { D = window } var E = "on" + F.toLowerCase(), G = (E in v); if (!G) { if (v.setAttribute && v.removeAttribute) { v.setAttribute(E, ""); G = typeof v[E] === "function"; if (typeof v[E] !== "undefined") { v[E] = undefined } v.removeAttribute(E) } } return G }, z = function () { var E = {}, L, H, M, N, I, J, F, K, D; J = w.browserPriority.length; for (I = 0; I < J; I++) { N = w.browserPriority[I]; if (!D) { M = w.browserPrefixes[N]; F = r.match(new RegExp("(" + M + ")([\\w\\._]+)")); K = F && F.length > 1 ? parseInt(F[2]) : 0; if (K) { D = true } } else { K = 0 } E[N] = K } if (E.ie) { var G = document.documentMode; if (G >= 8) { E.ie = G } } K = E.ie || false; L = Math.max(K, w.maxIEVersion); for (I = 8; I <= L; ++I) { H = "ie" + I; E[H + "m"] = K ? K <= I : 0; E[H] = K ? K === I : 0; E[H + "p"] = K ? K >= I : 0 } return E }, y = function () { var E = {}, J, K, M, G, H, F, D, I, L; M = c(w.osPrefixes); H = M.length; for (G = 0, L = 0; G < H; G++) { K = M[G]; J = w.osPrefixes[K]; F = r.match(new RegExp("(" + J + ")([^\\s;]+)")); D = F ? F[1] : null; if (D && (D === "HTC_" || D === "Silk/")) { I = 2.3 } else { I = F && F.length > 1 ? parseFloat(F[F.length - 1]) : 0 } if (I) { L++ } E[K] = I } M = c(w.fallbackOSPrefixes); H = M.length; for (G = 0; G < H; G++) { K = M[G]; if (L === 0) { J = w.fallbackOSPrefixes[K]; F = r.toLowerCase().match(new RegExp(J)); E[K] = F ? true : 0 } else { E[K] = 0 } } return E }, B = function () { var E = {}, J, H, I, G, D, F; I = c(w.devicePrefixes); D = I.length; for (G = 0; G < D; G++) { H = I[G]; J = w.devicePrefixes[H]; F = r.match(new RegExp(J)); E[H] = F ? true : 0 } return E }, t = z(), u = y(), C = B(), s = d.loadPlatformsParam(); p(m, t, u, C, s, true); m.phone = !!((m.iphone || m.ipod) || (!m.silk && (m.android && (m.android < 3 || x))) || (m.blackberry && x) || (m.windowsphone)); m.tablet = !!(!m.phone && (m.ipad || m.android || m.silk || m.rimtablet || (m.ie10 && /; Touch/.test(r)))); m.touch = A("touchend") || navigator.maxTouchPoints || navigator.msMaxTouchPoints; m.desktop = !m.phone && !m.tablet; m.cordova = m.phonegap = !!(window.PhoneGap || window.Cordova || window.cordova); m.webview = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)(?!.*FBAN)/i.test(r); m.androidstock = (m.android <= 4.3) && (m.safari || m.silk); p(m, s, true) }, loadPlatformsParam: function () { var r = window.location.search.substr(1), t = r.split("&"), v = {}, x, y = {}, A, w, u, s, z; for (x = 0; x < t.length; x++) { A = t[x].split("="); v[A[0]] = A[1] } if (v.platformTags) { A = v.platformTags.split(","); for (w = A.length, x = 0; x < w; x++) { u = A[x].split(":"); s = u[0]; z = true; if (u.length > 1) { z = u[1]; if (z === "false" || z === "0") { z = false } } y[s] = z } } return y }, filterPlatform: function (t, x) { t = e.concat(t || e); x = e.concat(x || e); var w = t.length, v = x.length, s = (!w && v), u, r; for (u = 0; u < w && !s; u++) { r = t[u]; s = !!m[r] } for (u = 0; u < v && s; u++) { r = x[u]; s = !m[r] } return s }, init: function () { var u = o.getElementsByTagName("script"), x = u[0], v = u.length, B = /\/ext(\-[a-z\-]+)?\.js$/, z, r, s, w, A, t, y; d.hasReadyState = ("readyState" in x); d.hasAsync = ("async" in x); d.hasDefer = ("defer" in x); d.hasOnLoad = ("onload" in x); d.isIE8 = d.hasReadyState && !d.hasAsync && d.hasDefer && !d.hasOnLoad; d.isIE9 = d.hasReadyState && !d.hasAsync && d.hasDefer && d.hasOnLoad; d.isIE10p = d.hasReadyState && d.hasAsync && d.hasDefer && d.hasOnLoad; d.isIE10 = (new Function("/*@cc_on return @_jscript_version @*/")()) === 10; d.isIE10m = d.isIE10 || d.isIE9 || d.isIE8; d.isIE11 = d.isIE10p && !d.isIE10; for (t = 0; t < v; t++) { r = (x = u[t]).src; if (!r) { continue } s = x.readyState || null; if (!w && B.test(r)) { w = r } if (!d.scripts[A = d.canonicalUrl(r)]) { z = new j({ key: A, url: r, done: s === null || s === "loaded" || s === "complete", el: x, prop: "src" }) } } if (!w) { x = u[u.length - 1]; w = x.src } d.baseUrl = w.substring(0, w.lastIndexOf("/") + 1); y = window.location.origin || window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port : ""); d.origin = y; d.detectPlatformTags(); Ext.filterPlatform = d.filterPlatform }, canonicalUrl: function (u) { n.href = u; var t = n.href, s = k.disableCachingParam, w = s ? t.indexOf(s + "=") : -1, v, r; if (w > 0 && ((v = t.charAt(w - 1)) === "?" || v === "&")) { r = t.indexOf("&", w); r = (r < 0) ? "" : t.substring(r); if (r && v === "?") { ++w; r = r.substring(1) } t = t.substring(0, w - 1) + r } return t }, getConfig: function (r) { return r ? d.config[r] : d.config }, setConfig: function (r, u) { if (typeof r === "string") { d.config[r] = u } else { for (var t in r) { d.setConfig(t, r[t]) } } return d }, getHead: function () { return d.docHead || (d.docHead = o.head || o.getElementsByTagName("head")[0]) }, create: function (t, u, r) { var s = r || {}; s.url = t; s.key = u; return d.scripts[u] = new j(s) }, getEntry: function (t, s, r) { var u, v; u = r ? t : d.canonicalUrl(t); v = d.scripts[u]; if (!v) { v = d.create(t, u, s); if (r) { v.canonicalPath = true } } return v }, registerContent: function (s, t, u) { var r = { content: u, loaded: true, css: t === "css" }; return d.getEntry(s, r) }, processRequest: function (s, r) { s.loadEntries(r) }, load: function (r) { var r = new b(r); if (r.sync || d.syncMode) { return d.loadSync(r) } if (d.currentRequest) { r.getEntries(); d.suspendedQueue.push(r) } else { d.currentRequest = r; d.processRequest(r, false) } return d }, loadSync: function (r) { var r = new b(r); d.syncMode++; d.processRequest(r, true); d.syncMode--; return d }, loadBasePrefix: function (r) { r = new b(r); r.prependBaseUrl = true; return d.load(r) }, loadSyncBasePrefix: function (r) { r = new b(r); r.prependBaseUrl = true; return d.loadSync(r) }, requestComplete: function (s) { var r; if (d.currentRequest === s) { d.currentRequest = null; while (d.suspendedQueue.length > 0) { r = d.suspendedQueue.shift(); if (!r.done) { d.load(r); break } } } if (!d.currentRequest && d.suspendedQueue.length == 0) { d.fireListeners() } }, isLoading: function () { return !d.currentRequest && d.suspendedQueue.length == 0 }, fireListeners: function () { var r; while (d.isLoading() && (r = d.listeners.shift())) { r() } }, onBootReady: function (r) { if (!d.isLoading()) { r() } else { d.listeners.push(r) } }, getPathsFromIndexes: function (u, r) { if (!("length" in u)) { var t = [], s; for (s in u) { if (!isNaN(+s)) { t[+s] = u[s] } } u = t } return b.prototype.getPathsFromIndexes(u, r) }, createLoadOrderMap: function (r) { return b.prototype.createLoadOrderMap(r) }, fetch: function (r, s, A, u) { u = (u === undefined) ? !!s : u; var z = new XMLHttpRequest(), B, w, x, t = false, y = function () { if (z && z.readyState == 4) { w = (z.status === 1223) ? 204 : (z.status === 0 && ((self.location || {}).protocol === "file:" || (self.location || {}).protocol === "ionp:")) ? 200 : z.status; x = z.responseText; B = { content: x, status: w, exception: t }; if (s) { s.call(A, B) } z.onreadystatechange = h; z = null } }; if (u) { z.onreadystatechange = y } try { z.open("GET", r, u); z.send(null) } catch (v) { t = v; y(); return B } if (!u) { y() } return B }, notifyAll: function (r) { r.notifyRequests() } }; function b(r) { if (r.$isRequest) { return r } var r = r.url ? r : { url: r }, s = r.url, t = s.charAt ? [s] : s, u = r.charset || d.config.charset; a(this, r); delete this.url; this.urls = t; this.charset = u } b.prototype = { $isRequest: true, createLoadOrderMap: function (s) { var r = s.length, t = {}, v, u; for (v = 0; v < r; v++) { u = s[v]; t[u.path] = u } return t }, getLoadIndexes: function (D, z, s, t, C) { var B = [], v = [D], r = D.idx, v, A, y, x, u, w; if (z[r]) { return B } z[r] = B[r] = true; while (D = v.shift()) { if (D.canonicalPath) { A = d.getEntry(D.path, null, true) } else { A = d.getEntry(this.prepareUrl(D.path)) } if (!(C && A.done)) { if (t && D.uses && D.uses.length) { y = D.requires.concat(D.uses) } else { y = D.requires } for (u = 0, w = y.length; u < w; u++) { x = y[u]; if (!z[x]) { z[x] = B[x] = true; v.push(s[x]) } } } } return B }, getPathsFromIndexes: function (u, s) { var v = [], t, r; for (t = 0, r = u.length; t < r; t++) { if (u[t]) { v.push(s[t].path) } } return v }, expandUrl: function (w, r, u, y, v, t) { var x, s; if (r) { x = u[w]; if (x) { s = this.getLoadIndexes(x, y, r, v, t); if (s.length) { return this.getPathsFromIndexes(s, r) } } } return [w] }, expandUrls: function (A, v) { var B = this, r = B.loadOrder, y = [], s = {}, z = [], C, F, w, x, E, u, D; if (typeof A === "string") { A = [A] } if (r) { C = B.loadOrderMap; if (!C) { C = B.loadOrderMap = B.createLoadOrderMap(r) } } for (w = 0, x = A.length; w < x; w++) { F = this.expandUrl(A[w], r, C, z, v, false); for (E = 0, u = F.length; E < u; E++) { D = F[E]; if (!s[D]) { s[D] = true; y.push(D) } } } if (y.length === 0) { y = A } return y }, expandLoadOrder: function () { var s = this, t = s.urls, r; if (!s.expanded) { r = this.expandUrls(t, true); s.expanded = true } else { r = t } s.urls = r; if (t.length != r.length) { s.sequential = true } return s }, getUrls: function () { this.expandLoadOrder(); return this.urls }, prepareUrl: function (r) { if (this.prependBaseUrl) { return d.baseUrl + r } return r }, getEntries: function () { var x = this, r = x.entries, s, w, u, v, y, t; if (!r) { r = []; y = x.getUrls(); if (x.loadOrder) { s = x.loadOrderMap } for (u = 0; u < y.length; u++) { t = x.prepareUrl(y[u]); if (s) { w = s[t] } v = d.getEntry(t, { buster: x.buster, charset: x.charset }, w && w.canonicalPath); v.requests.push(x); r.push(v) } x.entries = r } return r }, loadEntries: function (x) { var w = this, s = w.getEntries(), r = s.length, y = w.loadStart || 0, t, s, v, u; if (x !== undefined) { w.sync = x } w.loaded = w.loaded || 0; w.loading = w.loading || r; for (u = y; u < r; u++) { v = s[u]; if (!v.loaded) { t = s[u].load(w.sync) } else { t = true } if (!t) { w.loadStart = u; v.onDone(function () { w.loadEntries(x) }); break } } w.processLoadedEntries() }, processLoadedEntries: function () { var v = this, s = v.getEntries(), r = s.length, w = v.startIndex || 0, t, u; if (!v.done) { for (t = w; t < r; t++) { u = s[t]; if (!u.loaded) { v.startIndex = t; return } if (!u.evaluated) { u.evaluate() } if (u.error) { v.error = true } } v.notify() } }, notify: function () { var v = this; if (!v.done) { var s = v.error, u = v[s ? "failure" : "success"], r = ("delay" in v) ? v.delay : (s ? 1 : d.config.chainDelay), t = v.scope || v; v.done = true; if (u) { if (r === 0 || r > 0) { setTimeout(function () { u.call(t, v) }, r) } else { u.call(t, v) } } v.fireListeners(); d.requestComplete(v) } }, onDone: function (t) { var s = this, r = s.listeners || (s.listeners = []); if (s.done) { t(s) } else { r.push(t) } }, fireListeners: function () { var r = this.listeners, s; if (r) { while ((s = r.shift())) { s(this) } } } }; function j(s) { if (s.$isEntry) { return s } var x = s.charset || d.config.charset, w = Ext.manifest, r = w && w.loader, t = (s.cache !== undefined) ? s.cache : (r && r.cache), v, u; if (d.config.disableCaching) { if (t === undefined) { t = !d.config.disableCaching } if (t === false) { v = +new Date() } else { if (t !== true) { v = t } } if (v) { u = (r && r.cacheParam) || d.config.disableCachingParam; v = u + "=" + v } } a(this, s); this.charset = x; this.buster = v; this.requests = [] } j.prototype = { $isEntry: true, done: false, evaluated: false, loaded: false, isCrossDomain: function () { var r = this; if (r.crossDomain === undefined) { r.crossDomain = (r.getLoadUrl().indexOf(d.origin) !== 0) } return r.crossDomain }, isCss: function () { var s = this; if (s.css === undefined) { if (s.url) { var r = d.assetConfig[s.url]; s.css = r ? r.type === "css" : g.test(s.url) } else { s.css = false } } return this.css }, getElement: function (r) { var t = this, s = t.el; if (!s) { if (t.isCss()) { r = r || "link"; s = o.createElement(r); if (r == "link") { s.rel = "stylesheet"; t.prop = "href" } else { t.prop = "textContent" } s.type = "text/css" } else { r = r || "script"; s = o.createElement(r); s.type = "text/javascript"; t.prop = "src"; if (t.charset) { s.charset = t.charset } if (d.hasAsync) { s.async = false } } t.el = s } return s }, getLoadUrl: function () { var s = this, r; r = s.canonicalPath ? s.url : d.canonicalUrl(s.url); if (!s.loadUrl) { s.loadUrl = !!s.buster ? (r + (r.indexOf("?") === -1 ? "?" : "&") + s.buster) : r } return s.loadUrl }, fetch: function (u) { var s = this.getLoadUrl(), t = !!u.async, r = u.complete; d.fetch(s, r, this, t) }, onContentLoaded: function (s) { var w = this, r = s.status, v = s.content, u = s.exception, t = this.getLoadUrl(); w.loaded = true; if ((u || r === 0) && !i.phantom) { w.error = true; w.evaluated = true } else { if ((r >= 200 && r < 300) || r === 304 || i.phantom || (r === 0 && v.length > 0)) { w.content = v } else { w.error = true; w.evaluated = true } } }, createLoadElement: function (t) { var s = this, r = s.getElement(); s.preserve = true; r.onerror = function () { s.error = true; if (t) { t(); t = null } }; if (d.isIE10m) { r.onreadystatechange = function () { if (this.readyState === "loaded" || this.readyState === "complete") { if (t) { t(); t = this.onreadystatechange = this.onerror = null } } } } else { r.onload = function () { t(); t = this.onload = this.onerror = null } } r[s.prop] = s.getLoadUrl() }, onLoadElementReady: function () { d.getHead().appendChild(this.getElement()); this.evaluated = true }, inject: function (w, v) { var x = this, y = d.getHead(), r = x.url, z = x.key, s, t, u, A; if (x.isCss()) { x.preserve = true; A = z.substring(0, z.lastIndexOf("/") + 1); s = o.createElement("base"); s.href = A; if (y.firstChild) { y.insertBefore(s, y.firstChild) } else { y.appendChild(s) } s.href = s.href; if (r) { w += "\n/*# sourceURL=" + z + " */" } t = x.getElement("style"); u = ("styleSheet" in t); y.appendChild(s); if (u) { y.appendChild(t); t.styleSheet.cssText = w } else { t.textContent = w; y.appendChild(t) } y.removeChild(s) } else { if (r) { w += "\n//# sourceURL=" + z } Ext.globalEval(w) } return x }, loadCrossDomain: function () { var s = this, r = function () { s.el.onerror = s.el.onload = h; s.el = null; s.loaded = s.evaluated = s.done = true; s.notifyRequests() }; s.createLoadElement(function () { r() }); s.evaluateLoadElement(); return false }, loadElement: function () { var s = this, r = function () { s.el.onerror = s.el.onload = h; s.el = null; s.loaded = s.evaluated = s.done = true; s.notifyRequests() }; s.createLoadElement(function () { r() }); s.evaluateLoadElement(); return true }, loadSync: function () { var r = this; r.fetch({ async: false, complete: function (s) { r.onContentLoaded(s) } }); r.evaluate(); r.notifyRequests() }, load: function (s) { var r = this; if (!r.loaded) { if (r.loading) { return false } r.loading = true; if (!s) { if (d.isIE10 || r.isCrossDomain()) { return r.loadCrossDomain() } else { if (!r.isCss() && d.hasReadyState) { r.createLoadElement(function () { r.loaded = true; r.notifyRequests() }) } else { if (d.useElements && !(r.isCss() && i.phantom)) { return r.loadElement() } else { r.fetch({ async: !s, complete: function (t) { r.onContentLoaded(t); r.notifyRequests() } }) } } } } else { r.loadSync() } } return true }, evaluateContent: function () { this.inject(this.content); this.content = null }, evaluateLoadElement: function () { d.getHead().appendChild(this.getElement()) }, evaluate: function () { var r = this; if (!r.evaluated) { if (r.evaluating) { return } r.evaluating = true; if (r.content !== undefined) { r.evaluateContent() } else { if (!r.error) { r.evaluateLoadElement() } } r.evaluated = r.done = true; r.cleanup() } }, cleanup: function () { var t = this, s = t.el, u; if (!s) { return } if (!t.preserve) { t.el = null; s.parentNode.removeChild(s); for (u in s) { try { if (u !== t.prop) { s[u] = null } delete s[u] } catch (r) { } } } s.onload = s.onerror = s.onreadystatechange = h }, notifyRequests: function () { var u = this.requests, r = u.length, s, t; for (s = 0; s < r; s++) { t = u[s]; t.processLoadedEntries() } if (this.done) { this.fireListeners() } }, onDone: function (t) { var s = this, r = s.listeners || (s.listeners = []); if (s.done) { t(s) } else { r.push(t) } }, fireListeners: function () { var r = this.listeners, s; if (r && r.length > 0) { while ((s = r.shift())) { s(this) } } } }; Ext.disableCacheBuster = function (s, t) { var r = new Date(); r.setTime(r.getTime() + (s ? 10 * 365 : -1) * 24 * 60 * 60 * 1000); r = r.toGMTString(); o.cookie = "ext-cache=1; expires=" + r + "; path=" + (t || "/") }; d.init(); return d }(function () { })); Ext.globalEval = Ext.globalEval || (this.execScript ? function (a) { execScript(a) } : function ($$code) { eval.call(window, $$code) }); if (!Function.prototype.bind) { (function () { var a = Array.prototype.slice, b = function (d) { var c = a.call(arguments, 1), e = this; if (c.length) { return function () { var g = arguments; return e.apply(d, g.length ? c.concat(a.call(g)) : c) } } c = null; return function () { return e.apply(d, arguments) } }; Function.prototype.bind = b; b.$extjs = true }()) } Ext.setResourcePath = function (c, b) { var a = Ext.manifest || (Ext.manifest = {}), d = a.resources || (a.resources = {}); if (a) { if (typeof c !== "string") { Ext.apply(d, c) } else { d[c] = b } a.resources = d } }; Ext.getResourcePath = function (g, e, a) { if (typeof g !== "string") { e = g.pool; a = g.packageName; g = g.path } var d = Ext.manifest, h = d && d.resources, c = h[e], b = []; if (c == null) { c = h.path; if (c == null) { c = "resources" } } if (c) { b.push(c) } if (a) { b.push(a) } b.push(g); return b.join("/") }; var Ext = Ext || {}; (function () { var b = this, h = Object.prototype, c = h.toString, o = ["valueOf", "toLocaleString", "toString", "constructor"], l = function () { }, g = function () { }, j = function (i) { return i }, n = function () { var i = n.caller.caller; return i.$owner.prototype[i.$name].apply(this, arguments) }, a = Ext.manifest || {}, k, d = /\[object\s*(?:Array|Arguments|\w*Collection|\w*List|HTML\s+document\.all\s+class)\]/, e = /^\\?\/Date\(([-+])?(\d+)(?:[+-]\d{4})?\)\\?\/$/; Ext.global = b; Ext.now = Date.now || (Date.now = function () { return +new Date() }); Ext.ticks = (b.performance && b.performance.now) ? function () { return performance.now() } : Ext.now; Ext._startTime = Ext.ticks(); l.$nullFn = j.$nullFn = l.$emptyFn = j.$identityFn = g.$nullFn = true; g.$privacy = "framework"; l.$noClearOnDestroy = j.$noClearOnDestroy = true; g.$noClearOnDestroy = true; Ext.suspendLayouts = Ext.resumeLayouts = l; for (k in { toString: 1 }) { o = null } Ext.enumerables = o; Ext.apply = function (s, r, u) { if (u) { Ext.apply(s, u) } if (s && r && typeof r === "object") { var t, q, p; for (t in r) { s[t] = r[t] } if (o) { for (q = o.length; q--;) { p = o[q]; if (r.hasOwnProperty(p)) { s[p] = r[p] } } } } return s }; function m(r, i, s) { var p, q; for (p in s) { if (s.hasOwnProperty(p)) { q = s[p]; if (typeof q === "function") { q.$name = p; q.$owner = i; q.$previous = r.hasOwnProperty(p) ? r[p] : n } r[p] = q } } } Ext.buildSettings = Ext.apply({ baseCSSPrefix: "x-" }, Ext.buildSettings || {}); Ext.apply(Ext, { idSeed: 0, idPrefix: "ext-", isSecure: /^https/i.test(window.location.protocol), enableGarbageCollector: false, enableListenerCollection: true, name: Ext.sandboxName || "Ext", privateFn: g, emptyFn: l, identityFn: j, frameStartTime: Ext.now(), manifest: a, enableAria: true, startsWithHashRe: /^#/, validIdRe: /^[a-z_][a-z0-9\-_]*$/i, BLANK_IMAGE_URL: "data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==", makeIdSelector: function (i) { return "#" + i }, id: function (p, i) { if (p && p.id) { return p.id } var q = (i || Ext.idPrefix) + (++Ext.idSeed); if (p) { p.id = q } return q }, returnId: function (i) { return i.getId() }, returnTrue: function () { return true }, emptyString: new String(), baseCSSPrefix: Ext.buildSettings.baseCSSPrefix, $eventNameMap: {}, $vendorEventRe: /^(DOMMouse|Moz.+|MS.+|webkit.+)/, canonicalEventName: function (i) { return Ext.$eventNameMap[i] || (Ext.$eventNameMap[i] = (Ext.$vendorEventRe.test(i) ? i : i.toLowerCase())) }, applyIf: function (p, i) { var q; if (p) { for (q in i) { if (p[q] === undefined) { p[q] = i[q] } } } return p }, destroy: function () { var r = arguments.length, q, p; for (q = 0; q < r; q++) { p = arguments[q]; if (p) { if (Ext.isArray(p)) { this.destroy.apply(this, p) } else { if (Ext.isFunction(p.destroy)) { p.destroy() } } } } return null }, destroyMembers: function (s) { for (var u, r, t = 1, q = arguments, p = q.length; t < p; t++) { u = s[r = q[t]]; if (u != null) { s[r] = Ext.destroy(u) } } }, override: function (q, r) { if (q.$isClass) { q.override(r) } else { if (typeof q === "function") { Ext.apply(q.prototype, r) } else { var i = q.self, p; if (i && i.$isClass) { p = r.privates; if (p) { r = Ext.apply({}, r); delete r.privates; m(q, i, p) } m(q, i, r) } else { Ext.apply(q, r) } } } return q }, valueFrom: function (q, i, p) { return Ext.isEmpty(q, p) ? i : q }, isEmpty: function (i, p) { return (i == null) || (!p ? i === "" : false) || (Ext.isArray(i) && i.length === 0) }, isArray: ("isArray" in Array) ? Array.isArray : function (i) { return c.call(i) === "[object Array]" }, isDate: function (i) { return c.call(i) === "[object Date]" }, isMSDate: function (i) { if (!Ext.isString(i)) { return false } return e.test(i) }, isObject: (c.call(null) === "[object Object]") ? function (i) { return i !== null && i !== undefined && c.call(i) === "[object Object]" && i.ownerDocument === undefined } : function (i) { return c.call(i) === "[object Object]" }, isSimpleObject: function (i) { return i instanceof Object && i.constructor === Object }, isPrimitive: function (p) { var i = typeof p; return i === "string" || i === "number" || i === "boolean" }, isFunction: (typeof document !== "undefined" && typeof document.getElementsByTagName("body") === "function") ? function (i) { return !!i && c.call(i) === "[object Function]" } : function (i) { return !!i && typeof i === "function" }, isNumber: function (i) { return typeof i === "number" && isFinite(i) }, isNumeric: function (i) { return !isNaN(parseFloat(i)) && isFinite(i) }, isString: function (i) { return typeof i === "string" }, isBoolean: function (i) { return typeof i === "boolean" }, isElement: function (i) { return i ? i.nodeType === 1 : false }, isTextNode: function (i) { return i ? i.nodeName === "#text" : false }, isDefined: function (i) { return typeof i !== "undefined" }, isIterable: function (i) { if (!i || typeof i.length !== "number" || typeof i === "string" || Ext.isFunction(i)) { return false } if (!i.propertyIsEnumerable) { return !!i.item } if (i.hasOwnProperty("length") && !i.propertyIsEnumerable("length")) { return true } return d.test(c.call(i)) }, isDebugEnabled: l, clone: function (v, t) { if (v === null || v === undefined) { return v } if (t !== false && v.nodeType && v.cloneNode) { return v.cloneNode(true) } var u = c.call(v), s, q, p, w, r; if (u === "[object Date]") { return new Date(v.getTime()) } if (u === "[object Array]") { s = v.length; w = []; while (s--) { w[s] = Ext.clone(v[s], t) } } else { if (u === "[object Object]" && v.constructor === Object) { w = {}; for (r in v) { w[r] = Ext.clone(v[r], t) } if (o) { for (q = o.length; q--;) { p = o[q]; if (v.hasOwnProperty(p)) { w[p] = v[p] } } } } } return w || v }, getUniqueGlobalNamespace: function () { var q = this.uniqueGlobalNamespace, p; if (q === undefined) { p = 0; do { q = "ExtBox" + (++p) } while (b[q] !== undefined); b[q] = Ext; this.uniqueGlobalNamespace = q } return q }, functionFactoryCache: {}, cacheableFunctionFactory: function () { var t = this, q = Array.prototype.slice.call(arguments), p = t.functionFactoryCache, i, r, s; if (Ext.isSandboxed) { s = q.length; if (s > 0) { s--; q[s] = "var Ext=window." + Ext.name + ";" + q[s] } } i = q.join(""); r = p[i]; if (!r) { r = Function.prototype.constructor.apply(Function.prototype, q); p[i] = r } return r }, functionFactory: function () { var i = Array.prototype.slice.call(arguments), p; if (Ext.isSandboxed) { p = i.length; if (p > 0) { p--; i[p] = "var Ext=window." + Ext.name + ";" + i[p] } } return Function.prototype.constructor.apply(Function.prototype, i) }, Logger: { log: function (p, i) { if (p && b.console) { if (!i || !(i in b.console)) { i = "log" } p = "[" + i.toUpperCase() + "] " + p; b.console[i](p) } }, verbose: function (i) { this.log(i, "verbose") }, info: function (i) { this.log(i, "info") }, warn: function (i) { this.log(i, "warn") }, error: function (i) { throw new Error(i) }, deprecate: function (i) { this.log(i, "warn") } } || { verbose: l, log: l, info: l, warn: l, error: function (i) { throw new Error(i) }, deprecate: l }, ariaWarn: function (i, p) { if (Ext.enableAria && !Ext.slicer) { if (!Ext.ariaWarn.first) { Ext.ariaWarn.first = true; Ext.log.warn("WAI-ARIA compatibility warnings can be suppressed by adding the following to application startup code:"); Ext.log.warn("    Ext.ariaWarn = Ext.emptyFn;") } Ext.log.warn({ msg: p, dump: i }) } }, getElementById: function (i) { return document.getElementById(i) }, splitAndUnescape: (function () { var i = {}; return function (r, q) { if (!r) { return [] } else { if (!q) { return [r] } } var t = i[q] || (i[q] = new RegExp("\\\\" + q, "g")), p = [], u, s; u = r.split(q); while ((s = u.shift()) !== undefined) { while (s.charAt(s.length - 1) === "\\" && u.length > 0) { s = s + q + u.shift() } s = s.replace(t, q); p.push(s) } return p } })() }); Ext.returnTrue.$nullFn = Ext.returnId.$nullFn = true }()); Ext.platformTags.modern = !(Ext.platformTags.classic = Ext.isClassic = true); (function () { function a() { var c = this, b = c.sourceClass, e = c.sourceMethod, d = c.msg; if (e) { if (d) { e += "(): "; e += d } else { e += "()" } } if (b) { e = e ? (b + "." + e) : b } return e || d || "" } Ext.Error = function (c) { if (Ext.isString(c)) { c = { msg: c } } var b = new Error(); Ext.apply(b, c); b.message = b.message || b.msg; b.toString = a; return b }; Ext.apply(Ext.Error, { ignore: false, raise: function (d) { d = d || {}; if (Ext.isString(d)) { d = { msg: d } } var c = this, g = c.raise.caller, e, b; if (g === Ext.raise) { g = g.caller } if (g) { if (!d.sourceMethod && (b = g.$name)) { d.sourceMethod = b } if (!d.sourceClass && (b = g.$owner) && (b = b.$className)) { d.sourceClass = b } } if (c.handle(d) !== true) { e = a.call(d); throw new Ext.Error(d) } }, handle: function () { return this.ignore } }) })(); Ext.deprecated = function (a) { return Ext.emptyFn }; Ext.raise = function () { Ext.Error.raise.apply(Ext.Error, arguments) }; Ext.Array = (function () { var c = Array.prototype, l = c.slice, n = (function () { var v = [], e, u = 20; if (!v.splice) { return false } while (u--) { v.push("A") } v.splice(15, 0, "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F"); e = v.length; v.splice(13, 0, "XXX"); if (e + 1 !== v.length) { return false } return true }()), m = "indexOf" in c, h = true; function k(x, u) { var e = x.length, w = new Array(e), v; for (v = 0; v < e; v++) { w[v] = v } w.sort(function (z, y) { return u(x[z], x[y]) || (z - y) }); for (v = 0; v < e; v++) { w[v] = x[w[v]] } for (v = 0; v < e; v++) { x[v] = w[v] } return x } try { if (typeof document !== "undefined") { l.call(document.getElementsByTagName("body")) } } catch (p) { h = false } var j = function (u, e) { return (e < 0) ? Math.max(0, u.length + e) : Math.min(u.length, e) }, t = function (B, A, u, E) { var F = E ? E.length : 0, w = B.length, C = j(B, A); if (C === w) { if (F) { B.push.apply(B, E) } } else { var z = Math.min(u, w - C), D = C + z, v = D + F - z, e = w - D, x = w - z, y; if (v < D) { for (y = 0; y < e; ++y) { B[v + y] = B[D + y] } } else { if (v > D) { for (y = e; y--;) { B[v + y] = B[D + y] } } } if (F && C === x) { B.length = x; B.push.apply(B, E) } else { B.length = x + F; for (y = 0; y < F; ++y) { B[C + y] = E[y] } } } return B }, g = function (w, e, v, u) { if (u && u.length) { if (e === 0 && !v) { w.unshift.apply(w, u) } else { if (e < w.length) { w.splice.apply(w, [e, v].concat(u)) } else { w.push.apply(w, u) } } } else { w.splice(e, v) } return w }, b = function (v, e, u) { return t(v, e, u) }, o = function (v, e, u) { v.splice(e, u); return v }, i = function (y, u, w) { var e = arguments.length, x = j(y, u), v; if (e < 3) { w = y.length - x } v = y.slice(u, j(y, x + w)); if (e < 4) { t(y, x, w) } else { t(y, x, w, l.call(arguments, 3)) } return v }, d = function (e) { return e.splice.apply(e, l.call(arguments, 1)) }, s = n ? o : b, q = n ? g : t, r = n ? d : i, a = { binarySearch: function (A, x, v, e, z) { var w = A.length, u, y; if (v instanceof Function) { z = v; v = 0; e = w } else { if (e instanceof Function) { z = e; e = w } else { if (v === undefined) { v = 0 } if (e === undefined) { e = w } z = z || a.lexicalCompare } } --e; while (v <= e) { u = (v + e) >> 1; y = z(x, A[u]); if (y >= 0) { v = u + 1 } else { if (y < 0) { e = u - 1 } } } return v }, defaultCompare: function (e, u) { return (e < u) ? -1 : ((e > u) ? 1 : 0) }, lexicalCompare: function (e, u) { e = String(e); u = String(u); return (e < u) ? -1 : ((e > u) ? 1 : 0) }, each: function (y, w, v, e) { y = a.from(y); var u, x = y.length; if (e !== true) { for (u = 0; u < x; u++) { if (w.call(v || y[u], y[u], u, y) === false) { return u } } } else { for (u = x - 1; u > -1; u--) { if (w.call(v || y[u], y[u], u, y) === false) { return u } } } return true }, forEach: ("forEach" in c) ? function (v, u, e) { return v.forEach(u, e) } : function (x, v, u) { for (var e = 0, w = x.length; e < w; e++) { v.call(u, x[e], e, x) } }, indexOf: m ? function (v, e, u) { return v ? c.indexOf.call(v, e, u) : -1 } : function (x, v, w) { var e, u = x ? x.length : 0; for (e = (w < 0) ? Math.max(0, u + w) : w || 0; e < u; e++) { if (x[e] === v) { return e } } return -1 }, contains: m ? function (u, e) { return c.indexOf.call(u, e) !== -1 } : function (w, v) { var e, u; for (e = 0, u = w.length; e < u; e++) { if (w[e] === v) { return true } } return false }, toArray: function (v, x, e) { if (!v || !v.length) { return [] } if (typeof v === "string") { v = v.split("") } if (h) { return l.call(v, x || 0, e || v.length) } var w = [], u; x = x || 0; e = e ? ((e < 0) ? v.length + e : e) : v.length; for (u = x; u < e; u++) { w.push(v[u]) } return w }, pluck: function (y, e) { var u = [], v, x, w; for (v = 0, x = y.length; v < x; v++) { w = y[v]; u.push(w[e]) } return u }, map: ("map" in c) ? function (v, u, e) { return v.map(u, e) } : function (y, x, w) { var e = y.length, v = new Array(e), u; for (u = 0; u < e; u++) { v[u] = x.call(w, y[u], u, y) } return v }, every: ("every" in c) ? function (v, u, e) { return v.every(u, e) } : function (x, v, u) { var e = 0, w = x.length; for (; e < w; ++e) { if (!v.call(u, x[e], e, x)) { return false } } return true }, some: ("some" in c) ? function (v, u, e) { return v.some(u, e) } : function (x, v, u) { var e = 0, w = x.length; for (; e < w; ++e) { if (v.call(u, x[e], e, x)) { return true } } return false }, equals: function (x, w) { var u = x.length, e = w.length, v; if (x === w) { return true } if (u !== e) { return false } for (v = 0; v < u; ++v) { if (x[v] !== w[v]) { return false } } return true }, clean: function (x) { var u = [], e = 0, w = x.length, v; for (; e < w; e++) { v = x[e]; if (!Ext.isEmpty(v)) { u.push(v) } } return u }, unique: function (x) { var w = [], e = 0, v = x.length, u; for (; e < v; e++) { u = x[e]; if (a.indexOf(w, u) === -1) { w.push(u) } } return w }, filter: ("filter" in c) ? function (v, u, e) { return v.filter(u, e) } : function (y, w, v) { var u = [], e = 0, x = y.length; for (; e < x; e++) { if (w.call(v, y[e], e, y)) { u.push(y[e]) } } return u }, findBy: function (x, w, v) { var u = 0, e = x.length; for (; u < e; u++) { if (w.call(v || x, x[u], u)) { return x[u] } } return null }, from: function (v, u) { if (v === undefined || v === null) { return [] } if (Ext.isArray(v)) { return (u) ? l.call(v) : v } var e = typeof v; if (v && v.length !== undefined && e !== "string" && (e !== "function" || !v.apply)) { return a.toArray(v) } return [v] }, remove: function (v, u) { var e = a.indexOf(v, u); if (e !== -1) { s(v, e, 1) } return v }, removeAt: function (w, u, v) { var e = w.length; if (u >= 0 && u < e) { v = v || 1; v = Math.min(v, e - u); s(w, u, v) } return w }, include: function (u, e) { if (!a.contains(u, e)) { u.push(e) } }, clone: function (e) { return l.call(e) }, merge: function () { var e = l.call(arguments), w = [], u, v; for (u = 0, v = e.length; u < v; u++) { w = w.concat(e[u]) } return a.unique(w) }, intersect: function () { var e = [], v = l.call(arguments), G, E, A, D, H, w, u, C, F, x, B, z, y; if (!v.length) { return e } G = v.length; for (B = H = 0; B < G; B++) { w = v[B]; if (!D || w.length < D.length) { D = w; H = B } } D = a.unique(D); s(v, H, 1); u = D.length; G = v.length; for (B = 0; B < u; B++) { C = D[B]; x = 0; for (z = 0; z < G; z++) { E = v[z]; A = E.length; for (y = 0; y < A; y++) { F = E[y]; if (C === F) { x++; break } } } if (x === G) { e.push(C) } } return e }, difference: function (u, e) { var z = l.call(u), x = z.length, w, v, y; for (w = 0, y = e.length; w < y; w++) { for (v = 0; v < x; v++) { if (z[v] === e[w]) { s(z, v, 1); v--; x-- } } } return z }, reduce: Array.prototype.reduce ? function (v, u, e) { if (arguments.length === 3) { return Array.prototype.reduce.call(v, u, e) } return Array.prototype.reduce.call(v, u) } : function (y, x, e) { y = Object(y); var v = 0, w = y.length >>> 0, u = e; if (arguments.length < 3) { while (true) { if (v in y) { u = y[v++]; break } if (++v >= w) { throw new TypeError("Reduce of empty array with no initial value") } } } for (; v < w; ++v) { if (v in y) { u = x(u, y[v], v, y) } } return u }, slice: ([1, 2].slice(1, undefined).length ? function (v, u, e) { return l.call(v, u, e) } : function (v, u, e) { if (typeof u === "undefined") { return l.call(v) } if (typeof e === "undefined") { return l.call(v, u) } return l.call(v, u, e) }), sort: function (u, e) { return k(u, e || a.lexicalCompare) }, flatten: function (v) { var u = []; function e(w) { var y, z, x; for (y = 0, z = w.length; y < z; y++) { x = w[y]; if (Ext.isArray(x)) { e(x) } else { u.push(x) } } return u } return e(v) }, min: function (y, x) { var u = y[0], e, w, v; for (e = 0, w = y.length; e < w; e++) { v = y[e]; if (x) { if (x(u, v) === 1) { u = v } } else { if (v < u) { u = v } } } return u }, max: function (y, x) { var e = y[0], u, w, v; for (u = 0, w = y.length; u < w; u++) { v = y[u]; if (x) { if (x(e, v) === -1) { e = v } } else { if (v > e) { e = v } } } return e }, mean: function (e) { return e.length > 0 ? a.sum(e) / e.length : undefined }, sum: function (x) { var u = 0, e, w, v; for (e = 0, w = x.length; e < w; e++) { v = x[e]; u += v } return u }, toMap: function (x, e, v) { var w = {}, u = x.length; if (!e) { while (u--) { w[x[u]] = u + 1 } } else { if (typeof e === "string") { while (u--) { w[x[u][e]] = u + 1 } } else { while (u--) { w[e.call(v, x[u])] = u + 1 } } } return w }, toValueMap: function (z, w, E, y) { var e = {}, v = z.length, u, x, C, A, D, B; if (!w) { while (v--) { B = z[v]; e[B] = B } } else { if (!(A = (typeof w !== "string"))) { y = E } x = y === 1; u = y === 2; while (v--) { B = z[v]; D = A ? w.call(E, B) : B[w]; if (x) { if (D in e) { e[D].push(B) } else { e[D] = [B] } } else { if (u && (D in e)) { if ((C = e[D]) instanceof Array) { C.push(B) } else { e[D] = [C, B] } } else { e[D] = B } } } } return e }, erase: s, insert: function (v, u, e) { return q(v, u, 0, e) }, move: function (y, u, w) { if (w === u) { return } var v = y[u], x = w > u ? 1 : -1, e; for (e = u; e != w; e += x) { y[e] = y[e + x] } y[w] = v }, replace: q, splice: r, push: function (w) { var e = arguments.length, v = 1, u; if (w === undefined) { w = [] } else { if (!Ext.isArray(w)) { w = [w] } } for (; v < e; v++) { u = arguments[v]; Array.prototype.push[Ext.isIterable(u) ? "apply" : "call"](w, u) } return w }, numericSortFn: function (u, e) { return u - e } }; Ext.each = a.each; a.union = a.merge; Ext.min = a.min; Ext.max = a.max; Ext.sum = a.sum; Ext.mean = a.mean; Ext.flatten = a.flatten; Ext.clean = a.clean; Ext.unique = a.unique; Ext.pluck = a.pluck; Ext.toArray = function () { return a.toArray.apply(a, arguments) }; return a }()); Ext.String = (function () { var i = /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g, n = /('|\\)/g, b = /([-.*+?\^${}()|\[\]\/\\])/g, p = /^\s+|\s+$/g, j = /\s+/, l = /(^[^a-z]*|[^\w])/gi, e, a, h, d, g = function (r, q) { return e[q] }, k = function (r, q) { return (q in a) ? a[q] : String.fromCharCode(parseInt(q.substr(2), 10)) }, c = function (r, q) { if (r === null || r === undefined || q === null || q === undefined) { return false } return q.length <= r.length }, m = String.fromCharCode, o; return o = { fromCodePoint: String.fromCodePoint || function () { var s, q = "", t = [], r = -1, u = arguments.length; while (++r < u) { s = Number(arguments[r]); if (!isFinite(s) || s < 0 || s > 1114111 || Math.floor(s) !== s) { Ext.raise("Invalid code point: " + s) } if (s <= 65535) { t.push(s) } else { s -= 65536; t.push((s >> 10) + 55296, (s % 1024) + 56320) } if (r + 1 === u) { q += m(t); t.length = 0 } } return q }, insert: function (t, u, r) { if (!t) { return u } if (!u) { return t } var q = t.length; if (!r && r !== 0) { r = q } if (r < 0) { r *= -1; if (r >= q) { r = 0 } else { r = q - r } } if (r === 0) { t = u + t } else { if (r >= t.length) { t += u } else { t = t.substr(0, r) + u + t.substr(r) } } return t }, startsWith: function (t, u, r) { var q = c(t, u); if (q) { if (r) { t = t.toLowerCase(); u = u.toLowerCase() } q = t.lastIndexOf(u, 0) === 0 } return q }, endsWith: function (u, r, t) { var q = c(u, r); if (q) { if (t) { u = u.toLowerCase(); r = r.toLowerCase() } q = u.indexOf(r, u.length - r.length) !== -1 } return q }, createVarName: function (q) { return q.replace(l, "") }, htmlEncode: function (q) { return (!q) ? q : String(q).replace(h, g) }, htmlDecode: function (q) { return (!q) ? q : String(q).replace(d, k) }, hasHtmlCharacters: function (q) { return h.test(q) }, addCharacterEntities: function (r) { var q = [], u = [], s, t; for (s in r) { t = r[s]; a[s] = t; e[t] = s; q.push(t); u.push(s) } h = new RegExp("(" + q.join("|") + ")", "g"); d = new RegExp("(" + u.join("|") + "|&#[0-9]{1,5};)", "g") }, resetCharacterEntities: function () { e = {}; a = {}; this.addCharacterEntities({ "&amp;": "&", "&gt;": ">", "&lt;": "<", "&quot;": '"', "&#39;": "'" }) }, urlAppend: function (r, q) { if (!Ext.isEmpty(q)) { return r + (r.indexOf("?") === -1 ? "?" : "&") + q } return r }, trim: function (q) { if (q) { q = q.replace(i, "") } return q || "" }, capitalize: function (q) { if (q) { q = q.charAt(0).toUpperCase() + q.substr(1) } return q || "" }, uncapitalize: function (q) { if (q) { q = q.charAt(0).toLowerCase() + q.substr(1) } return q || "" }, ellipsis: function (s, r, t) { if (s && s.length > r) { if (t) { var u = s.substr(0, r - 2), q = Math.max(u.lastIndexOf(" "), u.lastIndexOf("."), u.lastIndexOf("!"), u.lastIndexOf("?")); if (q !== -1 && q >= (r - 15)) { return u.substr(0, q) + "..." } } return s.substr(0, r - 3) + "..." } return s }, escapeRegex: function (q) { return q.replace(b, "\\$1") }, createRegex: function (u, t, r, q) { var s = u; if (u != null && !u.exec) { s = o.escapeRegex(String(u)); if (t !== false) { s = "^" + s } if (r !== false) { s += "$" } s = new RegExp(s, (q !== false) ? "i" : "") } return s }, escape: function (q) { return q.replace(n, "\\$1") }, toggle: function (r, s, q) { return r === s ? q : s }, leftPad: function (r, s, t) { var q = String(r); t = t || " "; while (q.length < s) { q = t + q } return q }, repeat: function (u, t, r) { if (t < 1) { t = 0 } for (var q = [], s = t; s--;) { q.push(u) } return q.join(r || "") }, splitWords: function (q) { if (q && typeof q == "string") { return q.replace(p, "").split(j) } return q || [] } } }()); Ext.String.resetCharacterEntities(); Ext.htmlEncode = Ext.String.htmlEncode; Ext.htmlDecode = Ext.String.htmlDecode; Ext.urlAppend = Ext.String.urlAppend; Ext.Date = (function () { var g, e = Date, l = /(\\.)/g, a = /([gGhHisucUOPZ]|MS)/, h = /([djzmnYycU]|MS)/, k = /\\/gi, c = /\{(\d+)\}/g, i = new RegExp("\\/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\/"), d = Ext.String.leftPad, b = ["var me = this, dt, y, m, d, h, i, s, ms, o, O, z, zz, u, v, W, year, jan4, week1monday, daysInMonth, dayMatched,", "def = me.defaults,", "from = Ext.Number.from,", "results = String(input).match(me.parseRegexes[{0}]);", "if(results){", "{1}", "if(u != null){", "v = new Date(u * 1000);", "}else{", "dt = me.clearTime(new Date);", "y = from(y, from(def.y, dt.getFullYear()));", "m = from(m, from(def.m - 1, dt.getMonth()));", "dayMatched = d !== undefined;", "d = from(d, from(def.d, dt.getDate()));", "if (!dayMatched) {", "dt.setDate(1);", "dt.setMonth(m);", "dt.setFullYear(y);", "daysInMonth = me.getDaysInMonth(dt);", "if (d > daysInMonth) {", "d = daysInMonth;", "}", "}", "h  = from(h, from(def.h, dt.getHours()));", "i  = from(i, from(def.i, dt.getMinutes()));", "s  = from(s, from(def.s, dt.getSeconds()));", "ms = from(ms, from(def.ms, dt.getMilliseconds()));", "if(z >= 0 && y >= 0){", "v = me.add(new Date(y < 100 ? 100 : y, 0, 1, h, i, s, ms), me.YEAR, y < 100 ? y - 100 : 0);", "v = !strict? v : (strict === true && (z <= 364 || (me.isLeapYear(v) && z <= 365))? me.add(v, me.DAY, z) : null);", "}else if(strict === true && !me.isValid(y, m + 1, d, h, i, s, ms)){", "v = null;", "}else{", "if (W) {", "year = y || (new Date()).getFullYear();", "jan4 = new Date(year, 0, 4, 0, 0, 0);", "d = jan4.getDay();", "week1monday = new Date(jan4.getTime() - ((d === 0 ? 6 : d - 1) * 86400000));", "v = Ext.Date.clearTime(new Date(week1monday.getTime() + ((W - 1) * 604800000 + 43200000)));", "} else {", "v = me.add(new Date(y < 100 ? 100 : y, m, d, h, i, s, ms), me.YEAR, y < 100 ? y - 100 : 0);", "}", "}", "}", "}", "if(v){", "if(zz != null){", "v = me.add(v, me.SECOND, -v.getTimezoneOffset() * 60 - zz);", "}else if(o){", "v = me.add(v, me.MINUTE, -v.getTimezoneOffset() + (sn == '+'? -1 : 1) * (hr * 60 + mn));", "}", "}", "return (v != null) ? v : null;"].join("\n"); if (!Date.prototype.toISOString) { Date.prototype.toISOString = function () { var m = this; return d(m.getUTCFullYear(), 4, "0") + "-" + d(m.getUTCMonth() + 1, 2, "0") + "-" + d(m.getUTCDate(), 2, "0") + "T" + d(m.getUTCHours(), 2, "0") + ":" + d(m.getUTCMinutes(), 2, "0") + ":" + d(m.getUTCSeconds(), 2, "0") + "." + d(m.getUTCMilliseconds(), 3, "0") + "Z" } } function j(n) { var m = Array.prototype.slice.call(arguments, 1); return n.replace(c, function (o, p) { return m[p] }) } g = { now: e.now, toString: function (m) { if (!m) { m = new e() } return m.getFullYear() + "-" + d(m.getMonth() + 1, 2, "0") + "-" + d(m.getDate(), 2, "0") + "T" + d(m.getHours(), 2, "0") + ":" + d(m.getMinutes(), 2, "0") + ":" + d(m.getSeconds(), 2, "0") }, getElapsed: function (n, m) { return Math.abs(n - (m || g.now())) }, useStrict: false, formatCodeToRegex: function (n, m) { var o = g.parseCodes[n]; if (o) { o = typeof o === "function" ? o() : o; g.parseCodes[n] = o } return o ? Ext.applyIf({ c: o.c ? j(o.c, m || "{0}") : o.c }, o) : { g: 0, c: null, s: Ext.String.escapeRegex(n) } }, parseFunctions: { MS: function (n, m) { var o = (n || "").match(i); return o ? new e(((o[1] || "") + o[2]) * 1) : null }, time: function (n, m) { var o = parseInt(n, 10); if (o || o === 0) { return new e(o) } return null }, timestamp: function (n, m) { var o = parseInt(n, 10); if (o || o === 0) { return new e(o * 1000) } return null } }, parseRegexes: [], formatFunctions: { MS: function () { return "\\/Date(" + this.getTime() + ")\\/" }, time: function () { return this.getTime().toString() }, timestamp: function () { return g.format(this, "U") } }, y2kYear: 50, MILLI: "ms", SECOND: "s", MINUTE: "mi", HOUR: "h", DAY: "d", MONTH: "mo", YEAR: "y", DAYS_IN_WEEK: 7, MONTHS_IN_YEAR: 12, MAX_DAYS_IN_MONTH: 31, SUNDAY: 0, MONDAY: 1, TUESDAY: 2, WEDNESDAY: 3, THURSDAY: 4, FRIDAY: 5, SATURDAY: 6, defaults: {}, dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthNumbers: { January: 0, Jan: 0, February: 1, Feb: 1, March: 2, Mar: 2, April: 3, Apr: 3, May: 4, June: 5, Jun: 5, July: 6, Jul: 6, August: 7, Aug: 7, September: 8, Sep: 8, October: 9, Oct: 9, November: 10, Nov: 10, December: 11, Dec: 11 }, defaultFormat: "m/d/Y", firstDayOfWeek: 0, weekendDays: [0, 6], getShortMonthName: function (m) { return g.monthNames[m].substring(0, 3) }, getShortDayName: function (m) { return g.dayNames[m].substring(0, 3) }, getMonthNumber: function (m) { return g.monthNumbers[m.substring(0, 1).toUpperCase() + m.substring(1, 3).toLowerCase()] }, formatContainsHourInfo: function (m) { return a.test(m.replace(l, "")) }, formatContainsDateInfo: function (m) { return h.test(m.replace(l, "")) }, unescapeFormat: function (m) { return m.replace(k, "") }, formatCodes: { d: "Ext.String.leftPad(m.getDate(), 2, '0')", D: "Ext.Date.getShortDayName(m.getDay())", j: "m.getDate()", l: "Ext.Date.dayNames[m.getDay()]", N: "(m.getDay() ? m.getDay() : 7)", S: "Ext.Date.getSuffix(m)", w: "m.getDay()", z: "Ext.Date.getDayOfYear(m)", W: "Ext.String.leftPad(Ext.Date.getWeekOfYear(m), 2, '0')", F: "Ext.Date.monthNames[m.getMonth()]", m: "Ext.String.leftPad(m.getMonth() + 1, 2, '0')", M: "Ext.Date.getShortMonthName(m.getMonth())", n: "(m.getMonth() + 1)", t: "Ext.Date.getDaysInMonth(m)", L: "(Ext.Date.isLeapYear(m) ? 1 : 0)", o: "(m.getFullYear() + (Ext.Date.getWeekOfYear(m) == 1 && m.getMonth() > 0 ? +1 : (Ext.Date.getWeekOfYear(m) >= 52 && m.getMonth() < 11 ? -1 : 0)))", Y: "Ext.String.leftPad(m.getFullYear(), 4, '0')", y: "('' + m.getFullYear()).substring(2, 4)", a: "(m.getHours() < 12 ? 'am' : 'pm')", A: "(m.getHours() < 12 ? 'AM' : 'PM')", g: "((m.getHours() % 12) ? m.getHours() % 12 : 12)", G: "m.getHours()", h: "Ext.String.leftPad((m.getHours() % 12) ? m.getHours() % 12 : 12, 2, '0')", H: "Ext.String.leftPad(m.getHours(), 2, '0')", i: "Ext.String.leftPad(m.getMinutes(), 2, '0')", s: "Ext.String.leftPad(m.getSeconds(), 2, '0')", u: "Ext.String.leftPad(m.getMilliseconds(), 3, '0')", O: "Ext.Date.getGMTOffset(m)", P: "Ext.Date.getGMTOffset(m, true)", T: "Ext.Date.getTimezone(m)", Z: "(m.getTimezoneOffset() * -60)", c: function () { var q = "Y-m-dTH:i:sP", o = [], n, m = q.length, p; for (n = 0; n < m; ++n) { p = q.charAt(n); o.push(p === "T" ? "'T'" : g.getFormatCode(p)) } return o.join(" + ") }, C: function () { return "m.toISOString()" }, U: "Math.round(m.getTime() / 1000)" }, isValid: function (p, s, n, m, t, o, r) { m = m || 0; t = t || 0; o = o || 0; r = r || 0; var q = g.add(new e(p < 100 ? 100 : p, s - 1, n, m, t, o, r), g.YEAR, p < 100 ? p - 100 : 0); return p === q.getFullYear() && s === q.getMonth() + 1 && n === q.getDate() && m === q.getHours() && t === q.getMinutes() && o === q.getSeconds() && r === q.getMilliseconds() }, parse: function (n, q, m) { var o = g.parseFunctions; if (o[q] == null) { g.createParser(q) } return o[q].call(g, n, Ext.isDefined(m) ? m : g.useStrict) }, parseDate: function (n, o, m) { return g.parse(n, o, m) }, getFormatCode: function (n) { var m = g.formatCodes[n]; if (m) { m = typeof m === "function" ? m() : m; g.formatCodes[n] = m } return m || ("'" + Ext.String.escape(n) + "'") }, createFormat: function (q) { var p = [], m = false, o = "", n; for (n = 0; n < q.length; ++n) { o = q.charAt(n); if (!m && o === "\\") { m = true } else { if (m) { m = false; p.push("'" + Ext.String.escape(o) + "'") } else { if (o === "\n") { p.push("'\\n'") } else { p.push(g.getFormatCode(o)) } } } } g.formatFunctions[q] = Ext.functionFactory("var m=this;return " + p.join("+")) }, createParser: function (v) { var n = g.parseRegexes.length, w = 1, o = [], u = [], s = false, m = "", q = 0, r = v.length, t = [], p; for (; q < r; ++q) { m = v.charAt(q); if (!s && m === "\\") { s = true } else { if (s) { s = false; u.push(Ext.String.escape(m)) } else { p = g.formatCodeToRegex(m, w); w += p.g; u.push(p.s); if (p.g && p.c) { if (p.calcAtEnd) { t.push(p.c) } else { o.push(p.c) } } } } } o = o.concat(t); g.parseRegexes[n] = new RegExp("^" + u.join("") + "$", "i"); g.parseFunctions[v] = Ext.functionFactory("input", "strict", j(b, n, o.join(""))) }, parseCodes: { d: { g: 1, c: "d = parseInt(results[{0}], 10);\n", s: "(3[0-1]|[1-2][0-9]|0[1-9])" }, j: { g: 1, c: "d = parseInt(results[{0}], 10);\n", s: "(3[0-1]|[1-2][0-9]|[1-9])" }, D: function () { for (var m = [], n = 0; n < 7; m.push(g.getShortDayName(n)), ++n) { } return { g: 0, c: null, s: "(?:" + m.join("|") + ")" } }, l: function () { return { g: 0, c: null, s: "(?:" + g.dayNames.join("|") + ")" } }, N: { g: 0, c: null, s: "[1-7]" }, S: { g: 0, c: null, s: "(?:st|nd|rd|th)" }, w: { g: 0, c: null, s: "[0-6]" }, z: { g: 1, c: "z = parseInt(results[{0}], 10);\n", s: "(\\d{1,3})" }, W: { g: 1, c: "W = parseInt(results[{0}], 10);\n", s: "(\\d{2})" }, F: function () { return { g: 1, c: "m = parseInt(me.getMonthNumber(results[{0}]), 10);\n", s: "(" + g.monthNames.join("|") + ")" } }, M: function () { for (var m = [], n = 0; n < 12; m.push(g.getShortMonthName(n)), ++n) { } return Ext.applyIf({ s: "(" + m.join("|") + ")" }, g.formatCodeToRegex("F")) }, m: { g: 1, c: "m = parseInt(results[{0}], 10) - 1;\n", s: "(1[0-2]|0[1-9])" }, n: { g: 1, c: "m = parseInt(results[{0}], 10) - 1;\n", s: "(1[0-2]|[1-9])" }, t: { g: 0, c: null, s: "(?:\\d{2})" }, L: { g: 0, c: null, s: "(?:1|0)" }, o: { g: 1, c: "y = parseInt(results[{0}], 10);\n", s: "(\\d{4})" }, Y: { g: 1, c: "y = parseInt(results[{0}], 10);\n", s: "(\\d{4})" }, y: { g: 1, c: "var ty = parseInt(results[{0}], 10);\ny = ty > me.y2kYear ? 1900 + ty : 2000 + ty;\n", s: "(\\d{2})" }, a: { g: 1, c: "if (/(am)/i.test(results[{0}])) {\nif (!h || h == 12) { h = 0; }\n} else { if (!h || h < 12) { h = (h || 0) + 12; }}", s: "(am|pm|AM|PM)", calcAtEnd: true }, A: { g: 1, c: "if (/(am)/i.test(results[{0}])) {\nif (!h || h == 12) { h = 0; }\n} else { if (!h || h < 12) { h = (h || 0) + 12; }}", s: "(AM|PM|am|pm)", calcAtEnd: true }, g: { g: 1, c: "h = parseInt(results[{0}], 10);\n", s: "(1[0-2]|[0-9])" }, G: { g: 1, c: "h = parseInt(results[{0}], 10);\n", s: "(2[0-3]|1[0-9]|[0-9])" }, h: { g: 1, c: "h = parseInt(results[{0}], 10);\n", s: "(1[0-2]|0[1-9])" }, H: { g: 1, c: "h = parseInt(results[{0}], 10);\n", s: "(2[0-3]|[0-1][0-9])" }, i: { g: 1, c: "i = parseInt(results[{0}], 10);\n", s: "([0-5][0-9])" }, s: { g: 1, c: "s = parseInt(results[{0}], 10);\n", s: "([0-5][0-9])" }, u: { g: 1, c: "ms = results[{0}]; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n", s: "(\\d+)" }, O: { g: 1, c: ["o = results[{0}];", "var sn = o.substring(0,1),", "hr = o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),", "mn = o.substring(3,5) % 60;", "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join("\n"), s: "([+-]\\d{4})" }, P: { g: 1, c: ["o = results[{0}];", "var sn = o.substring(0,1),", "hr = o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),", "mn = o.substring(4,6) % 60;", "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join("\n"), s: "([+-]\\d{2}:\\d{2})" }, T: { g: 0, c: null, s: "[A-Z]{1,5}" }, Z: { g: 1, c: "zz = results[{0}] * 1;\nzz = (-43200 <= zz && zz <= 50400)? zz : null;\n", s: "([+-]?\\d{1,5})" }, c: function () { var o = [], m = [g.formatCodeToRegex("Y", 1), g.formatCodeToRegex("m", 2), g.formatCodeToRegex("d", 3), g.formatCodeToRegex("H", 4), g.formatCodeToRegex("i", 5), g.formatCodeToRegex("s", 6), { c: "ms = results[7] || '0'; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n" }, { c: ["if(results[8]) {", "if(results[8] == 'Z'){", "zz = 0;", "}else if (results[8].indexOf(':') > -1){", g.formatCodeToRegex("P", 8).c, "}else{", g.formatCodeToRegex("O", 8).c, "}", "}"].join("\n") }], p, n; for (p = 0, n = m.length; p < n; ++p) { o.push(m[p].c) } return { g: 1, c: o.join(""), s: [m[0].s, "(?:", "-", m[1].s, "(?:", "-", m[2].s, "(?:", "(?:T| )?", m[3].s, ":", m[4].s, "(?::", m[5].s, ")?", "(?:(?:\\.|,)(\\d+))?", "(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?", ")?", ")?", ")?"].join("") } }, U: { g: 1, c: "u = parseInt(results[{0}], 10);\n", s: "(-?\\d+)" } }, dateFormat: function (m, n) { return g.format(m, n) }, isEqual: function (n, m) { if (n && m) { return (n.getTime() === m.getTime()) } return !(n || m) }, format: function (n, o) { var m = g.formatFunctions; if (!Ext.isDate(n)) { return "" } if (m[o] == null) { g.createFormat(o) } return m[o].call(n) + "" }, getTimezone: function (m) { return m.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,5})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, "$1$2").replace(/[^A-Z]/g, "") }, getGMTOffset: function (m, n) { var o = m.getTimezoneOffset(); return (o > 0 ? "-" : "+") + Ext.String.leftPad(Math.floor(Math.abs(o) / 60), 2, "0") + (n ? ":" : "") + Ext.String.leftPad(Math.abs(o % 60), 2, "0") }, getDayOfYear: function (p) { var o = 0, r = g.clone(p), n = p.getMonth(), q; for (q = 0, r.setDate(1), r.setMonth(0); q < n; r.setMonth(++q)) { o += g.getDaysInMonth(r) } return o + p.getDate() - 1 }, getWeekOfYear: (function () { var m = 86400000, n = 7 * m; return function (p) { var q = e.UTC(p.getFullYear(), p.getMonth(), p.getDate() + 3) / m, o = Math.floor(q / 7), r = new e(o * n).getUTCFullYear(); return o - Math.floor(e.UTC(r, 0, 7) / n) + 1 } }()), isLeapYear: function (m) { var n = m.getFullYear(); return !!((n & 3) === 0 && (n % 100 || (n % 400 === 0 && n))) }, getFirstDayOfMonth: function (n) { var m = (n.getDay() - (n.getDate() - 1)) % 7; return (m < 0) ? (m + 7) : m }, getLastDayOfMonth: function (m) { return g.getLastDateOfMonth(m).getDay() }, getFirstDateOfMonth: function (m) { return new e(m.getFullYear(), m.getMonth(), 1) }, getLastDateOfMonth: function (m) { return new e(m.getFullYear(), m.getMonth(), g.getDaysInMonth(m)) }, getDaysInMonth: (function () { var m = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; return function (o) { var n = o.getMonth(); return n === 1 && g.isLeapYear(o) ? 29 : m[n] } }()), getSuffix: function (m) { switch (m.getDate()) { case 1: case 21: case 31: return "st"; case 2: case 22: return "nd"; case 3: case 23: return "rd"; default: return "th" } }, clone: function (m) { return new e(m.getTime()) }, isDST: function (m) { return new e(m.getFullYear(), 0, 1).getTimezoneOffset() !== m.getTimezoneOffset() }, clearTime: function (m, q) { if (isNaN(m.getTime())) { return m } if (q) { return g.clearTime(g.clone(m)) } var o = m.getDate(), n, p; m.setHours(0); m.setMinutes(0); m.setSeconds(0); m.setMilliseconds(0); if (m.getDate() !== o) { for (n = 1, p = g.add(m, g.HOUR, n); p.getDate() !== o; n++ , p = g.add(m, g.HOUR, n)) { } m.setDate(o); m.setHours(p.getHours()) } return m }, add: function (o, n, r) { var s = g.clone(o), q = 0, m, p; if (!n || r === 0) { return s } p = r - parseInt(r, 10); r = parseInt(r, 10); if (r) { switch (n.toLowerCase()) { case g.MILLI: s.setTime(s.getTime() + r); break; case g.SECOND: s.setTime(s.getTime() + r * 1000); break; case g.MINUTE: s.setTime(s.getTime() + r * 60 * 1000); break; case g.HOUR: s.setTime(s.getTime() + r * 60 * 60 * 1000); break; case g.DAY: s.setTime(s.getTime() + r * 24 * 60 * 60 * 1000); break; case g.MONTH: m = o.getDate(); if (m > 28) { m = Math.min(m, g.getLastDateOfMonth(g.add(g.getFirstDateOfMonth(o), g.MONTH, r)).getDate()) } s.setDate(m); s.setMonth(o.getMonth() + r); break; case g.YEAR: m = o.getDate(); if (m > 28) { m = Math.min(m, g.getLastDateOfMonth(g.add(g.getFirstDateOfMonth(o), g.YEAR, r)).getDate()) } s.setDate(m); s.setFullYear(o.getFullYear() + r); break } } if (p) { switch (n.toLowerCase()) { case g.MILLI: q = 1; break; case g.SECOND: q = 1000; break; case g.MINUTE: q = 1000 * 60; break; case g.HOUR: q = 1000 * 60 * 60; break; case g.DAY: q = 1000 * 60 * 60 * 24; break; case g.MONTH: m = g.getDaysInMonth(s); q = 1000 * 60 * 60 * 24 * m; break; case g.YEAR: m = (g.isLeapYear(s) ? 366 : 365); q = 1000 * 60 * 60 * 24 * m; break }if (q) { s.setTime(s.getTime() + q * p) } } return s }, subtract: function (n, m, o) { return g.add(n, m, -o) }, between: function (n, p, m) { var o = n.getTime(); return p.getTime() <= o && o <= m.getTime() }, isWeekend: function (m) { return Ext.Array.indexOf(this.weekendDays, m.getDay()) > -1 }, utcToLocal: function (m) { return new Date(m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes(), m.getUTCSeconds(), m.getUTCMilliseconds()) }, localToUtc: function (m) { return g.utc(m.getFullYear(), m.getMonth(), m.getDate(), m.getHours(), m.getMinutes(), m.getSeconds(), m.getMilliseconds()) }, utc: function (r, t, n, m, p, q, o) { return new Date(Date.UTC(r, t, n, m || 0, p || 0, q || 0, o || 0)) }, compat: function () { var u, v = ["useStrict", "formatCodeToRegex", "parseFunctions", "parseRegexes", "formatFunctions", "y2kYear", "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "MONTH", "YEAR", "defaults", "dayNames", "monthNames", "monthNumbers", "getShortMonthName", "getShortDayName", "getMonthNumber", "formatCodes", "isValid", "parseDate", "getFormatCode", "createFormat", "createParser", "parseCodes"], t = ["dateFormat", "format", "getTimezone", "getGMTOffset", "getDayOfYear", "getWeekOfYear", "isLeapYear", "getFirstDayOfMonth", "getLastDayOfMonth", "getDaysInMonth", "getSuffix", "clone", "isDST", "clearTime", "add", "between"], n = v.length, m = t.length, q, r, o; for (o = 0; o < n; o++) { q = v[o]; e[q] = g[q] } for (u = 0; u < m; u++) { r = t[u]; e.prototype[r] = function () { var p = Array.prototype.slice.call(arguments); p.unshift(this); return g[r].apply(g, p) } } }, diff: function (n, m, p) { var o, q = +m - n; switch (p) { case g.MILLI: return q; case g.SECOND: return Math.floor(q / 1000); case g.MINUTE: return Math.floor(q / 60000); case g.HOUR: return Math.floor(q / 3600000); case g.DAY: return Math.floor(q / 86400000); case "w": return Math.floor(q / 604800000); case g.MONTH: o = (m.getFullYear() * 12 + m.getMonth()) - (n.getFullYear() * 12 + n.getMonth()); if (g.add(n, p, o) > m) { return o - 1 } return o; case g.YEAR: o = m.getFullYear() - n.getFullYear(); if (g.add(n, p, o) > m) { return o - 1 } else { return o } } }, align: function (n, p, o) { var m = new e(+n); switch (p.toLowerCase()) { case g.MILLI: return m; case g.SECOND: m.setUTCSeconds(m.getUTCSeconds() - m.getUTCSeconds() % o); m.setUTCMilliseconds(0); return m; case g.MINUTE: m.setUTCMinutes(m.getUTCMinutes() - m.getUTCMinutes() % o); m.setUTCSeconds(0); m.setUTCMilliseconds(0); return m; case g.HOUR: m.setUTCHours(m.getUTCHours() - m.getUTCHours() % o); m.setUTCMinutes(0); m.setUTCSeconds(0); m.setUTCMilliseconds(0); return m; case g.DAY: if (o === 7 || o === 14) { m.setUTCDate(m.getUTCDate() - m.getUTCDay() + 1) } m.setUTCHours(0); m.setUTCMinutes(0); m.setUTCSeconds(0); m.setUTCMilliseconds(0); return m; case g.MONTH: m.setUTCMonth(m.getUTCMonth() - (m.getUTCMonth() - 1) % o, 1); m.setUTCHours(0); m.setUTCMinutes(0); m.setUTCSeconds(0); m.setUTCMilliseconds(0); return m; case g.YEAR: m.setUTCFullYear(m.getUTCFullYear() - m.getUTCFullYear() % o, 1, 1); m.setUTCHours(0); m.setUTCMinutes(0); m.setUTCSeconds(0); m.setUTCMilliseconds(0); return n } } }; g.parseCodes.C = g.parseCodes.c; return g }()); Ext.Function = (function () { var b = 0, m, e = [], n = [], i = 0, j = {}, h = window, d = Ext.global, g = !!(d.setImmediate && d.clearImmediate), l = h.requestAnimationFrame || h.webkitRequestAnimationFrame || h.mozRequestAnimationFrame || h.oRequestAnimationFrame || function (r) { var o = Ext.now(), p = Math.max(0, 16 - (o - b)), q = h.setTimeout(function () { r(o + p) }, p); b = o + p; return q }, c = function () { var o = e.length, r, p, q; m = null; for (p = 0; p < o; p++) { q = e[p]; r = q[3]; if (j[r]) { q[0].apply(q[1] || d, q[2] || n); delete j[r] } } e = e.slice(o) }, a = function () { Ext.elevateFunction(c) }, k = { flexSetter: function (o) { return function (q, s) { var p, r; if (q !== null) { if (typeof q !== "string") { for (p in q) { if (q.hasOwnProperty(p)) { o.call(this, p, q[p]) } } if (Ext.enumerables) { for (r = Ext.enumerables.length; r--;) { p = Ext.enumerables[r]; if (q.hasOwnProperty(p)) { o.call(this, p, q[p]) } } } } else { o.call(this, q, s) } } return this } }, bind: function (r, q, p, o) { if (arguments.length === 2) { return function () { return r.apply(q, arguments) } } var t = r, s = Array.prototype.slice; return function () { var u = p || arguments; if (o === true) { u = s.call(arguments, 0); u = u.concat(p) } else { if (typeof o === "number") { u = s.call(arguments, 0); Ext.Array.insert(u, o, p) } } return t.apply(q || d, u) } }, bindCallback: function (s, r, q, p, o) { return function () { var t = Ext.Array.slice(arguments); return Ext.callback(s, r, q ? q.concat(t) : t, p, o) } }, pass: function (q, o, p) { if (!Ext.isArray(o)) { if (Ext.isIterable(o)) { o = Ext.Array.clone(o) } else { o = o !== undefined ? [o] : [] } } return function () { var r = o.slice(); r.push.apply(r, arguments); return q.apply(p || this, r) } }, alias: function (p, o) { return function () { return p[o].apply(p, arguments) } }, clone: function (o) { return function () { return o.apply(this, arguments) } }, createInterceptor: function (r, q, p, o) { if (!Ext.isFunction(q)) { return r } else { o = Ext.isDefined(o) ? o : null; return function () { var t = this, s = arguments; return (q.apply(p || t || d, s) !== false) ? r.apply(t || d, s) : o } } }, createDelayed: function (s, q, r, p, o) { if (r || p) { s = Ext.Function.bind(s, r, p, o) } return function () { var u = this, t = Array.prototype.slice.call(arguments); setTimeout(function () { if (Ext.elevateFunction) { Ext.elevateFunction(s, u, t) } else { s.apply(u, t) } }, q) } }, defer: function (s, q, r, p, o) { s = Ext.Function.bind(s, r, p, o); if (q > 0) { return setTimeout(function () { if (Ext.elevateFunction) { Ext.elevateFunction(s) } else { s() } }, q) } s(); return 0 }, interval: function (s, q, r, p, o) { s = Ext.Function.bind(s, r, p, o); return setInterval(function () { if (Ext.elevateFunction) { Ext.elevateFunction(s) } else { s() } }, q) }, createSequence: function (p, q, o) { if (!q) { return p } else { return function () { var r = p.apply(this, arguments); q.apply(o || this, arguments); return r } } }, createBuffered: function (s, p, r, q) { var o; return function () { var u = q || Array.prototype.slice.call(arguments, 0), t = r || this; if (o) { clearTimeout(o) } o = setTimeout(function () { if (Ext.elevateFunction) { Ext.elevateFunction(s, t, u) } else { s.apply(t, u) } }, p) } }, createAnimationFrame: function (r, q, p, s) { var o; s = s || 3; return function () { var t = p || Array.prototype.slice.call(arguments, 0); q = q || this; if (s === 3 && o) { k.cancelAnimationFrame(o) } if ((s & 1) || !o) { o = k.requestAnimationFrame(function () { o = null; r.apply(q, t) }) } } }, requestAnimationFrame: function (r, q, o) { var s = ++i, p = Array.prototype.slice.call(arguments, 0); p[3] = s; j[s] = 1; e.push(p); if (!m) { m = l(Ext.elevateFunction ? a : c) } return s }, cancelAnimationFrame: function (o) { delete j[o] }, createThrottled: function (s, p, r) { var t = 0, o, q, v, u = function () { if (Ext.elevateFunction) { Ext.elevateFunction(s, r, q) } else { s.apply(r, q) } t = Ext.now(); v = null }; return function () { if (!r) { r = this } o = Ext.now() - t; q = arguments; if (o >= p) { clearTimeout(v); u() } else { if (!v) { v = Ext.defer(u, p - o) } } } }, createBarrier: function (q, p, o) { return function () { if (!--q) { p.apply(o, arguments) } } }, interceptBefore: function (p, o, r, q) { var s = p[o] || Ext.emptyFn; return (p[o] = function () { var t = r.apply(q || this, arguments); s.apply(this, arguments); return t }) }, interceptAfter: function (p, o, r, q) { var s = p[o] || Ext.emptyFn; return (p[o] = function () { s.apply(this, arguments); return r.apply(q || this, arguments) }) }, interceptAfterOnce: function (q, p, s, r) { var t = q[p], o; o = function () { var u; if (t) { t.apply(this, arguments) } u = s.apply(r || this, arguments); q[p] = t; q = p = s = r = t = o = null; return u }; q[p] = o; return o }, makeCallback: function (p, o) { return function () { return o[p].apply(o, arguments) } }, memoize: function (r, q, o) { var p = {}, s = o && Ext.isFunction(o); return function (u) { var t = s ? o.apply(q, arguments) : u; if (!(t in p)) { p[t] = r.apply(q, arguments) } return p[t] } } }; Ext.asap = g ? function (p, o, q) { if (o != null || q != null) { p = k.bind(p, o, q) } return setImmediate(function () { if (Ext.elevateFunction) { Ext.elevateFunction(p) } else { p() } }) } : function (p, o, q) { if (o != null || q != null) { p = k.bind(p, o, q) } return setTimeout(function () { if (Ext.elevateFunction) { Ext.elevateFunction(p) } else { p() } }, 0, true) }, Ext.asapCancel = g ? function (o) { clearImmediate(o) } : function (o) { clearTimeout(o) }; Ext.defer = k.defer; Ext.interval = k.interval; Ext.pass = k.pass; Ext.bind = k.bind; Ext.deferCallback = k.requestAnimationFrame; return k })(); Ext.Number = (new function () { var d = this, c = (0.9).toFixed() !== "1", b = Math, a = { count: false, inclusive: false, wrap: true }; Ext.apply(d, { MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -(b.pow(2, 53) - 1), MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || b.pow(2, 53) - 1, Clip: { DEFAULT: a, COUNT: Ext.applyIf({ count: true }, a), INCLUSIVE: Ext.applyIf({ inclusive: true }, a), NOWRAP: Ext.applyIf({ wrap: false }, a) }, clipIndices: function (m, n, h) { h = h || a; var g = 0, l = h.wrap, k, e, j; n = n || []; for (j = 0; j < 2; ++j) { k = e; e = n[j]; if (e == null) { e = g } else { if (j && h.count) { e += k; e = (e > m) ? m : e } else { if (l) { e = (e < 0) ? (m + e) : e } if (j && h.inclusive) { ++e } e = (e < 0) ? 0 : ((e > m) ? m : e) } } g = m } n[0] = k; n[1] = (e < k) ? k : e; return n }, constrain: function (i, h, g) { var e = parseFloat(i); if (h === null) { h = i } if (g === null) { g = i } return (e < h) ? h : ((e > g) ? g : e) }, snap: function (i, g, h, j) { var e; if (i === undefined || i < h) { return h || 0 } if (g) { e = i % g; if (e !== 0) { i -= e; if (e * 2 >= g) { i += g } else { if (e * 2 < -g) { i -= g } } } } return d.constrain(i, h, j) }, snapInRange: function (i, e, h, j) { var g; h = (h || 0); if (i === undefined || i < h) { return h } if (e && (g = ((i - h) % e))) { i -= g; g *= 2; if (g >= e) { i += e } } if (j !== undefined) { if (i > (j = d.snapInRange(j, e, h))) { i = j } } return i }, roundToNearest: function (g, e) { e = e || 1; return e * b.round(g / e) }, sign: b.sign || function (e) { e = +e; if (e === 0 || isNaN(e)) { return e } return (e > 0) ? 1 : -1 }, log10: b.log10 || function (e) { return b.log(e) * b.LOG10E }, isEqual: function (g, e, h) { return b.abs(g - e) < h }, isFinite: Number.isFinite || function (e) { return typeof e === "number" && isFinite(e) }, toFixed: c ? function (h, e) { e = e || 0; var g = b.pow(10, e); return (b.round(h * g) / g).toFixed(e) } : function (g, e) { return g.toFixed(e) }, from: function (g, e) { if (isFinite(g)) { g = parseFloat(g) } return !isNaN(g) ? g : e }, randomInt: function (g, e) { return b.floor(b.random() * (e - g + 1) + g) }, correctFloat: function (e) { return parseFloat(e.toPrecision(14)) } }); Ext.num = function () { return d.from.apply(this, arguments) } }()); (function () { var d = function () { }, b = /^\?/, c = /(\[):?([^\]]*)\]/g, a = /^([^\[]+)/, g = /\+/g, e = Ext.Object = { chain: Object.create || function (i) { d.prototype = i; var h = new d(); d.prototype = null; return h }, clear: function (h) { for (var i in h) { delete h[i] } return h }, freeze: Object.freeze ? function (j, h) { if (j && typeof j === "object" && !Object.isFrozen(j)) { Object.freeze(j); if (h) { for (var i in j) { e.freeze(j[i], h) } } } return j } : Ext.identityFn, toQueryObjects: function (k, o, j) { var h = e.toQueryObjects, n = [], l, m; if (Ext.isArray(o)) { for (l = 0, m = o.length; l < m; l++) { if (j) { n = n.concat(h(k + "[" + l + "]", o[l], true)) } else { n.push({ name: k, value: o[l] }) } } } else { if (Ext.isObject(o)) { for (l in o) { if (o.hasOwnProperty(l)) { if (j) { n = n.concat(h(k + "[" + l + "]", o[l], true)) } else { n.push({ name: k, value: o[l] }) } } } } else { n.push({ name: k, value: o }) } } return n }, toQueryString: function (m, k) { var n = [], l = [], p, o, q, h, r; for (p in m) { if (m.hasOwnProperty(p)) { n = n.concat(e.toQueryObjects(p, m[p], k)) } } for (o = 0, q = n.length; o < q; o++) { h = n[o]; r = h.value; if (Ext.isEmpty(r)) { r = "" } else { if (Ext.isDate(r)) { r = Ext.Date.toString(r) } } l.push(encodeURIComponent(h.name) + "=" + encodeURIComponent(String(r))) } return l.join("&") }, fromQueryString: function (k, v) { var q = k.replace(b, "").split("&"), y = {}, w, o, A, r, u, m, s, t, h, n, x, p, z, l; for (u = 0, m = q.length; u < m; u++) { s = q[u]; if (s.length > 0) { o = s.split("="); A = o[0]; A = A.replace(g, "%20"); A = decodeURIComponent(A); r = o[1]; if (r !== undefined) { r = r.replace(g, "%20"); r = decodeURIComponent(r) } else { r = "" } if (!v) { if (y.hasOwnProperty(A)) { if (!Ext.isArray(y[A])) { y[A] = [y[A]] } y[A].push(r) } else { y[A] = r } } else { n = A.match(c); x = A.match(a); A = x[0]; p = []; if (n === null) { y[A] = r; continue } for (t = 0, h = n.length; t < h; t++) { z = n[t]; z = (z.length === 2) ? "" : z.substring(1, z.length - 1); p.push(z) } p.unshift(A); w = y; for (t = 0, h = p.length; t < h; t++) { z = p[t]; if (t === h - 1) { if (Ext.isArray(w) && z === "") { w.push(r) } else { w[z] = r } } else { if (w[z] === undefined || typeof w[z] === "string") { l = p[t + 1]; w[z] = (Ext.isNumeric(l) || l === "") ? [] : {} } w = w[z] } } } } } return y }, each: function (j, m, l) { var h = Ext.enumerables, k, n; if (j) { l = l || j; for (n in j) { if (j.hasOwnProperty(n)) { if (m.call(l, n, j[n], j) === false) { return } } } if (h) { for (k = h.length; k--;) { if (j.hasOwnProperty(n = h[k])) { if (m.call(l, n, j[n], j) === false) { return } } } } } }, eachValue: function (j, m, l) { var h = Ext.enumerables, k, n; l = l || j; for (n in j) { if (j.hasOwnProperty(n)) { if (m.call(l, j[n]) === false) { return } } } if (h) { for (k = h.length; k--;) { if (j.hasOwnProperty(n = h[k])) { if (m.call(l, j[n]) === false) { return } } } } }, merge: function (o) { var m = 1, n = arguments.length, h = e.merge, k = Ext.clone, l, q, p, j; for (; m < n; m++) { l = arguments[m]; for (q in l) { p = l[q]; if (p && p.constructor === Object) { j = o[q]; if (j && j.constructor === Object) { h(j, p) } else { o[q] = k(p) } } else { o[q] = p } } } return o }, mergeIf: function (h) { var m = 1, n = arguments.length, k = Ext.clone, j, l, o; for (; m < n; m++) { j = arguments[m]; for (l in j) { if (!(l in h)) { o = j[l]; if (o && o.constructor === Object) { h[l] = k(o) } else { h[l] = o } } } } return h }, getAllKeys: function (h) { var i = [], j; for (j in h) { i.push(j) } return i }, getKey: function (h, j) { for (var i in h) { if (h.hasOwnProperty(i) && h[i] === j) { return i } } return null }, getValues: function (i) { var h = [], j; for (j in i) { if (i.hasOwnProperty(j)) { h.push(i[j]) } } return h }, getKeys: (typeof Object.keys == "function") ? function (h) { if (!h) { return [] } return Object.keys(h) } : function (h) { var i = [], j; for (j in h) { if (h.hasOwnProperty(j)) { i.push(j) } } return i }, getSize: function (h) { var i = 0, j; for (j in h) { if (h.hasOwnProperty(j)) { i++ } } return i }, isEmpty: function (h) { for (var i in h) { if (h.hasOwnProperty(i)) { return false } } return true }, equals: (function () { var h = function (k, j) { var i; for (i in k) { if (k.hasOwnProperty(i)) { if (k[i] !== j[i]) { return false } } } return true }; return function (j, i) { if (j === i) { return true } if (j && i) { return h(j, i) && h(i, j) } else { if (!j && !i) { return j === i } else { return false } } } })(), fork: function (k) { var h, i, j; if (k && k.constructor === Object) { h = e.chain(k); for (i in k) { j = k[i]; if (j) { if (j.constructor === Object) { h[i] = e.fork(j) } else { if (j instanceof Array) { h[i] = Ext.Array.clone(j) } } } } } else { h = k } return h }, defineProperty: ("defineProperty" in Object) ? Object.defineProperty : function (i, h, j) { if (!Object.prototype.__defineGetter__) { return } if (j.get) { i.__defineGetter__(h, j.get) } if (j.set) { i.__defineSetter__(h, j.set) } }, classify: function (k) { var j = k, m = [], i = {}, h = function () { var o = 0, p = m.length, q; for (; o < p; o++) { q = m[o]; this[q] = new i[q]() } }, l, n; for (l in k) { if (k.hasOwnProperty(l)) { n = k[l]; if (n && n.constructor === Object) { m.push(l); i[l] = e.classify(n) } } } h.prototype = j; return h } }; Ext.merge = Ext.Object.merge; Ext.mergeIf = Ext.Object.mergeIf }()); Ext.apply(Ext, { _namedScopes: { "this": { isThis: 1 }, controller: { isController: 1 }, self: { isSelf: 1 }, "self.controller": { isSelf: 1, isController: 1 } }, escapeId: (function () { var c = /^[a-zA-Z_][a-zA-Z0-9_\-]*$/i, d = /([\W]{1})/g, b = /^(\d)/g, a = function (h, g) { return "\\" + g }, e = function (h, g) { return "\\00" + g.charCodeAt(0).toString(16) + " " }; return function (g) { return c.test(g) ? g : g.replace(d, a).replace(b, e) } }()), callback: function (i, g, d, c, b, h) { if (!i) { return } var e = (g in Ext._namedScopes); if (i.charAt) { if ((!g || e) && b) { g = b.resolveListenerScope(e ? g : h) } i = g[i] } else { if (e) { g = h || b } else { if (!g) { g = b } } } var a; if (i && Ext.isFunction(i)) { g = g || Ext.global; if (c) { Ext.defer(i, c, g, d) } else { if (Ext.elevateFunction) { a = Ext.elevateFunction(i, g, d) } else { if (d) { a = i.apply(g, d) } else { a = i.call(g) } } } } return a }, coerce: function (e, d) { var c = Ext.typeOf(e), b = Ext.typeOf(d), a = typeof e === "string"; if (c !== b) { switch (b) { case "string": return String(e); case "number": return Number(e); case "boolean": return a && (!e || e === "false" || e === "0") ? false : Boolean(e); case "null": return a && (!e || e === "null") ? null : false; case "undefined": return a && (!e || e === "undefined") ? undefined : false; case "date": return a && isNaN(e) ? Ext.Date.parse(e, Ext.Date.defaultFormat) : Date(Number(e)) } } return e }, copyTo: function (b, d, g, e) { if (typeof g === "string") { g = g.split(Ext.propertyNameSplitRe) } for (var a, c = 0, h = g ? g.length : 0; c < h; c++) { a = g[c]; if (e || d.hasOwnProperty(a)) { b[a] = d[a] } } return b }, copy: function (b, d, g, e) { if (typeof g === "string") { g = g.split(Ext.propertyNameSplitRe) } for (var a, c = 0, h = g ? g.length : 0; c < h; c++) { a = g[c]; if (d.hasOwnProperty(a) || (e && a in d)) { b[a] = d[a] } } return b }, propertyNameSplitRe: /[,;\s]+/, copyToIf: function (a, d, e) { if (typeof e === "string") { e = e.split(Ext.propertyNameSplitRe) } for (var b, c = 0, g = e ? e.length : 0; c < g; c++) { b = e[c]; if (a[b] === undefined) { a[b] = d[b] } } return a }, copyIf: function (a, d, e) { if (typeof e === "string") { e = e.split(Ext.propertyNameSplitRe) } for (var b, c = 0, g = e ? e.length : 0; c < g; c++) { b = e[c]; if (!(b in a) && (b in d)) { a[b] = d[b] } } return a }, extend: (function () { var a = Object.prototype.constructor, b = function (d) { var c; for (c in d) { if (!d.hasOwnProperty(c)) { continue } this[c] = d[c] } }; return function (c, i, g) { if (Ext.isObject(i)) { g = i; i = c; c = g.constructor !== a ? g.constructor : function () { i.apply(this, arguments) } } var e = function () { }, d, h = i.prototype; e.prototype = h; d = c.prototype = new e(); d.constructor = c; c.superclass = h; if (h.constructor === a) { h.constructor = i } c.override = function (j) { Ext.override(c, j) }; d.override = b; d.proto = d; c.override(g); c.extend = function (j) { return Ext.extend(c, j) }; return c } }()), iterate: function (a, c, b) { if (Ext.isEmpty(a)) { return } if (b === undefined) { b = a } if (Ext.isIterable(a)) { Ext.Array.each.call(Ext.Array, a, c, b) } else { Ext.Object.each.call(Ext.Object, a, c, b) } }, _resourcePoolRe: /^[<]([^<>@:]*)(?:[@]([^<>@:]+))?[>](.+)$/, resolveResource: function (c) { var b = c, a; if (c && c.charAt(0) === "<") { a = Ext._resourcePoolRe.exec(c); if (a) { b = Ext.getResourcePath(a[3], a[1], a[2]) } } return b }, urlEncode: function () { var a = Ext.Array.from(arguments), b = ""; if (Ext.isString(a[1])) { b = a[1] + "&"; a[1] = false } return b + Ext.Object.toQueryString.apply(Ext.Object, a) }, urlDecode: function () { return Ext.Object.fromQueryString.apply(Ext.Object, arguments) }, getScrollbarSize: function (c) { var b = Ext._scrollbarSize; if (c || !b) { var a = document.body, d = document.createElement("div"); d.style.width = d.style.height = "100px"; d.style.overflow = "scroll"; d.style.position = "absolute"; a.appendChild(d); Ext._scrollbarSize = b = { width: d.offsetWidth - d.clientWidth, height: d.offsetHeight - d.clientHeight }; a.removeChild(d) } return b }, typeOf: (function () { var a = /\S/, c = Object.prototype.toString, d = { number: 1, string: 1, "boolean": 1, "undefined": 1 }, b = { "[object Array]": "array", "[object Date]": "date", "[object Boolean]": "boolean", "[object Number]": "number", "[object RegExp]": "regexp" }; return function (h) { if (h === null) { return "null" } var g = typeof h, e, i; if (d[g]) { return g } e = b[i = c.call(h)]; if (e) { return e } if (g === "function") { return "function" } if (g === "object") { if (h.nodeType !== undefined) { if (h.nodeType === 3) { return a.test(h.nodeValue) ? "textnode" : "whitespace" } else { return "element" } } return "object" } return i } }()), factory: function (b, e, a, g) { var d = Ext.ClassManager, c; if (!b || b.isInstance) { if (a && a !== b) { a.destroy() } return b } if (g) { if (typeof b === "string") { return d.instantiateByAlias(g + "." + b) } else { if (Ext.isObject(b) && "type" in b) { return d.instantiateByAlias(g + "." + b.type, b) } } } if (b === true) { return a || Ext.create(e) } if ("xtype" in b) { c = d.instantiateByAlias("widget." + b.xtype, b) } else { if ("xclass" in b) { c = Ext.create(b.xclass, b) } } if (c) { if (a) { a.destroy() } return c } if (a) { return a.setConfig(b) } return Ext.create(e, b) }, log: (function () { var a = function () { }; a.info = a.warn = a.error = Ext.emptyFn; return a }()) }); (function () { var d = [""], i = /([^\d\.])/, b = /[^\d]/g, a = /[\-+]/g, h = /\s/g, c = /_/g, g = { classic: 1, modern: 1 }, e; Ext.Version = e = function (r, n) { var s = this, l = s.padModes, j, p, m, o, t, k, q; if (r.isVersion) { r = r.version } s.version = q = String(r).toLowerCase().replace(c, ".").replace(a, ""); j = q.charAt(0); if (j in l) { q = q.substring(1); m = l[j] } else { m = n ? l[n] : 0 } s.pad = m; k = q.search(i); s.shortVersion = q; if (k !== -1) { s.release = t = q.substr(k, r.length); s.shortVersion = q.substr(0, k); t = e.releaseValueMap[t] || t } s.releaseValue = t || m; s.shortVersion = s.shortVersion.replace(b, ""); s.parts = o = q.split("."); for (p = o.length; p--;) { o[p] = parseInt(o[p], 10) } if (m === Infinity) { o.push(m) } s.major = o[0] || m; s.minor = o[1] || m; s.patch = o[2] || m; s.build = o[3] || m; return s }; e.prototype = { isVersion: true, padModes: { "~": NaN, "^": Infinity }, release: "", compareTo: function (t) { var u = this, n = u.pad, r = u.parts, v = r.length, m = t.isVersion ? t : new e(t), k = m.pad, q = m.parts, p = q.length, j = Math.max(v, p), o, l, s; for (o = 0; o < j; o++) { l = (o < v) ? r[o] : n; s = (o < p) ? q[o] : k; if (l < s) { return -1 } if (l > s) { return 1 } } l = u.releaseValue; s = m.releaseValue; if (l < s) { return -1 } if (l > s) { return 1 } return 0 }, toString: function () { return this.version }, valueOf: function () { return this.version }, getMajor: function () { return this.major }, getMinor: function () { return this.minor }, getPatch: function () { return this.patch }, getBuild: function () { return this.build }, getRelease: function () { return this.release }, getReleaseValue: function () { return this.releaseValue }, isGreaterThan: function (j) { return this.compareTo(j) > 0 }, isGreaterThanOrEqual: function (j) { return this.compareTo(j) >= 0 }, isLessThan: function (j) { return this.compareTo(j) < 0 }, isLessThanOrEqual: function (j) { return this.compareTo(j) <= 0 }, equals: function (j) { return this.compareTo(j) === 0 }, match: function (j) { j = String(j); return this.version.substr(0, j.length) === j }, toArray: function () { var j = this; return [j.getMajor(), j.getMinor(), j.getPatch(), j.getBuild(), j.getRelease()] }, getShortVersion: function () { return this.shortVersion }, gt: function (j) { return this.compareTo(j) > 0 }, lt: function (j) { return this.compareTo(j) < 0 }, gtEq: function (j) { return this.compareTo(j) >= 0 }, ltEq: function (j) { return this.compareTo(j) <= 0 } }; Ext.apply(e, { aliases: { from: { extjs: "ext", core: "core", touch: "modern" }, to: { ext: ["extjs"], core: ["core"], modern: ["touch"] } }, releaseValueMap: { dev: -6, alpha: -5, a: -5, beta: -4, b: -4, rc: -3, "#": -2, p: -1, pl: -1 }, getComponentValue: function (j) { return !j ? 0 : (isNaN(j) ? this.releaseValueMap[j] || j : parseInt(j, 10)) }, compare: function (l, k) { var j = l.isVersion ? l : new e(l); return j.compareTo(k) }, set: function (o, m, l) { var k = e.aliases.to[m], j = l.isVersion ? l : new e(l), n; o[m] = j; if (k) { for (n = k.length; n-- > 0;) { o[k[n]] = j } } return j } }); Ext.apply(Ext, { compatVersions: {}, versions: {}, lastRegisteredVersion: null, getCompatVersion: function (k) { var j = Ext.compatVersions, l; if (!k) { l = j.ext || j.touch || j.core } else { l = j[e.aliases.from[k] || k] } return l || Ext.getVersion(k) }, setCompatVersion: function (k, j) { e.set(Ext.compatVersions, k, j) }, setVersion: function (k, j) { if (k in g) { Ext.toolkit = k } Ext.lastRegisteredVersion = e.set(Ext.versions, k, j); return this }, getVersion: function (k) { var j = Ext.versions; if (!k) { return j.ext || j.touch || j.core } return j[e.aliases.from[k] || k] }, checkVersion: function (p, x) { var t = Ext.isArray(p), l = e.aliases.from, y = t ? p : d, k = y.length, m = Ext.versions, w = m.ext || m.touch, q, v, s, n, o, j, z, r, u; if (!t) { d[0] = p } for (q = 0; q < k; ++q) { if (!Ext.isString(z = y[q])) { s = Ext.checkVersion(z.and || z.or, !z.or); if (z.not) { s = !s } } else { if (z.indexOf(" ") >= 0) { z = z.replace(h, "") } v = z.indexOf("@"); if (v < 0) { r = z; u = w } else { j = z.substring(0, v); if (!(u = m[l[j] || j])) { if (x) { return false } continue } r = z.substring(v + 1) } v = r.indexOf("-"); if (v < 0) { if (r.charAt(v = r.length - 1) === "+") { n = r.substring(0, v); o = null } else { n = o = r } } else { if (v > 0) { n = r.substring(0, v); o = r.substring(v + 1) } else { n = null; o = r.substring(v + 1) } } s = true; if (n) { n = new e(n, "~"); s = n.ltEq(u) } if (s && o) { o = new e(o, "~"); s = o.gtEq(u) } } if (s) { if (!x) { return true } } else { if (x) { return false } } } return !!x }, deprecate: function (j, l, m, k) { if (e.compare(Ext.getVersion(j), l) < 1) { m.call(k) } } }) }()); (function (d) { var e = (d && d.packages) || {}, c = d && d.compatibility, b, a; for (b in e) { a = e[b]; Ext.setVersion(b, a.version) } if (c) { if (Ext.isString(c)) { Ext.setCompatVersion("core", c) } else { for (b in c) { Ext.setCompatVersion(b, c[b]) } } } if (!e.ext && !e.touch) { Ext.setVersion("ext", "6.2.0.981"); Ext.setVersion("core", "6.2.0.981") } })(Ext.manifest); Ext.Config = function (b) { var c = this, a = b.charAt(0).toUpperCase() + b.substr(1); c.name = b; c.names = { internal: "_" + b, initializing: "is" + a + "Initializing", apply: "apply" + a, update: "update" + a, get: "get" + a, set: "set" + a, initGet: "initGet" + a, changeEvent: b.toLowerCase() + "change" }; c.root = c }; Ext.Config.map = {}; Ext.Config.get = function (b) { var c = Ext.Config.map, a = c[b] || (c[b] = new Ext.Config(b)); return a }; Ext.Config.prototype = { self: Ext.Config, isConfig: true, getGetter: function () { return this.getter || (this.root.getter = this.makeGetter()) }, getInitGetter: function () { return this.initGetter || (this.root.initGetter = this.makeInitGetter()) }, getSetter: function () { return this.setter || (this.root.setter = this.makeSetter()) }, getEventedSetter: function () { return this.eventedSetter || (this.root.eventedSetter = this.makeEventedSetter()) }, getInternalName: function (a) { return a.$configPrefixed ? this.names.internal : this.name }, mergeNew: function (g, b, e, d) { var a, c; if (!b) { a = g } else { if (!g) { a = b } else { a = Ext.Object.chain(b); for (c in g) { if (!d || !(c in a)) { a[c] = g[c] } } } } return a }, mergeSets: function (e, c, a) { var b = c ? Ext.Object.chain(c) : {}, d, g; if (e instanceof Array) { for (d = e.length; d--;) { g = e[d]; if (!a || !(g in b)) { b[g] = true } } } else { if (e) { if (e.constructor === Object) { for (d in e) { g = e[d]; if (!a || !(d in b)) { b[d] = g } } } else { if (!a || !(e in b)) { b[e] = true } } } } return b }, makeGetter: function () { var a = this.name, b = this.names.internal; return function () { var c = this.$configPrefixed ? b : a; return this[c] } }, makeInitGetter: function () { var a = this.name, e = this.names, d = e.set, b = e.get, c = e.initializing; return function () { var g = this; g[c] = true; delete g[b]; g[d](g.config[a]); delete g[c]; return g[b].apply(g, arguments) } }, makeSetter: function () { var a = this.name, e = this.names, c = e.internal, d = e.get, b = e.apply, h = e.update, g; g = function (l) { var k = this, j = k.$configPrefixed ? c : a, i = k[j]; delete k[d]; if (!k[b] || (l = k[b](l, i)) !== undefined) { if (l !== (i = k[j])) { k[j] = l; if (k[h]) { k[h](l, i) } } } return k }; g.$isDefault = true; return g }, makeEventedSetter: function () { var b = this.name, h = this.names, j = h.internal, a = h.get, i = h.apply, d = h.update, g = h.changeEvent, e = function (m, n, k, l) { m[l] = n; if (m[d]) { m[d](n, k) } }, c; c = function (n) { var m = this, l = m.$configPrefixed ? j : b, k = m[l]; delete m[a]; if (!m[i] || (n = m[i](n, k)) !== undefined) { if (n !== (k = m[l])) { if (m.isConfiguring) { m[l] = n; if (m[d]) { m[d](n, k) } } else { m.fireEventedAction(g, [m, n, k], e, m, [m, n, k, l]) } } } return m }; c.$isDefault = true; return c } }; (function () { var b = Ext.Config, c = b.map, a = Ext.Object; Ext.Configurator = function (d) { var g = this, e = d.prototype, h = d.superclass ? d.superclass.self.$config : null; g.cls = d; g.superCfg = h; if (h) { g.configs = a.chain(h.configs); g.cachedConfigs = a.chain(h.cachedConfigs); g.initMap = a.chain(h.initMap); g.values = a.chain(h.values); g.needsFork = h.needsFork } else { g.configs = {}; g.cachedConfigs = {}; g.initMap = {}; g.values = {} } e.config = e.defaultConfig = g.values; d.$config = g }; Ext.Configurator.prototype = { self: Ext.Configurator, needsFork: false, initList: null, add: function (u, d) { var v = this, i = v.cls, l = v.configs, w = v.cachedConfigs, n = v.initMap, q = i.prototype, x = d && d.$config.configs, e = v.values, k, m, t, g, h, j, y, p, o, r; for (y in u) { r = u[y]; k = r && r.constructor === Object; m = k && "$value" in r ? r : null; t = false; if (m) { t = !!m.cached; r = m.$value; k = r && r.constructor === Object } g = m && m.merge; h = l[y]; if (h) { if (d) { g = h.merge; if (!g) { continue } m = null } else { g = g || h.merge } j = e[y]; if (g) { r = g.call(h, r, j, i, d) } else { if (k) { if (j && j.constructor === Object) { r = a.merge({}, j, r) } } } } else { if (x) { h = x[y]; m = null } else { h = b.get(y) } l[y] = h; if (h.cached || t) { w[y] = true } p = h.names; if (!q[o = p.get]) { q[o] = h.getter || h.getGetter() } if (!q[o = p.set]) { q[o] = (m && m.evented) ? (h.eventedSetter || h.getEventedSetter()) : (h.setter || h.getSetter()) } } if (m) { if (h.owner !== i) { l[y] = h = Ext.Object.chain(h); h.owner = i } Ext.apply(h, m); delete h.$value } if (!v.needsFork && r && (r.constructor === Object || r instanceof Array)) { v.needsFork = true } if (r !== null) { n[y] = true } else { if (q.$configPrefixed) { q[l[y].names.internal] = null } else { q[l[y].name] = null } if (y in n) { n[y] = false } } e[y] = r } }, configure: function (y, m) { var A = this, l = A.configs, n = A.initMap, p = A.initListMap, w = A.initList, q = A.cls.prototype, e = A.values, r = 0, t = !w, g, h, j, v, u, k, o, B, s, z, x, d; e = A.needsFork ? a.fork(e) : a.chain(e); y.isConfiguring = true; if (t) { A.initList = w = []; A.initListMap = p = {}; y.isFirstInstance = true; for (B in n) { h = l[B]; z = h.cached; if (n[B]) { o = h.names; s = e[B]; if (!q[o.set].$isDefault || q[o.apply] || q[o.update] || typeof s === "object") { if (z) { (g || (g = [])).push(h) } else { w.push(h); p[B] = true } y[o.get] = h.initGetter || h.getInitGetter() } else { q[h.getInternalName(q)] = s } } else { if (z) { q[h.getInternalName(q)] = undefined } } } } k = g && g.length; if (k) { for (v = 0; v < k; ++v) { u = g[v].getInternalName(q); y[u] = null } for (v = 0; v < k; ++v) { o = (h = g[v]).names; j = o.get; if (y.hasOwnProperty(j)) { y[o.set](e[h.name]); delete y[j] } } for (v = 0; v < k; ++v) { u = g[v].getInternalName(q); q[u] = y[u]; delete y[u] } } if (m && m.platformConfig) { m = A.resolvePlatformConfig(y, m) } if (t) { if (y.afterCachedConfig && !y.afterCachedConfig.$nullFn) { y.afterCachedConfig(m) } } y.config = e; for (v = 0, k = w.length; v < k; ++v) { h = w[v]; y[h.names.get] = h.initGetter || h.getInitGetter() } if (y.transformInstanceConfig) { m = y.transformInstanceConfig(m) } if (m) { for (B in m) { s = m[B]; h = l[B]; if (!h) { y[B] = s } else { if (!h.lazy) { ++r } if (!p[B]) { y[h.names.get] = h.initGetter || h.getInitGetter() } if (h.merge) { s = h.merge(s, e[B], y) } else { if (s && s.constructor === Object) { x = e[B]; if (x && x.constructor === Object) { s = a.merge(e[B], s) } else { s = Ext.clone(s, false) } } } } e[B] = s } } if (y.beforeInitConfig && !y.beforeInitConfig.$nullFn) { if (y.beforeInitConfig(m) === false) { return } } if (m) { for (B in m) { if (!r) { break } h = l[B]; if (h && !h.lazy) { --r; o = h.names; j = o.get; if (y.hasOwnProperty(j)) { y[o.set](e[B]); delete y[o.get] } } } } for (v = 0, k = w.length; v < k; ++v) { h = w[v]; o = h.names; j = o.get; if (!h.lazy && y.hasOwnProperty(j)) { y[o.set](e[h.name]); delete y[j] } } delete y.isConfiguring }, getCurrentConfig: function (e) { var d = e.defaultConfig, h = {}, g; for (g in d) { h[g] = e[c[g].names.get]() } return h }, merge: function (d, j, h) { var l = this.configs, g, k, i, e; for (g in h) { k = h[g]; e = l[g]; if (e) { if (e.merge) { k = e.merge(k, j[g], d) } else { if (k && k.constructor === Object) { i = j[g]; if (i && i.constructor === Object) { k = Ext.Object.merge(i, k) } else { k = Ext.clone(k, false) } } } } j[g] = k } return j }, reconfigure: function (s, n, t) { var j = s.config, k = [], r = s.$configStrict && !(t && t.strict === false), o = this.configs, g = t && t.defaults, m, q, h, l, e, p, d; for (e in n) { if (g && s.hasOwnProperty(e)) { continue } j[e] = n[e]; m = o[e]; if (m) { s[m.names.get] = m.initGetter || m.getInitGetter() } else { d = s.self.prototype[e]; if (r) { if ((typeof d === "function") && !d.$nullFn) { continue } } } k.push(e) } for (h = 0, l = k.length; h < l; h++) { e = k[h]; m = o[e]; if (m) { p = m.names; q = p.get; if (s.hasOwnProperty(q)) { s[p.set](n[e]); delete s[q] } } else { m = c[e] || Ext.Config.get(e); p = m.names; if (s[p.set]) { s[p.set](n[e]) } else { s[e] = n[e] } } } }, resolvePlatformConfig: function (d, l) { var j = l && l.platformConfig, e = l, g, h, k; if (j) { h = Ext.getPlatformConfigKeys(j); k = h.length; if (k) { e = Ext.merge({}, e); for (g = 0, k = h.length; g < k; ++g) { this.merge(d, e, j[h[g]]) } } } return e } } }()); Ext.Base = (function (c) { var b = [], k, m = [], n = function (r, q) { var t = this, p, o, s; if (r) { o = Ext.Config.map[r]; s = o.names.get; if (q && t.hasOwnProperty(s)) { p = t.config[r] } else { p = t[s]() } } else { p = t.getCurrentConfig() } return p }, h = function (o) { return function () { return this[o].apply(this, arguments) } }, a = Ext.Version, j = /^\d/, l = {}, e = {}, i = function () { }, d = i.prototype, g; Ext.Reaper = g = { delay: 100, queue: [], timer: null, add: function (o) { if (!g.timer) { g.timer = Ext.defer(g.tick, g.delay) } g.queue.push(o) }, flush: function () { if (g.timer) { clearTimeout(g.timer); g.timer = null } var o = g.queue, r = o.length, p, q; g.queue = []; for (p = 0; p < r; ++p) { q = o[p]; if (q && q.$reap) { q.$reap() } } }, tick: function () { g.timer = null; g.flush() } }; Ext.apply(i, { $className: "Ext.Base", $isClass: true, create: function () { return Ext.create.apply(Ext, [this].concat(Array.prototype.slice.call(arguments, 0))) }, addDeprecations: function (u) { var D = this, p = [], r = Ext.getCompatVersion(u.name), C, y, t, z, E, w, B, v, A, F, x, o, s, q; for (y in u) { if (j.test(y)) { q = new Ext.Version(y); q.deprecations = u[y]; p.push(q) } } p.sort(a.compare); for (t = p.length; t--;) { C = (q = p[t]).deprecations; E = D.prototype; s = C.statics; w = r && r.lt(q); if (!w) { break } while (C) { A = C.methods; if (A) { for (F in A) { o = A[F]; v = null; if (!o) { } else { if (Ext.isString(o)) { if (w) { v = h(o) } } else { z = ""; if (o.message || o.fn) { o = o.fn } B = E.hasOwnProperty(F) && E[F]; if (w && o) { o.$owner = D; o.$name = F; if (B) { o.$previous = B } v = o } } } if (v) { E[F] = v } } } C = s; s = null; E = D } } }, extend: function (r) { var s = this, o = r.prototype, q, p, t; q = s.prototype = Ext.Object.chain(o); q.self = s; s.superclass = q.superclass = o; if (!r.$isClass) { for (p in d) { if (p in q) { q[p] = d[p] } } } t = o.$inheritableStatics; if (t) { for (p in t) { if (!s.hasOwnProperty(p)) { s[p] = r[p] } } } if (r.$onExtended) { s.$onExtended = r.$onExtended.slice() } s.getConfigurator() }, $onExtended: [], triggerExtended: function () { var q = this.$onExtended, p = q.length, o, r; if (p > 0) { for (o = 0; o < p; o++) { r = q[o]; r.fn.apply(r.scope || this, arguments) } } }, onExtended: function (p, o) { this.$onExtended.push({ fn: p, scope: o }); return this }, addStatics: function (o) { this.addMembers(o, true); return this }, addInheritableStatics: function (o) { var r = this, q = r.prototype, s = r.$inheritableStatics, p, u, t; if (!s) { s = Ext.apply({}, q.$inheritableStatics); r.$inheritableStatics = q.$inheritableStatics = s } for (p in o) { if (o.hasOwnProperty(p)) { u = o[p]; t = r[p]; if (typeof t === "function" && !t.$isClass && !t.$nullFn) { u.$previous = t } r[p] = u; s[p] = true } } return r }, addMembers: function (s, D, p) { var B = this, w = Ext.Function.clone, z = D ? B : B.prototype, t = !D && z.defaultConfig, C = Ext.enumerables, x = s.privates, y, v, A, u, o, q, r; if (x) { delete s.privates; if (!D) { r = x.statics; delete x.statics } B.addMembers(x, D, q); if (r) { B.addMembers(r, true, q) } } for (o in s) { if (s.hasOwnProperty(o)) { u = s[o]; if (typeof u === "function" && !u.$isClass && !u.$nullFn) { if (u.$owner) { u = w(u) } if (z.hasOwnProperty(o)) { u.$previous = z[o] } u.$owner = B; u.$name = o } else { if (t && (o in t) && !z.config.hasOwnProperty(o)) { (y || (y = {}))[o] = u; continue } } z[o] = u } } if (y) { B.addConfig(y) } if (C) { for (v = 0, A = C.length; v < A; ++v) { if (s.hasOwnProperty(o = C[v])) { u = s[o]; if (u && !u.$nullFn) { if (u.$owner) { u = w(u) } u.$owner = B; u.$name = o; if (z.hasOwnProperty(o)) { u.$previous = z[o] } } z[o] = u } } } return this }, addMember: function (o, p) { l[o] = p; this.addMembers(l); delete l[o]; return this }, borrow: function (u, o) { var q = u.prototype, s = {}, r, t, p; o = Ext.Array.from(o); for (r = 0, t = o.length; r < t; r++) { p = o[r]; s[p] = q[p] } return this.addMembers(s) }, override: function (p) { var r = this, u = p.statics, t = p.inheritableStatics, q = p.config, o = p.mixins, s = p.cachedConfig; if (u || t || q) { p = Ext.apply({}, p) } if (u) { r.addMembers(u, true); delete p.statics } if (t) { r.addInheritableStatics(t); delete p.inheritableStatics } if (p.platformConfig) { r.addPlatformConfig(p) } if (q) { r.addConfig(q); delete p.config } if (s) { r.addCachedConfig(s); delete p.cachedConfig } delete p.mixins; r.addMembers(p); if (o) { r.mixin(o) } return r }, addPlatformConfig: function (t) { var y = this, u = t.platformConfig, q = t.config, z, v, w, r, p, B, o, A, s, x; delete t.platformConfig; r = y.getConfigurator(); v = r.configs; B = Ext.getPlatformConfigKeys(u); for (s = 0, x = B.length; s < x; ++s) { w = u[B[s]]; p = z = null; for (o in w) { A = w[o]; if (q && o in q) { (z || (z = {}))[o] = A; (p || (p = {}))[o] = q[o]; delete q[o] } else { if (o in v) { (z || (z = {}))[o] = A } else { t[o] = A } } } if (p) { r.add(p) } if (z) { r.add(z) } } }, callParent: function (o) { var p; return (p = this.callParent.caller) && (p.$previous || ((p = p.$owner ? p : p.caller) && p.$owner.superclass.self[p.$name])).apply(this, o || b) }, callSuper: function (o) { var p; return (p = this.callSuper.caller) && ((p = p.$owner ? p : p.caller) && p.$owner.superclass.self[p.$name]).apply(this, o || b) }, mixin: function (o, q) { var v = this, A, x, z, w, r, u, s, o, y, t, p; if (typeof o !== "string") { t = o; if (t instanceof Array) { for (r = 0, u = t.length; r < u; r++) { A = t[r]; v.mixin(A.prototype.mixinId || A.$className, A) } } else { for (s in t) { v.mixin(s, t[s]) } } return } A = q.prototype; x = v.prototype; if (A.onClassMixedIn) { A.onClassMixedIn.call(q, v) } if (!x.hasOwnProperty("mixins")) { if ("mixins" in x) { x.mixins = Ext.Object.chain(x.mixins) } else { x.mixins = {} } } for (z in A) { y = A[z]; if (z === "mixins") { Ext.applyIf(x.mixins, y) } else { if (!(z === "mixinId" || z === "config" || z === "$inheritableStatics") && (x[z] === undefined)) { x[z] = y } } } w = A.$inheritableStatics; if (w) { p = {}; for (o in w) { if (!v.hasOwnProperty(o)) { p[o] = q[o] } } v.addInheritableStatics(p) } if ("config" in A) { v.addConfig(A.config, q) } x.mixins[o] = A; if (A.afterClassMixedIn) { A.afterClassMixedIn.call(q, v) } return v }, addConfig: function (p, q) { var o = this.$config || this.getConfigurator(); o.add(p, q) }, addCachedConfig: function (o, q) { var r = {}, p; for (p in o) { r[p] = { cached: true, $value: o[p] } } this.addConfig(r, q) }, getConfigurator: function () { return this.$config || new Ext.Configurator(this) }, getName: function () { return Ext.getClassName(this) }, createAlias: c(function (p, o) { e[p] = function () { return this[o].apply(this, arguments) }; this.override(e); delete e[p] }) }); for (k in i) { if (i.hasOwnProperty(k)) { m.push(k) } } i.$staticMembers = m; i.getConfigurator(); i.addMembers({ $className: "Ext.Base", isInstance: true, $configPrefixed: true, $configStrict: true, isConfiguring: false, isFirstInstance: false, destroyed: false, clearPropertiesOnDestroy: true, clearPrototypeOnDestroy: false, statics: function () { var p = this.statics.caller, o = this.self; if (!p) { return o } return p.$owner }, callParent: function (p) { var q, o = (q = this.callParent.caller) && (q.$previous || ((q = q.$owner ? q : q.caller) && q.$owner.superclass[q.$name])); return o.apply(this, p || b) }, callSuper: function (p) { var q, o = (q = this.callSuper.caller) && ((q = q.$owner ? q : q.caller) && q.$owner.superclass[q.$name]); return o.apply(this, p || b) }, self: i, constructor: function () { return this }, initConfig: function (q) { var p = this, o = p.self.getConfigurator(); p.initConfig = Ext.emptyFn; p.initialConfig = q || {}; o.configure(p, q); return p }, beforeInitConfig: Ext.emptyFn, getConfig: n, setConfig: function (q, s, p) { var r = this, o; if (q) { if (typeof q === "string") { o = {}; o[q] = s } else { o = q } r.self.getConfigurator().reconfigure(r, o, p) } return r }, getCurrentConfig: function () { var o = this.self.getConfigurator(); return o.getCurrentConfig(this) }, hasConfig: function (o) { return o in this.defaultConfig }, getInitialConfig: function (p) { var o = this.config; if (!p) { return o } return o[p] }, $links: null, link: function (p, r) { var q = this, o = q.$links || (q.$links = {}); o[p] = true; q[p] = r; return r }, unlink: function (t) { var r = this, o, q, p, s; for (o = 0, q = t.length; o < q; o++) { p = t[o]; s = r[p]; if (s) { if (s.isInstance && !s.destroyed) { s.destroy() } else { if (s.parentNode && "nodeType" in s) { s.parentNode.removeChild(s) } } } r[p] = null } return r }, $reap: function () { var q = this, o = q.$noClearOnDestroy, s, r, p; for (s in q) { if ((!o || !o[s]) && q.hasOwnProperty(s)) { r = q[s]; p = typeof r; if (p === "object" || (p === "function" && !r.$noClearOnDestroy)) { q[s] = null } } } }, destroy: function () { var q = this, p = q.$links, o = q.clearPropertiesOnDestroy; if (p) { q.$links = null; q.unlink(Ext.Object.getKeys(p)) } q.destroy = Ext.emptyFn; q.isDestroyed = q.destroyed = true; if (o === true) { q.$reap() } else { if (o) { g.add(q) } } } }); d.callOverridden = d.callParent; return i }(Ext.Function.flexSetter)); (function (b, a) { (Ext.util || (Ext.util = {})).Cache = b = function (c) { var e = this, d; if (c) { Ext.apply(e, c) } e.head = d = { key: null, value: null }; e.map = {}; d.next = d.prev = d }; b.prototype = a = { maxSize: 100, count: 0, clear: function () { var e = this, c = e.head, d = c.next; c.next = c.prev = c; if (!e.evict.$nullFn) { for (; d !== c; d = d.next) { e.evict(d.key, d.value) } } e.count = 0 }, each: function (e, d) { d = d || this; for (var c = this.head, g = c.next; g !== c; g = g.next) { if (e.call(d, g.key, g.value)) { break } } }, get: function (d) { var g = this, c = g.head, h = g.map, e = h[d]; if (e) { if (e.prev !== c) { g.unlinkEntry(e); g.linkEntry(e) } } else { h[d] = e = { key: d, value: g.miss.apply(g, arguments) }; g.linkEntry(e); ++g.count; while (g.count > g.maxSize) { g.unlinkEntry(c.prev, true); --g.count } } return e.value }, evict: Ext.emptyFn, linkEntry: function (d) { var c = this.head, e = c.next; d.next = e; d.prev = c; c.next = d; e.prev = d }, unlinkEntry: function (e, g) { var c = e.next, d = e.prev; d.next = c; c.prev = d; if (g) { this.evict(e.key, e.value) } } }; a.destroy = a.clear }()); (function () { var d, c = Ext.Base, e = c.$staticMembers, b = function (h, g) { return (h.length - g.length) || ((h < g) ? -1 : ((h > g) ? 1 : 0)) }; function a(h) { function g() { return this.constructor.apply(this, arguments) || null } return g } Ext.Class = d = function (h, i, g) { if (typeof h != "function") { g = i; i = h; h = null } if (!i) { i = {} } h = d.create(h, i); d.process(h, i, g); return h }; Ext.apply(d, { makeCtor: a, onBeforeCreated: function (h, i, g) { h.addMembers(i); g.onCreated.call(h, h) }, create: function (g, k) { var j = e.length, h; if (!g) { g = a() } while (j--) { h = e[j]; g[h] = c[h] } return g }, process: function (g, o, k) { var h = o.preprocessors || d.defaultPreprocessors, r = this.preprocessors, u = { onBeforeCreated: this.onBeforeCreated }, t = [], v, n, m, s, l, q, p; delete o.preprocessors; g._classHooks = u; for (m = 0, s = h.length; m < s; m++) { v = h[m]; if (typeof v == "string") { v = r[v]; n = v.properties; if (n === true) { t.push(v.fn) } else { if (n) { for (l = 0, q = n.length; l < q; l++) { p = n[l]; if (o.hasOwnProperty(p)) { t.push(v.fn); break } } } } } else { t.push(v) } } u.onCreated = k ? k : Ext.emptyFn; u.preprocessors = t; this.doProcess(g, o, u) }, doProcess: function (h, l, g) { var k = this, m = g.preprocessors, i = m.shift(), j = k.doProcess; for (; i; i = m.shift()) { if (i.call(k, h, l, g, j) === false) { return } } g.onBeforeCreated.apply(k, arguments) }, preprocessors: {}, registerPreprocessor: function (h, k, i, g, j) { if (!g) { g = "last" } if (!i) { i = [h] } this.preprocessors[h] = { name: h, properties: i || false, fn: k }; this.setDefaultPreprocessorPosition(h, g, j); return this }, getPreprocessor: function (g) { return this.preprocessors[g] }, getPreprocessors: function () { return this.preprocessors }, defaultPreprocessors: [], getDefaultPreprocessors: function () { return this.defaultPreprocessors }, setDefaultPreprocessors: function (g) { this.defaultPreprocessors = Ext.Array.from(g); return this }, setDefaultPreprocessorPosition: function (i, k, j) { var g = this.defaultPreprocessors, h; if (typeof k == "string") { if (k === "first") { g.unshift(i); return this } else { if (k === "last") { g.push(i); return this } } k = (k === "after") ? 1 : -1 } h = Ext.Array.indexOf(g, j); if (h !== -1) { Ext.Array.splice(g, Math.max(0, h + k), 0, i) } return this } }); d.registerPreprocessor("extend", function (h, k, p) { var l = Ext.Base, m = l.prototype, n = k.extend, g, o, j; delete k.extend; if (n && n !== Object) { g = n } else { g = l } o = g.prototype; if (!g.$isClass) { for (j in m) { if (!o[j]) { o[j] = m[j] } } } h.extend(g); h.triggerExtended.apply(h, arguments); if (k.onClassExtended) { h.onExtended(k.onClassExtended, h); delete k.onClassExtended } }, true); d.registerPreprocessor("privates", function (g, j) { var i = j.privates, k = i.statics, h = i.privacy || true; delete j.privates; delete i.statics; g.addMembers(i, false, h); if (k) { g.addMembers(k, true, h) } }); d.registerPreprocessor("statics", function (g, h) { g.addStatics(h.statics); delete h.statics }); d.registerPreprocessor("inheritableStatics", function (g, h) { g.addInheritableStatics(h.inheritableStatics); delete h.inheritableStatics }); Ext.createRuleFn = function (g) { return new Function("$c", "with($c) { try { return (" + g + "); } catch(e) { return false;}}") }; Ext.expressionCache = new Ext.util.Cache({ miss: Ext.createRuleFn }); Ext.ruleKeySortFn = b; Ext.getPlatformConfigKeys = function (i) { var h = [], g, j; for (g in i) { j = Ext.expressionCache.get(g); if (j(Ext.platformTags)) { h.push(g) } } h.sort(b); return h }; d.registerPreprocessor("platformConfig", function (h, i, g) { h.addPlatformConfig(i) }); d.registerPreprocessor("config", function (g, h) { if (h.hasOwnProperty("$configPrefixed")) { g.prototype.$configPrefixed = h.$configPrefixed } g.addConfig(h.config); delete h.config }); d.registerPreprocessor("cachedConfig", function (g, h) { if (h.hasOwnProperty("$configPrefixed")) { g.prototype.$configPrefixed = h.$configPrefixed } g.addCachedConfig(h.cachedConfig); delete h.cachedConfig }); d.registerPreprocessor("mixins", function (j, k, g) { var i = k.mixins, h = g.onCreated; delete k.mixins; g.onCreated = function () { g.onCreated = h; j.mixin(i); return g.onCreated.apply(this, arguments) } }); Ext.extend = function (i, j, h) { if (arguments.length === 2 && Ext.isObject(j)) { h = j; j = i; i = null } var g; if (!j) { throw new Error("[Ext.extend] Attempting to extend from a class which has not been loaded on the page.") } h.extend = j; h.preprocessors = ["extend", "statics", "inheritableStatics", "mixins", "platformConfig", "config"]; if (i) { g = new d(i, h); g.prototype.constructor = i } else { g = new d(h) } g.prototype.override = function (l) { for (var k in l) { if (l.hasOwnProperty(k)) { this[k] = l[k] } } }; return g } }()); Ext.Inventory = function () { var a = this; a.names = []; a.paths = {}; a.alternateToName = {}; a.aliasToName = {}; a.nameToAliases = {}; a.nameToAlternates = {}; a.nameToPrefix = {} }; Ext.Inventory.prototype = { _array1: [0], prefixes: null, dotRe: /\./g, wildcardRe: /\*/g, addAlias: function (b, a, c) { return this.addMapping(b, a, this.aliasToName, this.nameToAliases, c) }, addAlternate: function (a, b) { return this.addMapping(a, b, this.alternateToName, this.nameToAlternates) }, addMapping: function (m, e, g, p, h) { var b = m.$className || m, k = b, l = this._array1, o, d, q, j, c, n; if (Ext.isString(b)) { k = {}; k[b] = e } for (q in k) { d = k[q]; if (Ext.isString(d)) { l[0] = d; d = l } c = d.length; n = p[q] || (p[q] = []); for (j = 0; j < c; ++j) { if (!(o = d[j])) { continue } if (g[o] !== q) { g[o] = q; n.push(o) } } } }, getAliasesByName: function (a) { return this.nameToAliases[a] || null }, getAlternatesByName: function (a) { return this.nameToAlternates[a] || null }, getNameByAlias: function (a) { return this.aliasToName[a] || "" }, getNameByAlternate: function (a) { return this.alternateToName[a] || "" }, getNamesByExpression: function (m, a, j) { var v = this, s = v.aliasToName, p = v.alternateToName, b = v.nameToAliases, d = v.nameToAlternates, u = j ? a : {}, l = [], t = Ext.isString(m) ? [m] : m, h = t.length, e = v.wildcardRe, c, q, r, k, o, w, g; for (q = 0; q < h; ++q) { if ((c = t[q]).indexOf("*") < 0) { if (!(w = s[c])) { if (!(w = p[c])) { w = c } } if (!(w in u) && !(a && (w in a))) { u[w] = 1; l.push(w) } } else { g = new RegExp("^" + c.replace(e, "(.*?)") + "$"); for (w in b) { if (!(w in u) && !(a && (w in a))) { if (!(k = g.test(w))) { o = (r = b[w]).length; while (!k && o-- > 0) { k = g.test(r[o]) } r = d[w]; if (r && !k) { o = r.length; while (!k && o-- > 0) { k = g.test(r[o]) } } } if (k) { u[w] = 1; l.push(w) } } } } } return l }, getPath: function (b) { var c = this, e = c.paths, a = "", d; if (b in e) { a = e[b] } else { d = c.nameToPrefix[b] || (c.nameToPrefix[b] = c.getPrefix(b)); if (d) { b = b.substring(d.length + 1); a = e[d]; if (a) { a += "/" } } a += b.replace(c.dotRe, "/") + ".js" } return a }, getPrefix: function (h) { if (h in this.paths) { return h } else { if (h in this.nameToPrefix) { return this.nameToPrefix[h] } } var e = this.getPrefixes(), b = h.length, i, c, a, g, d, k; while (b-- > 0) { i = e[b]; if (i) { c = h.charAt(b); if (c !== ".") { continue } a = h.substring(0, b); for (d = 0, k = i.length; d < k; d++) { g = i[d]; if (g === h.substring(0, b)) { return g } } } } return "" }, getPrefixes: function () { var e = this, g = e.prefixes, j, c, h, b, d, a; if (!g) { j = e.names.slice(0); e.prefixes = g = []; for (d = 0, a = j.length; d < a; d++) { c = j[d]; h = c.length; b = g[h] || (g[h] = []); b.push(c) } } return g }, removeName: function (b) { var g = this, k = g.aliasToName, m = g.alternateToName, l = g.nameToAliases, e = g.nameToAlternates, c = l[b], h = e[b], d, j; delete l[b]; delete e[b]; delete g.nameToPrefix[b]; if (c) { for (d = c.length; d--;) { if (b === (j = c[d])) { delete k[j] } } } if (h) { for (d = h.length; d--;) { if (b === (j = h[d])) { delete m[j] } } } }, resolveName: function (a) { var b = this, c; if (!(a in b.nameToAliases)) { if (!(c = b.aliasToName[a])) { c = b.alternateToName[a] } } return c || a }, select: function (e, c) { var d = this, g = {}, b = { excludes: g, exclude: function () { d.getNamesByExpression(arguments, g, true); return this } }, a; for (a in e) { b[a] = d.selectMethod(g, e[a], c || e) } return b }, selectMethod: function (d, b, a) { var c = this; return function (e) { var g = Ext.Array.slice(arguments, 1); g.unshift(c.getNamesByExpression(e, d)); return b.apply(a, g) } }, setPath: Ext.Function.flexSetter(function (a, c) { var b = this; b.paths[a] = c; b.names.push(a); b.prefixes = null; b.nameToPrefix = {}; return b }) }; Ext.ClassManager = (function (q, l, s, e, o) { var b = Ext.Class.makeCtor, h = [], i = { Ext: { name: "Ext", value: Ext } }, c = Ext.apply(new Ext.Inventory(), { classes: {}, classState: {}, existCache: {}, instantiators: [], isCreated: function (u) { if (c.classes[u] || c.existCache[u]) { return true } if (!c.lookupName(u, false)) { return false } c.triggerCreated(u); return true }, createdListeners: [], nameCreatedListeners: {}, existsListeners: [], nameExistsListeners: {}, overrideMap: {}, triggerCreated: function (u, v) { c.existCache[u] = v || 1; c.classState[u] += 40; c.notify(u, c.createdListeners, c.nameCreatedListeners) }, onCreated: function (w, v, u) { c.addListener(w, v, u, c.createdListeners, c.nameCreatedListeners) }, notify: function (C, E, w) { var x = c.getAlternatesByName(C), D = [C], z, B, y, A, v, u; for (z = 0, B = E.length; z < B; z++) { v = E[z]; v.fn.call(v.scope, C) } while (D) { for (z = 0, B = D.length; z < B; z++) { u = D[z]; E = w[u]; if (E) { for (y = 0, A = E.length; y < A; y++) { v = E[y]; v.fn.call(v.scope, u) } delete w[u] } } D = x; x = null } }, addListener: function (z, y, x, w, v) { if (Ext.isArray(x)) { z = Ext.Function.createBarrier(x.length, z, y); for (u = 0; u < x.length; u++) { this.addListener(z, null, x[u], w, v) } return } var u, A = { fn: z, scope: y }; if (x) { if (this.isCreated(x)) { z.call(y, x); return } if (!v[x]) { v[x] = [] } v[x].push(A) } else { w.push(A) } }, $namespaceCache: i, addRootNamespaces: function (v) { for (var u in v) { i[u] = { name: u, value: v[u] } } }, clearNamespaceCache: function () { h.length = 0; for (var u in i) { if (!i[u].value) { delete i[u] } } }, getNamespaceEntry: function (v) { if (typeof v !== "string") { return v } var w = i[v], u; if (!w) { u = v.lastIndexOf("."); if (u < 0) { w = { name: v } } else { w = { name: v.substring(u + 1), parent: c.getNamespaceEntry(v.substring(0, u)) } } i[v] = w } return w }, lookupName: function (x, z) { var y = c.getNamespaceEntry(x), w = Ext.global, u = 0, A, v; for (A = y; A; A = A.parent) { h[u++] = A } while (w && u-- > 0) { A = h[u]; v = w; w = A.value || w[A.name]; if (!w && z) { v[A.name] = w = {} } } return w }, setNamespace: function (v, x) { var w = c.getNamespaceEntry(v), u = Ext.global; if (w.parent) { u = c.lookupName(w.parent, true) } u[w.name] = x; return x }, setXType: function (u, B) { var w = u.$className, A = w ? u : c.get(w = u), x = A.prototype, y = x.xtypes, v = x.xtypesChain, z = x.xtypesMap; if (!x.hasOwnProperty("xtypes")) { x.xtypes = y = []; x.xtypesChain = v = v ? v.slice(0) : []; x.xtypesMap = z = Ext.apply({}, z) } c.addAlias(w, "widget." + B, true); y.push(B); v.push(B); z[B] = true }, set: function (u, w) { var v = c.getName(w); c.classes[u] = c.setNamespace(u, w); if (v && v !== u) { c.addAlternate(v, u) } return c }, get: function (u) { return c.classes[u] || c.lookupName(u, false) }, addNameAliasMappings: function (u) { c.addAlias(u) }, addNameAlternateMappings: function (u) { c.addAlternate(u) }, getByAlias: function (u) { return c.get(c.getNameByAlias(u)) }, getByConfig: function (v, w) { var x = v.xclass, u; if (x) { u = x } else { u = v.xtype; if (u) { w = "widget." } else { u = v.type } u = c.getNameByAlias(w + u) } return c.get(u) }, getName: function (u) { return u && u.$className || "" }, getClass: function (u) { return u && u.self || null }, create: function (v, x, u) { var w = b(v); if (typeof x === "function") { x = x(w) } x.$className = v; return new q(w, x, function () { var y = x.postprocessors || c.defaultPostprocessors, F = c.postprocessors, G = [], E, A, D, z, C, B, H; delete x.postprocessors; for (A = 0, D = y.length; A < D; A++) { E = y[A]; if (typeof E === "string") { E = F[E]; B = E.properties; if (B === true) { G.push(E.fn) } else { if (B) { for (z = 0, C = B.length; z < C; z++) { H = B[z]; if (x.hasOwnProperty(H)) { G.push(E.fn); break } } } } } else { G.push(E) } } x.postprocessors = G; x.createdFn = u; c.processCreate(v, this, x) }) }, processCreate: function (x, v, z) { var y = this, u = z.postprocessors.shift(), w = z.createdFn; if (!u) { if (x) { y.set(x, v) } delete v._classHooks; if (w) { w.call(v, v) } if (x) { y.triggerCreated(x) } return } if (u.call(y, x, v, z, y.processCreate) !== false) { y.processCreate(x, v, z) } }, createOverride: function (B, z, x) { var C = this, D = z.override, F = z.requires, y = z.uses, A = z.mixins, v, E = 1, u, w = function () { var G, K, J, I, H; if (!u) { K = F ? F.slice(0) : []; if (A) { if (!(v = A instanceof Array)) { for (I in A) { if (Ext.isString(G = A[I])) { K.push(G) } } } else { for (J = 0, H = A.length; J < H; ++J) { if (Ext.isString(G = A[J])) { K.push(G) } } } } u = true; if (K.length) { Ext.require(K, w); return } } if (v) { for (J = 0, H = A.length; J < H; ++J) { if (Ext.isString(G = A[J])) { A[J] = Ext.ClassManager.get(G) } } } else { if (A) { for (I in A) { if (Ext.isString(G = A[I])) { A[I] = Ext.ClassManager.get(G) } } } } G = D.$isClass ? D : C.get(D); delete z.override; delete z.compatibility; delete z.requires; delete z.uses; Ext.override(G, z); Ext.Loader.history.push(B); if (y) { Ext.Loader.addUsedClasses(y) } if (x) { x.call(G, G) } }; if (B) { c.overrideMap[B] = true } if ("compatibility" in z) { E = z.compatibility; if (!E) { E = false } else { if (typeof E === "number") { E = true } else { if (typeof E !== "boolean") { E = Ext.checkVersion(E) } } } } if (E) { if (D.$isClass) { w() } else { C.onCreated(w, C, D) } } C.triggerCreated(B, 2); return C }, instantiateByAlias: function () { var v = arguments[0], u = s.call(arguments), w = this.getNameByAlias(v); u[0] = w; return Ext.create.apply(Ext, u) }, instantiate: function () { return Ext.create.apply(Ext, arguments) }, dynInstantiate: function (v, u) { u = e(u, true); u.unshift(v); return Ext.create.apply(Ext, u) }, getInstantiator: function (x) { var w = this.instantiators, y, v, u; y = w[x]; if (!y) { v = x; u = []; for (v = 0; v < x; v++) { u.push("a[" + v + "]") } y = w[x] = new Function("c", "a", "return new c(" + u.join(",") + ")") } return y }, postprocessors: {}, defaultPostprocessors: [], registerPostprocessor: function (v, y, w, u, x) { if (!u) { u = "last" } if (!w) { w = [v] } this.postprocessors[v] = { name: v, properties: w || false, fn: y }; this.setDefaultPostprocessorPosition(v, u, x); return this }, setDefaultPostprocessors: function (u) { this.defaultPostprocessors = e(u); return this }, setDefaultPostprocessorPosition: function (v, y, x) { var w = this.defaultPostprocessors, u; if (typeof y === "string") { if (y === "first") { w.unshift(v); return this } else { if (y === "last") { w.push(v); return this } } y = (y === "after") ? 1 : -1 } u = Ext.Array.indexOf(w, x); if (u !== -1) { Ext.Array.splice(w, Math.max(0, u + y), 0, v) } return this } }); c.registerPostprocessor("alias", function (w, v, z) { var u = Ext.Array.from(z.alias), x, y; for (x = 0, y = u.length; x < y; x++) { l = u[x]; this.addAlias(v, l) } }, ["xtype", "alias"]); c.registerPostprocessor("singleton", function (v, u, x, w) { if (x.singleton) { w.call(this, v, new u(), x) } else { return true } return false }); c.registerPostprocessor("alternateClassName", function (v, u, z) { var x = z.alternateClassName, w, y, A; if (!(x instanceof Array)) { x = [x] } for (w = 0, y = x.length; w < y; w++) { A = x[w]; this.set(A, u) } }); c.registerPostprocessor("debugHooks", function (v, u, w) { var x = u.isInstance ? u.self : u; delete x.prototype.debugHooks }); c.registerPostprocessor("deprecated", function (v, u, w) { var x = u.isInstance ? u.self : u; x.addDeprecations(w.deprecated); delete x.prototype.deprecated }); Ext.apply(Ext, { create: function () { var w = arguments[0], x = typeof w, v = s.call(arguments, 1), u; if (x === "function") { u = w } else { if (x !== "string" && v.length === 0) { v = [w]; if (!(w = w.xclass)) { w = v[0].xtype; if (w) { w = "widget." + w } } } w = c.resolveName(w); u = c.get(w) } if (!u) { Ext.syncRequire(w); u = c.get(w) } return c.getInstantiator(v.length)(u, v) }, widget: function (w, v) { var z = w, x, y, u; if (typeof z !== "string") { v = w; z = v.xtype; y = v.xclass } else { v = v || {} } if (v.isComponent) { return v } if (!y) { x = "widget." + z; y = c.getNameByAlias(x) } if (y) { u = c.get(y) } if (!u) { return Ext.create(y || x, v) } return new u(v) }, createByAlias: l(c, "instantiateByAlias"), define: function (v, w, u) { if (w.override) { c.classState[v] = 20; return c.createOverride.apply(c, arguments) } c.classState[v] = 10; return c.create.apply(c, arguments) }, undefine: function (w) { var u = c.classes; delete u[w]; delete c.existCache[w]; delete c.classState[w]; c.removeName(w); var x = c.getNamespaceEntry(w), v = x.parent ? c.lookupName(x.parent, false) : Ext.global; if (v) { try { delete v[x.name] } catch (y) { v[x.name] = undefined } } }, getClassName: l(c, "getName"), getDisplayName: function (u) { if (u) { if (u.displayName) { return u.displayName } if (u.$name && u.$class) { return Ext.getClassName(u.$class) + "#" + u.$name } if (u.$className) { return u.$className } } return "Anonymous" }, getClass: l(c, "getClass"), namespace: function () { var u = o, v; for (v = arguments.length; v-- > 0;) { u = c.lookupName(arguments[v], true) } return u } }); Ext.addRootNamespaces = c.addRootNamespaces; Ext.createWidget = Ext.widget; Ext.ns = Ext.namespace; q.registerPreprocessor("className", function (u, v) { if ("$className" in v) { u.$className = v.$className } }, true, "first"); q.registerPreprocessor("alias", function (F, z) { var D = F.prototype, w = e(z.xtype), u = e(z.alias), G = "widget.", E = G.length, A = Array.prototype.slice.call(D.xtypesChain || []), x = Ext.merge({}, D.xtypesMap || {}), y, C, B, v; for (y = 0, C = u.length; y < C; y++) { B = u[y]; if (B.substring(0, E) === G) { v = B.substring(E); Ext.Array.include(w, v) } } F.xtype = z.xtype = w[0]; z.xtypes = w; for (y = 0, C = w.length; y < C; y++) { v = w[y]; if (!x[v]) { x[v] = true; A.push(v) } } z.xtypesChain = A; z.xtypesMap = x; Ext.Function.interceptAfterOnce(F, "onClassCreated", function () { var I = this, K = I.prototype, H = K.mixins, L, J; for (L in H) { if (H.hasOwnProperty(L)) { J = H[L]; w = J.xtypes; if (w) { for (y = 0, C = w.length; y < C; y++) { v = w[y]; if (!x[v]) { x[v] = true; A.push(v) } } } } } }); for (y = 0, C = w.length; y < C; y++) { v = w[y]; Ext.Array.include(u, G + v) } z.alias = u }, ["xtype", "alias"]); if (Ext.manifest) { var g = Ext.manifest, r = g.classes, n = g.paths, p = {}, j = {}, d, k, t, m, a; if (n) { if (g.bootRelative) { a = Ext.Boot.baseUrl; for (m in n) { if (n.hasOwnProperty(m)) { n[m] = a + n[m] } } } c.setPath(n) } if (r) { for (d in r) { j[d] = []; p[d] = []; k = r[d]; if (k.alias) { p[d] = k.alias } if (k.alternates) { j[d] = k.alternates } } } c.addAlias(p); c.addAlternate(j) } return c }(Ext.Class, Ext.Function.alias, Array.prototype.slice, Ext.Array.from, Ext.global)); (Ext.env || (Ext.env = {})).Browser = function (u, o) { var v = this, a = Ext.Boot.browserPrefixes, c = Ext.Boot.browserNames, b = v.enginePrefixes, k = v.engineNames, r = u.match(new RegExp("((?:" + Ext.Object.getValues(a).join(")|(?:") + "))([\\w\\._]+)")), h = u.match(new RegExp("((?:" + Ext.Object.getValues(b).join(")|(?:") + "))([\\w\\._]+)")), q = c.other, t = k.other, m = "", g = "", d = "", j = false, p, n, l, w, s; v.userAgent = u; this.is = function (i) { return !!this.is[i] }; if (/Edge\//.test(u)) { r = u.match(/(Edge\/)([\w.]+)/) } if (r) { q = c[Ext.Object.getKey(a, r[1])]; if (q === "Safari" && /^Opera/.test(u)) { q = "Opera" } m = new Ext.Version(r[2]) } if (h) { t = k[Ext.Object.getKey(b, h[1])]; g = new Ext.Version(h[2]) } if (t === "Trident" && q !== "IE") { q = "IE"; var e = u.match(/.*rv:(\d+.\d+)/); if (e && e.length) { e = e[1]; m = new Ext.Version(e) } } if (q && m) { Ext.setVersion(q, m) } if (u.match(/FB/) && q === "Other") { q = c.safari; t = k.webkit } if (u.match(/Android.*Chrome/g)) { q = "ChromeMobile" } if (u.match(/OPR/)) { q = "Opera"; r = u.match(/OPR\/(\d+.\d+)/); m = new Ext.Version(r[1]) } Ext.apply(this, { engineName: t, engineVersion: g, name: q, version: m }); this.setFlag(q, true, o); if (m) { d = m.getMajor() || ""; if (v.is.IE) { d = parseInt(d, 10); l = document.documentMode; if (l === 7 || (d === 7 && l !== 8 && l !== 9 && l !== 10)) { d = 7 } else { if (l === 8 || (d === 8 && l !== 8 && l !== 9 && l !== 10)) { d = 8 } else { if (l === 9 || (d === 9 && l !== 7 && l !== 8 && l !== 10)) { d = 9 } else { if (l === 10 || (d === 10 && l !== 7 && l !== 8 && l !== 9)) { d = 10 } else { if (l === 11 || (d === 11 && l !== 7 && l !== 8 && l !== 9 && l !== 10)) { d = 11 } } } } } s = Math.max(d, Ext.Boot.maxIEVersion); for (p = 7; p <= s; ++p) { n = "isIE" + p; if (d <= p) { Ext[n + "m"] = true } if (d === p) { Ext[n] = true } if (d >= p) { Ext[n + "p"] = true } } } if (v.is.Opera && parseInt(d, 10) <= 12) { Ext.isOpera12m = true } Ext.chromeVersion = Ext.isChrome ? d : 0; Ext.firefoxVersion = Ext.isFirefox ? d : 0; Ext.ieVersion = Ext.isIE ? d : 0; Ext.operaVersion = Ext.isOpera ? d : 0; Ext.safariVersion = Ext.isSafari ? d : 0; Ext.webKitVersion = Ext.isWebKit ? d : 0; this.setFlag(q + d, true, o); this.setFlag(q + m.getShortVersion()) } for (p in c) { if (c.hasOwnProperty(p)) { w = c[p]; this.setFlag(w, q === w) } } this.setFlag(w); if (g) { this.setFlag(t + (g.getMajor() || "")); this.setFlag(t + g.getShortVersion()) } for (p in k) { if (k.hasOwnProperty(p)) { w = k[p]; this.setFlag(w, t === w, o) } } this.setFlag("Standalone", !!navigator.standalone); this.setFlag("Ripple", !!document.getElementById("tinyhippos-injected") && !Ext.isEmpty(window.top.ripple)); this.setFlag("WebWorks", !!window.blackberry); if (window.PhoneGap !== undefined || window.Cordova !== undefined || window.cordova !== undefined) { j = true; this.setFlag("PhoneGap"); this.setFlag("Cordova") } if (/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)(?!.*FBAN)/i.test(u)) { j = true } this.setFlag("WebView", j); this.isStrict = Ext.isStrict = document.compatMode === "CSS1Compat"; this.isSecure = Ext.isSecure; this.identity = q + d + (this.isStrict ? "Strict" : "Quirks") }; Ext.env.Browser.prototype = { constructor: Ext.env.Browser, engineNames: { webkit: "WebKit", gecko: "Gecko", presto: "Presto", trident: "Trident", other: "Other" }, enginePrefixes: { webkit: "AppleWebKit/", gecko: "Gecko/", presto: "Presto/", trident: "Trident/" }, styleDashPrefixes: { WebKit: "-webkit-", Gecko: "-moz-", Trident: "-ms-", Presto: "-o-", Other: "" }, stylePrefixes: { WebKit: "Webkit", Gecko: "Moz", Trident: "ms", Presto: "O", Other: "" }, propertyPrefixes: { WebKit: "webkit", Gecko: "moz", Trident: "ms", Presto: "o", Other: "" }, name: null, version: null, engineName: null, engineVersion: null, setFlag: function (a, c, b) { if (c === undefined) { c = true } this.is[a] = c; this.is[a.toLowerCase()] = c; if (b) { Ext["is" + a] = c } return this }, getStyleDashPrefix: function () { return this.styleDashPrefixes[this.engineName] }, getStylePrefix: function () { return this.stylePrefixes[this.engineName] }, getVendorProperyName: function (a) { var b = this.propertyPrefixes[this.engineName]; if (b.length > 0) { return b + Ext.String.capitalize(a) } return a }, getPreferredTranslationMethod: function (a) { if (typeof a === "object" && "translationMethod" in a && a.translationMethod !== "auto") { return a.translationMethod } else { return "csstransform" } } }; (function (a) { Ext.browser = new Ext.env.Browser(a, true); Ext.userAgent = a.toLowerCase(); Ext.SSL_SECURE_URL = Ext.isSecure && Ext.isIE ? "javascript:''" : "about:blank" }(Ext.global.navigator.userAgent)); Ext.env.OS = function (p, b, m) { var l = this, k = Ext.Boot.osNames, d = Ext.Boot.osPrefixes, a, j = "", g = l.is, c, h, e, o, n; m = m || Ext.browser; for (c in d) { if (d.hasOwnProperty(c)) { h = d[c]; e = p.match(new RegExp("(?:" + h + ")([^\\s;]+)")); if (e) { a = k[c]; n = e[1]; if (n && n === "HTC_") { j = new Ext.Version("2.3") } else { if (n && n === "Silk/") { j = new Ext.Version("2.3") } else { j = new Ext.Version(e[e.length - 1]) } } break } } } if (!a) { a = k[(p.toLowerCase().match(/mac|win|linux/) || ["other"])[0]]; j = new Ext.Version("") } this.name = a; this.version = j; if (p.match(/ipad/i)) { b = "iPad" } if (b) { this.setFlag(b.replace(/ simulator$/i, "")) } this.setFlag(a); if (j) { this.setFlag(a + (j.getMajor() || "")); this.setFlag(a + j.getShortVersion()) } for (c in k) { if (k.hasOwnProperty(c)) { o = k[c]; if (!g.hasOwnProperty(a)) { this.setFlag(o, (a === o)) } } } if (this.name === "iOS" && window.screen.height === 568) { this.setFlag("iPhone5") } if (m.is.Safari || m.is.Silk) { if (this.is.Android2 || this.is.Android3 || m.version.shortVersion === 501) { m.setFlag("AndroidStock") } if (this.is.Android4) { m.setFlag("AndroidStock"); m.setFlag("AndroidStock4") } } }; Ext.env.OS.prototype = { constructor: Ext.env.OS, is: function (a) { return !!this[a] }, name: null, version: null, setFlag: function (a, b) { if (b === undefined) { b = true } if (this.flags) { this.flags[a] = b } this.is[a] = b; this.is[a.toLowerCase()] = b; return this } }; (function () { var a = Ext.global.navigator, h = a.userAgent, g = Ext.env.OS, e = (Ext.is || (Ext.is = {})), i, d, b; g.prototype.flags = e; Ext.os = i = new g(h, a.platform); d = i.name; Ext["is" + d] = true; Ext.isMac = e.Mac = e.MacOS; var j = window.location.search.match(/deviceType=(Tablet|Phone)/), c = window.deviceType; if (j && j[1]) { b = j[1] } else { if (c === "iPhone") { b = "Phone" } else { if (c === "iPad") { b = "Tablet" } else { if (!i.is.Android && !i.is.iOS && !i.is.WindowsPhone && /Windows|Linux|MacOS/.test(d)) { b = "Desktop"; Ext.browser.is.WebView = !!Ext.browser.is.Ripple } else { if (i.is.iPad || i.is.RIMTablet || i.is.Android3 || Ext.browser.is.Silk || (i.is.Android && h.search(/mobile/i) === -1)) { b = "Tablet" } else { b = "Phone" } } } } } i.setFlag(b, true); i.deviceType = b; delete g.prototype.flags }()); Ext.feature = { has: function (a) { return !!this.has[a] }, testElements: {}, getTestElement: function (a, b) { if (a === undefined) { a = "div" } else { if (typeof a !== "string") { return a } } if (b) { return document.createElement(a) } if (!this.testElements[a]) { this.testElements[a] = document.createElement(a) } return this.testElements[a] }, isStyleSupported: function (c, b) { var d = this.getTestElement(b).style, a = Ext.String.capitalize(c); if (typeof d[c] !== "undefined" || typeof d[Ext.browser.getStylePrefix(c) + a] !== "undefined") { return true } return false }, isStyleSupportedWithoutPrefix: function (b, a) { var c = this.getTestElement(a).style; if (typeof c[b] !== "undefined") { return true } return false }, isEventSupported: function (c, a) { if (a === undefined) { a = window } var e = this.getTestElement(a), b = "on" + c.toLowerCase(), d = (b in e); if (!d) { if (e.setAttribute && e.removeAttribute) { e.setAttribute(b, ""); d = typeof e[b] === "function"; if (typeof e[b] !== "undefined") { e[b] = undefined } e.removeAttribute(b) } } return d }, getStyle: function (c, b) { var a = c.ownerDocument.defaultView, d = (a ? a.getComputedStyle(c, null) : c.currentStyle); return (d || c.style)[b] }, getSupportedPropertyName: function (b, a) { var c = Ext.browser.getVendorProperyName(a); if (c in b) { return c } else { if (a in b) { return a } } return null }, detect: function (j) { var k = this, m = document, g = k.toRun || k.tests, e = g.length, b = m.createElement("div"), c = [], p = Ext.supports, o = k.has, a, i, h, d, l; b.innerHTML = '<div style="height:30px;width:50px;"><div style="height:20px;width:20px;"></div></div><div style="width: 200px; height: 200px; position: relative; padding: 5px;"><div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div></div><div style="position: absolute; left: 10%; top: 10%;"></div><div style="float:left; background-color:transparent;"></div>'; if (j) { m.body.appendChild(b) } d = k.preDetected[Ext.browser.identity] || []; while (e--) { h = g[e]; l = d[e]; a = h.name; i = h.names; if (l === undefined) { if (!j && h.ready) { c.push(h); continue } l = h.fn.call(k, m, b) } if (a) { p[a] = o[a] = l } else { if (i) { while (i.length) { a = i.pop(); p[a] = o[a] = l } } } } if (j) { m.body.removeChild(b) } k.toRun = c }, report: function () { var b = [], a = this.tests.length, c; for (c = 0; c < a; ++c) { b.push(this.has[this.tests[c].name] ? 1 : 0) } Ext.log(Ext.browser.identity + ": [" + b.join(",") + "]") }, preDetected: {}, tests: [{ name: "CloneNodeCopiesExpando", fn: function () { var a = document.createElement("div"); a.expandoProp = {}; return a.cloneNode().expandoProp === a.expandoProp } }, { name: "CSSPointerEvents", fn: function (a) { return "pointerEvents" in a.documentElement.style } }, { name: "CSS3BoxShadow", fn: function (a) { return "boxShadow" in a.documentElement.style || "WebkitBoxShadow" in a.documentElement.style || "MozBoxShadow" in a.documentElement.style } }, { name: "CSS3NegationSelector", fn: function (b) { try { b.querySelectorAll("foo:not(bar)") } catch (a) { return false } return true } }, { name: "ClassList", fn: function (a) { return !!a.documentElement.classList } }, { name: "Canvas", fn: function () { var a = this.getTestElement("canvas"); return !!(a && a.getContext && a.getContext("2d")) } }, { name: "Svg", fn: function (a) { return !!(a.createElementNS && !!a.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect) } }, { name: "Vml", fn: function () { var b = this.getTestElement(), a = false; b.innerHTML = "<!--[if vml]><br><![endif]-->"; a = (b.childNodes.length === 1); b.innerHTML = ""; return a } }, { name: "Touch", fn: function () { var a = navigator.msMaxTouchPoints || navigator.maxTouchPoints; if (Ext.browser.is.Chrome && Ext.browser.version.isLessThanOrEqual(39)) { return (Ext.supports.TouchEvents && a !== 1) || a > 1 } else { return Ext.supports.TouchEvents || a > 0 } } }, { name: "TouchEvents", fn: function () { return this.isEventSupported("touchend") } }, { name: "PointerEvents", fn: function () { return navigator.pointerEnabled } }, { name: "MSPointerEvents", fn: function () { return navigator.msPointerEnabled } }, { name: "Orientation", fn: function () { return ("orientation" in window) && this.isEventSupported("orientationchange") } }, { name: "OrientationChange", fn: function () { return this.isEventSupported("orientationchange") } }, { name: "DeviceMotion", fn: function () { return this.isEventSupported("devicemotion") } }, { names: ["Geolocation", "GeoLocation"], fn: function () { return "geolocation" in window.navigator } }, { name: "SqlDatabase", fn: function () { return "openDatabase" in window } }, { name: "WebSockets", fn: function () { return "WebSocket" in window } }, { name: "Range", fn: function () { return !!document.createRange } }, { name: "CreateContextualFragment", fn: function () { var a = !!document.createRange ? document.createRange() : false; return a && !!a.createContextualFragment } }, { name: "History", fn: function () { return ("history" in window && "pushState" in window.history) } }, { name: "Css3dTransforms", fn: function () { return this.has("CssTransforms") && this.isStyleSupported("perspective") } }, { name: "CssTransforms", fn: function () { return this.isStyleSupported("transform") } }, { name: "CssTransformNoPrefix", fn: function () { return this.isStyleSupportedWithoutPrefix("transform") } }, { name: "CssAnimations", fn: function () { return this.isStyleSupported("animationName") } }, { names: ["CssTransitions", "Transitions"], fn: function () { return this.isStyleSupported("transitionProperty") } }, { names: ["Audio", "AudioTag"], fn: function () { return !!this.getTestElement("audio").canPlayType } }, { name: "Video", fn: function () { return !!this.getTestElement("video").canPlayType } }, { name: "LocalStorage", fn: function () { try { if ("localStorage" in window && window.localStorage !== null) { localStorage.setItem("sencha-localstorage-test", "test success"); localStorage.removeItem("sencha-localstorage-test"); return true } } catch (a) { } return false } }, { name: "XHR2", fn: function () { return window.ProgressEvent && window.FormData && window.XMLHttpRequest && ("withCredentials" in new XMLHttpRequest()) } }, { name: "XHRUploadProgress", fn: function () { if (window.XMLHttpRequest && !Ext.browser.is.AndroidStock) { var a = new XMLHttpRequest(); return a && ("upload" in a) && ("onprogress" in a.upload) } return false } }, { name: "NumericInputPlaceHolder", fn: function () { return !(Ext.browser.is.AndroidStock4 && Ext.os.version.getMinor() < 2) } }, { name: "matchesSelector", fn: function () { var b = document.documentElement, e = "matches", d = "webkitMatchesSelector", a = "msMatchesSelector", c = "mozMatchesSelector"; return b[e] ? e : b[d] ? d : b[a] ? a : b[c] ? c : null } }, { name: "RightMargin", ready: true, fn: function (b, c) { var a = b.defaultView; return !(a && a.getComputedStyle(c.firstChild.firstChild, null).marginRight !== "0px") } }, { name: "DisplayChangeInputSelectionBug", fn: function () { var a = Ext.webKitVersion; return 0 < a && a < 533 } }, { name: "DisplayChangeTextAreaSelectionBug", fn: function () { var a = Ext.webKitVersion; return 0 < a && a < 534.24 } }, { name: "TransparentColor", ready: true, fn: function (b, c, a) { a = b.defaultView; return !(a && a.getComputedStyle(c.lastChild, null).backgroundColor !== "transparent") } }, { name: "ComputedStyle", ready: true, fn: function (b, c, a) { a = b.defaultView; return a && a.getComputedStyle } }, { name: "Float", fn: function (a) { return "cssFloat" in a.documentElement.style } }, { name: "CSS3BorderRadius", ready: true, fn: function (d) { var b = ["borderRadius", "BorderRadius", "MozBorderRadius", "WebkitBorderRadius", "OBorderRadius", "KhtmlBorderRadius"], c = false, a; for (a = 0; a < b.length; a++) { if (d.documentElement.style[b[a]] !== undefined) { c = true } } return c && !Ext.isIE9 } }, { name: "CSS3LinearGradient", fn: function (g, a) { var i = "background-image:", h = "-webkit-gradient(linear, left top, right bottom, from(black), to(white))", e = "linear-gradient(left top, black, white)", d = "-moz-" + e, b = "-ms-" + e, c = "-o-" + e, j = [i + h, i + e, i + d, i + b, i + c]; a.style.cssText = j.join(";"); return (("" + a.style.backgroundImage).indexOf("gradient") !== -1) && !Ext.isIE9 } }, { name: "MouseEnterLeave", fn: function (a) { return ("onmouseenter" in a.documentElement && "onmouseleave" in a.documentElement) } }, { name: "MouseWheel", fn: function (a) { return ("onmousewheel" in a.documentElement) } }, { name: "Opacity", fn: function (a, b) { if (Ext.isIE8) { return false } b.firstChild.style.cssText = "opacity:0.73"; return b.firstChild.style.opacity == "0.73" } }, { name: "Placeholder", fn: function (a) { return "placeholder" in a.createElement("input") } }, { name: "Direct2DBug", fn: function (a) { return Ext.isString(a.documentElement.style.msTransformOrigin) && Ext.isIE9m } }, { name: "BoundingClientRect", fn: function (a) { return "getBoundingClientRect" in a.documentElement } }, { name: "RotatedBoundingClientRect", ready: true, fn: function (e) { var a = e.body, b = false, d = e.createElement("div"), c = d.style; if (d.getBoundingClientRect) { c.position = "absolute"; c.top = "0"; c.WebkitTransform = c.MozTransform = c.msTransform = c.OTransform = c.transform = "rotate(90deg)"; c.width = "100px"; c.height = "30px"; a.appendChild(d); b = d.getBoundingClientRect().height !== 100; a.removeChild(d) } return b } }, { name: "ChildContentClearedWhenSettingInnerHTML", ready: true, fn: function () { var a = this.getTestElement(), b; a.innerHTML = "<div>a</div>"; b = a.firstChild; a.innerHTML = "<div>b</div>"; return b.innerHTML !== "a" } }, { name: "IncludePaddingInWidthCalculation", ready: true, fn: function (a, b) { return b.childNodes[1].firstChild.offsetWidth === 210 } }, { name: "IncludePaddingInHeightCalculation", ready: true, fn: function (a, b) { return b.childNodes[1].firstChild.offsetHeight === 210 } }, { name: "TextAreaMaxLength", fn: function (a) { return ("maxlength" in a.createElement("textarea")) } }, { name: "GetPositionPercentage", ready: true, fn: function (a, b) { return Ext.feature.getStyle(b.childNodes[2], "left") === "10%" } }, { name: "PercentageHeightOverflowBug", ready: true, fn: function (d) { var a = false, c, b; if (Ext.getScrollbarSize().height) { b = this.getTestElement(); c = b.style; c.height = "50px"; c.width = "50px"; c.overflow = "auto"; c.position = "absolute"; b.innerHTML = ['<div style="display:table;height:100%;">', '<div style="width:51px;"></div>', "</div>"].join(""); d.body.appendChild(b); if (b.firstChild.offsetHeight === 50) { a = true } d.body.removeChild(b) } return a } }, { name: "xOriginBug", ready: true, fn: function (d, e) { e.innerHTML = '<div id="b1" style="height:100px;width:100px;direction:rtl;position:relative;overflow:scroll"><div id="b2" style="position:relative;width:100%;height:20px;"></div><div id="b3" style="position:absolute;width:20px;height:20px;top:0px;right:0px"></div></div>'; var c = document.getElementById("b1").getBoundingClientRect(), b = document.getElementById("b2").getBoundingClientRect(), a = document.getElementById("b3").getBoundingClientRect(); return (b.left !== c.left && a.right !== c.right) } }, { name: "ScrollWidthInlinePaddingBug", ready: true, fn: function (d) { var a = false, c, b; b = d.createElement("div"); c = b.style; c.height = "50px"; c.width = "50px"; c.padding = "10px"; c.overflow = "hidden"; c.position = "absolute"; b.innerHTML = '<span style="display:inline-block;zoom:1;height:60px;width:60px;"></span>'; d.body.appendChild(b); if (b.scrollWidth === 70) { a = true } d.body.removeChild(b); return a } }, { name: "rtlVertScrollbarOnRight", ready: true, fn: function (c, d) { d.innerHTML = '<div style="height:100px;width:100px;direction:rtl;overflow:scroll"><div style="width:20px;height:200px;"></div></div>'; var b = d.firstChild, a = b.firstChild; return (a.offsetLeft + a.offsetWidth !== b.offsetLeft + b.offsetWidth) } }, { name: "rtlVertScrollbarOverflowBug", ready: true, fn: function (b, c) { c.innerHTML = '<div style="height:100px;width:100px;direction:rtl;overflow:auto"><div style="width:95px;height:200px;"></div></div>'; var a = c.firstChild; return a.clientHeight === a.offsetHeight } }, { identity: "defineProperty", fn: function () { if (Ext.isIE8m) { Ext.Object.defineProperty = Ext.emptyFn; return false } return true } }, { identify: "nativeXhr", fn: function () { if (typeof XMLHttpRequest !== "undefined") { return true } XMLHttpRequest = function () { try { return new ActiveXObject("MSXML2.XMLHTTP.3.0") } catch (a) { return null } }; return false } }, { name: "SpecialKeyDownRepeat", fn: function () { return Ext.isWebKit ? parseInt(navigator.userAgent.match(/AppleWebKit\/(\d+)/)[1], 10) >= 525 : !(!(Ext.isGecko || Ext.isIE) || (Ext.isOpera && Ext.operaVersion < 12)) } }, { name: "EmulatedMouseOver", fn: function () { return Ext.os.is.iOS } }, { name: "Hashchange", fn: function () { var a = document.documentMode; return "onhashchange" in window && (a === undefined || a > 7) } }, { name: "FixedTableWidthBug", ready: true, fn: function () { if (Ext.isIE8) { return false } var b = document.createElement("div"), a = document.createElement("div"), c; b.setAttribute("style", "display:table;table-layout:fixed;"); a.setAttribute("style", "display:table-cell;min-width:50px;"); b.appendChild(a); document.body.appendChild(b); b.offsetWidth; b.style.width = "25px"; c = b.offsetWidth; document.body.removeChild(b); return c === 50 } }, { name: "FocusinFocusoutEvents", fn: function () { return !Ext.isGecko } }, { name: "AsyncFocusEvents", fn: function () { return Ext.asyncFocus = !!Ext.isIE } }, { name: "accessibility", ready: true, fn: function (h) { var a = h.body, i, d, e, b, c; function g(o) { var j = [], l = 0, n, k; if (o.indexOf("rgb(") !== -1) { j = o.replace("rgb(", "").replace(")", "").split(", ") } else { if (o.indexOf("#") !== -1) { n = o.length === 7 ? /^#(\S\S)(\S\S)(\S\S)$/ : /^#(\S)(\S)(\S)$/; k = o.match(n); if (k) { j = ["0x" + k[1], "0x" + k[2], "0x" + k[3]] } } } for (var m = 0; m < j.length; m++) { l += parseInt(j[m]) } return l } i = h.createElement("div"); d = h.createElement("img"); e = i.style; Ext.apply(e, { width: "2px", position: "absolute", clip: "rect(1px,1px,1px,1px)", borderWidth: "1px", borderStyle: "solid", borderTopTolor: "#f00", borderRightColor: "#ff0", backgroundColor: "#fff", backgroundImage: "url(" + Ext.BLANK_IMAGE_URL + ")" }); d.alt = ""; d.src = Ext.BLANK_IMAGE_URL; i.appendChild(d); a.appendChild(i); e = i.currentStyle || i.style; c = e.backgroundImage; b = { Images: d.offsetWidth === 1 && d.readyState !== "uninitialized", BackgroundImages: !(c !== null && (c === "none" || c === "url(invalid-url:)")), BorderColors: e.borderTopColor !== e.borderRightColor, LightOnDark: g(e.color) - g(e.backgroundColor) > 0 }; Ext.supports.HighContrastMode = !b.BackgroundImages; a.removeChild(i); i = d = null; return b } }, { name: "ViewportUnits", ready: true, fn: function (e) { if (Ext.isIE8) { return false } var a = e.body, g = document.createElement("div"), d = g.currentStyle || g.style, c, b; a.appendChild(g); Ext.apply(d, { width: "50vw" }); c = parseInt(window.innerWidth / 2, 10); b = parseInt((window.getComputedStyle ? getComputedStyle(g, null) : g.currentStyle).width, 10); a.removeChild(g); g = null; return c === b } }, { name: "CSSVariables", ready: false, fn: function (b) { if (!window.getComputedStyle) { return false } var a = window.getComputedStyle(b.documentElement); return a.getPropertyValue && !!a.getPropertyValue("--x-supports-variables") } }, { name: "Selectors2", ready: false, fn: function (b) { try { return !!b.querySelectorAll(":scope") } catch (a) { return false } } }, { name: "CSSScrollSnap", ready: false, fn: function (b) { var a = b.documentElement.style; return "scrollSnapType" in a || "webkitScrollSnapType" in a || "msScrollSnapType" in a } }, 0] }; Ext.feature.tests.pop(); Ext.supports = {}; Ext.feature.detect(); Ext.env.Ready = { blocks: (location.search || "").indexOf("ext-pauseReadyFire") > 0 ? 1 : 0, bound: 0, delay: 1, firing: false, generation: 0, listeners: [], nextId: 0, sortGeneration: 0, state: 0, timer: null, bind: function () { var a = Ext.env.Ready, b = document; if (!a.bound) { if (b.readyState === "complete") { a.onReadyEvent({ type: b.readyState || "body" }) } else { a.bound = 1; if (Ext.browser.is.PhoneGap && !Ext.os.is.Desktop) { a.bound = 2; b.addEventListener("deviceready", a.onReadyEvent, false) } b.addEventListener("DOMContentLoaded", a.onReadyEvent, false); window.addEventListener("load", a.onReadyEvent, false) } } }, block: function () { ++this.blocks; Ext.isReady = false }, fireReady: function () { var a = Ext.env.Ready; if (!a.state) { Ext._readyTime = Ext.ticks(); Ext.isDomReady = true; a.state = 1; Ext.feature.detect(true); if (!a.delay) { a.handleReady() } else { if (navigator.standalone) { a.timer = Ext.defer(function () { a.timer = null; a.handleReadySoon() }, 1) } else { a.handleReadySoon() } } } }, handleReady: function () { var a = this; if (a.state === 1) { a.state = 2; Ext._beforeReadyTime = Ext.ticks(); a.invokeAll(); Ext._afterReadyTime = Ext.ticks() } }, handleReadySoon: function (a) { var b = this; if (!b.timer) { b.timer = Ext.defer(function () { b.timer = null; b.handleReady() }, a || b.delay) } }, invoke: function (b) { var a = b.delay; if (a) { Ext.defer(b.fn, a, b.scope) } else { if (Ext.elevateFunction) { Ext.elevateFunction(b.fn, b.scope) } else { b.fn.call(b.scope) } } }, invokeAll: function () { if (Ext.elevateFunction) { Ext.elevateFunction(this.doInvokeAll, this) } else { this.doInvokeAll() } }, doInvokeAll: function () { var b = this, a = b.listeners, c; if (!b.blocks) { Ext.isReady = true } b.firing = true; while (a.length) { if (b.sortGeneration !== b.generation) { b.sortGeneration = b.generation; a.sort(b.sortFn) } c = a.pop(); if (b.blocks && !c.dom) { a.push(c); break } b.invoke(c) } b.firing = false }, makeListener: function (d, c, b) { var a = { fn: d, id: ++this.nextId, scope: c, dom: false, priority: 0 }; if (b) { Ext.apply(a, b) } a.phase = a.dom ? 0 : 1; return a }, on: function (c, b, a) { var d = Ext.env.Ready, e = d.makeListener(c, b, a); if (d.state === 2 && !d.firing && (e.dom || !d.blocks)) { d.invoke(e) } else { d.listeners.push(e); ++d.generation; if (!d.bound) { d.bind() } } }, onReadyEvent: function (b) { var a = Ext.env.Ready; if (Ext.elevateFunction) { Ext.elevateFunction(a.doReadyEvent, a, arguments) } else { a.doReadyEvent(b) } }, doReadyEvent: function (b) { var a = this; if (a.bound > 0) { a.unbind(); a.bound = -1 } if (!a.state) { a.fireReady() } }, sortFn: function (d, c) { return -((d.phase - c.phase) || (c.priority - d.priority) || (d.id - c.id)) }, unblock: function () { var a = this; if (a.blocks) { if (!--a.blocks) { if (a.state === 2 && !a.firing) { a.invokeAll() } } } }, unbind: function () { var a = this, b = document; if (a.bound > 1) { b.removeEventListener("deviceready", a.onReadyEvent, false) } b.removeEventListener("DOMContentLoaded", a.onReadyEvent, false); window.removeEventListener("load", a.onReadyEvent, false) } }; (function () { var a = Ext.env.Ready; if (Ext.isIE9m) { Ext.apply(a, { scrollTimer: null, readyStatesRe: /complete/i, pollScroll: function () { var b = true; try { document.documentElement.doScroll("left") } catch (c) { b = false } if (b && document.body) { a.onReadyEvent({ type: "doScroll" }) } else { a.scrollTimer = Ext.defer(a.pollScroll, 20) } return b }, bind: function () { if (a.bound) { return } var d = document, b; try { b = window.frameElement === undefined } catch (c) { } if (!b || !d.documentElement.doScroll) { a.pollScroll = Ext.emptyFn } else { if (a.pollScroll()) { return } } if (d.readyState === "complete") { a.onReadyEvent({ type: "already " + (d.readyState || "body") }) } else { d.attachEvent("onreadystatechange", a.onReadyStateChange); window.attachEvent("onload", a.onReadyEvent); a.bound = 1 } }, unbind: function () { document.detachEvent("onreadystatechange", a.onReadyStateChange); window.detachEvent("onload", a.onReadyEvent); if (Ext.isNumber(a.scrollTimer)) { clearTimeout(a.scrollTimer); a.scrollTimer = null } }, onReadyStateChange: function () { var b = document.readyState; if (a.readyStatesRe.test(b)) { a.onReadyEvent({ type: b }) } } }) } Ext.onDocumentReady = function (e, d, b) { var c = { dom: true }; if (b) { Ext.apply(c, b) } a.on(e, d, c) }; Ext.onReady = function (d, c, b) { a.on(d, c, b) }; Ext.onInternalReady = function (d, c, b) { a.on(d, c, Ext.apply({ priority: 1000 }, b)) }; a.bind() }()); Ext.Loader = (new function () { var c = this, a = Ext.ClassManager, h = Ext.Boot, d = Ext.Class, j = Ext.env.Ready, i = Ext.Function.alias, g = ["extend", "mixins", "requires"], m = {}, k = [], b = [], e = [], n = {}, l = { enabled: true, scriptChainDelay: false, disableCaching: true, disableCachingParam: "_dc", paths: a.paths, preserveScripts: true, scriptCharset: undefined }, o = { disableCaching: true, disableCachingParam: true, preserveScripts: true, scriptChainDelay: "loadDelay" }; Ext.apply(c, { isInHistory: m, isLoading: false, history: k, config: l, readyListeners: b, optionalRequires: e, requiresMap: n, hasFileLoadError: false, scriptsLoading: 0, classesLoading: {}, missingCount: 0, missingQueue: {}, syncModeEnabled: false, init: function () { var v = document.getElementsByTagName("script"), p = v[v.length - 1].src, C = p.substring(0, p.lastIndexOf("/") + 1), A = Ext._classPathMetadata, B = Ext.Microloader, r = Ext.manifest, s, u, x, z, w, y, t, q; if (!a.getPath("Ext")) { a.setPath("Ext", C + "src") } if (A) { Ext._classPathMetadata = null; c.addClassPathMappings(A) } if (r) { s = r.loadOrder; w = Ext.Boot.baseUrl; if (s && r.bootRelative) { for (y = s.length, t = 0; t < y; t++) { q = s[t]; q.path = w + q.path; q.canonicalPath = true } } } if (B) { j.block(); B.onMicroloaderReady(function () { j.unblock() }) } }, setConfig: Ext.Function.flexSetter(function (p, q) { if (p === "paths") { c.setPath(q) } else { l[p] = q; var r = o[p]; if (r) { h.setConfig((r === true) ? p : r, q) } } return c }), getConfig: function (p) { return p ? l[p] : l }, setPath: function () { a.setPath.apply(a, arguments); return c }, addClassPathMappings: function (p) { a.setPath(p); return c }, addBaseUrlClassPathMappings: function (p) { for (var q in p) { p[q] = h.baseUrl + p[q] } Ext.Loader.addClassPathMappings(p) }, getPath: function (p) { return a.getPath(p) }, require: function (r, q, p, t) { if (t) { return c.exclude(t).require(r, q, p) } var s = a.getNamesByExpression(r); return c.load(s, q, p) }, syncRequire: function () { var q = c.syncModeEnabled; c.syncModeEnabled = true; var p = c.require.apply(c, arguments); c.syncModeEnabled = q; return p }, exclude: function (q) { var p = a.select({ require: function (t, s, r) { return c.load(t, s, r) }, syncRequire: function (v, t, s) { var u = c.syncModeEnabled; c.syncModeEnabled = true; var r = c.load(v, t, s); c.syncModeEnabled = u; return r } }); p.exclude(q); return p }, load: function (p, y, A) { if (y) { if (y.length) { y = c.makeLoadCallback(p, y) } y = y.bind(A || Ext.global) } var r = a.classState, t = [], x = [], z = {}, s = p.length, q, w, v, u; for (v = 0; v < s; ++v) { w = a.resolveName(p[v]); if (!a.isCreated(w)) { t.push(w); if (!r[w]) { z[w] = c.getPath(w); x.push(z[w]) } } } u = t.length; if (u) { c.missingCount += u; a.onCreated(function () { if (y) { Ext.callback(y, A, arguments) } c.checkReady() }, c, t); if (!l.enabled) { Ext.raise("Ext.Loader is not enabled, so dependencies cannot be resolved dynamically. Missing required class" + ((t.length > 1) ? "es" : "") + ": " + t.join(", ")) } if (x.length) { c.loadScripts({ url: x, _classNames: t, _urlByClass: z }) } else { c.checkReady() } } else { if (y) { y.call(A) } c.checkReady() } if (c.syncModeEnabled) { if (s === 1) { return a.get(p[0]) } } return c }, makeLoadCallback: function (p, q) { return function () { var s = [], r = p.length; while (r-- > 0) { s[r] = a.get(p[r]) } return q.apply(this, s) } }, onLoadFailure: function () { var p = this, q = p.onError; c.hasFileLoadError = true; --c.scriptsLoading; if (q) { q.call(p.userScope, p) } c.checkReady() }, onLoadSuccess: function () { var x = this, u = x.onLoad, p = x._classNames, w = x._urlByClass, q = a.classState, v = c.missingQueue, t, r, s; --c.scriptsLoading; if (u) { u.call(x.userScope, x) } for (r = 0, s = p.length; r < s; r++) { t = p[r]; if (!q[t]) { v[t] = w[t] } } c.checkReady() }, onReady: function (r, q, t, p) { if (t) { j.on(r, q, p) } else { var s = j.makeListener(r, q, p); if (c.isLoading) { b.push(s) } else { j.invoke(s) } } }, addUsedClasses: function (r) { var p, q, s; if (r) { r = (typeof r === "string") ? [r] : r; for (q = 0, s = r.length; q < s; q++) { p = r[q]; if (typeof p === "string" && !Ext.Array.contains(e, p)) { e.push(p) } } } return c }, triggerReady: function () { var p, q = e; if (c.isLoading && q.length) { e = []; c.require(q) } else { c.isLoading = false; b.sort(j.sortFn); while (b.length && !c.isLoading) { p = b.pop(); j.invoke(p) } j.unblock() } }, historyPush: function (p) { if (p && !m[p] && !a.overrideMap[p]) { m[p] = true; k.push(p) } return c }, loadScripts: function (t) { var s = Ext.manifest, p = s && s.loadOrder, q = s && s.loadOrderMap, r; ++c.scriptsLoading; if (p && !q) { s.loadOrderMap = q = h.createLoadOrderMap(p) } c.checkReady(); r = Ext.apply({ loadOrder: p, loadOrderMap: q, charset: l.scriptCharset, success: c.onLoadSuccess, failure: c.onLoadFailure, sync: c.syncModeEnabled, _classNames: [] }, t); r.userScope = r.scope; r.scope = r; h.load(r) }, loadScriptsSync: function (q) { var p = c.syncModeEnabled; c.syncModeEnabled = true; c.loadScripts({ url: q }); c.syncModeEnabled = p }, loadScriptsSyncBasePrefix: function (q) { var p = c.syncModeEnabled; c.syncModeEnabled = true; c.loadScripts({ url: q, prependBaseUrl: true }); c.syncModeEnabled = p }, loadScript: function (x) { var q = typeof x === "string", t = x instanceof Array, w = !t && !q, p = w ? x.url : x, s = w && x.onError, u = w && x.onLoad, v = w && x.scope, r = { url: p, scope: v, onLoad: u, onError: s, _classNames: [] }; c.loadScripts(r) }, checkMissingQueue: function () { var p = c.missingQueue, q = {}, r, s = 0; for (r in p) { if (!(a.classState[r] || a.isCreated(r))) { q[r] = p[r]; s++ } } c.missingCount = s; c.missingQueue = q }, checkReady: function () { var q = c.isLoading, p; c.checkMissingQueue(); p = c.missingCount + c.scriptsLoading; if (p && !q) { j.block(); c.isLoading = !!p } else { if (!p && q) { c.triggerReady() } } } }); Ext.require = i(c, "require"); Ext.syncRequire = i(c, "syncRequire"); Ext.exclude = i(c, "exclude"); d.registerPreprocessor("loader", function (E, t, D, C) { var z = this, x = [], p, y = a.getName(E), s, r, w, v, B, u, q, A; for (s = 0, w = g.length; s < w; s++) { u = g[s]; if (t.hasOwnProperty(u)) { q = t[u]; if (typeof q === "string") { x.push(q) } else { if (q instanceof Array) { for (r = 0, v = q.length; r < v; r++) { B = q[r]; if (typeof B === "string") { x.push(B) } } } else { if (typeof q !== "function") { for (r in q) { if (q.hasOwnProperty(r)) { B = q[r]; if (typeof B === "string") { x.push(B) } } } } } } } } if (x.length === 0) { return } if (y) { n[y] = x } (y ? c.exclude(y) : c).require(x, function () { for (s = 0, w = g.length; s < w; s++) { u = g[s]; if (t.hasOwnProperty(u)) { q = t[u]; if (typeof q === "string") { t[u] = a.get(q) } else { if (q instanceof Array) { for (r = 0, v = q.length; r < v; r++) { B = q[r]; if (typeof B === "string") { t[u][r] = a.get(B) } } } else { if (typeof q !== "function") { for (var F in q) { if (q.hasOwnProperty(F)) { B = q[F]; if (typeof B === "string") { t[u][F] = a.get(B) } } } } } } } } C.call(z, E, t, D) }); return false }, true, "after", "className"); a.registerPostprocessor("uses", function (r, q, s) { var p = s.uses, t; if (p) { t = a.getNamesByExpression(s.uses); c.addUsedClasses(t) } }); a.onCreated(c.historyPush); c.init() }()); Ext._endTime = Ext.ticks(); if (Ext._beforereadyhandler) { Ext._beforereadyhandler() } (Ext.cmd.derive("Ext.Mixin", Ext.Base, function (a) { return { statics: { addHook: function (i, e, c, d) { var h = Ext.isFunction(i), g = function () { var k = arguments, l = h ? i : d[i], j = this.callParent(k); l.apply(this, k); return j }, b = e.hasOwnProperty(c) && e[c]; if (h) { i.$previous = Ext.emptyFn } g.$name = c; g.$owner = e.self; if (b) { g.$previous = b.$previous; b.$previous = g } else { e[c] = g } } }, onClassExtended: function (l, d) { var g = d.mixinConfig, j = d.xhooks, i = l.superclass, e = d.onClassMixedIn, b, h, k, c; if (j) { delete d.xhooks; (g || (d.mixinConfig = g = {})).on = j } if (g) { b = i.mixinConfig; if (b) { d.mixinConfig = g = Ext.merge({}, b, g) } d.mixinId = g.id; h = g.before; k = g.after; j = g.on; c = g.extended } if (h || k || j || c) { d.onClassMixedIn = function (p) { var m = this.prototype, o = p.prototype, n; if (h) { Ext.Object.each(h, function (q, r) { p.addMember(q, function () { if (m[r].apply(this, arguments) !== false) { return this.callParent(arguments) } }) }) } if (k) { Ext.Object.each(k, function (q, r) { p.addMember(q, function () { var s = this.callParent(arguments); m[r].apply(this, arguments); return s }) }) } if (j) { for (n in j) { a.addHook(j[n], o, n, m) } } if (c) { p.onExtended(function () { var q = Ext.Array.slice(arguments, 0); q.unshift(p); return c.apply(this, q) }, this) } if (e) { e.apply(this, arguments) } } } } } }, 0, 0, 0, 0, 0, 0, [Ext, "Mixin"], 0)); Ext.util = Ext.util || {}; Ext.util.DelayedTask = function (e, d, b, i, h) { var g = this, a, c = function () { var j = Ext.GlobalEvents; clearInterval(g.id); g.id = null; e.apply(d, b || []); if (h !== false && j.hasListeners.idle) { j.fireEvent("idle") } }; i = typeof i === "boolean" ? i : true; g.id = null; g.delay = function (k, m, l, j) { if (i) { g.cancel() } if (typeof k === "number") { a = k } e = m || e; d = l || d; b = j || b; if (!g.id) { g.id = Ext.interval(c, a) } }; g.cancel = function () { if (g.id) { clearInterval(g.id); g.id = null } } }; (Ext.cmd.derive("Ext.util.Event", Ext.Base, function () { var d = Array.prototype.slice, a = Ext.Array.insert, c = Ext.Array.toArray, b = {}; return { isEvent: true, suspended: 0, noOptions: {}, constructor: function (g, e) { this.name = e; this.observable = g; this.listeners = [] }, addListener: function (n, e, g, u, q) { var y = this, l = false, p = y.observable, k = y.name, r, j, x, t, z, s, h, m, v, o, w; if (y.findListener(n, e) === -1) { j = y.createListener(n, e, g, u, q); if (y.firing) { y.listeners = y.listeners.slice(0) } r = y.listeners; m = h = r.length; x = g && g.priority; z = y._highestNegativePriorityIndex; s = z !== undefined; if (x) { t = (x < 0); if (!t || s) { for (v = (t ? z : 0); v < h; v++) { o = r[v].o ? r[v].o.priority || 0 : 0; if (o < x) { m = v; break } } } else { y._highestNegativePriorityIndex = m } } else { if (s) { m = z } } if (!t && m <= z) { y._highestNegativePriorityIndex++ } if (m === h) { r[h] = j } else { a(r, m, [j]) } if (p.isElement) { p._getPublisher(k).subscribe(p, k, g.delegated !== false, g.capture) } if (q) { w = q.managedListeners || (q.managedListeners = []); w.push({ item: y.observable, ename: (g && g.managedName) || y.name, fn: n, scope: e, options: g }) } l = true } return l }, createListener: function (n, q, e, g, i) { var l = this, m = Ext._namedScopes[q], h = { fn: n, scope: q, ev: l, caller: g, manager: i, namedScope: m, defaultScope: m ? (q || l.observable) : undefined, lateBound: typeof n === "string" }, p = n, k = false, j; if (e) { h.o = e; if (e.single) { p = l.createSingle(p, h, e, q); k = true } if (e.target) { p = l.createTargeted(p, h, e, q, k); k = true } if (e.onFrame) { p = l.createAnimFrame(p, h, e, q, k); k = true } if (e.delay) { p = l.createDelayed(p, h, e, q, k); k = true } if (e.buffer) { p = l.createBuffered(p, h, e, q, k); k = true } if (l.observable.isElement) { j = e.type; if (j) { h.type = j } } } h.fireFn = p; h.wrapped = k; return h }, findListener: function (j, h) { var g = this.listeners, e = g.length, k; while (e--) { k = g[e]; if (k) { if (k.fn === j && k.scope == h) { return e } } } return -1 }, removeListener: function (p, r, n) { var o = this, m = false, e = o.observable, l = o.name, h, s, j, q, g, k; n = n != null ? n : o.findListener(p, r); if (n !== -1) { h = o.listeners[n]; if (o.firing) { o.listeners = o.listeners.slice(0) } o.listeners.splice(n, 1); if (o._highestNegativePriorityIndex) { if (n < o._highestNegativePriorityIndex) { o._highestNegativePriorityIndex-- } else { if (n === o._highestNegativePriorityIndex && n === o.listeners.length) { delete o._highestNegativePriorityIndex } } } if (h) { s = h.o; if (h.task) { h.task.cancel(); delete h.task } k = h.tasks && h.tasks.length; if (k) { while (k--) { h.tasks[k].cancel() } delete h.tasks } j = h.manager; if (j) { q = j.managedListeners; if (q) { for (k = q.length; k--;) { g = q[k]; if (g.item === o.observable && g.ename === l && g.fn === p && g.scope === r) { q.splice(k, 1) } } } } if (e.isElement) { e._getPublisher(l).unsubscribe(e, l, s.delegated !== false, s.capture) } } m = true } return m }, clearListeners: function () { var g = this.listeners, e = g.length, h; while (e--) { h = g[e]; this.removeListener(h.fn, h.scope) } }, suspend: function () { ++this.suspended }, resume: function () { if (this.suspended) { --this.suspended } }, isSuspended: function () { return this.suspended > 0 }, fireDelegated: function (g, e) { this.firingObservable = g; return this.fire.apply(this, e) }, fire: function () { var C = this, g = Ext.ComponentQuery, t = C.listeners, n = t.length, q = C.observable, u = q.isElement, B = q.isComponent, z = C.firingObservable, k, y, r, w, h, l, x, v, D, j, p, m, A, s, o; if (!C.suspended && n > 0) { C.firing = true; h = arguments.length ? d.call(arguments, 0) : []; x = h.length; if (u) { A = h[0] } for (w = 0; w < n; w++) { l = t[w]; if (!l) { continue } k = l.o; if (u) { if (D) { A.setCurrentTarget(D) } j = l.type; if (j) { p = A; A = h[0] = p.chain({ type: j }) } Ext.EventObject = A } m = h; if (k) { y = k.delegate; if (y) { if (u) { v = A.getTarget("#" + A.currentTarget.id + " " + y); if (v) { h[1] = v; D = A.currentTarget; A.setCurrentTarget(v) } else { continue } } else { if (B && !g.is(z, y, q)) { continue } } } if (u) { if (k.preventDefault) { A.preventDefault() } if (k.stopPropagation) { A.stopPropagation() } if (k.stopEvent) { A.stopEvent() } } h[x] = k; if (k.args) { m = k.args.concat(h) } } r = C.getFireInfo(l); s = r.fn; o = r.scope; r.fn = r.scope = null; if (o && o.destroyed) { C.removeListener(s, o, w); s = null } if (s && s.apply(o, m) === false) { Ext.EventObject = null; return (C.firing = false) } if (k) { h.length-- } if (p) { A = h[0] = p; p = null } Ext.EventObject = null } } C.firing = false; return true }, getFireInfo: function (k, j) { var l = this.observable, e = k.fireFn, i = k.scope, g = k.namedScope, h; if (!j && k.wrapped) { b.fn = e; return b } h = j ? k.fn : e; if (k.lateBound) { if (!i || g) { i = (k.caller || l).resolveListenerScope(k.defaultScope) } h = i[h] } else { if (g && g.isController) { i = (k.caller || l).resolveListenerScope(k.defaultScope) } else { if (!i || g) { i = l } } } b.fn = h; b.scope = i; return b }, createAnimFrame: function (h, i, k, g, e) { var j; if (!e) { j = i.ev.getFireInfo(i, true); h = j.fn; g = j.scope; j.fn = j.scope = null } return Ext.Function.createAnimationFrame(h, g, k.args) }, createTargeted: function (h, i, j, g, e) { return function () { if (j.target === arguments[0]) { var k; if (!e) { k = i.ev.getFireInfo(i, true); h = k.fn; g = k.scope; k.fn = k.scope = null } return h.apply(g, arguments) } } }, createBuffered: function (h, i, j, g, e) { i.task = new Ext.util.DelayedTask(); return function () { if (i.task) { var k; if (!e) { k = i.ev.getFireInfo(i, true); h = k.fn; g = k.scope; k.fn = k.scope = null } i.task.delay(j.buffer, h, g, c(arguments)) } } }, createDelayed: function (h, i, j, g, e) { return function () { var k = new Ext.util.DelayedTask(), l; if (!e) { l = i.ev.getFireInfo(i, true); h = l.fn; g = l.scope; l.fn = l.scope = null } if (!i.tasks) { i.tasks = [] } i.tasks.push(k); k.delay(j.delay || 10, h, g, c(arguments)) } }, createSingle: function (h, i, j, g, e) { return function () { var l = i.ev, m = l.observable, k = i.fn, n; if (m) { m.removeListener(l.name, k, g) } else { l.removeListener(k, g) } if (!e) { n = l.getFireInfo(i, true); h = n.fn; g = n.scope; n.fn = n.scope = null } return h.apply(g, arguments) } } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "Event"], 0)); (Ext.cmd.derive("Ext.mixin.Identifiable", Ext.Base, { statics: { uniqueIds: {} }, isIdentifiable: true, mixinId: "identifiable", idCleanRegex: /\.|[^\w\-]/g, defaultIdPrefix: "ext-", defaultIdSeparator: "-", getOptimizedId: function () { return this.id }, getUniqueId: function () { var g = this.id, b, d, e, a, c; if (!(g || g === 0)) { b = this.self.prototype; d = this.defaultIdSeparator; a = Ext.mixin.Identifiable.uniqueIds; if (!b.hasOwnProperty("identifiablePrefix")) { e = this.xtype; if (e) { c = this.defaultIdPrefix + e.replace(this.idCleanRegex, d) + d } else { if (!(c = b.$className)) { c = this.defaultIdPrefix + "anonymous" + d } else { c = c.replace(this.idCleanRegex, d).toLowerCase() + d } } b.identifiablePrefix = c } c = this.identifiablePrefix; if (!a.hasOwnProperty(c)) { a[c] = 0 } g = this.id = this.id = c + (++a[c]) } this.getUniqueId = this.getOptimizedId; return g }, setId: function (a) { this.id = this.id = a }, getId: function () { var a = this.id; if (!a) { a = this.getUniqueId() } this.getId = this.getOptimizedId; return a } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "Identifiable"], 0)); (Ext.cmd.derive("Ext.mixin.Observable", Ext.Mixin, function (b) { var e = Ext.emptyFn, d = [], g = Array.prototype, h = g.slice, c = function (i) { if (i instanceof c) { return i } this.observable = i; if (arguments[1].isObservable) { this.managedListeners = true } this.args = h.call(arguments, 1) }, a = ["events", "hasListeners", "managedListeners", "eventedBeforeEventNames"]; c.prototype.destroy = function () { this.destroy = Ext.emptyFn; var i = this.observable; if (!i.destroyed) { i[this.managedListeners ? "mun" : "un"].apply(i, this.args) } }; return { mixinConfig: { id: "observable", after: { destroy: "destroyObservable" } }, statics: { releaseCapture: function (i) { i.fireEventArgs = this.prototype.fireEventArgs }, capture: function (l, j, i) { var k = function (m, n) { return j.apply(i, [m].concat(n)) }; this.captureArgs(l, k, i) }, captureArgs: function (k, j, i) { k.fireEventArgs = Ext.Function.createInterceptor(k.fireEventArgs, j, i) }, observe: function (i, j) { if (i) { if (!i.isObservable) { Ext.applyIf(i, new this()); this.captureArgs(i.prototype, i.fireEventArgs, i) } if (Ext.isObject(j)) { i.on(j) } } return i }, prepareClass: function (n, v, p) { var u = n.listeners = [], s = p || n.prototype, j = s.listeners, m = v ? v.listeners : n.superclass.self.listeners, k, w, t, o, r; if (m) { u.push(m) } if (j) { w = j.scope; if (!w) { j.scope = "self" } else { t = Ext._namedScopes[w]; if (t && t.isController) { j.scope = "self.controller" } } u.push(j); s.listeners = null } if (!n.HasListeners) { var q = function () { }, l = n.superclass.HasListeners || (v && v.HasListeners) || b.HasListeners; n.prototype.HasListeners = n.HasListeners = q; q.prototype = n.hasListeners = new l() } w = n.prototype.$noClearOnDestroy || {}; for (o = 0, r = a.length; o < r; o++) { w[a[o]] = true } n.prototype.$noClearOnDestroy = w } }, isObservable: true, $vetoClearingPrototypeOnDestroy: true, eventsSuspended: 0, constructor: function (m) { var p = this, l = p.self, k, o, q, j, n; if (p.$observableInitialized) { return } p.$observableInitialized = true; p.hasListeners = p.hasListeners = new p.HasListeners(); p.eventedBeforeEventNames = {}; p.events = p.events || {}; k = l.listeners; if (k && !p._addDeclaredListeners(k)) { l.listeners = null } o = (m && m.listeners) || p.listeners; if (o) { if (o instanceof Array) { for (n = 0, j = o.length; n < j; ++n) { p.addListener(o[n]) } } else { p.addListener(o) } } q = (m && m.bubbleEvents) || p.bubbleEvents; if (q) { p.enableBubble(q) } if (p.$applyConfigs) { if (m) { Ext.apply(p, m) } } else { p.initConfig(m) } if (o) { p.listeners = null } }, onClassExtended: function (i, j) { if (!i.HasListeners) { b.prepareClass(i, i.prototype.$observableMixedIn ? undefined : j) } }, $eventOptions: { scope: 1, delay: 1, buffer: 1, onFrame: 1, single: 1, args: 1, destroyable: 1, priority: 1, order: 1 }, $orderToPriority: { before: 100, current: 0, after: -100 }, _addDeclaredListeners: function (i) { var j = this; if (i instanceof Array) { Ext.each(i, j._addDeclaredListeners, j) } else { j._addedDeclaredListeners = true; j.addListener(i) } return j._addedDeclaredListeners }, addManagedListener: function (p, l, n, q, r, k) { var m = this, o = m.managedListeners = m.managedListeners || [], j, i; if (typeof l !== "string") { i = arguments.length > 4 ? r : l; r = l; for (l in r) { if (r.hasOwnProperty(l)) { j = r[l]; if (!p.$eventOptions[l]) { m.addManagedListener(p, l, j.fn || j, j.scope || r.scope || q, j.fn ? j : i, true) } } } if (r && r.destroyable) { return new c(m, p, r) } } else { if (n !== e) { p.doAddListener(l, n, q, r, null, m, m); if (!k && r && r.destroyable) { return new c(m, p, l, n, q) } } } }, removeManagedListener: function (q, l, o, r) { var n = this, s, k, p, j, m; if (q.$observableDestroyed) { return } if (typeof l !== "string") { s = l; for (l in s) { if (s.hasOwnProperty(l)) { k = s[l]; if (!q.$eventOptions[l]) { n.removeManagedListener(q, l, k.fn || k, k.scope || s.scope || r) } } } } else { p = n.managedListeners ? n.managedListeners.slice() : []; l = Ext.canonicalEventName(l); for (m = 0, j = p.length; m < j; m++) { n.removeManagedListenerItem(false, p[m], q, l, o, r) } } }, fireEvent: function (i) { return this.fireEventArgs(i, h.call(arguments, 1)) }, resolveListenerScope: function (j) { var i = Ext._namedScopes[j]; if (i) { if (i.isSelf || i.isThis) { j = null } } return j || this }, fireEventArgs: function (i, k) { i = Ext.canonicalEventName(i); var n = this, l = n.events, m = l && l[i], j = true; if (n.hasListeners[i]) { j = n.doFireEvent(i, k || d, m ? m.bubble : false) } return j }, fireAction: function (j, l, n, m, k, i) { if (typeof n === "string" && !m) { n = this[n] } k = k ? Ext.Object.chain(k) : {}; k.single = true; k.priority = ((i === "after") ? -99.5 : 99.5); this.doAddListener(j, n, m, k); this.fireEventArgs(j, l) }, $eventedController: { _paused: 1, pause: function () { ++this._paused }, resume: function () { var n = this, m = n.fn, l = n.scope, o = n.fnArgs, i = n.owner, k, j; if (!--n._paused) { if (m) { k = Ext.Array.slice(o || n.args); if (o === false) { k.shift() } n.fn = null; k.push(n); if (Ext.isFunction(m)) { j = m.apply(l, k) } else { if (l && Ext.isString(m) && Ext.isFunction(l[m])) { j = l[m].apply(l, k) } } if (j === false) { return false } } if (!n._paused) { return n.owner.fireEventArgs(n.eventName, n.args) } } } }, fireEventedAction: function (j, l, o, r, n) { var m = this, q = m.eventedBeforeEventNames, k = q[j] || (q[j] = "before" + j), i = Ext.apply({ owner: m, eventName: j, fn: o, scope: r, fnArgs: n, args: l }, m.$eventedController), p; l.push(i); p = m.fireEventArgs(k, l); l.pop(); if (p === false) { return false } return i.resume() }, doFireEvent: function (k, m, j) { var o = this, i, n, l = true; do { if (o.eventsSuspended) { if ((i = o.eventQueue)) { i.push([k, m]) } return l } else { n = o.events && o.events[k]; if (n && n !== true) { if ((l = n.fire.apply(n, m)) === false) { break } } } } while (j && (o = o.getBubbleParent())); return l }, getBubbleParent: function () { var j = this, i = j.getBubbleTarget && j.getBubbleTarget(); if (i && i.isObservable) { return i } return null }, addListener: function (m, s, t, u, k, i) { var r = this, n = Ext._namedScopes, j, q, o, p, l; if (typeof m !== "string") { u = m; t = u.scope; q = t && n[t]; o = q && q.isSelf; l = ((r.isComponent || r.isWidget) && u.element) ? r.$elementEventOptions : r.$eventOptions; for (m in u) { j = u[m]; if (!l[m]) { p = j.scope; if (p && o) { q = n[p]; if (q && q.isController) { p = "self.controller" } } r.doAddListener(m, j.fn || j, p || t, j.fn ? j : u, k, i) } } if (u && u.destroyable) { return new c(r, u) } } else { r.doAddListener(m, s, t, u, k, i); if (u && u.destroyable) { return new c(r, m, s, t, u) } } return r }, removeListener: function (l, n, m, i) { var o = this, k, j; if (typeof l !== "string") { j = l; i = i || o.$eventOptions; for (l in j) { if (j.hasOwnProperty(l)) { k = j[l]; if (!o.$eventOptions[l]) { o.doRemoveListener(l, k.fn || k, k.scope || j.scope) } } } } else { o.doRemoveListener(l, n, m) } return o }, onBefore: function (i, l, k, j) { return this.addListener(i, l, k, j, "before") }, onAfter: function (i, l, k, j) { return this.addListener(i, l, k, j, "after") }, unBefore: function (i, l, k, j) { return this.removeListener(i, l, k, j, "before") }, unAfter: function (i, l, k, j) { return this.removeListener(i, l, k, j, "after") }, addBeforeListener: function () { return this.onBefore.apply(this, arguments) }, addAfterListener: function () { return this.onAfter.apply(this, arguments) }, removeBeforeListener: function () { return this.unBefore.apply(this, arguments) }, removeAfterListener: function () { return this.unAfter.apply(this, arguments) }, clearListeners: function () { var m = this, k = m.events, i = m.hasListeners, l, j; if (k) { for (j in k) { if (k.hasOwnProperty(j)) { l = k[j]; if (l.isEvent) { delete i[j]; l.clearListeners() } } } m.events = null } m.clearManagedListeners() }, clearManagedListeners: function () { var m = this, k = m.managedListeners ? m.managedListeners.slice() : [], l = 0, j = k.length; for (; l < j; l++) { m.removeManagedListenerItem(true, k[l]) } m.managedListeners = [] }, removeManagedListenerItem: function (j, i, n, k, m, l) { if (j || (i.item === n && i.ename === k && (!m || i.fn === m) && (!l || i.scope === l))) { if (!i.item.destroyed) { i.item.doRemoveListener(i.ename, i.fn, i.scope, i.options) } if (!j) { Ext.Array.remove(this.managedListeners, i) } } }, hasListener: function (i) { i = Ext.canonicalEventName(i); return !!this.hasListeners[i] }, isSuspended: function (k) { var j = this.eventsSuspended > 0, i = this.events; if (!j && k && i) { k = i[k]; if (k && k.isEvent) { return k.isSuspended() } } return j }, suspendEvents: function (i) { ++this.eventsSuspended; if (i && !this.eventQueue) { this.eventQueue = [] } }, suspendEvent: function () { var o = this, m = o.events, j = arguments.length, l, n, k; for (l = 0; l < j; l++) { k = arguments[l]; k = Ext.canonicalEventName(k); n = m[k]; if (!n || !n.isEvent) { n = o._initEvent(k) } n.suspend() } }, resumeEvent: function () { var m = this.events || 0, j = m && arguments.length, l, n, k; for (l = 0; l < j; l++) { k = Ext.canonicalEventName(arguments[l]); n = m[k]; if (n && n.resume) { n.resume() } } }, resumeEvents: function (i) { var j = this, m = j.eventQueue, l, k; if (j.eventsSuspended && !--j.eventsSuspended) { delete j.eventQueue; if (!i && m) { l = m.length; for (k = 0; k < l; k++) { j.fireEventArgs.apply(j, m[k]) } } } }, relayEvents: function (q, r, l) { var p = this, m = r.length, k = 0, j, n, o = {}; if (Ext.isObject(r)) { for (k in r) { n = r[k]; o[k] = p.createRelayer(n) } } else { for (; k < m; k++) { j = r[k]; o[j] = p.createRelayer(l ? l + j : j) } } p.mon(q, o, null, null, undefined); return new c(p, q, o) }, createRelayer: function (i, j) { var k = this; return function () { return k.fireEventArgs.call(k, i, j ? h.apply(arguments, j) : arguments) } }, enableBubble: function (q) { if (q) { var o = this, p = (typeof q == "string") ? arguments : q, l = o.events, n = l && p.length, k, m, j; for (j = 0; j < n; ++j) { k = p[j]; k = Ext.canonicalEventName(k); m = l[k]; if (!m || !m.isEvent) { m = o._initEvent(k) } o.hasListeners._incr_(k); m.bubble = true } } }, destroy: function () { this.clearListeners(); this.callParent(); this.destroyObservable(true) }, destroyObservable: function (j) { var i = this; if (i.$observableDestroyed) { return } if (!j) { i.clearListeners() } if (i.destroyed) { if (i.clearPropertiesOnDestroy) { if (!i.clearPrototypeOnDestroy) { i.fireEvent = i.fireEventArgs = i.fireAction = i.fireEventedAction = Ext.emptyFn } i.events = i.managedListeners = i.eventedBeforeEventNames = null; i.$observableDestroyed = true } } }, privates: { doAddListener: function (l, p, r, s, k, j, m) { var o = this, n = false, i, q; k = k || (s && s.order); if (k) { q = (s && s.priority); if (!q) { s = s ? Ext.Object.chain(s) : {}; s.priority = o.$orderToPriority[k] } } l = Ext.canonicalEventName(l); i = (o.events || (o.events = {}))[l]; if (!i || !i.isEvent) { i = o._initEvent(l) } if (p !== e) { if (!m && (r && r.isObservable && (r !== o))) { m = r } if (i.addListener(p, r, s, j, m)) { o.hasListeners._incr_(l); n = true } } return n }, doRemoveListener: function (k, m, l) { var o = this, i = false, j = o.events, n; k = Ext.canonicalEventName(k); n = j && j[k]; if (n && n.isEvent) { if (n.removeListener(m, l)) { o.hasListeners._decr_(k); i = true } } return i }, _initEvent: function (i) { return (this.events[i] = new Ext.util.Event(this, i)) } }, deprecated: { "5.0": { methods: { addEvents: null } } } } }, 1, 0, 0, 0, 0, [[Ext.mixin.Identifiable.prototype.mixinId || Ext.mixin.Identifiable.$className, Ext.mixin.Identifiable]], [Ext.mixin, "Observable"], function () { var b = this, e = b.prototype, c = function () { }, g = function (h) { if (!h.HasListeners) { var i = h.prototype; i.$observableMixedIn = 1; b.prepareClass(h, this); h.onExtended(function (j, k) { b.prepareClass(j, null, k) }); if (i.onClassMixedIn) { Ext.override(h, { onClassMixedIn: function (j) { g.call(this, j); this.callParent(arguments) } }) } else { i.onClassMixedIn = function (j) { g.call(this, j) } } } a.call(this, h) }, a = e.onClassMixedIn; c.prototype = { _decr_: function (i, h) { if (h == null) { h = 1 } if (!(this[i] -= h)) { delete this[i] } }, _incr_: function (h) { if (this.hasOwnProperty(h)) { ++this[h] } else { this[h] = 1 } } }; e.HasListeners = b.HasListeners = c; b.createAlias({ on: "addListener", un: "removeListener", mon: "addManagedListener", mun: "removeManagedListener", setListeners: "addListener" }); b.observeClass = b.observe; function d(n) { var m = (this.methodEvents = this.methodEvents || {})[n], j, i, k, l = this, h; if (!m) { this.methodEvents[n] = m = {}; m.originalFn = this[n]; m.methodName = n; m.before = []; m.after = []; h = function (q, p, o) { if ((i = q.apply(p || l, o)) !== undefined) { if (typeof i == "object") { if (i.returnValue !== undefined) { j = i.returnValue } else { j = i } k = !!i.cancel } else { if (i === false) { k = true } else { j = i } } } }; this[n] = function () { var q = Array.prototype.slice.call(arguments, 0), p, r, o; j = i = undefined; k = false; for (r = 0, o = m.before.length; r < o; r++) { p = m.before[r]; h(p.fn, p.scope, q); if (k) { return j } } if ((i = m.originalFn.apply(l, q)) !== undefined) { j = i } for (r = 0, o = m.after.length; r < o; r++) { p = m.after[r]; h(p.fn, p.scope, q); if (k) { return j } } return j } } return m } Ext.apply(e, { onClassMixedIn: g, beforeMethod: function (j, i, h) { d.call(this, j).before.push({ fn: i, scope: h }) }, afterMethod: function (j, i, h) { d.call(this, j).after.push({ fn: i, scope: h }) }, removeMethodListener: function (n, l, k) { var m = this.getMethodEvent(n), j, h; for (j = 0, h = m.before.length; j < h; j++) { if (m.before[j].fn == l && m.before[j].scope == k) { Ext.Array.erase(m.before, j, 1); return } } for (j = 0, h = m.after.length; j < h; j++) { if (m.after[j].fn == l && m.after[j].scope == k) { Ext.Array.erase(m.after, j, 1); return } } }, toggleEventLogging: function (h) { Ext.util.Observable[h ? "capture" : "releaseCapture"](this, function (i) { if (Ext.isDefined(Ext.global.console)) { Ext.global.console.log(i, arguments) } }) } }) })); (Ext.cmd.derive("Ext.util.HashMap", Ext.Base, { generation: 0, config: { keyFn: null }, constructor: function (a) { var c = this, b; c.mixins.observable.constructor.call(c, a); c.clear(true); b = c.getKeyFn(); if (b) { c.getKey = b } }, getCount: function () { return this.length }, getData: function (a, b) { if (b === undefined) { b = a; a = this.getKey(b) } return [a, b] }, getKey: function (a) { return a.id }, add: function (a, c) { var b = this; if (arguments.length === 1) { c = a; a = b.getKey(c) } if (b.containsKey(a)) { return b.replace(a, c) } b.map[a] = c; ++b.length; b.generation++; if (b.hasListeners.add) { b.fireEvent("add", b, a, c) } return c }, replace: function (b, d) { var c = this, e = c.map, a; if (arguments.length === 1) { d = b; b = c.getKey(d) } if (!c.containsKey(b)) { c.add(b, d) } a = e[b]; e[b] = d; c.generation++; if (c.hasListeners.replace) { c.fireEvent("replace", c, b, d, a) } return d }, remove: function (b) { var a = this.findKey(b); if (a !== undefined) { return this.removeAtKey(a) } return false }, removeAtKey: function (a) { var b = this, c; if (b.containsKey(a)) { c = b.map[a]; delete b.map[a]; --b.length; b.generation++; if (b.hasListeners.remove) { b.fireEvent("remove", b, a, c) } return true } return false }, get: function (a) { var b = this.map; return b.hasOwnProperty(a) ? b[a] : undefined }, clear: function (a) { var b = this; if (a || b.generation) { b.map = {}; b.length = 0; b.generation = a ? 0 : b.generation + 1 } if (a !== true && b.hasListeners.clear) { b.fireEvent("clear", b) } return b }, containsKey: function (a) { var b = this.map; return b.hasOwnProperty(a) && b[a] !== undefined }, contains: function (a) { return this.containsKey(this.findKey(a)) }, getKeys: function () { return this.getArray(true) }, getValues: function () { return this.getArray(false) }, getArray: function (d) { var a = [], b, c = this.map; for (b in c) { if (c.hasOwnProperty(b)) { a.push(d ? b : c[b]) } } return a }, each: function (d, c) { var a = Ext.apply({}, this.map), b, e = this.length; c = c || this; for (b in a) { if (a.hasOwnProperty(b)) { if (d.call(c, b, a[b], e) === false) { break } } } return this }, clone: function () { var c = new this.self(this.initialConfig), b = this.map, a; c.suspendEvents(); for (a in b) { if (b.hasOwnProperty(a)) { c.add(a, b[a]) } } c.resumeEvents(); return c }, findKey: function (b) { var a, c = this.map; for (a in c) { if (c.hasOwnProperty(a) && c[a] === b) { return a } } return undefined } }, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.util, "HashMap"], function (b) { var a = b.prototype; a.removeByKey = a.removeAtKey })); (Ext.cmd.derive("Ext.AbstractManager", Ext.Base, { typeName: "type", constructor: function (a) { Ext.apply(this, a || {}); this.all = new Ext.util.HashMap(); this.types = {} }, get: function (a) { return this.all.get(a) }, register: function (a) { this.all.add(a) }, unregister: function (a) { this.all.remove(a) }, registerType: function (b, a) { this.types[b] = a; a[this.typeName] = b }, isRegistered: function (a) { return this.types[a] !== undefined }, create: function (a, d) { var b = a[this.typeName] || a.type || d, c = this.types[b]; return new c(a) }, onAvailable: function (g, c, b) { var a = this.all, d, e; if (a.containsKey(g)) { d = a.get(g); c.call(b || d, d) } else { e = function (j, h, i) { if (h == g) { c.call(b || i, i); a.un("add", e) } }; a.on("add", e) } }, each: function (b, a) { this.all.each(b, a || this) }, getCount: function () { return this.all.getCount() } }, 1, 0, 0, 0, 0, 0, [Ext, "AbstractManager"], 0)); (Ext.cmd.derive("Ext.promise.Consequence", Ext.Base, function (a) { return { promise: null, deferred: null, onFulfilled: null, onRejected: null, onProgress: null, constructor: function (e, b, d) { var c = this; c.onFulfilled = e; c.onRejected = b; c.onProgress = d; c.deferred = new Ext.promise.Deferred(); c.promise = c.deferred.promise }, trigger: function (e, d) { var c = this, b = c.deferred; switch (e) { case "fulfill": c.propagate(d, c.onFulfilled, b, b.resolve); break; case "reject": c.propagate(d, c.onRejected, b, b.reject); break } }, update: function (b) { if (Ext.isFunction(this.onProgress)) { b = this.onProgress(b) } this.deferred.update(b) }, propagate: function (d, e, b, c) { if (Ext.isFunction(e)) { this.schedule(function () { try { b.resolve(e(d)) } catch (g) { b.reject(g) } }) } else { c.call(this.deferred, d) } }, schedule: function (c) { var b = a.queueSize++; a.queue[b] = c; if (!b) { Ext.asap(a.dispatch) } }, statics: { queue: new Array(10000), queueSize: 0, dispatch: function () { var b = a.queue, d, c; for (c = 0; c < a.queueSize; ++c) { d = b[c]; b[c] = null; d() } a.queueSize = 0 } } } }, 1, 0, 0, 0, 0, 0, [Ext.promise, "Consequence"], 0)); (Ext.cmd.derive("Ext.promise.Deferred", Ext.Base, { promise: null, consequences: [], completed: false, completionAction: null, completionValue: null, constructor: function () { var a = this; a.promise = new Ext.promise.Promise(a); a.consequences = []; a.completed = false; a.completionAction = null; a.completionValue = null }, then: function (e, a, d) { var c = this, b = new Ext.promise.Consequence(e, a, d); if (c.completed) { b.trigger(c.completionAction, c.completionValue) } else { c.consequences.push(b) } return b.promise }, resolve: function (d) { var c = this, a, b; if (c.completed) { return } try { if (d === c.promise) { throw new TypeError("A Promise cannot be resolved with itself.") } if (d != null && (typeof d === "object" || Ext.isFunction(d)) && Ext.isFunction(b = d.then)) { a = false; try { b.call(d, function (h) { if (!a) { a = true; c.resolve(h) } }, function (h) { if (!a) { a = true; c.reject(h) } }) } catch (g) { if (!a) { c.reject(g) } } } else { c.complete("fulfill", d) } } catch (e) { c.reject(e) } }, reject: function (a) { if (this.completed) { return } this.complete("reject", a) }, update: function (b) { var e = this.consequences, d, c, a; if (this.completed) { return } for (c = 0, a = e.length; c < a; c++) { d = e[c]; d.update(b) } }, complete: function (g, e) { var d = this, h = d.consequences, c, b, a; d.completionAction = g; d.completionValue = e; d.completed = true; for (b = 0, a = h.length; b < a; b++) { c = h[b]; c.trigger(d.completionAction, d.completionValue) } d.consequences = null } }, 1, 0, 0, 0, 0, 0, [Ext.promise, "Deferred"], 0)); (Ext.cmd.derive("Ext.promise.Promise", Ext.Base, function (b) { var a; return { statics: { CancellationError: Ext.global.CancellationError || Error, _ready: function () { a = Ext.promise.Deferred }, all: function (c) { return b.when(c).then(function (e) { var n = new a(), j = e.length, g = new Array(j), l, d, m, h, k; if (!j) { n.resolve(g) } else { m = function (o, i) { return b.when(o).then(function (p) { g[i] = p; if (!--j) { n.resolve(g) } return p }, function (p) { return n.reject(p) }) }; for (l = h = 0, k = e.length; h < k; l = ++h) { d = e[l]; if (l in e) { m(d, l) } else { j-- } } } return n.promise }) }, is: function (c) { return c != null && (typeof c === "object" || Ext.isFunction(c)) && Ext.isFunction(c.then) }, rethrowError: function (c) { Ext.asap(function () { throw c }) }, when: function (d) { var c = new Ext.promise.Deferred(); c.resolve(d); return c.promise } }, owner: null, constructor: function (c) { this.owner = c }, then: function (h, c, g, d) { var e; if (arguments.length === 1 && Ext.isObject(arguments[0])) { e = arguments[0]; h = e.success; c = e.failure; g = e.progress; d = e.scope } if (d) { if (h) { h = Ext.Function.bind(h, d) } if (c) { c = Ext.Function.bind(c, d) } if (g) { g = Ext.Function.bind(g, d) } } return this.owner.then(h, c, g) }, otherwise: function (c, d) { var e; if (arguments.length === 1 && Ext.isObject(arguments[0])) { e = arguments[0]; c = e.fn; d = e.scope } if (d != null) { c = Ext.Function.bind(c, d) } return this.owner.then(null, c) }, always: function (c, d) { var e; if (arguments.length === 1 && Ext.isObject(arguments[0])) { e = arguments[0]; c = e.fn; d = e.scope } if (d != null) { c = Ext.Function.bind(c, d) } return this.owner.then(function (g) { try { c() } catch (h) { b.rethrowError(h) } return g }, function (h) { try { c() } catch (g) { b.rethrowError(g) } throw h }) }, done: function () { this.owner.then(null, b.rethrowError) }, cancel: function (c) { if (c == null) { c = null } this.owner.reject(new this.self.CancellationError(c)) }, log: function (c) { if (c == null) { c = "" } return this.owner.then(function (d) { Ext.log("" + (c || "Promise") + " resolved with value: " + d); return d }, function (d) { Ext.log("" + (c || "Promise") + " rejected with reason: " + d); throw d }) } } }, 1, 0, 0, 0, 0, 0, [Ext.promise, "Promise"], function (a) { a._ready() })); (Ext.cmd.derive("Ext.Promise", Ext.Base, function () { var a; return { statics: { _ready: function () { a = Ext.promise.Promise }, all: function () { return a.all.apply(a, arguments) }, race: function () { }, reject: function (c) { var b = new Ext.promise.Deferred(); b.reject(c); return b.promise }, resolve: function (c) { var b = new Ext.promise.Deferred(); b.resolve(c); return b.promise } }, constructor: function (c) { var b = new Ext.promise.Deferred(); c(b.resolve.bind(b), b.reject.bind(b)); return b.promise } } }, 1, 0, 0, 0, 0, 0, [Ext, "Promise"], function (a) { var b = Ext.global.Promise; if (b && b.resolve) { Ext.Promise = b } else { a._ready() } })); (Ext.cmd.derive("Ext.Deferred", Ext.promise.Deferred, function (b) { var c, a; return { statics: { _ready: function () { c = Ext.promise.Promise; a = Ext.Promise.resolve }, all: function () { return c.all.apply(c, arguments) }, any: function (d) { return b.some(d, 1).then(function (e) { return e[0] }, function (e) { if (e instanceof Error && e.message === "Too few Promises were resolved.") { Ext.raise("No Promises were resolved.") } else { throw e } }) }, delay: function (d, g) { var e; if (arguments.length === 1) { g = d; d = undefined } g = Math.max(g, 0); e = new b(); setTimeout(function () { e.resolve(d) }, g); return e.promise }, map: function (d, e) { return b.resolved(d).then(function (h) { var p, n, g, l, o, j, k, m; l = h.length; j = new Array(h.length); p = new b(); if (!l) { p.resolve(j) } else { o = function (q, i) { return b.resolved(q).then(function (r) { return e(r, i, j) }).then(function (r) { j[i] = r; if (!--l) { p.resolve(j) } return r }, function (r) { return p.reject(r) }) }; for (n = k = 0, m = h.length; k < m; n = ++k) { g = h[n]; if (n in h) { o(g, n) } else { l-- } } } return p.promise }) }, memoize: function (h, g, d) { var e = Ext.Function.memoize(h, g, d); return function () { return b.all(Ext.Array.slice(arguments)).then(function (i) { return e.apply(g, i) }) } }, parallel: function (e, g) { if (g == null) { g = null } var d = Ext.Array.slice(arguments, 2); return b.map(e, function (h) { if (!Ext.isFunction(h)) { throw new Error("Invalid parameter: expected a function.") } return h.apply(g, d) }) }, pipeline: function (e, d, g) { if (g == null) { g = null } return b.reduce(e, function (i, h) { if (!Ext.isFunction(h)) { throw new Error("Invalid parameter: expected a function.") } return h.call(g, i) }, d) }, reduce: function (e, g, d) { var h = arguments.length === 3; return b.resolved(e).then(function (j) { var i = [j, function (l, m, k) { return b.resolved(l).then(function (n) { return b.resolved(m).then(function (o) { return g(n, o, k, j) }) }) }]; if (h) { i.push(d) } return Ext.Array.reduce.apply(Ext.Array, i) }) }, rejected: function (e) { var d = new Ext.Deferred(); d.reject(e); return d.promise }, resolved: function (e) { var d = new Ext.Deferred(); d.resolve(e); return d.promise }, sequence: function (e, g) { if (g == null) { g = null } var d = Ext.Array.slice(arguments, 2); return b.reduce(e, function (h, i) { if (!Ext.isFunction(i)) { throw new Error("Invalid parameter: expected a function.") } return b.resolved(i.apply(g, d)).then(function (j) { h.push(j); return h }) }, []) }, some: function (e, d) { return b.resolved(e).then(function (j) { var r, n, p, q, h, g, l, o, k, m; o = []; l = d; g = (j.length - l) + 1; r = new b(); if (j.length < d) { r.reject(new Error("Too few Promises were resolved.")) } else { q = function (i) { if (l > 0) { o.push(i) } l--; if (l === 0) { r.resolve(o) } return i }; p = function (i) { g--; if (g === 0) { r.reject(new Error("Too few Promises were resolved.")) } return i }; for (n = k = 0, m = j.length; k < m; n = ++k) { h = j[n]; if (n in j) { b.resolved(h).then(q, p) } } } return r.promise }) }, timeout: function (d, g) { var e = new b(), h; h = setTimeout(function () { if (h) { e.reject(new Error("Promise timed out.")) } }, g); b.resolved(d).then(function (i) { clearTimeout(h); h = null; e.resolve(i) }, function (i) { clearTimeout(h); h = null; e.reject(i) }); return e.promise } } } }, 0, 0, 0, 0, 0, 0, [Ext, "Deferred"], function (a) { a._ready() })); Ext.Factory = function (a) { var b = this; b.aliasPrefix = a + "."; b.cache = {}; b.name = a.replace(b.fixNameRe, b.fixNameFn); b.type = a }; Ext.Factory.prototype = { defaultProperty: "type", instanceProp: "isInstance", create: function (c, e) { var i = this, a = Ext.ClassManager, b = i.cache, d, h, g, j; if (c) { if (c[i.instanceProp]) { return c } if (typeof c === "string") { j = c; c = {}; c[i.defaultProperty] = j } h = c.xclass; j = c.type } if (e && e.constructor === Object) { c = Ext.apply({}, c, e); e = e.type } if (h) { if (!(g = a.get(h))) { return a.instantiate(h, c) } } else { if (!(j = j || e || i.defaultType)) { g = i.defaultClass } if (!g && !(g = b[j])) { d = i.aliasPrefix + j; h = a.getNameByAlias(d); if (!(g = h && a.get(h))) { return a.instantiateByAlias(d, c) } b[j] = g } } return g.isInstance ? g : new g(c) }, fixNameRe: /\.[a-z]/ig, fixNameFn: function (a) { return a.substring(1).toUpperCase() }, clearCache: function () { this.cache = {} } }; Ext.Factory.define = function (g, d) { var a = Ext.Factory, b, c, e; if (g.constructor === Object) { Ext.Object.each(g, a.define, a) } else { c = new Ext.Factory(g); if (d) { if (d.constructor === Object) { Ext.apply(c, d); if (typeof (b = c.xclass) === "string") { c.defaultClass = Ext.ClassManager.get(b) } } else { c.defaultType = d } } a[c.name] = e = c.create.bind(c); e.instance = c } return e }; (Ext.cmd.derive("Ext.mixin.Factoryable", Ext.Base, { mixinId: "factoryable", onClassMixedIn: function (g) { var e = g.prototype, h = e.factoryConfig, d = e.alias, c = {}, b, a; d = d && d.length && d[0]; if (d && (b = d.lastIndexOf(".")) > 0) { c.type = d.substring(0, b); c.defaultType = d.substring(b + 1) } if (h) { delete e.factoryConfig; Ext.apply(c, h) } a = Ext.Factory.define(c.type, c); if (g.create === Ext.Base.create) { g.create = a } } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "Factoryable"], 0)); (Ext.cmd.derive("Ext.data.request.Base", Ext.Base, { factoryConfig: { type: "request", defaultType: "ajax" }, result: null, success: null, timer: null, constructor: function (a) { var b = this; Ext.apply(b, a.options || {}, a.ownerConfig); b.id = ++Ext.data.Connection.requestId; b.owner = a.owner; b.options = a.options; b.requestOptions = a.requestOptions }, start: function () { var a = this, b = a.getTimeout(); if (b && a.async) { a.timer = Ext.defer(a.onTimeout, b, a) } }, abort: function () { var a = this; a.clearTimer(); if (!a.timedout) { a.aborted = true } a.abort = Ext.emptyFn }, createDeferred: function () { return (this.deferred = new Ext.Deferred()) }, getDeferred: function () { return this.deferred || this.createDeferred() }, getPromise: function () { return this.getDeferred().promise }, then: function () { var a = this.getPromise(); return a.then.apply(a, arguments) }, onComplete: function () { var c = this, b = c.deferred, a = c.result; c.clearTimer(); if (b) { if (c.success) { b.resolve(a) } else { b.reject(a) } } }, onTimeout: function () { var a = this; a.timedout = true; a.timer = null; a.abort(true) }, getTimeout: function () { return this.timeout }, clearTimer: function () { var a = this.timer; if (a) { clearTimeout(a); this.timer = null } }, destroy: function () { var a = this; a.abort(); a.owner = a.options = a.requestOptions = a.result = null; a.callParent() }, privates: { createException: function () { var b = this, a; a = { request: b, requestId: b.id, status: b.aborted ? -1 : 0, statusText: b.aborted ? "transaction aborted" : "communication failure", getResponseHeader: b._getHeader, getAllResponseHeaders: b._getHeaders }; if (b.aborted) { a.aborted = true } if (b.timedout) { a.timedout = true } return a }, _getHeader: function (a) { var b = this.headers; return b && b[a.toLowerCase()] }, _getHeaders: function () { return this.headers } } }, 1, 0, 0, 0, 0, [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.request, "Base"], 0)); (Ext.cmd.derive("Ext.data.flash.BinaryXhr", Ext.Base, { statics: { flashPluginActivated: function () { Ext.data.flash.BinaryXhr.flashPluginActive = true; Ext.data.flash.BinaryXhr.flashPlugin = document.getElementById("ext-flash-polyfill"); Ext.GlobalEvents.fireEvent("flashready") }, flashPluginActive: false, flashPluginInjected: false, connectionIndex: 1, liveConnections: {}, flashPlugin: null, onFlashStateChange: function (d, c, b) { var a; a = this.liveConnections[Number(d)]; if (a) { a.onFlashStateChange(c, b) } }, registerConnection: function (b) { var a = this.connectionIndex; this.conectionIndex = this.connectionIndex + 1; this.liveConnections[a] = b; return a }, injectFlashPlugin: function () { var b = this, a, c; b.flashPolyfillEl = Ext.getBody().appendChild({ id: "ext-flash-polyfill", cn: [{ tag: "p", html: "To view this page ensure that Adobe Flash Player version 11.1.0 or greater is installed." }, { tag: "a", href: "http://www.adobe.com/go/getflashplayer", cn: [{ tag: "img", src: window.location.protocol + "//www.adobe.com/images/shared/download_buttons/get_flash_player.gif", alt: "Get Adobe Flash player" }] }] }); a = [Ext.Loader.getPath("Ext.data.Connection"), "../../../plugins/flash/swfobject.js"].join("/"); c = "/plugins/flash/FlashPlugin.swf"; if (Ext.flashPluginPath) { c = Ext.flashPluginPath } Ext.Loader.loadScript({ url: a, onLoad: function () { var e = "11.4.0"; var h = "playerProductInstall.swf"; var d = {}; var i = {}; i.quality = "high"; i.bgcolor = "#ffffff"; i.allowscriptaccess = "sameDomain"; i.allowfullscreen = "true"; var g = {}; g.id = "ext-flash-polyfill"; g.name = "polyfill"; g.align = "middle"; swfobject.embedSWF(c, "ext-flash-polyfill", "0", "0", e, h, d, i, g) }, onError: function () { }, scope: b }); Ext.data.flash.BinaryXhr.flashPluginInjected = true } }, readyState: 0, status: 0, statusText: "", responseBytes: null, javascriptId: null, constructor: function (a) { if (!Ext.data.flash.BinaryXhr.flashPluginInjected) { Ext.data.flash.BinaryXhr.injectFlashPlugin() } var b = this; Ext.apply(b, a); b.requestHeaders = {} }, abort: function () { var a = this; if (a.readyState == 4) { return } a.aborted = true; if (!Ext.data.flash.BinaryXhr.flashPluginActive) { Ext.GlobalEvents.removeListener("flashready", a.onFlashReady, a); return } Ext.data.flash.BinaryXhr.flashPlugin.abortRequest(a.javascriptId); delete Ext.data.flash.BinaryXhr.liveConnections[a.javascriptId] }, getAllResponseHeaders: function () { var a = []; Ext.Object.each(this.responseHeaders, function (b, c) { a.push(b + ": " + c) }); return a.join("\r\n") }, getResponseHeader: function (b) { var a = this.responseHeaders; return (a && a[b]) || null }, open: function (g, c, d, a, b) { var e = this; e.method = g; e.url = c; e.async = d !== false; e.user = a; e.password = b }, overrideMimeType: function (a) { this.mimeType = a }, send: function (a) { var b = this; b.body = a; if (!Ext.data.flash.BinaryXhr.flashPluginActive) { Ext.GlobalEvents.addListener("flashready", b.onFlashReady, b) } else { this.onFlashReady() } }, onFlashReady: function () { var c = this, b, a; c.javascriptId = Ext.data.flash.BinaryXhr.registerConnection(c); b = { method: c.method, url: c.url, user: c.user, password: c.password, mimeType: c.mimeType, requestHeaders: c.requestHeaders, body: c.body, javascriptId: c.javascriptId }; a = Ext.data.flash.BinaryXhr.flashPlugin.postBinary(b) }, setReadyState: function (b) { var a = this; if (a.readyState != b) { a.readyState = b; a.onreadystatechange() } }, setRequestHeader: function (b, a) { this.requestHeaders[b] = a }, onreadystatechange: Ext.emptyFn, parseData: function (b) { var a = this; this.status = b.status || 0; a.responseHeaders = {}; if (a.mimeType) { a.responseHeaders["content-type"] = a.mimeType } if (b.reason == "complete") { this.responseBytes = b.data; a.responseHeaders["content-length"] = b.data.length } else { if (b.reason == "error" || b.reason == "securityError") { this.statusText = b.text; a.responseHeaders["content-length"] = 0 } } }, onFlashStateChange: function (c, b) { var a = this; if (c == 4) { a.parseData(b); delete Ext.data.flash.BinaryXhr.liveConnections[a.javascriptId] } a.setReadyState(c) } }, 1, 0, 0, 0, 0, 0, [Ext.data.flash, "BinaryXhr"], 0)); (Ext.cmd.derive("Ext.data.request.Ajax", Ext.data.request.Base, { statics: { parseStatus: function (b, c) { var a; if (c) { if (c.responseType === "arraybuffer") { a = c.byteLength } else { if (c.responseText) { a = c.responseText.length } } } b = b == 1223 ? 204 : b; var e = (b >= 200 && b < 300) || b == 304 || (b == 0 && Ext.isNumber(a)), d = false; if (!e) { switch (b) { case 12002: case 12029: case 12030: case 12031: case 12152: case 13030: d = true; break } } return { success: e, isException: d } } }, start: function (e) { var c = this, b = c.options, a = c.requestOptions, d = c.isXdr, h, g; h = c.xhr = c.openRequest(b, a, c.async, c.username, c.password); if (!d) { g = c.setupHeaders(h, b, a.data, a.params) } if (c.async) { if (!d) { h.onreadystatechange = Ext.Function.bind(c.onStateChange, c) } } if (d) { c.processXdrRequest(c, h) } Ext.data.request.Base.prototype.start.call(this, e); h.send(e); if (!c.async) { return c.onComplete() } return c }, abort: function (b) { var a = this, d = a.xhr; if (b || a.isLoading()) { try { d.onreadystatechange = null } catch (c) { d.onreadystatechange = Ext.emptyFn } d.abort(); Ext.data.request.Base.prototype.abort.call(this, b); a.onComplete(); a.cleanup() } }, cleanup: function () { this.xhr = null; delete this.xhr }, isLoading: function () { var a = this, d = a.xhr, b = d && d.readyState, c = Ext.data.flash && Ext.data.flash.BinaryXhr; if (!d || a.aborted || a.timedout) { return false } if (c && d instanceof c) { return b !== 4 } return b !== 0 && b !== 4 }, openRequest: function (c, a, d, h, b) { var e = this, g = e.newRequest(c); if (h) { g.open(a.method, a.url, d, h, b) } else { if (e.isXdr) { g.open(a.method, a.url) } else { g.open(a.method, a.url, d) } } if (c.binary || e.binary) { if (window.Uint8Array) { g.responseType = "arraybuffer" } else { if (g.overrideMimeType) { g.overrideMimeType("text/plain; charset=x-user-defined") } } } if (c.withCredentials || e.withCredentials) { g.withCredentials = true } return g }, newRequest: function (a) { var b = this, c; if (a.binaryData) { if (window.Uint8Array) { c = b.getXhrInstance() } else { c = new Ext.data.flash.BinaryXhr() } } else { if (b.cors && Ext.isIE9m) { c = b.getXdrInstance(); b.isXdr = true } else { c = b.getXhrInstance(); b.isXdr = false } } return c }, setupHeaders: function (o, p, g, d) { var k = this, b = Ext.apply({}, p.headers || {}, k.defaultHeaders), n = k.defaultPostHeader, l = p.jsonData, a = p.xmlData, j = "Content-Type", c = k.useDefaultXhrHeader, m, h; if (!b.hasOwnProperty(j) && (g || d)) { if (g) { if (p.rawData) { n = "text/plain" } else { if (a && Ext.isDefined(a)) { n = "text/xml" } else { if (l && Ext.isDefined(l)) { n = "application/json" } } } } b[j] = n } if (c && !b["X-Requested-With"]) { b["X-Requested-With"] = k.defaultXhrHeader } if (b[j] === undefined || b[j] === null) { delete b[j] } try { for (m in b) { if (b.hasOwnProperty(m)) { h = b[m]; o.setRequestHeader(m, h) } } } catch (i) { k.owner.fireEvent("exception", m, h) } return b }, getXdrInstance: function () { var a; if (Ext.ieVersion >= 8) { a = new XDomainRequest() } else { Ext.raise({ msg: "Your browser does not support CORS" }) } return a }, getXhrInstance: (function () { var b = [function () { return new XMLHttpRequest() }, function () { return new ActiveXObject("MSXML2.XMLHTTP.3.0") }, function () { return new ActiveXObject("MSXML2.XMLHTTP") }, function () { return new ActiveXObject("Microsoft.XMLHTTP") }], c = 0, a = b.length, g; for (; c < a; ++c) { try { g = b[c]; g(); break } catch (d) { } } return g }()), processXdrRequest: function (b, c) { var a = this; delete b.headers; b.contentType = b.options.contentType || a.defaultXdrContentType; c.onload = Ext.Function.bind(a.onStateChange, a, [true]); c.onerror = c.ontimeout = Ext.Function.bind(a.onStateChange, a, [false]) }, processXdrResponse: function (a, b) { a.getAllResponseHeaders = function () { return [] }; a.getResponseHeader = function () { return "" }; a.contentType = b.contentType || this.defaultXdrContentType }, onStateChange: function (b) { var c = this, d = c.xhr, a = Ext.GlobalEvents; if ((d && d.readyState == 4) || c.isXdr) { c.clearTimer(); c.onComplete(b); c.cleanup(); if (a.hasListeners.idle) { a.fireEvent("idle") } } }, onComplete: function (j) { var g = this, a = g.owner, k = g.options, i = g.xhr, b = { success: false, isException: false }, l, h, c; if (!i || g.destroyed) { return g.result = b } try { l = Ext.data.request.Ajax.parseStatus(i.status, i); if (l.success) { l.success = i.readyState === 4 } } catch (d) { l = b } h = g.success = g.isXdr ? j : l.success; if (h) { c = g.createResponse(i); if (a.hasListeners.requestcomplete) { a.fireEvent("requestcomplete", a, c, k) } if (k.success) { Ext.callback(k.success, k.scope, [c, k]) } } else { if (l.isException || g.aborted || g.timedout) { c = g.createException(i) } else { c = g.createResponse(i) } if (a.hasListeners.requestexception) { a.fireEvent("requestexception", a, c, k) } if (k.failure) { Ext.callback(k.failure, k.scope, [c, k]) } } g.result = c; if (k.callback) { Ext.callback(k.callback, k.scope, [k, h, c]) } a.onRequestComplete(g); Ext.data.request.Base.prototype.onComplete.call(this, j); return c }, createResponse: function (j) { var h = this, c = h.isXdr, b = {}, k = c ? [] : j.getAllResponseHeaders().replace(/\r\n/g, "\n").split("\n"), e = k.length, l, g, i, d, a; while (e--) { l = k[e]; g = l.indexOf(":"); if (g >= 0) { i = l.substr(0, g).toLowerCase(); if (l.charAt(g + 1) == " ") { ++g } b[i] = l.substr(g + 1) } } d = { request: h, requestId: h.id, status: j.status, statusText: j.statusText, getResponseHeader: function (m) { return b[m.toLowerCase()] }, getAllResponseHeaders: function () { return b } }; if (c) { h.processXdrResponse(d, j) } if (h.binary) { d.responseBytes = h.getByteArray(j) } else { d.responseText = j.responseText; d.responseXML = j.responseXML } return d }, destroy: function () { this.xhr = null; Ext.data.request.Base.prototype.destroy.call(this) }, privates: { getByteArray: function (k) { var c = k.response, b = k.responseBody, l = Ext.data.flash && Ext.data.flash.BinaryXhr, a, j, g, d; if (k instanceof l) { a = k.responseBytes } else { if (window.Uint8Array) { a = c ? new Uint8Array(c) : [] } else { if (Ext.isIE9p) { try { a = new VBArray(b).toArray() } catch (h) { a = [] } } else { if (Ext.isIE) { if (!this.self.vbScriptInjected) { this.injectVBScript() } getIEByteArray(k.responseBody, a = []) } else { a = []; j = k.responseText; g = j.length; for (d = 0; d < g; d++) { a.push(j.charCodeAt(d) & 255) } } } } } return a }, injectVBScript: function () { var a = document.createElement("script"); a.type = "text/vbscript"; a.text = ["Function getIEByteArray(byteArray, out)", "Dim len, i", "len = LenB(byteArray)", "For i = 1 to len", "out.push(AscB(MidB(byteArray, i, 1)))", "Next", "End Function"].join("\n"); Ext.getHead().dom.appendChild(a); this.self.vbScriptInjected = true } } }, 0, 0, 0, 0, ["request.ajax"], 0, [Ext.data.request, "Ajax"], 0)); (Ext.cmd.derive("Ext.data.request.Form", Ext.data.request.Base, { start: function (d) { var c = this, b = c.options, a = c.requestOptions; Ext.data.request.Base.prototype.start.call(this, d); c.form = c.upload(b.form, a.url, a.data, b); return c }, abort: function (b) { var a = this, d; if (a.isLoading()) { try { d = a.frame.dom; if (d.stop) { d.stop() } else { d.document.execCommand("Stop") } } catch (c) { } } Ext.data.request.Base.prototype.abort.call(this, b); a.onComplete(); a.cleanup() }, cleanup: function () { var a = this, b = a.frame; if (b) { b.un("load", a.onComplete, a); Ext.removeNode(b) } a.frame = a.form = null }, isLoading: function () { return !!this.frame }, upload: function (b, i, u, g) { b = Ext.getDom(b); g = g || {}; var s = document.createElement("iframe"), m = Ext.get(s), o = m.id, c = [], d = "multipart/form-data", t = { target: b.target, method: b.method, encoding: b.encoding, enctype: b.enctype, action: b.action }, a = function (h, v) { j = document.createElement("input"); Ext.fly(j).set({ type: "hidden", value: v, name: h }); b.appendChild(j); c.push(j) }, j, l, q, w, p, k, n, r, e; m.set({ name: o, cls: "x-hidden-display", src: Ext.SSL_SECURE_URL, tabIndex: -1 }); document.body.appendChild(s); if (document.frames) { document.frames[o].name = o } Ext.fly(b).set({ target: o, method: "POST", enctype: d, encoding: d, action: i || t.action }); if (u) { l = Ext.Object.fromQueryString(u) || {}; for (w in l) { if (l.hasOwnProperty(w)) { q = l[w]; if (Ext.isArray(q)) { p = q.length; for (k = 0; k < p; k++) { a(w, q[k]) } } else { a(w, q) } } } } this.frame = m; m.on({ load: this.onComplete, scope: this, single: !Ext.isOpera }); b.submit(); Ext.fly(b).set(t); for (n = c.length, r = 0; r < n; r++) { Ext.removeNode(c[r]) } return b }, getDoc: function () { var a = this.frame.dom; return (a && (a.contentWindow.document || a.contentDocument)) || (window.frames[a.id] || {}).document }, getTimeout: function () { return this.options.timeout }, onComplete: function () { var h = this, b = h.frame, a = h.owner, l = h.options, j, i, k, d, c; if (!b) { return } if (h.aborted || h.timedout) { h.result = c = h.createException(); c.responseXML = null; c.responseText = '{success:false,message:"' + Ext.String.trim(c.statusText) + '"}'; c.request = h; j = l.failure; k = false } else { try { i = h.getDoc(); h.result = c = { responseText: "", responseXML: null, request: h }; if (i) { if (Ext.isOpera && i.location == Ext.SSL_SECURE_URL) { return } if (i.body) { if ((d = i.body.firstChild) && /pre/i.test(d.tagName)) { c.responseText = d.textContent || d.innerText } else { if ((d = i.getElementsByTagName("textarea")[0])) { c.responseText = d.value } else { c.responseText = i.body.textContent || i.body.innerText } } } c.responseXML = i.XMLDocument || i; j = l.success; k = true; c.status = 200 } else { Ext.raise("Could not acquire a suitable connection for the file upload service.") } } catch (g) { h.result = c = h.createException(); c.status = 400; c.statusText = (g.message || g.description) + ""; c.responseText = '{success:false,message:"' + Ext.String.trim(c.statusText) + '"}'; c.responseXML = null; j = l.failure; k = false } } h.frame = null; h.success = k; a.fireEvent(k ? "requestcomplete" : "requestexception", a, c, l); Ext.callback(j, l.scope, [c, l]); Ext.callback(l.callback, l.scope, [l, k, c]); a.onRequestComplete(h); Ext.asap(b.destroy, b); Ext.data.request.Base.prototype.onComplete.call(this) }, destroy: function () { this.cleanup(); Ext.data.request.Base.prototype.destroy.call(this) } }, 0, 0, 0, 0, ["request.form"], 0, [Ext.data.request, "Form"], 0)); (Ext.cmd.derive("Ext.data.Connection", Ext.Base, { statics: { requestId: 0 }, enctypeRe: /multipart\/form-data/i, config: { url: null, async: true, username: "", password: "", disableCaching: true, withCredentials: false, binary: false, cors: false, isXdr: false, defaultXdrContentType: "text/plain", disableCachingParam: "_dc", timeout: 30000, extraParams: null, autoAbort: false, method: null, defaultHeaders: null, defaultPostHeader: "application/x-www-form-urlencoded; charset=UTF-8", useDefaultXhrHeader: true, defaultXhrHeader: "XMLHttpRequest" }, constructor: function (a) { this.mixins.observable.constructor.call(this, a); this.requests = {} }, request: function (b) { b = b || {}; var d = this, a, c; if (d.fireEvent("beforerequest", d, b) !== false) { a = d.setOptions(b, b.scope || Ext.global); c = d.createRequest(b, a); return c.start(a.data) } Ext.callback(b.callback, b.scope, [b, undefined, undefined]); return Ext.Deferred.rejected([b, undefined, undefined]) }, createRequest: function (b, a) { var e = this, c = b.type || a.type, d; if (!c) { c = e.isFormUpload(b) ? "form" : "ajax" } if (b.autoAbort || e.getAutoAbort()) { e.abort() } d = Ext.Factory.request({ type: c, owner: e, options: b, requestOptions: a, ownerConfig: e.getConfig() }); e.requests[d.id] = d; e.latestId = d.id; return d }, isFormUpload: function (a) { var b = this.getForm(a); if (b) { return a.isUpload || this.enctypeRe.test(b.getAttribute("enctype")) } return false }, getForm: function (a) { return Ext.getDom(a.form) }, setOptions: function (m, l) { var j = this, e = m.params || {}, i = j.getExtraParams(), d = m.urlParams, c = m.url || j.getUrl(), h = m.cors, k = m.jsonData, b, a, g; if (h !== undefined) { j.setCors(h) } if (Ext.isFunction(e)) { e = e.call(l, m) } if (Ext.isFunction(c)) { c = c.call(l, m) } c = this.setupUrl(m, c); g = m.rawData || m.binaryData || m.xmlData || k || null; if (k && !Ext.isPrimitive(k)) { g = Ext.encode(g) } if (m.binaryData) { if (j.nativeBinaryPostSupport()) { g = (new Uint8Array(m.binaryData)); if ((Ext.isChrome && Ext.chromeVersion < 22) || Ext.isSafari || Ext.isGecko) { g = g.buffer } } } if (Ext.isObject(e)) { e = Ext.Object.toQueryString(e) } if (Ext.isObject(i)) { i = Ext.Object.toQueryString(i) } e = e + ((i) ? ((e) ? "&" : "") + i : ""); d = Ext.isObject(d) ? Ext.Object.toQueryString(d) : d; e = this.setupParams(m, e); b = (m.method || j.getMethod() || ((e || g) ? "POST" : "GET")).toUpperCase(); this.setupMethod(m, b); a = m.disableCaching !== false ? (m.disableCaching || j.getDisableCaching()) : false; if (b === "GET" && a) { c = Ext.urlAppend(c, (m.disableCachingParam || j.getDisableCachingParam()) + "=" + (new Date().getTime())) } if ((b == "GET" || g) && e) { c = Ext.urlAppend(c, e); e = null } if (d) { c = Ext.urlAppend(c, d) } return { url: c, method: b, data: g || e || null } }, setupUrl: function (b, a) { var c = this.getForm(b); if (c) { a = a || c.action } return a }, setupParams: function (a, d) { var c = this.getForm(a), b; if (c && !this.isFormUpload(a)) { b = Ext.Element.serializeForm(c); d = d ? (d + "&" + b) : b } return d }, setupMethod: function (a, b) { if (this.isFormUpload(a)) { return "POST" } return b }, isLoading: function (a) { if (!a) { a = this.getLatest() } return a ? a.isLoading() : false }, abort: function (a) { if (!a) { a = this.getLatest() } if (a && a.isLoading()) { a.abort() } }, abortAll: function () { var b = this.requests, a; for (a in b) { this.abort(b[a]) } }, getLatest: function () { var b = this.latestId, a; if (b) { a = this.requests[b] } return a || null }, clearTimeout: function (a) { if (!a) { a = this.getLatest() } if (a) { a.clearTimer() } }, onRequestComplete: function (a) { delete this.requests[a.id] }, nativeBinaryPostSupport: function () { return Ext.isChrome || (Ext.isSafari && Ext.isDefined(window.Uint8Array)) || (Ext.isGecko && Ext.isDefined(window.Uint8Array)) } }, 1, 0, 0, 0, 0, [["observable", Ext.mixin.Observable]], [Ext.data, "Connection"], 0)); (Ext.cmd.derive("Ext.Ajax", Ext.data.Connection, { singleton: true, autoAbort: false }, 0, 0, 0, 0, 0, 0, [Ext, "Ajax"], 0)); (Ext.cmd.derive("Ext.AnimationQueue", Ext.Base, { singleton: true, constructor: function () { var a = this; a.queue = []; a.taskQueue = []; a.runningQueue = []; a.idleQueue = []; a.isRunning = false; a.isIdle = true; a.run = Ext.Function.bind(a.run, a); if (Ext.os.is.iOS) { Ext.interval(a.watch, 500, a) } }, start: function (c, b, a) { var d = this; d.queue.push(arguments); if (!d.isRunning) { if (d.hasOwnProperty("idleTimer")) { clearTimeout(d.idleTimer); delete d.idleTimer } if (d.hasOwnProperty("idleQueueTimer")) { clearTimeout(d.idleQueueTimer); delete d.idleQueueTimer } d.isIdle = false; d.isRunning = true; d.doStart() } }, watch: function () { if (this.isRunning && Ext.now() - this.lastRunTime >= 500) { this.run() } }, run: function () { var e = this; if (!e.isRunning) { return } var a = e.runningQueue, b = Ext.now(), c, d; e.lastRunTime = b; e.frameStartTime = b; a.push.apply(a, e.queue); for (c = 0, d = a.length; c < d; c++) { e.invoke(a[c]) } a.length = 0; e.doIterate() }, doStart: function () { this.animationFrameId = Ext.Function.requestAnimationFrame(this.run); this.lastRunTime = Ext.now() }, doIterate: function () { this.animationFrameId = Ext.Function.requestAnimationFrame(this.run) }, doStop: function () { Ext.Function.cancelAnimationFrame(this.animationFrameId) }, stop: function (e, d, b) { var j = this; if (!j.isRunning) { return } var a = j.queue, h = a.length, c, g; for (c = 0; c < h; c++) { g = a[c]; if (g[0] === e && g[1] === d && g[2] === b) { a.splice(c, 1); c--; h-- } } if (h === 0) { j.doStop(); j.isRunning = false; j.idleTimer = Ext.defer(j.whenIdle, 100, j) } }, onIdle: function (e, d, a) { var c = this.idleQueue, b, g, h; for (b = 0, g = c.length; b < g; b++) { h = c[b]; if (e === h[0] && d === h[1] && a === h[2]) { return } } c.push(arguments); if (this.isIdle) { this.processIdleQueue() } }, unIdle: function (e, d, a) { var c = this.idleQueue, b, g, h; for (b = 0, g = c.length; b < g; b++) { h = c[b]; if (e === h[0] && d === h[1] && a === h[2]) { c.splice(b, 1); return true } } return false }, queueTask: function (c, b, a) { this.taskQueue.push(arguments); this.processTaskQueue() }, dequeueTask: function (e, d, a) { var c = this.taskQueue, b, g, h; for (b = 0, g = c.length; b < g; b++) { h = c[b]; if (e === h[0] && d === h[1] && a === h[2]) { c.splice(b, 1); b--; g-- } } }, invoke: function (d) { var c = d[0], b = d[1], a = d[2]; c = (typeof c == "string" ? b[c] : c); if (Ext.isArray(a)) { c.apply(b, a) } else { c.call(b, a) } }, whenIdle: function () { this.isIdle = true; this.processIdleQueue() }, processIdleQueue: function () { if (!this.hasOwnProperty("idleQueueTimer")) { this.idleQueueTimer = Ext.defer(this.processIdleQueueItem, 1, this) } }, processIdleQueueItem: function () { delete this.idleQueueTimer; if (!this.isIdle) { return } var a = this.idleQueue, b; if (a.length > 0) { b = a.shift(); this.invoke(b); this.processIdleQueue() } }, processTaskQueue: function () { if (!this.hasOwnProperty("taskQueueTimer")) { this.taskQueueTimer = Ext.defer(this.processTaskQueueItem, 15, this) } }, processTaskQueueItem: function () { delete this.taskQueueTimer; var a = this.taskQueue, b; if (a.length > 0) { b = a.shift(); this.invoke(b); this.processTaskQueue() } } }, 1, 0, 0, 0, 0, 0, [Ext, "AnimationQueue"], 0)); (Ext.cmd.derive("Ext.ComponentManager", Ext.Base, { alternateClassName: "Ext.ComponentMgr", singleton: true, count: 0, typeName: "xtype", constructor: function (a) { var b = this; Ext.apply(b, a || {}); b.all = {}; b.references = {}; b.onAvailableCallbacks = {} }, create: function (a, b) { if (typeof a === "string") { return Ext.widget(a) } if (a.isComponent) { return a } if ("xclass" in a) { return Ext.create(a.xclass, a) } return Ext.widget(a.xtype || b, a) }, get: function (a) { return this.all[a] }, register: function (a) { var e = this, d = e.all, c = a.getId(), b = e.onAvailableCallbacks; d[c] = a; if (a.getReference && a.getReference()) { e.references[c] = a } ++e.count; if (!e.hasFocusListener) { Ext.on("focus", e.onGlobalFocus, e); e.hasFocusListener = true } b = b && b[c]; if (b && b.length) { e.notifyAvailable(a) } }, unregister: function (a) { var b = a.getId(); if (a.getReference && a.getReference()) { this.references[b] = null; delete this.references[b] } this.all[b] = null; delete this.all[b]; this.count-- }, markReferencesDirty: function () { this.referencesDirty = true }, fixReferences: function () { var c = this, b = c.references, a; if (c.referencesDirty) { for (a in b) { if (b.hasOwnProperty(a)) { b[a].fixReference() } } c.referencesDirty = false } }, onAvailable: function (h, c, b) { var g = this, e = g.onAvailableCallbacks, a = g.all, d; if (h in a) { d = a[h]; c.call(b || d, d) } else { if (h) { if (!Ext.isArray(e[h])) { e[h] = [] } e[h].push(function (i) { c.call(b || i, i) }) } } }, notifyAvailable: function (b) { var a = this.onAvailableCallbacks[b && b.getId()] || []; while (a.length) { (a.shift())(b) } }, each: function (b, a) { return Ext.Object.each(this.all, b, a) }, getCount: function () { return this.count }, getAll: function () { return Ext.Object.getValues(this.all) }, getActiveComponent: function () { return Ext.Component.fromElement(Ext.dom.Element.getActiveElement()) }, onGlobalFocus: function (i) { var d = this, b = i.toElement, j = i.fromElement, h = Ext.Component.fromElement(b), a = Ext.Component.fromElement(j), c, g; if (h === a) { return } c = d.getCommonAncestor(a, h); if (a && !(a.destroyed || a.destroying)) { if (a.handleBlurEvent) { a.handleBlurEvent(i) } for (g = a; g && g !== c; g = g.getRefOwner()) { if (!(g.destroyed || g.destroying)) { g.onFocusLeave({ event: i.event, type: "focusleave", target: j, relatedTarget: b, fromComponent: a, toComponent: h }) } } } if (h && !(h.destroyed || h.destroying)) { if (h.handleFocusEvent) { h.handleFocusEvent(i) } for (g = h; g && g !== c; g = g.getRefOwner()) { g.onFocusEnter({ event: i.event, type: "focusenter", relatedTarget: j, target: b, fromComponent: a, toComponent: h }) } } }, getCommonAncestor: function (b, a) { if (b === a) { return b } while (b && !(b.isAncestor(a) || b === a)) { b = b.getRefOwner() } return b }, privates: { clearAll: function () { this.all = {}; this.references = {}; this.onAvailableCallbacks = {} }, fromElement: function (b, d, c) { var h = Ext.getDom(b), a = this.all, e = 0, j, g, i; if (typeof d !== "number") { j = Ext.getDom(d); d = Number.MAX_VALUE } while (h && h.nodeType === 1 && e < d && h !== j) { g = h.getAttribute("data-componentid") || h.id; if (g) { i = a[g]; if (i && (!c || Ext.ComponentQuery.is(i, c))) { return i } e++ } h = h.parentNode } return null } }, deprecated: { 5: { methods: { isRegistered: null, registerType: null } } } }, 1, 0, 0, 0, 0, 0, [Ext, "ComponentManager", Ext, "ComponentMgr"], function () { Ext.getCmp = function (a) { return Ext.ComponentManager.get(a) } })); Ext.ns("Ext.util").Operators = { "=": function (b, c) { return b == c }, "!=": function (b, c) { return b != c }, "^=": function (b, c) { return b && b.substr(0, c.length) == c }, "$=": function (b, c) { return b && b.substr(b.length - c.length) == c }, "*=": function (b, c) { return b && b.indexOf(c) !== -1 }, "%=": function (b, c) { return (b % c) === 0 }, "|=": function (b, c) { return b && (b == c || b.substr(0, c.length + 1) == c + "-") }, "~=": function (b, c) { return b && (" " + b + " ").indexOf(" " + c + " ") != -1 } }; (Ext.cmd.derive("Ext.util.LruCache", Ext.util.HashMap, { config: { maxSize: null }, add: function (a, e) { var d = this, c, b; d.removeAtKey(a); b = d.last; c = { prev: b, next: null, key: a, value: e }; if (b) { b.next = c } else { d.first = c } d.last = c; Ext.util.HashMap.prototype.add.call(this, a, c); d.prune(); return e }, insertBefore: function (b, g, c) { var e = this, a, d; if (c = this.map[this.findKey(c)]) { a = e.findKey(g); if (a) { e.unlinkEntry(d = e.map[a]) } else { d = { prev: c.prev, next: c, key: b, value: g } } if (c.prev) { d.prev.next = d } else { e.first = d } d.next = c; c.prev = d; e.prune(); return g } else { return e.add(b, g) } }, get: function (a) { var b = this.map[a]; if (b) { if (b.next) { this.moveToEnd(b) } return b.value } }, removeAtKey: function (a) { this.unlinkEntry(this.map[a]); return Ext.util.HashMap.prototype.removeAtKey.apply(this, arguments) }, clear: function (a) { this.first = this.last = null; return Ext.util.HashMap.prototype.clear.call(this, a) }, unlinkEntry: function (a) { if (a) { if (a.next) { a.next.prev = a.prev } else { this.last = a.prev } if (a.prev) { a.prev.next = a.next } else { this.first = a.next } a.prev = a.next = null } }, moveToEnd: function (a) { this.unlinkEntry(a); if (a.prev = this.last) { this.last.next = a } else { this.first = a } this.last = a }, getArray: function (c) { var a = [], b = this.first; while (b) { a.push(c ? b.key : b.value); b = b.next } return a }, each: function (c, b, a) { var g = this, e = a ? g.last : g.first, d = g.length; b = b || g; while (e) { if (c.call(b, e.key, e.value, d) === false) { break } e = a ? e.prev : e.next } return g }, findKey: function (b) { var a, c = this.map; for (a in c) { if (c.hasOwnProperty(a) && c[a].value === b) { return a } } return undefined }, clone: function () { var a = new this.self(this.initialConfig), c = this.map, b; a.suspendEvents(); for (b in c) { if (c.hasOwnProperty(b)) { a.add(b, c[b].value) } } a.resumeEvents(); return a }, prune: function () { var b = this, a = b.getMaxSize(), c = a ? (b.length - a) : 0; if (c > 0) { for (; b.first && c; c--) { b.removeAtKey(b.first.key) } } } }, 0, 0, 0, 0, 0, 0, [Ext.util, "LruCache"], 0)); (Ext.cmd.derive("Ext.ComponentQuery", Ext.Base, { singleton: true }, 0, 0, 0, 0, 0, 0, [Ext, "ComponentQuery"], function () { var g = this, s = Ext.util.Operators, k = /(\d*)n\+?(\d*)/, e = /\D/, m = /^(\s)+/, l = /\\(.)/g, n = new Ext.util.LruCache({ maxSize: 100 }), o = ["var r = [],", "i = 0,", "it = items,", "l = it.length,", "c;", "for (; i < l; i++) {", "c = it[i];", "if (c.{0}) {", "r.push(c);", "}", "}", "return r;"].join(""), p = function (u, t) { return t.method.apply(this, [u].concat(t.args)) }, a = function (v, z) { var t = [], w = 0, y = v.length, x, u = z !== ">"; for (; w < y; w++) { x = v[w]; if (x.getRefItems) { t = t.concat(x.getRefItems(u)) } } return t }, h = function (u) { var t = [], v = 0, x = u.length, w; for (; v < x; v++) { w = u[v]; while (!!(w = w.getRefOwner())) { t.push(w) } } return t }, d = function (u, z, y) { if (z === "*") { return u.slice() } else { var t = [], v = 0, x = u.length, w; for (; v < x; v++) { w = u[v]; if (w.isXType(z, y)) { t.push(w) } } return t } }, b = function (C, D, w, v) { var G = [], B = 0, u = C.length, F, y, E, t, A, z, x; if (D.charAt(0) === "@") { F = true; D = D.substr(1) } if (D.charAt(0) === "?") { F = true; y = true; D = D.substr(1) } for (; B < u; B++) { E = C[B]; x = E.self && E.self.getConfigurator && E.self.$config.configs[D]; if (x) { t = E[x.names.get]() } else { if (F && !E.hasOwnProperty(D)) { continue } else { t = E[D] } } if (y) { G.push(E) } else { if (w === "~=") { if (t) { if (!Ext.isArray(t)) { t = t.split(" ") } for (A = 0, z = t.length; A < z; A++) { if (s[w](Ext.coerce(t[A], v), v)) { G.push(E); break } } } } else { if (w === "/=") { if (t != null && v.test(t)) { G.push(E) } } else { if (!v ? !!E[D] : s[w](Ext.coerce(t, v), v)) { G.push(E) } } } } } return G }, i = function (w, A, v) { var t = [], x = 0, z = w.length, y, u; for (; x < z; x++) { y = w[x]; u = v ? y.id : y.getItemId(); if (u === A) { t.push(y) } } return t }, r = function (t, u, v) { return g.pseudos[u](t, v) }, j = /^(\s?([>\^])\s?|\s|$)/, q = /^(#)?((?:\\\.|[\w\-])+|\*)(?:\((true|false)\))?/, c = [{ re: /^\.((?:\\\.|[\w\-])+)(?:\((true|false)\))?/, method: d, argTransform: function (t) { if (t[1] !== undefined) { t[1] = t[1].replace(l, "$1") } return t.slice(1) } }, { re: /^(?:\[((?:[@?$])?[\w\-]*)\s*(?:([\^$*~%!\/]?=)\s*(['"])?((?:\\\]|.)*?)\3)?(?!\\)\])/, method: b, argTransform: function (w) { var t = w[0], x = w[1], u = w[2], v = w[4], y; if (v !== undefined) { v = v.replace(l, "$1") } if (u === "/=") { y = n.get(v); if (y) { v = y } else { v = n.add(v, new RegExp(v)) } } return [x, u, v] } }, { re: /^#((?:\\\.|[\w\-])+)/, method: i }, { re: /^\:([\w\-]+)(?:\(((?:\{[^\}]+\})|(?:(?!\{)[^\s>\/]*?(?!\})))\))?/, method: r, argTransform: function (t) { if (t[2] !== undefined) { t[2] = t[2].replace(l, "$1") } return t.slice(1) } }, { re: /^(?:\{([^\}]+)\})/, method: o }]; g.Query = Ext.extend(Object, { constructor: function (t) { t = t || {}; Ext.apply(this, t) }, execute: function (v) { var w = this.operations, u = [], y, x, t; for (x = 0, t = w.length; x < t; x++) { y = w[x]; u = u.concat(this._execute(v, y)) } return u }, _execute: function (u, w) { var x = 0, y = w.length, v, t; if (!u) { t = Ext.ComponentManager.getAll() } else { if (Ext.isIterable(u)) { t = u } else { if (u.isMixedCollection) { t = u.items } } } for (; x < y; x++) { v = w[x]; if (v.mode === "^") { t = h(t || [u]) } else { if (v.mode) { t = a(t || [u], v.mode) } else { t = p(t || a([u]), v) } } if (x === y - 1) { return t } } return [] }, is: function (x, v) { var w = this.operations, u = false, t = w.length, z, y; if (t === 0) { return true } for (y = 0; y < t; y++) { z = w[y]; u = this._is(x, v, z); if (u) { return u } } return false }, _is: function (B, C, t) { var z = t.length, u = [B], v, x, w, y, A, D; for (x = z - 1; x >= 0; --x) { v = t[x]; y = v.mode; if (y) { if (y === "^") { u = a(u, " ") } else { if (y === ">") { A = []; for (w = 0, z = u.length; w < z; ++w) { D = u[w].getRefOwner(); if (D) { A.push(D) } } u = A } else { u = h(u) } } } else { u = p(u, v) } if (u.length === 0) { return false } } if (C) { if (!y) { u = h(u) } if (u.length > 0) { u = p(u, { method: i, args: [C.id, true] }) } if (u.length === 0) { return false } } return true }, getMatches: function (w, u) { var t = u.length, v; for (v = 0; v < t; ++v) { w = p(w, u[v]); if (w.length === 0) { break } } return w }, isMultiMatch: function () { return this.operations.length > 1 } }); Ext.apply(g, { cache: new Ext.util.LruCache({ maxSize: 100 }), pseudos: { not: function (z, t) { var x = 0, y = z.length, w = [], v = -1, u; for (; x < y; ++x) { u = z[x]; if (!g.is(u, t)) { w[++v] = u } } return w }, first: function (u) { var t = []; if (u.length > 0) { t.push(u[0]) } return t }, last: function (v) { var t = v.length, u = []; if (t > 0) { u.push(v[t - 1]) } return u }, focusable: function (u) { var t = u.length, w = [], v = 0, x; for (; v < t; v++) { x = u[v]; if (x.isFocusable && x.isFocusable()) { w.push(x) } } return w }, canfocus: function (u, x) { var t = u.length, w = [], v = 0, y; for (; v < t; v++) { y = u[v]; if (y.canFocus && y.canFocus(false, x)) { w.push(y) } } return w }, "nth-child": function (z, A) { var B = [], u = k.exec(A === "even" && "2n" || A === "odd" && "2n+1" || !e.test(A) && "n+" + A || A), x = (u[1] || 1) - 0, y = u[2] - 0, w, t, v; for (w = 0; t = z[w]; w++) { v = w + 1; if (x === 1) { if (y === 0 || v === y) { B.push(t) } } else { if ((v + y) % x === 0) { B.push(t) } } } return B }, scrollable: function (u) { var t = u.length, w = [], v = 0, x; for (; v < t; v++) { x = u[v]; if (x.scrollable || x._scrollable) { w.push(x) } } return w }, visible: function (v, u) { u = u === "true"; var t = v.length, x = [], w = 0, y; for (; w < t; w++) { y = v[w]; if (y.isVisible(u)) { x.push(y) } } return x } }, query: function (t, A) { if (!t) { return Ext.ComponentManager.all.getArray() } var v = [], B = [], y = {}, x = g.cache.get(t), w, z, u; if (!x) { x = g.cache.add(t, g.parse(t)) } v = x.execute(A); if (x.isMultiMatch()) { w = v.length; for (u = 0; u < w; u++) { z = v[u]; if (!y[z.id]) { B.push(z); y[z.id] = true } } v = B } return v }, visitPreOrder: function (t, v, x, w, u) { g._visit(true, t, v, x, w, u) }, visitPostOrder: function (t, v, x, w, u) { g._visit(false, t, v, x, w, u) }, _visit: function (D, u, C, B, E, y) { var A = g.cache.get(u), x = [C], t, z = 0, w, v; if (!A) { A = g.cache.add(u, g.parse(u)) } v = A.is(C); if (C.getRefItems) { t = C.getRefItems(); z = t.length } if (y) { Ext.Array.push(x, y) } if (D) { if (v) { if (B.apply(E || C, x) === false) { return false } } } for (w = 0; w < z; w++) { if (g._visit.call(g, D, u, t[w], B, E, y) === false) { return false } } if (!D) { if (v) { if (B.apply(E || C, x) === false) { return false } } } }, is: function (v, t, u) { if (!t) { return true } var w = g.cache.get(t); if (!w) { w = g.cache.add(t, g.parse(t)) } return w.is(v, u) }, parse: function (u) { var v = [], x, y, w, t; x = Ext.splitAndUnescape(u, ","); for (w = 0, t = x.length; w < t; w++) { y = Ext.String.trim(x[w]); v.push(g._parse(y)) } return new g.Query({ operations: v }) }, _parse: function (z) { var u = [], x = Ext.String.trim, v = c.length, E, A, y, F, G, H, w, B, C, t, D; while (z && E !== z) { E = z; A = z.match(q); if (A) { F = A[1]; y = x(A[2]).replace(l, "$1"); if (F === "#") { u.push({ method: i, args: [y] }) } else { u.push({ method: d, args: [y, Boolean(A[3])] }) } z = z.replace(A[0], "").replace(m, "$1") } while (!(G = z.match(j))) { for (B = 0; z && B < v; B++) { C = c[B]; H = z.match(C.re); t = C.method; w = C.argTransform; if (H) { if (w) { D = w(H) } else { D = H.slice(1) } u.push({ method: Ext.isString(C.method) ? Ext.functionFactory("items", Ext.String.format.apply(Ext.String, [t].concat(H.slice(1)))) : C.method, args: D }); z = z.replace(H[0], "").replace(m, "$1"); break } if (B === (v - 1)) { Ext.raise('Invalid ComponentQuery selector: "' + arguments[0] + '"') } } } if (G[1]) { u.push({ mode: G[2] || G[1] }); z = z.replace(G[0], "").replace(m, "") } } return u } }); Ext.all = function () { return g.query.apply(g, arguments) }; Ext.first = function () { var t = g.query.apply(g, arguments); return (t && t[0]) || null } })); (Ext.cmd.derive("Ext.Evented", Ext.Base, { alternateClassName: "Ext.EventedBase", initialized: false, constructor: function (a) { this.mixins.observable.constructor.call(this, a); this.initialized = true }, onClassExtended: function (b, e) { if (!e.hasOwnProperty("eventedConfig")) { return } var d = e.config, g = e.eventedConfig, c, a; if (d) { Ext.applyIf(d, g) } else { b.addConfig(g) } for (c in g) { if (g.hasOwnProperty(c)) { a = Ext.Config.get(c); e[a.names.set] = a.eventedSetter || a.getEventedSetter() } } } }, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext, "Evented", Ext, "EventedBase"], 0)); (Ext.cmd.derive("Ext.util.Positionable", Ext.Base, { mixinId: "positionable", _positionTopLeft: ["position", "top", "left"], clippedCls: "x-clipped", afterSetPosition: Ext.emptyFn, adjustForConstraints: function (c, b) { var a = this.getConstrainVector(b, c); if (a) { c[0] += a[0]; c[1] += a[1] } return c }, alignTo: function (c, a, g, b) { var e = this, d = e.el; return e.setXY(e.getAlignToXY(c, a, g), d.anim && !!b ? d.anim(b) : false) }, calculateAnchorXY: function (a, e, d, b) { var c = this.getRegion(); c.setPosition(0, 0); c.translateBy(e || 0, d || 0); if (b) { c.setWidth(b.width); c.setHeight(b.height) } return c.getAnchorPoint(a) }, convertPositionSpec: function (a) { return Ext.util.Region.getAlignInfo(a) }, getAlignToXY: function (a, b, d) { var c = this.getAlignToRegion(a, b, d); return [c.x, c.y] }, getAlignToRegion: function (b, c, h, e) { var d = this, a, g; b = Ext.get(b.el || b); if (!b || !b.dom) { } c = d.convertPositionSpec(c); if (c.constrain) { if (c.constrain === "!") { a = b } else { a = d.constrainTo || d.container || d.el.parent() } a = Ext.get(a.el || a).getConstrainRegion() } g = d.getRegion().alignTo({ target: b.getRegion(), inside: a, minHeight: e, offset: h, align: c, axisLock: true }); return g }, getAnchorXY: function (b, d, c) { var g = this, h = g.getRegion(), e = g.el, i = e.dom.nodeName === "BODY" || e.dom.nodeType === 9, a = e.getScroll(); if (d) { h.setPosition(0, 0) } else { if (i) { h.setPosition(a.left, a.top) } } if (c) { h.setWidth(c.width); h.setHeight(c.height) } return h.getAnchorPoint(b) }, getBox: function (d, i) { var e = this, m = i ? e.getLocalXY() : e.getXY(), j = m[0], g = m[1], k, b, c, a, l; if (e.el.dom.nodeName === "BODY" || e.el.dom.nodeType === 9) { k = Ext.Element.getViewportWidth(); b = Ext.Element.getViewportHeight() } else { k = e.getWidth(); b = e.getHeight() } if (d) { c = e.getBorderPadding(); a = c.beforeX; l = c.beforeY; j += a; g += l; k -= (a + c.afterX); b -= (l + c.afterY) } return { x: j, left: j, 0: j, y: g, top: g, 1: g, width: k, height: b, right: j + k, bottom: g + b } }, calculateConstrainedPosition: function (h, b, l, d) { var k = this, c, i = k.floatParent, e = i ? i.getTargetEl() : null, a, g, j, m = false; if (l && i) { a = e.getXY(); g = e.getBorderPadding(); a[0] += g.beforeX; a[1] += g.beforeY; if (b) { j = [b[0] + a[0], b[1] + a[1]] } } else { j = b } h = h || k.constrainTo || e || k.container || k.el.parent(); if (l && j) { j = k.reverseTranslateXY(j) } c = ((k.constrainHeader && k.header.rendered) ? k.header : k).getConstrainVector(h, j, d); if (c) { m = b || k.getPosition(l); m[0] += c[0]; m[1] += c[1] } return m }, getConstrainRegion: function () { var h = this, c = h.el, a = c.dom.nodeName === "BODY", e = c.dom, g = c.getBorders(), i = c.getXY(), d = i[0] + g.beforeX, j = i[1] + g.beforeY, k, b, l; if (a) { k = c.getScroll(); d = k.left; j = k.top; b = Ext.Element.getViewportWidth(); l = Ext.Element.getViewportHeight() } else { b = e.clientWidth; l = e.clientHeight } return new Ext.util.Region(j, d + b, j + l, d) }, getConstrainVector: function (h, c, e) { var i = this, a = i.getRegion(), d = [0, 0], b = (i.shadow && i.constrainShadow && !i.shadowDisabled) ? i.el.shadow.getShadowSize() : undefined, j = false, g = i.constraintInsets; if (!(h instanceof Ext.util.Region)) { h = Ext.get(h.el || h); h = h.getConstrainRegion() } if (g) { g = Ext.isObject(g) ? g : Ext.Element.parseBox(g); h.adjust(g.top, g.right, g.bottom, g.left) } if (c) { a.translateBy(c[0] - a.x, c[1] - a.y) } if (e) { a.right = a.left + e[0]; a.bottom = a.top + e[1] } if (b) { h.adjust(b[0], -b[1], -b[2], b[3]) } if (a.right > h.right) { j = true; d[0] = (h.right - a.right) } if (a.left + d[0] < h.left) { j = true; d[0] = (h.left - a.left) } if (a.bottom > h.bottom) { j = true; d[1] = (h.bottom - a.bottom) } if (a.top + d[1] < h.top) { j = true; d[1] = (h.top - a.top) } return j ? d : false }, getOffsetsTo: function (a) { var c = this.getXY(), b = Ext.fly(a.el || a).getXY(); return [c[0] - b[0], c[1] - b[1]] }, getRegion: function (a) { var b = this.getBox(a); return new Ext.util.Region(b.top, b.right, b.bottom, b.left) }, getClientRegion: function () { var b = this, a, c = b.getBox(), d = b.dom; a = d.offsetWidth - d.clientWidth; if (a) { if (b.getStyle("direction") === "rtl") { c.left += a } else { c.right -= a } } a = d.offsetHeight - d.clientHeight; if (a) { c.bottom -= a } return new Ext.util.Region(c.top, c.right, c.bottom, c.left) }, getViewRegion: function () { var g = this, c = g.el, a = c.dom.nodeName === "BODY", e, j, h, i, d, b, k; if (a) { j = c.getScroll(); d = j.left; i = j.top; b = Ext.Element.getViewportWidth(); k = Ext.Element.getViewportHeight() } else { e = g.getBorderPadding(); h = g.getXY(); d = h[0] + e.beforeX; i = h[1] + e.beforeY; b = g.getWidth(true); k = g.getHeight(true) } return new Ext.util.Region(i, d + b, i + k, d) }, getClientRegion: function () { var c = this.el, g, h, e, d, b, a; g = this.getBorderPadding(); h = this.getXY(); e = h[0] + g.beforeX; d = h[1] + g.beforeY; b = c.dom.clientWidth; a = c.dom.clientHeight; return new Ext.util.Region(d, e + b, d + a, e) }, move: function (j, b, c) { var g = this, m = g.getXY(), k = m[0], i = m[1], d = [k - b, i], l = [k + b, i], h = [k, i - b], a = [k, i + b], e = { l: d, left: d, r: l, right: l, t: h, top: h, up: h, b: a, bottom: a, down: a }; j = j.toLowerCase(); g.setXY([e[j][0], e[j][1]], c) }, setBox: function (c) { var b = this, a, d; if (c.isRegion) { c = { x: c.left, y: c.top, width: c.right - c.left, height: c.bottom - c.top } } b.constrainBox(c); a = c.x; d = c.y; b.setXY([a, d]); b.setSize(c.width, c.height); b.afterSetPosition(a, d); return b }, constrainBox: function (d) { var c = this, b, a, e; if (c.constrain || c.constrainHeader) { a = ("x" in d) ? d.x : d.left; e = ("y" in d) ? d.y : d.top; b = c.calculateConstrainedPosition(null, [a, e], false, [d.width, d.height]); if (b) { d.x = b[0]; d.y = b[1] } } }, translatePoints: function (a, c) { var b = this.translateXY(a, c); return { left: b.x, top: b.y } }, translateXY: function (h, e) { var d = this, b = d.el, i = b.getStyle(d._positionTopLeft), a = i.position === "relative", c = parseFloat(i.left), g = parseFloat(i.top), j = d.getXY(); if (Ext.isArray(h)) { e = h[1]; h = h[0] } if (isNaN(c)) { c = a ? 0 : b.dom.offsetLeft } if (isNaN(g)) { g = a ? 0 : b.dom.offsetTop } c = (typeof h === "number") ? h - j[0] + c : undefined; g = (typeof e === "number") ? e - j[1] + g : undefined; return { x: c, y: g } }, reverseTranslateXY: function (j) { var h = j, c = this.el, d = c.dom, b = d.offsetParent, a, e, i, g; if (b) { a = c.isStyle("position", "relative"), e = Ext.fly(b).getXY(), i = j[0] + e[0] + b.clientLeft; g = j[1] + e[1] + b.clientTop; if (a) { i += c.getPadding("l"); g += c.getPadding("t") } h = [i, g] } return h }, privates: { clipTo: function (k, b) { var c, a = this.el, h = a.getRegion(), d, j, e = [], n = this.clippedCls, l, g, m; if (k.isRegion) { c = k } else { c = (k.isComponent ? k.el : Ext.fly(k)).getConstrainRegion() } if (!b) { b = 15 } if (b & 1 && (d = c.top - h.top) > 0) { e[0] = d; g = true } else { e[0] = -10000 } if (b & 2 && (d = h.right - c.right) > 0) { e[1] = Math.max(0, a.getWidth() - d); g = true } else { e[1] = 10000 } if (b & 4 && (d = h.bottom - c.bottom) > 0) { e[2] = Math.max(0, a.getHeight() - d); g = true } else { e[2] = 10000 } if (b & 8 && (d = c.left - h.left) > 0) { e[3] = d; g = true } else { e[3] = -10000 } l = "rect("; for (j = 0; j < 4; ++j) { l += Ext.Element.addUnits(e[j], "px"); l += (j === 3) ? ")" : "," } a.dom.style.clip = l; a.addCls(n); if ((m = a.shadow) && (a = m.el) && a.dom) { e[2] -= m.offsets.y; e[3] -= m.offsets.x; l = "rect("; for (j = 0; j < 4; ++j) { l += Ext.Element.addUnits(e[j], "px"); l += (j === 3) ? ")" : "," } a.dom.style.clip = l; if (g && !Ext.supports.CSS3BoxShadow) { a.dom.style.display = "none" } else { a.dom.style.display = ""; a.addCls(n) } } }, clearClip: function () { var b = this.el, a = this.clippedCls; b.dom.style.clip = Ext.isIE8 ? "auto" : ""; b.removeCls(a); if (b.shadow && b.shadow.el && b.shadow.el.dom) { b.shadow.el.dom.style.clip = Ext.isIE8 ? "auto" : ""; if (!Ext.supports.CSS3BoxShadow) { b.dom.style.display = ""; b.removeCls(a) } } } } }, 0, 0, 0, 0, 0, 0, [Ext.util, "Positionable"], 0)); Ext.define("Ext.overrides.util.Positionable", { override: "Ext.util.Positionable", anchorTo: function (h, e, b, a, j, k) { var g = this, i = !Ext.isEmpty(j), c = function () { g.mixins.positionable.alignTo.call(g, h, e, b, a); Ext.callback(k, g) }, d = g.getAnchor(); g.removeAnchor(); Ext.apply(d, { fn: c, scroll: i }); Ext.on("resize", c, null); if (i) { Ext.getWin().on("scroll", c, null, { buffer: !isNaN(j) ? j : 50 }) } c(); return g }, getAnchor: function () { var b = this.el, c, a; if (!b || !b.dom) { return } c = b.getData(); a = c._anchor; if (!a) { a = c._anchor = {} } return a }, alignTo: function (d, a, h, c) { var g = this, e = g.el, b, i; if (g.isComponent && g.getSizeModel().height.shrinkWrap) { if (g.maxHeight) { g.setMaxHeight(null) } b = true } i = g.getAlignToRegion(d, a, h, g.minHeight || 150); g.setXY([i.x, i.y], e.anim && !!c ? e.anim(c) : false); if (b && (b = i.getHeight()) !== g.getHeight()) { g.setMaxHeight(b) } return g }, removeAnchor: function () { var a = this.getAnchor(); if (a && a.fn) { Ext.un("resize", a.fn); if (a.scroll) { Ext.getWin().on("scroll", a.fn) } delete a.fn } return this }, setBox: function (c, a) { var b = this; if (c.isRegion) { c = { x: c.left, y: c.top, width: c.right - c.left, height: c.bottom - c.top } } if (a) { b.constrainBox(c); b.animate(Ext.applyIf({ to: c, listeners: { afteranimate: Ext.Function.bind(b.afterSetPosition, b, [c.x, c.y]) } }, a)) } else { arguments.callee.$previous.call(this, c) } return b } }); (Ext.cmd.derive("Ext.dom.UnderlayPool", Ext.Base, { constructor: function (a) { this.elementConfig = a; this.cache = [] }, checkOut: function () { var a = this.cache.shift(); if (!a) { a = Ext.Element.create(this.elementConfig); a.setVisibilityMode(2) } return a }, checkIn: function (a) { this.cache.push(a) }, reset: function () { var a = this.cache, b = a.length; while (b--) { a[b].destroy() } this.cache = [] } }, 1, 0, 0, 0, 0, 0, [Ext.dom, "UnderlayPool"], 0)); (Ext.cmd.derive("Ext.dom.Underlay", Ext.Base, { constructor: function (a) { Ext.apply(this, a) }, beforeShow: Ext.emptyFn, getInsertionTarget: function () { return this.target }, getPool: function () { return this.pool || (this.self.prototype.pool = new Ext.dom.UnderlayPool(this.elementConfig)) }, hide: function () { var b = this, a = b.el; if (a) { a.hide(); b.getPool().checkIn(a); b.el = null; b.hidden = true } }, realign: function (i, h, a, j) { var e = this, b = e.el, d = e.target, c = e.offsets, g = Math.max; if (b) { if (i == null) { i = d.getX() } if (h == null) { h = d.getY() } if (a == null) { a = d.getWidth() } if (j == null) { j = d.getHeight() } if (c) { i = i + c.x; h = h + c.y; a = g(a + c.w, 0); j = g(j + c.h, 0) } b.setXY([i, h]); b.setSize(a, j) } }, setZIndex: function (a) { this.zIndex = a; if (this.el) { this.el.setStyle("z-index", a) } }, show: function () { var b = this, d = b.target, g = b.zIndex, a = b.el, c = b.getInsertionTarget().dom, e; if (!a) { a = b.el = b.getPool().checkOut() } b.beforeShow(); if (g == null) { g = (parseInt(d.getStyle("z-index"), 10)) } if (g) { a.setStyle("z-index", g) } a.setStyle("position", b.fixed ? "fixed" : ""); e = a.dom; if (e.nextSibling !== c) { d.dom.parentNode.insertBefore(e, c) } a.show(); b.realign(); b.hidden = false } }, 1, 0, 0, 0, 0, 0, [Ext.dom, "Underlay"], 0)); (Ext.cmd.derive("Ext.dom.Shadow", Ext.dom.Underlay, { alternateClassName: "Ext.Shadow", mode: "drop", offset: 4, cls: "x-" + (!Ext.supports.CSS3BoxShadow ? "ie" : "css") + "-shadow", constructor: function (b) { var d = this, e, c, g, a; Ext.dom.Underlay.prototype.constructor.call(this, b); d.elementConfig = { cls: d.cls, role: "presentation" }; g = d.offset; a = Math.floor(g / 2); d.opacity = 50; switch (d.mode.toLowerCase()) { case "drop": e = { x: 0, y: 0, w: g, h: g }; if (Ext.supports.CSS3BoxShadow) { c = { x: g, y: g, h: -g, w: -g } } else { c = { x: -a, y: -a, h: -a, w: -a } } break; case "sides": e = { x: -g, y: 0, w: g * 2, h: g }; if (Ext.supports.CSS3BoxShadow) { c = { x: 0, y: g, h: -g, w: 0 } } else { c = { x: 1 + a - 2 * g, y: -(1 + a), h: -1, w: a - 1 } } break; case "frame": e = { x: -g, y: -g, w: g * 2, h: g * 2 }; if (Ext.supports.CSS3BoxShadow) { c = { x: 0, y: 0, h: 0, w: 0 } } else { c = { x: 1 + a - 2 * g, y: 1 + a - 2 * g, h: g - a - 1, w: g - a - 1 } } break; case "bottom": e = { x: -g, y: 0, w: g * 2, h: g }; if (Ext.supports.CSS3BoxShadow) { c = { x: 0, y: g, h: -g, w: 0 } } else { c = { x: 0, y: g, h: 0, w: 0 } } break }d.offsets = c; d.outerOffsets = e }, getShadowSize: function () { var b = this, d = b.el ? b.offset : 0, a = [d, d, d, d], c = b.mode.toLowerCase(); if (b.el && c !== "frame") { a[0] = 0; if (c == "drop") { a[3] = 0 } } return a }, boxShadowProperty: (function () { var b = "boxShadow", a = document.documentElement.style; if (!("boxShadow" in a)) { if ("WebkitBoxShadow" in a) { b = "WebkitBoxShadow" } else { if ("MozBoxShadow" in a) { b = "MozBoxShadow" } } } return b }()), beforeShow: function () { var b = this, a = b.el.dom.style, c = b.shim; if (Ext.supports.CSS3BoxShadow) { a[b.boxShadowProperty] = "0 0 " + (b.offset + 2) + "px #888" } else { a.filter = "progid:DXImageTransform.Microsoft.alpha(opacity=" + b.opacity + ") progid:DXImageTransform.Microsoft.Blur(pixelradius=" + (b.offset) + ")" } if (c) { c.realign() } }, setOpacity: function (a) { var b = this.el; if (b) { if (Ext.isIE && !Ext.supports.CSS3BoxShadow) { a = Math.floor(a * 100 / 2) / 100 } this.opacity = a; b.setOpacity(a) } } }, 1, 0, 0, 0, 0, 0, [Ext.dom, "Shadow", Ext, "Shadow"], 0)); (Ext.cmd.derive("Ext.dom.Shim", Ext.dom.Underlay, { cls: "x-shim", constructor: function (a) { Ext.dom.Underlay.prototype.constructor.call(this, a); this.elementConfig = { tag: "iframe", cls: this.cls, role: "presentation", frameBorder: "0", src: Ext.SSL_SECURE_URL, tabindex: "-1" } }, getInsertionTarget: function () { var a = this.shadow; return (a && a.el) || this.target } }, 1, 0, 0, 0, 0, 0, [Ext.dom, "Shim"], 0)); (Ext.cmd.derive("Ext.dom.ElementEvent", Ext.util.Event, { addListener: function (h, l, m, c, e) { var g = this, i = false, a = g.name, k = Ext.event.publisher.Dom.instance.directEvents[a], b, d, j; m = m || {}; if (m.delegated === false || k) { if (k && m.delegate) { m.capture = true } if (m.capture) { j = g.directCaptures || (g.directCaptures = new Ext.util.Event(g.observable, a)); i = j.addListener(h, l, m, c, e) } else { d = g.directs || (g.directs = new Ext.util.Event(g.observable, a)); i = d.addListener(h, l, m, c, e) } } else { if (m.capture) { b = g.captures || (g.captures = new Ext.util.Event(g.observable, a)); i = b.addListener(h, l, m, c, e) } else { i = Ext.util.Event.prototype.addListener.call(this, h, l, m, c, e) } } return i }, removeListener: function (e, d) { var g = this, a = g.captures, c = g.directs, h = g.directCaptures, i = false, b = g.findListener(e, d); if (b !== -1) { i = Ext.util.Event.prototype.removeListener.call(this, e, d, b) } else { if (c) { b = c.findListener(e, d) } if (b !== -1) { i = c.removeListener(e, d, b) } else { if (a) { b = a.findListener(e, d) } if (b !== -1) { i = a.removeListener(e, d, b) } else { if (h) { b = h.findListener(e, d); if (b !== -1) { i = h.removeListener(e, d, b) } } } } } return i }, clearListeners: function () { var c = this, d = c.directCaptures, b = c.directs, a = c.captures; if (d) { d.clearListeners() } if (b) { b.clearListeners() } if (a) { a.clearListeners() } Ext.util.Event.prototype.clearListeners.call(this) }, suspend: function () { var c = this, d = c.directCaptures, b = c.directs, a = c.captures; if (d) { d.suspend() } if (b) { b.suspend() } if (a) { a.suspend() } Ext.util.Event.prototype.suspend.call(this) }, resume: function () { var c = this, d = c.directCaptures, b = c.directs, a = c.captures; if (d) { d.resume() } if (b) { b.resume() } if (a) { a.resume() } Ext.util.Event.prototype.resume.call(this) } }, 0, 0, 0, 0, 0, 0, [Ext.dom, "ElementEvent"], 0)); (Ext.cmd.derive("Ext.event.publisher.Publisher", Ext.Base, { isEventPublisher: true, $vetoClearingPrototypeOnDestroy: true, handledEvents: [], statics: { publishers: {}, publishersByEvent: {} }, constructor: function () { var b = this, a = b.type; b.handles = {}; b.registerEvents(); Ext.event.publisher.Publisher.publishers[a] = b }, registerEvents: function (e) { var h = this, d = Ext.event.publisher.Publisher.publishersByEvent, b = e || h.handledEvents, g = b.length, a, c; for (c = 0; c < g; c++) { a = b[c]; h.handles[a] = 1; d[a] = h } }, fire: function (c, a, b) { var d; if (c.hasListeners[a]) { d = c.events[a]; if (d) { d.fire.apply(d, b) } } } }, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, "Publisher"], 0)); (Ext.cmd.derive("Ext.util.Offset", Ext.Base, { statics: { fromObject: function (a) { if (a instanceof this) { return a } if (typeof a === "number") { return new this(a, a) } if (a.length) { return new this(a[0], a[1]) } return new this(a.x, a.y) } }, constructor: function (a, b) { this.x = (a != null && !isNaN(a)) ? a : 0; this.y = (b != null && !isNaN(b)) ? b : 0; return this }, copy: function () { return new Ext.util.Offset(this.x, this.y) }, copyFrom: function (a) { this.x = a.x; this.y = a.y }, toString: function () { return "Offset[" + this.x + "," + this.y + "]" }, equals: function (a) { return (this.x === a.x && this.y === a.y) }, add: function (a) { this.x += a.x; this.y += a.y }, round: function (b) { if (!isNaN(b)) { var a = Math.pow(10, b); this.x = Math.round(this.x * a) / a; this.y = Math.round(this.y * a) / a } else { this.x = Math.round(this.x); this.y = Math.round(this.y) } }, isZero: function () { return this.x === 0 && this.y === 0 } }, 3, 0, 0, 0, 0, 0, [Ext.util, "Offset"], 0)); (Ext.cmd.derive("Ext.util.Region", Ext.Base, function () { var b = Ext.util, m = /([^\?!]*)(!|\?)?$/, k = /^(?:(?:([trbl])(\d+))|(tl|t|tc|tr|l|c|r|bl|b|bc|br))(?:-(?:(?:([trbl])(\d+))|(tl|t|tc|tr|l|c|r|bl|b|bc|br)))?$/i, g = { l: 0, r: 100, t: 0, b: 100, c: 50 }, i = { l: 100, r: 0, t: 0, b: 100, c: 50 }, p = { b: 0, l: 1, t: 2, r: 3 }, l = { "tl-tr": "l0-r0", "tl-r": "l0-r50", "bl-r": "l100-r50", "bl-br": "l100-r100", "tr-tl": "r0-l0", "tr-l": "r0-l50", "br-l": "r100-l50", "br-bl": "r100-l100" }, a = { "tl-tr": "r0-l0", "tl-r": "r0-l50", "bl-r": "r100-l50", "bl-br": "r100-l100", "tr-tl": "l0-r0", "tr-l": "l0-r50", "br-l": "l100-r50", "br-bl": "l100-r100" }, j = [], c = new b.Offset(0, 0), n = function (u) { var v = b.Region, t = typeof u, x, s, r, w; if (u == null) { return v.EMPTY } if (u.isRegion) { return u } if (u.isElement || u.nodeType === 1) { return this.getRegion(u) } if (t === "string") { u = u.split(" "); switch (u.length) { case 1: u[1] = u[2] = u[3] = u[0]; break; case 2: u[2] = u[0]; u[3] = u[1]; break; case 3: u[3] = u[1] }x = parseInt(u[0], 10) || 0; s = parseInt(u[1], 10) || 0; r = parseInt(u[2], 10) || 0; w = parseInt(u[3], 10) || 0 } else { if (t === "number") { x = s = r = w = u } else { if (typeof u.x === "number") { x = u.y; w = u.x; if (typeof u.right === "number") { s = u.right; r = u.bottom } else { s = w + u.width; r = x + u.height } } } } return new v(x, s, r, w) }, e = [-1, 1, 1, -1], o = function (t, s, r) { if (r != null && s) { j[0] = j[1] = j[2] = j[3] = 0; j[r] = s.y * e[r]; t = b.Region.from(t); t.adjust.apply(t, j) } return t }, h = function (z, F, s, A, t) { var E = Math.ceil(A.x / 2) + 2, r, u, w, v, D, C, B; if (t && !t.intersect(z)) { return } if (s != null) { if (s & 1) { r = new b.Region(0, 0, 0, 0).setWidth(A.y).setHeight(A.x); u = s === 3; C = u ? F.right : F.left; w = new b.Region(Math.max(F.top, z.top), C, Math.min(F.bottom, z.bottom), C); if (z.getHeight() > E) { v = w.getHeight(); if (v < z.width && v < A.x + 4) { if (v < E) { if (w.getAnchorPoint_c()[1] > z.getAnchorPoint_c()[1]) { B = z.bottom - E } else { D = true; B = z.top + E - F.getHeight() } if (t) { B = Math.min(Math.max(B, t.top), t.bottom - F.getHeight()) } F.setPosition(F.x, B); w = new b.Region(Math.max(F.top, z.top), C, Math.min(F.bottom, z.bottom), C); v = w.getHeight(); if (v < E) { return } if (D) { w.setPosition(C, z.y - A.x / 2 - 2) } } w.setHeight(Math.max(v, A.x + 4)); if (t && !t.contains(w)) { return } } } F.anchor = r.alignTo({ target: w, align: u ? "l-r" : "r-l", overlap: true }); F.anchor.position = u ? "right" : "left" } else { r = new b.Region(0, 0, 0, 0).setWidth(A.x).setHeight(A.y); u = s === 0; B = u ? F.bottom : F.top; w = new b.Region(B, Math.min(F.right, z.right), B, Math.max(F.left, z.left)); if (z.getWidth() > E) { v = w.getWidth(); if (v < z.height && v < A.x + 4) { if (v < E) { if (w.getAnchorPoint_c()[0] > z.getAnchorPoint_c()[0]) { C = z.right - E } else { D = true; C = z.left + E - F.getWidth() } if (t) { C = Math.min(Math.max(C, t.left), t.right - F.getWidth()) } F.setPosition(C, F.y); w = new b.Region(B, Math.min(F.right, z.right), B, Math.max(F.left, z.left)); v = w.getWidth(); if (v < E) { return } if (D) { w.setPosition(z.x - A.x / 2 - 2, B) } } w.setWidth(Math.max(v, A.x + 4)); if (t && !t.contains(w)) { return } } } F.anchor = r.alignTo({ target: w, align: u ? "t-b" : "b-t", overlap: true }); F.anchor.position = u ? "bottom" : "top" } F.anchor.align = s } return F }, q = function (u, s, v, r) { var t; if (u && r) { if (s.top >= v.bottom && s.bottom > r.bottom) { s.setHeight(Math.max(s.getHeight() + r.bottom - s.bottom, u)); s.constrainHeight = true } else { if (s.bottom <= v.top && s.top < r.top) { t = Math.max(s.getHeight() + s.top - r.top, u); s.adjust(s.getHeight() - t); s.constrainHeight = true } else { if (s.getHeight() > r.getHeight()) { s.setHeight(Math.max(u, r.getHeight())); s.setPosition(s.x, 0); s.constrainHeight = true } } } } }, d = function (t, s, v, r) { var u; if (t && r) { if (s.left >= v.right && s.right > r.right) { s.setWidth(Math.max(s.getWidth() + r.right - s.right, t)); s.constrainWidth = true } else { if (s.right <= v.left && s.left < r.left) { u = Math.max(s.getWidth() + s.left - r.left, t); s.adjust(0, 0, 0, s.getWidth() - u); s.constrainWidth = true } else { if (s.getWidth() > r.getWidth()) { s.setWidth(Math.max(t, r.getWidth())); s.setPosition(0, s.y); s.constrainWidth = true } } } } }; return { isRegion: true, statics: { getRegion: function (r) { return Ext.fly(r).getRegion() }, from: function (r) { return new this(r.top, r.right, r.bottom, r.left) }, getAlignInfo: function (w, u) { if (typeof w === "object") { return w } w = w ? ((w.indexOf("-") < 0) ? "tl-" + w : w) : "tl-bl"; v = m.exec(w); w = v[1]; w = (u ? a : l)[w] || w; var t = u ? i : g, v, s = k.exec(w), r; r = { myEdge: s[1], myOffset: s[2], otherEdge: s[4], otherOffset: s[5], constrain: v[2] }; if (s[3]) { r.myEdge = s[3][0]; r.myOffset = t[s[3][1]]; if (r.myOffset == null) { r.myOffset = 50 } } if (s[6]) { r.otherEdge = s[6][0]; r.otherOffset = t[s[6][1]]; if (r.otherOffset == null) { r.otherOffset = 50 } } r.position = p[r.myEdge]; return r } }, constructor: function (v, s, r, u) { var t = this; t.y = t.top = t[1] = v; t.right = s; t.bottom = r; t.x = t.left = t[0] = u; t.height = t.bottom - t.top; t.width = t.right - t.left }, setPosition: function (r, s) { if (arguments.length === 1) { s = r[1]; r = r[0] } return this.translateBy(r - this.x, s - this.y) }, contains: function (s) { var r = this; return (s.x >= r.x && (s.right || s.x) <= r.right && s.y >= r.y && (s.bottom || s.y) <= r.bottom) }, intersect: function (y) { var x = this, v = Math.max(x.y, y.y), w = Math.min(x.right, y.right), s = Math.min(x.bottom, y.bottom), u = Math.max(x.x, y.x); if (s > v && w > u) { return new this.self(v, w, s, u) } else { return false } }, union: function (y) { var x = this, v = Math.min(x.y, y.y), w = Math.max(x.right, y.right), s = Math.max(x.bottom, y.bottom), u = Math.min(x.x, y.x); return new this.self(v, w, s, u) }, constrainTo: function (s) { var r = this, t = Ext.Number.constrain; r.top = r.y = t(r.top, s.y, s.bottom); r.bottom = t(r.bottom, s.y, s.bottom); r.left = r.x = t(r.left, s.x, s.right); r.right = t(r.right, s.x, s.right); return r }, adjust: function (v, s, r, u) { var t = this; t.top = t.y += v || 0; t.left = t.x += u || 0; t.right += s || 0; t.bottom += r || 0; return t }, getOutOfBoundOffset: function (r, s) { if (!Ext.isObject(r)) { if (r === "x") { return this.getOutOfBoundOffsetX(s) } else { return this.getOutOfBoundOffsetY(s) } } else { s = r; var t = new b.Offset(); t.x = this.getOutOfBoundOffsetX(s.x); t.y = this.getOutOfBoundOffsetY(s.y); return t } }, getOutOfBoundOffsetX: function (r) { if (r <= this.x) { return this.x - r } else { if (r >= this.right) { return this.right - r } } return 0 }, getOutOfBoundOffsetY: function (r) { if (r <= this.y) { return this.y - r } else { if (r >= this.bottom) { return this.bottom - r } } return 0 }, isOutOfBound: function (r, s) { if (!Ext.isObject(r)) { if (r === "x") { return this.isOutOfBoundX(s) } else { return this.isOutOfBoundY(s) } } else { s = r; return (this.isOutOfBoundX(s.x) || this.isOutOfBoundY(s.y)) } }, isOutOfBoundX: function (r) { return (r < this.x || r > this.right) }, isOutOfBoundY: function (r) { return (r < this.y || r > this.bottom) }, restrict: function (s, u, r) { if (Ext.isObject(s)) { var t; r = u; u = s; if (u.copy) { t = u.copy() } else { t = { x: u.x, y: u.y } } t.x = this.restrictX(u.x, r); t.y = this.restrictY(u.y, r); return t } else { if (s === "x") { return this.restrictX(u, r) } else { return this.restrictY(u, r) } } }, restrictX: function (s, r) { if (!r) { r = 1 } if (s <= this.x) { s -= (s - this.x) * r } else { if (s >= this.right) { s -= (s - this.right) * r } } return s }, restrictY: function (s, r) { if (!r) { r = 1 } if (s <= this.y) { s -= (s - this.y) * r } else { if (s >= this.bottom) { s -= (s - this.bottom) * r } } return s }, alignTo: function (H) { var B = this, G = B.self, A = b.Offset, z = n(H.target), D, C = H.rtl, E = H.overlap, y = H.align, x = H.anchorSize, u = H.offset, t = H.inside, w = H.position, s = H.allowXTranslate, v = H.allowYTranslate, r, F; if (u) { u = A.fromObject(u) } if (x) { x = A.fromObject(x) } if (w) { if (w.length === 2) { w = new b.Point(w[0], w[1]) } F = new G().copyFrom(B).setPosition(w.x, w.y) } else { y = B.getAlignInfo(y, C); if (t) { if (z.x >= t.right) { z.setPosition(t.right - 1, z.y); if (y.position !== 3) { y = B.getAlignInfo("r-l", C) } } else { if (z.right < t.x) { z.setPosition(t.x - z.getWidth() + 1, z.y); if (y.position !== 1) { y = B.getAlignInfo("l-r", C) } } } if (z.y >= t.bottom) { z.setPosition(z.x, t.bottom - 1); if (y.position !== 0) { y = B.getAlignInfo("b-t", C) } } else { if (z.bottom < t.y) { z.setPosition(z.x, t.y - z.getHeight() + 1); if (y.position !== 2) { y = B.getAlignInfo("t-b", C) } } } } D = x ? o(z, x, y.position) : z; F = G.from(B).translateBy(B.getAlignToVector(D, y)); E = !!F.intersect(D); if (u && (E || !x)) { F.translateBy(u) } if (x) { h(z, F, y.position, x, t) } } if (t) { if (F.left < t.left) { F.translateBy(t.left - F.left, 0); r = true } if (F.right > t.right && F.left > t.left) { F.translateBy(t.right - F.right, 0); r = true } if (F.top < t.top) { F.translateBy(0, t.top - F.top); r = true } if (F.bottom > t.bottom && F.top > t.top) { F.translateBy(0, t.bottom - F.bottom); r = true } if (r && !E) { F.anchor = null; if (H.axisLock) { if (y.position & 1) { v = false } else { s = false } } if (w) { if (F.contains(w)) { w.exclude(F, { inside: t, centerOnSideChange: false }) } } else { if (F.intersect(D)) { y.position = z.exclude(F, { defaultPosition: y.position, inside: t, minHeight: H.minHeight, minWidth: H.minWidth, allowX: s, allowY: v, offset: u, anchorHeight: x ? x.y : 0, centerOnSideChange: !!x }) } else { if (H.minWidth && F.getWidth() > t.getWidth()) { F.setPosition(0, F.y); F.setWidth(Math.max(t.getWidth(), H.minWidth)); F.constrainWidth = true } else { if (H.minHeight && F.getHeight() > t.getHeight()) { F.setPosition(F.x, 0); F.setHeight(Math.max(t.getHeight(), H.minHeight)); F.constrainHeight = true } } } F.align = y; if (x) { h(z, F, y.position, x, t) } } } } return F }, exclude: function (x, s) { s = s || {}; var L = this, J = s.inside, u = s.defaultPosition, r = s.centerOnSideChange, z = s.minHeight, D = s.minWidth, F = s.allowX !== false, E = s.allowY !== false, K = s.anchorHeight, y = s.offset, v = [], G, C, I, w, H, A, B; if (!y) { y = c } if (E) { v.push([0, C = L.top - x.bottom - K + y.y, "b-t", 0, Math.abs(C)]); v.push([0, C = L.bottom - x.top + K + y.y, "t-b", 2, Math.abs(C)]) } else { r = false } if (F) { v.push([C = L.left - x.right - K + y.x, 0, "r-l", 3, Math.abs(C)]); v.push([C = L.right - x.left + K + y.x, 0, "l-r", 1, Math.abs(C)]) } else { r = false } Ext.Array.sort(v, function (M, N) { var t = M[4] - N[4]; if (!t) { if (M[3] === u) { return -1 } if (N[3] === u) { return 1 } } return t }); if (J) { for (I = 0; I < v.length; I++) { C = v[I]; G = b.Region.from(x); G.translateBy.apply(G, C); if (J.contains(G)) { x.copyFrom(G); B = { align: C[2], position: C[3], distance: C[4] }; break } if (z) { q(z, G, L, J); if (J.contains(G)) { if (!w || G.getArea() > w.region.getArea()) { w = { region: G, align: C[2], position: C[3], distance: C[4] } } } } if (D) { d(D, G, L, J); if (J.contains(G)) { if (!w || G.getArea() > w.region.getArea()) { w = { region: G, align: C[2], position: C[3], distance: C[4] } } } } A = J.intersect(G); if (A) { A = A.getArea(); if (!H || (A && H.area < A)) { H = { region: G, align: C[2], position: C[3], distance: C[4], area: A } } } } if (!B) { if (w) { x.copyFrom(w.region); B = w; x.constrainWidth = w.region.constrainWidth; x.constrainHeight = w.region.constrainHeight } else { if (H) { x.copyFrom(H.region); B = H } } } if (B) { if ((B.position & 1) !== (u & 1)) { if (B.distance && r) { C = x.alignTo({ align: B.align, target: L, anchorSize: K, offset: y, axisLock: true, inside: J, minHeight: s.minHeight, minWidth: s.minWidth }); if (J.contains(C)) { x.setPosition(C.x, C.y) } } } return B.position } } else { x.translateBy.apply(x, v[0]); return v[0][3] } return u }, getAlignToXY: function (t, u, s) { var r = this.getAlignToVector(t, u, s); return [this.x + r[0], this.y + r[1]] }, getAnchorPoint: function (s, r) { s = (typeof s === "string") ? this.getAlignInfo(s + "-tl", r) : s; return this["getAnchorPoint_" + s.myEdge](s.myOffset) }, getAlignToVector: function (u, v, t) { v = (typeof v === "string") ? this.getAlignInfo(v, t) : v; var r = this["getAnchorPoint_" + v.myEdge](v.myOffset), s = u["getAnchorPoint_" + v.otherEdge](v.otherOffset); return [s[0] - r[0], s[1] - r[1]] }, getAnchorPoint_t: function (r) { return [this.x + Math.round(this.getWidth() * (r / 100)), this.y] }, getAnchorPoint_b: function (r) { return [this.x + Math.round(this.getWidth() * (r / 100)), this.bottom] }, getAnchorPoint_l: function (r) { return [this.x, this.y + Math.round(this.getHeight() * (r / 100))] }, getAnchorPoint_r: function (r) { return [this.right, this.y + Math.round(this.getHeight() * (r / 100))] }, getAnchorPoint_c: function () { return [this.x + Math.round(this.getWidth() / 2), this.y + Math.round(this.getHeight() / 2)] }, getHeight: function () { return this.bottom - this.y }, getWidth: function () { return this.right - this.x }, getArea: function () { return this.getHeight() * this.getWidth() }, setHeight: function (r) { this.bottom = this.top + r; return this }, setWidth: function (r) { this.right = this.left + r; return this }, getSize: function () { return { width: this.right - this.x, height: this.bottom - this.y } }, copy: function () { return new this.self(this.y, this.right, this.bottom, this.x) }, copyFrom: function (s) { var r = this; r.top = r.y = r[1] = s.y; r.right = s.right; r.bottom = s.bottom; r.left = r.x = r[0] = s.x; return this }, toString: function () { return "Region[" + this.top + "," + this.right + "," + this.bottom + "," + this.left + "]" }, translateBy: function (r, t) { if (r.length) { t = r[1]; r = r[0] } else { if (arguments.length === 1) { t = r.y; r = r.x } } var s = this; s.top = s.y += t; s.right += r; s.bottom += t; s.left = s.x += r; return s }, round: function () { var r = this; r.top = r.y = Math.round(r.y); r.right = Math.round(r.right); r.bottom = Math.round(r.bottom); r.left = r.x = Math.round(r.x); return r }, equals: function (r) { return (this.top === r.top && this.right === r.right && this.bottom === r.bottom && this.left === r.left) }, getOffsetsTo: function (r) { return { x: this.x - r.x, y: this.y - r.y } } } }, 3, 0, 0, 0, 0, 0, [Ext.util, "Region"], function (a) { a.prototype.getAlignInfo = a.getAlignInfo; a.EMPTY = new a(0, 0, 0, 0) })); (Ext.cmd.derive("Ext.util.Point", Ext.util.Region, { isPoint: true, radianToDegreeConstant: 180 / Math.PI, origin: { x: 0, y: 0 }, statics: { fromEvent: function (b) { var a = b.changedTouches, c = (a && a.length > 0) ? a[0] : b; return this.fromTouch(c) }, fromTouch: function (a) { return new this(a.pageX, a.pageY) }, from: function (a) { if (!a) { return new this(0, 0) } if (!(a instanceof this)) { return new this(a.x, a.y) } return a } }, constructor: function (a, b) { if (a == null) { a = 0 } if (b == null) { b = 0 } Ext.util.Region.prototype.constructor.call(this, b, a, b, a) }, clone: function () { return new this.self(this.x, this.y) }, copy: function () { return this.clone.apply(this, arguments) }, copyFrom: function (a) { this.x = a.x; this.y = a.y; return this }, toString: function () { return "Point[" + this.x + "," + this.y + "]" }, equals: function (a) { return (this.x === a.x && this.y === a.y) }, isCloseTo: function (c, b) { if (typeof b == "number") { return this.getDistanceTo(c) <= b } var a = c.x, g = c.y, e = b.x, d = b.y; return (this.x <= a + e && this.x >= a - e && this.y <= g + d && this.y >= g - d) }, isWithin: function () { return this.isCloseTo.apply(this, arguments) }, isContainedBy: function (a) { if (!(a instanceof Ext.util.Region)) { a = Ext.get(a.el || a).getRegion() } return a.contains(this) }, roundedEquals: function (a) { if (!a || typeof a !== "object") { a = this.origin } return (Math.round(this.x) === Math.round(a.x) && Math.round(this.y) === Math.round(a.y)) }, getDistanceTo: function (b) { if (!b || typeof b !== "object") { b = this.origin } var c = this.x - b.x, a = this.y - b.y; return Math.sqrt(c * c + a * a) }, getAngleTo: function (b) { if (!b || typeof b !== "object") { b = this.origin } var c = this.x - b.x, a = this.y - b.y; return Math.atan2(a, c) * this.radianToDegreeConstant } }, 3, 0, 0, 0, 0, 0, [Ext.util, "Point"], function () { this.prototype.translate = this.prototype.translateBy })); (Ext.cmd.derive("Ext.event.Event", Ext.Base, { alternateClassName: "Ext.EventObjectImpl", stopped: false, claimed: false, defaultPrevented: false, isEvent: true, statics: { resolveTextNode: function (a) { return (a && a.nodeType === 3) ? a.parentNode : a }, pointerEvents: { pointerdown: 1, pointermove: 1, pointerup: 1, pointercancel: 1, pointerover: 1, pointerout: 1, pointerenter: 1, pointerleave: 1, MSPointerDown: 1, MSPointerMove: 1, MSPointerUp: 1, MSPointerOver: 1, MSPointerOut: 1, MSPointerCancel: 1, MSPointerEnter: 1, MSPointerLeave: 1 }, mouseEvents: { mousedown: 1, mousemove: 1, mouseup: 1, mouseover: 1, mouseout: 1, mouseenter: 1, mouseleave: 1 }, clickEvents: { click: 1, dblclick: 1 }, touchEvents: { touchstart: 1, touchmove: 1, touchend: 1, touchcancel: 1 }, focusEvents: { focus: 1, blur: 1, focusin: 1, focusout: 1, focusenter: 1, focusleave: 1 }, pointerTypeMap: { 2: "touch", 3: "pen", 4: "mouse", touch: "touch", pen: "pen", mouse: "mouse" }, keyFlags: { CTRL: "ctrlKey", CONTROL: "ctrlKey", ALT: "altKey", SHIFT: "shiftKey", CMD: "metaKey", COMMAND: "metaKey", CMDORCTRL: Ext.isMac ? "metaKey" : "ctrlKey", COMMANDORCONTROL: Ext.isMac ? "metaKey" : "ctrlKey", META: "metaKey" }, modifierGlyphs: { ctrlKey: "⌃", altKey: "⌥", metaKey: Ext.isMac ? "⌘" : "⊞", shiftKey: "⇧" }, specialKeyGlyphs: { BACKSPACE: "⌫", TAB: "⇥", ENTER: "⏎", RETURN: "⏎", SPACE: "␣", PAGE_UP: "⇞", PAGE_DOWN: "⇟", END: "⇲", HOME: "⌂", LEFT: "←", UP: "↑", RIGHT: "→", DOWN: "↓", PRINT_SCREEN: "⎙", INSERT: "⎀", DELETE: "⌦", CONTEXT_MENU: "☰" }, getKeyId: function (e) { e = e.toUpperCase(); var g = this, h = e.split("+"), j = h.length - 1, c = h[j], b = [], a, d; for (d = 0; d < j; d++) { a = g.keyFlags[h[d]]; b[a] = true } if (b.ctrlKey) { b.push(g.modifierGlyphs.ctrlKey) } if (b.altKey) { b.push(g.modifierGlyphs.altKey) } if (b.shiftKey) { b.push(g.modifierGlyphs.shiftKey) } if (b.metaKey) { b.push(g.modifierGlyphs.metaKey) } b.push(this.specialKeyGlyphs[c] || c); return b.join("") } }, constructor: function (b) { var i = this, l = i.self, h = i.self.resolveTextNode, k = b.changedTouches, c = k ? k[0] : b, j = b.type, a, g; i.timeStamp = i.time = Ext.now(); i.pageX = c.pageX; i.pageY = c.pageY; i.clientX = c.clientX; i.clientY = c.clientY; i.target = i.delegatedTarget = h(b.target); g = b.relatedTarget; if (g) { if (Ext.isGecko && j === "dragenter" || j === "dragleave") { try { i.relatedTarget = h(g) } catch (d) { i.relatedTarget = null } } else { i.relatedTarget = h(g) } } i.browserEvent = i.event = b; i.type = j; i.button = b.button || 0; i.shiftKey = b.shiftKey; i.ctrlKey = b.ctrlKey || b.metaKey || false; i.altKey = b.altKey; i.charCode = b.charCode; i.keyCode = b.keyCode; i.buttons = b.buttons; if (i.button === 0 && i.buttons === 0) { i.buttons = 1 } if (l.focusEvents[j]) { if (l.forwardTab !== undefined) { i.forwardTab = l.forwardTab } } else { if (j !== "keydown") { delete l.forwardTab } } if (l.mouseEvents[j]) { a = "mouse" } else { if (l.clickEvents[j]) { a = l.pointerTypeMap[b.pointerType] || "mouse" } else { if (l.pointerEvents[j]) { a = l.pointerTypeMap[b.pointerType] } else { if (l.touchEvents[j]) { a = "touch" } } } } if (a) { i.pointerType = a } i.isMultitouch = b.isPrimary === false || (b.touches && b.touches.length > 1) }, chain: function (a) { var b = Ext.Object.chain(this); b.parentEvent = this; return Ext.apply(b, a) }, correctWheelDelta: function (c) { var b = this.WHEEL_SCALE, a = Math.round(c / b); if (!a && c) { a = (c < 0) ? -1 : 1 } return a }, getCharCode: function () { return this.charCode || this.keyCode }, getKey: function () { return this.keyCode || this.charCode }, getKeyName: function () { return this.keyCodes[this.keyCode] }, getPoint: function () { var b = this, a = b.point, c; if (!a) { c = b.getXY(); a = b.point = new Ext.util.Point(c[0], c[1]) } return a }, getRelatedTarget: function (b, e, a) { var c = this.relatedTarget, d = null; if (c && c.nodeType) { if (b) { d = Ext.fly(c).findParent(b, e, a) } else { d = a ? Ext.get(c) : c } } return d }, getTarget: function (b, c, a) { return b ? Ext.fly(this.target).findParent(b, c, a) : (a ? Ext.get(this.target) : this.target) }, getTime: function () { return this.time }, getWheelDelta: function () { var a = this.getWheelDeltas(); return a.y }, getWheelDeltas: function () { var d = this, c = d.browserEvent, b = 0, a = 0; if (Ext.isDefined(c.wheelDeltaX)) { b = c.wheelDeltaX; a = c.wheelDeltaY } else { if (c.wheelDelta) { a = c.wheelDelta } else { if ("deltaX" in c) { b = c.deltaX; a = -c.deltaY } else { if (c.detail) { a = -c.detail; if (a > 100) { a = 3 } else { if (a < -100) { a = -3 } } if (Ext.isDefined(c.axis) && c.axis === c.HORIZONTAL_AXIS) { b = a; a = 0 } } } } } return { x: d.correctWheelDelta(b), y: d.correctWheelDelta(a) } }, getX: function () { return this.getXY()[0] }, getXY: function () { var c = this, e = c.xy; if (!e) { e = c.xy = [c.pageX, c.pageY]; var b = e[0], h, d, g, a; if (!b && b !== 0) { h = c.browserEvent; d = document; g = d.documentElement; a = d.body; e[0] = h.clientX + (g && g.scrollLeft || a && a.scrollLeft || 0) - (g && g.clientLeft || a && a.clientLeft || 0); e[1] = h.clientY + (g && g.scrollTop || a && a.scrollTop || 0) - (g && g.clientTop || a && a.clientTop || 0) } } return e }, getY: function () { return this.getXY()[1] }, hasModifier: function () { var a = this; return !!(a.ctrlKey || a.altKey || a.shiftKey || a.metaKey) }, isNavKeyPress: function (d) { var c = this, a = c.keyCode, b = c.type === "keypress"; return ((!b || Ext.isGecko) && a >= 33 && a <= 40) || (!d && (a === c.RETURN || a === c.TAB || a === c.ESC)) }, isSpecialKey: function () { var d = this, b = d.keyCode, a = Ext.isGecko, c = d.type === "keypress"; return (a && c && d.charCode === 0) || (this.isNavKeyPress()) || (b === d.BACKSPACE) || (b === d.ENTER) || (b >= 16 && b <= 20) || ((!c || a) && b >= 44 && b <= 46) }, makeUnpreventable: function () { this.browserEvent.preventDefault = Ext.emptyFn }, preventDefault: function () { var b = this, a = b.parentEvent; b.defaultPrevented = true; if (a) { a.defaultPrevented = true } b.browserEvent.preventDefault(); return b }, setCurrentTarget: function (a) { this.currentTarget = this.delegatedTarget = a }, stopEvent: function () { return this.preventDefault().stopPropagation() }, stopPropagation: function () { var b = this, c = b.browserEvent, a = b.parentEvent; b.stopped = true; if (a && !b.isGesture) { a.stopped = true } if (!c.stopPropagation) { c.cancelBubble = true; return b } c.stopPropagation(); return b }, claimGesture: function () { var b = this, a = b.parentEvent; b.claimed = true; if (a && !b.hasOwnProperty("isGesture")) { a.claimGesture() } else { b.preventDefault() } return b }, within: function (c, d, a) { var b; if (c) { b = d ? this.getRelatedTarget() : this.getTarget() } return b ? Ext.fly(c).contains(b) || !!(a && b === Ext.getDom(c)) : false }, deprecated: { "4.0": { methods: { getPageX: "getX", getPageY: "getY" } } } }, 1, 0, 0, 0, 0, 0, [Ext.event, "Event", Ext, "EventObjectImpl"], function (a) { var c = a.prototype, d = { BACKSPACE: 8, TAB: 9, NUM_CENTER: 12, ENTER: 13, RETURN: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE: 19, CAPS_LOCK: 20, ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PRINT_SCREEN: 44, INSERT: 45, DELETE: 46, ZERO: 48, ONE: 49, TWO: 50, THREE: 51, FOUR: 52, FIVE: 53, SIX: 54, SEVEN: 55, EIGHT: 56, NINE: 57, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, CONTEXT_MENU: 93, NUM_ZERO: 96, NUM_ONE: 97, NUM_TWO: 98, NUM_THREE: 99, NUM_FOUR: 100, NUM_FIVE: 101, NUM_SIX: 102, NUM_SEVEN: 103, NUM_EIGHT: 104, NUM_NINE: 105, NUM_MULTIPLY: 106, NUM_PLUS: 107, NUM_MINUS: 109, NUM_PERIOD: 110, NUM_DIVISION: 111, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, WHEEL_SCALE: (function () { var h; if (Ext.isGecko) { h = 3 } else { if (Ext.isMac) { if (Ext.isSafari && Ext.webKitVersion >= 532) { h = 120 } else { h = 12 } h *= 3 } else { h = 120 } } return h }()) }, b = {}, e, g; Ext.apply(a, d); Ext.apply(c, d); delete d.WHEEL_SCALE; delete d.RETURN; for (e in d) { g = d[e]; b[g] = e } c.keyCodes = b; c.getTrueXY = c.getXY })); Ext.define("Ext.overrides.event.Event", { override: "Ext.event.Event", mousedownEvents: { mousedown: 1, pointerdown: 1, touchstart: 1 }, injectEvent: (function () { var d, e = {}, c; if (!Ext.isIE9m && document.createEvent) { d = { createHtmlEvent: function (k, i, h, g) { var j = k.createEvent("HTMLEvents"); j.initEvent(i, h, g); return j }, createMouseEvent: function (u, s, m, l, o, k, i, j, g, r, q, n, p) { var h = u.createEvent("MouseEvents"), t = u.defaultView || window; if (h.initMouseEvent) { h.initMouseEvent(s, m, l, t, o, k, i, k, i, j, g, r, q, n, p) } else { h = u.createEvent("UIEvents"); h.initEvent(s, m, l); h.view = t; h.detail = o; h.screenX = k; h.screenY = i; h.clientX = k; h.clientY = i; h.ctrlKey = j; h.altKey = g; h.metaKey = q; h.shiftKey = r; h.button = n; h.relatedTarget = p } return h }, createUIEvent: function (m, k, i, h, j) { var l = m.createEvent("UIEvents"), g = m.defaultView || window; l.initUIEvent(k, i, h, g, j); return l }, fireEvent: function (i, g, h) { i.dispatchEvent(h) } } } else { if (document.createEventObject) { c = { 0: 1, 1: 4, 2: 2 }; d = { createHtmlEvent: function (k, i, h, g) { var j = k.createEventObject(); j.bubbles = h; j.cancelable = g; return j }, createMouseEvent: function (t, s, m, l, o, k, i, j, g, r, q, n, p) { var h = t.createEventObject(); h.bubbles = m; h.cancelable = l; h.detail = o; h.screenX = k; h.screenY = i; h.clientX = k; h.clientY = i; h.ctrlKey = j; h.altKey = g; h.shiftKey = r; h.metaKey = q; h.button = c[n] || n; h.relatedTarget = p; return h }, createUIEvent: function (l, j, h, g, i) { var k = l.createEventObject(); k.bubbles = h; k.cancelable = g; return k }, fireEvent: function (i, g, h) { i.fireEvent("on" + g, h) } } } } Ext.Object.each({ load: [false, false], unload: [false, false], select: [true, false], change: [true, false], submit: [true, true], reset: [true, false], resize: [true, false], scroll: [true, false] }, function (i, j) { var h = j[0], g = j[1]; e[i] = function (m, k) { var l = d.createHtmlEvent(i, h, g); d.fireEvent(m, i, l) } }); function b(i, h) { var g = (i !== "mousemove"); return function (m, j) { var l = j.getXY(), k = d.createMouseEvent(m.ownerDocument, i, true, g, h, l[0], l[1], j.ctrlKey, j.altKey, j.shiftKey, j.metaKey, j.button, j.relatedTarget); d.fireEvent(m, i, k) } } Ext.each(["click", "dblclick", "mousedown", "mouseup", "mouseover", "mousemove", "mouseout"], function (g) { e[g] = b(g, 1) }); Ext.Object.each({ focusin: [true, false], focusout: [true, false], activate: [true, true], focus: [false, false], blur: [false, false] }, function (i, j) { var h = j[0], g = j[1]; e[i] = function (m, k) { var l = d.createUIEvent(m.ownerDocument, i, h, g, 1); d.fireEvent(m, i, l) } }); if (!d) { e = {}; d = {} } function a(h, g) { } return function (j) { var i = this, h = e[i.type] || a, g = j ? (j.dom || j) : i.getTarget(); h(g, i) } }()), preventDefault: function (g) { var d = this, c = d.browserEvent, b = d.parentEvent, a, e; if (typeof c.type !== "unknown") { if (!g) { d.defaultPrevented = true } if (b) { b.defaultPrevented = true } if (c.preventDefault) { c.preventDefault() } else { if (c.type === "mousedown") { e = c.target; a = e.getAttribute("unselectable"); if (a !== "on") { e.setAttribute("unselectable", "on"); Ext.defer(function () { e.setAttribute("unselectable", a) }, 1) } } c.returnValue = false; if (c.ctrlKey || c.keyCode > 111 && c.keyCode < 124) { c.keyCode = -1 } } } return d }, stopPropagation: function () { var b = this, a = b.browserEvent; if (typeof a.type !== "unknown") { if (b.mousedownEvents[b.type]) { Ext.GlobalEvents.fireMouseDown(b) } arguments.callee.$previous.call(this) } return b }, deprecated: { "5.0": { methods: { clone: function () { return new this.self(this.browserEvent, this) } } } } }, function () { var a = this, d, c = function (g) { if (g.keyCode === 9) { a.forwardTab = !g.shiftKey } }, b = function (g) { if (g.keyCode === 9) { delete a.forwardTab } }; if (Ext.isIE9m) { d = { 0: 0, 1: 0, 4: 1, 2: 2 }; a.override({ statics: { enableIEAsync: function (h) { var e, g = {}; for (e in h) { g[e] = h[e] } return g } }, constructor: function (i, j, g, e) { var h = this; h.callParent([i, j, g, e]); h.button = d[i.button]; if (i.type === "contextmenu") { h.button = 2 } h.toElement = i.toElement; h.fromElement = i.fromElement }, mouseLeaveRe: /(mouseout|mouseleave)/, mouseEnterRe: /(mouseover|mouseenter)/, enableIEAsync: function (e) { this.browserEvent = this.self.enableIEAsync(e) }, getRelatedTarget: function (g, k, e) { var i = this, h, j; if (!i.relatedTarget) { h = i.type; if (i.mouseLeaveRe.test(h)) { j = i.toElement } else { if (i.mouseEnterRe.test(h)) { j = i.fromElement } } if (j) { i.relatedTarget = i.self.resolveTextNode(j) } } return i.callParent([g, k, e]) } }); document.attachEvent("onkeydown", c); document.attachEvent("onkeyup", b); window.attachEvent("onunload", function () { document.detachEvent("onkeydown", c); document.detachEvent("onkeyup", b) }) } else { if (document.addEventListener) { document.addEventListener("keydown", c, true); document.addEventListener("keyup", b, true) } } }); (Ext.cmd.derive("Ext.event.publisher.Dom", Ext.event.publisher.Publisher, { type: "dom", handledDomEvents: [], reEnterCount: 0, captureEvents: { animationstart: 1, animationend: 1, resize: 1, focus: 1, blur: 1 }, directEvents: { mouseenter: 1, mouseleave: 1, pointerenter: 1, pointerleave: 1, MSPointerEnter: 1, MSPointerLeave: 1, load: 1, unload: 1, beforeunload: 1, error: 1, DOMContentLoaded: 1, DOMFrameContentLoaded: 1, hashchange: 1, scroll: 1 }, blockedPointerEvents: { pointerover: 1, pointerout: 1, pointerenter: 1, pointerleave: 1, MSPointerOver: 1, MSPointerOut: 1, MSPointerEnter: 1, MSPointerLeave: 1 }, blockedCompatibilityMouseEvents: { mouseenter: 1, mouseleave: 1 }, constructor: function () { var a = this; a.bubbleSubscribers = {}; a.captureSubscribers = {}; a.directSubscribers = {}; a.directCaptureSubscribers = {}; a.delegatedListeners = {}; a.initHandlers(); Ext.onInternalReady(a.onReady, a); Ext.event.publisher.Publisher.prototype.constructor.call(this) }, registerEvents: function () { var g = this, d = Ext.event.publisher.Publisher.publishersByEvent, a = g.handledDomEvents, e = a.length, c = 0, b; for (; c < e; c++) { b = a[c]; g.handles[b] = 1; d[b] = g } Ext.event.publisher.Publisher.prototype.registerEvents.call(this) }, onReady: function () { var d = this, a = d.handledDomEvents, c, b; if (a) { for (b = 0, c = a.length; b < c; b++) { d.addDelegatedListener(a[b]) } } Ext.getWin().on("unload", d.destroy, d) }, initHandlers: function () { var a = this; a.onDelegatedEvent = Ext.bind(a.onDelegatedEvent, a); a.onDirectEvent = Ext.bind(a.onDirectEvent, a); a.onDirectCaptureEvent = Ext.bind(a.onDirectCaptureEvent, a) }, addDelegatedListener: function (a) { this.delegatedListeners[a] = 1; this.target.addEventListener(a, this.onDelegatedEvent, !!this.captureEvents[a]) }, removeDelegatedListener: function (a) { delete this.delegatedListeners[a]; this.target.removeEventListener(a, this.onDelegatedEvent, !!this.captureEvents[a]) }, addDirectListener: function (b, c, a) { c.dom.addEventListener(b, a ? this.onDirectCaptureEvent : this.onDirectEvent, a) }, removeDirectListener: function (b, c, a) { c.dom.removeEventListener(b, a ? this.onDirectCaptureEvent : this.onDirectEvent, a) }, subscribe: function (c, b, g, a) { var d = this, e, h; if (g && !d.directEvents[b]) { e = a ? d.captureSubscribers : d.bubbleSubscribers; if (!d.handles[b] && !d.delegatedListeners[b]) { d.addDelegatedListener(b) } if (e[b]) { ++e[b] } else { e[b] = 1 } } else { e = a ? d.directCaptureSubscribers : d.directSubscribers; h = c.id; e = e[b] || (e[b] = {}); if (e[h]) { ++e[h] } else { e[h] = 1; d.addDirectListener(b, c, a) } } }, unsubscribe: function (e, g, b, j) { var i = this, h, d, a, c; if (b && !i.directEvents[g]) { h = i.captureSubscribers; d = i.bubbleSubscribers; a = j ? h : d; if (a[g]) { --a[g] } if (!i.handles[g] && !d[g] && !h[g]) { this.removeDelegatedListener(g) } } else { a = j ? i.directCaptureSubscribers : i.directSubscribers; c = e.id; a = a[g]; if (a[c]) { --a[c] } if (!a[c]) { delete a[c]; i.removeDirectListener(g, e, j) } } }, getPropagatingTargets: function (d) { var c = d, b = [], a; while (c) { b.push(c); a = c.parentNode; if (!a) { a = c.defaultView } c = a } return b }, publish: function (l, h, b) { var o = this, m = false, c = false, r, p, k, a, g, n, d, q; b = b || false; if (!h) { k = l.target; if (o.captureEvents[l.type]) { a = Ext.cache[k.id]; h = a ? [a] : [] } else { h = o.getPropagatingTargets(k) } } r = Ext.Array.from(l); n = h.length; q = r.length; for (g = 0; g < q; g++) { p = r[g].type; if (!m && o.captureSubscribers[p]) { m = true } if (!c && o.bubbleSubscribers[p]) { c = true } } if (m) { for (g = n; g--;) { a = Ext.cache[h[g].id]; if (a) { for (d = 0; d < q; d++) { l = r[d]; o.fire(a, l.type, l, false, true); if (!b && l.claimed) { b = true; d = o.filterClaimed(r, l); q = r.length } if (l.stopped) { r.splice(d, 1); d--; q-- } } } } } if (c && !l.stopped) { for (g = 0; g < n; g++) { a = Ext.cache[h[g].id]; if (a) { for (d = 0; d < q; d++) { l = r[d]; o.fire(a, l.type, l, false, false); if (!b && l.claimed && o.filterClaimed) { b = true; d = o.filterClaimed(r, l); q = r.length } if (l.stopped) { r.splice(d, 1); d--; q-- } } } } } }, publishDelegatedDomEvent: function (a) { this.publish(a) }, fire: function (c, b, g, h, a) { var d; if (c.hasListeners[b]) { d = c.events[b]; if (d) { if (a && h) { d = d.directCaptures } else { if (a) { d = d.captures } else { if (h) { d = d.directs } } } if (d) { g.setCurrentTarget(c.dom); d.fire(g, g.target) } } } }, onDelegatedEvent: function (a) { if (Ext.elevateFunction) { Ext.elevateFunction(this.doDelegatedEvent, this, [a]) } else { this.doDelegatedEvent(a) } }, doDelegatedEvent: function (c) { var b = this, a; c = new Ext.event.Event(c); a = c.time; if (!b.isEventBlocked(c)) { b.beforeEvent(c); Ext.frameStartTime = a; b.reEnterCount++; b.publishDelegatedDomEvent(c); b.reEnterCount--; b.afterEvent(c) } }, onDirectEvent: function (a) { if (Ext.elevateFunction) { Ext.elevateFunction(this.doDirectEvent, this, [a, false]) } else { this.doDirectEvent(a, false) } }, onDirectCaptureEvent: function (a) { if (Ext.elevateFunction) { Ext.elevateFunction(this.doDirectEvent, this, [a, true]) } else { this.doDirectEvent(a, true) } }, doDirectEvent: function (h, b) { var d = this, g = h.currentTarget, a, c; h = new Ext.event.Event(h); a = h.time; if (d.isEventBlocked(h)) { return } d.beforeEvent(h); Ext.frameStartTime = a; c = Ext.cache[g.id]; if (c) { d.reEnterCount++; d.fire(c, h.type, h, true, b); d.reEnterCount-- } d.afterEvent(h) }, beforeEvent: function (c) { var g = c.browserEvent, a = Ext.event.publisher.Dom, b, d; if (g.type === "touchstart") { b = g.touches; if (b.length === 1) { d = b[0]; a.lastTouchStartX = d.pageX; a.lastTouchStartY = d.pageY } } }, afterEvent: function (d) { var g = d.browserEvent, c = g.type, b = Ext.event.publisher.Dom, a = Ext.GlobalEvents; if (d.self.pointerEvents[c] && d.pointerType !== "mouse") { b.lastScreenPointerEventTime = Ext.now() } if (c === "touchend") { b.lastTouchEndTime = Ext.now() } if (!this.reEnterCount && a.hasListeners.idle && !a.idleEventMask[c]) { a.fireEvent("idle") } }, isEventBlocked: function (g) { var d = this, c = g.type, a = Ext.event.publisher.Dom, b = Ext.now(); if (Ext.isGecko && g.type === "click" && g.button === 2) { return true } return (d.blockedPointerEvents[c] && g.pointerType !== "mouse") || (d.blockedCompatibilityMouseEvents[c] && (b - a.lastScreenPointerEventTime < 1000)) || (Ext.supports.TouchEvents && g.self.mouseEvents[g.type] && Math.abs(g.pageX - a.lastTouchStartX) < 15 && Math.abs(g.pageY - a.lastTouchStartY) < 15 && (Ext.now() - a.lastTouchEndTime) < 1000) }, destroy: function () { var b = Ext.dom.GarbageCollector, a; for (a in this.delegatedListeners) { this.removeDelegatedListener(a) } Ext.Reaper.flush(); if (b) { b.collect() } this.callParent() }, reset: function () { var a = Ext.event.publisher.Dom; a.lastScreenPointerEventTime = a.lastTouchEndTime = a.lastTouchStartX = a.lastTouchStartY = undefined } }, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, "Dom"], function (b) { var d = document, c = d.defaultView, a = b.prototype; if ((Ext.os.is.iOS && Ext.os.version.getMajor() < 5) || Ext.browser.is.AndroidStock || !(c && c.addEventListener)) { a.target = d } else { a.target = c } b.instance = new b() })); Ext.define("Ext.overrides.event.publisher.Dom", { override: "Ext.event.publisher.Dom" }, function (g) { if (Ext.isIE9m) { var b = document.documentElement, e = document.body, d = g.prototype, a, c; d.target = document; d.directBoundListeners = {}; a = function (j, i, h) { j.target = j.srcElement || window; j.currentTarget = this; if (h) { i.onDirectCaptureEvent(j) } else { i.onDirectEvent(j) } }; c = function (i, h) { i.target = i.srcElement || window; i.currentTarget = this; h.onDirectCaptureEvent(i) }; g.override({ addDelegatedListener: function (h) { this.delegatedListeners[h] = 1; this.target.attachEvent("on" + h, this.onDelegatedEvent) }, removeDelegatedListener: function (h) { delete this.delegatedListeners[h]; this.target.detachEvent("on" + h, this.onDelegatedEvent) }, addDirectListener: function (k, l, j) { var n = this, o = l.dom, m = Ext.Function.bind(a, o, [n, j], true), h = n.directBoundListeners, i = h[k] || (h[k] = {}); i[o.id] = m; if (o.attachEvent) { o.attachEvent("on" + k, m) } else { n.callParent([k, l, j]) } }, removeDirectListener: function (i, j, h) { var k = j.dom; if (k.detachEvent) { k.detachEvent("on" + i, this.directBoundListeners[i][k.id]) } else { this.callParent([i, j, h]) } }, doDelegatedEvent: function (h) { h.target = h.srcElement || window; if (h.type === "focusin") { h.relatedTarget = h.fromElement === e || h.fromElement === b ? null : h.fromElement } else { if (h.type === "focusout") { h.relatedTarget = h.toElement === e || h.toElement === b ? null : h.toElement } } return this.callParent([h]) } }); Ext.apply(d.directEvents, d.captureEvents); Ext.apply(d.directEvents, { change: 1, input: 1, paste: 1 }); d.captureEvents = {} } }); (Ext.cmd.derive("Ext.event.publisher.Gesture", Ext.event.publisher.Dom, { type: "gesture", isCancelEvent: { touchcancel: 1, pointercancel: 1, MSPointerCancel: 1 }, handledEvents: [], handledDomEvents: [], constructor: function (b) { var g = this, c = g.handledDomEvents, a = Ext.supports, e = a.TouchEvents, h = g.onTouchStart, d = g.onTouchMove, i = g.onTouchEnd; g.handlers = { touchstart: h, touchmove: d, touchend: i, touchcancel: i, pointerdown: h, pointermove: d, pointerup: i, pointercancel: i, MSPointerDown: h, MSPointerMove: d, MSPointerUp: i, MSPointerCancel: i, mousedown: h, mousemove: d, mouseup: i }; g.activeTouchesMap = {}; g.activeTouches = []; g.changedTouches = []; g.recognizers = []; g.eventToRecognizer = {}; g.cancelEvents = []; if (e) { g.onTargetTouchMove = g.onTargetTouchMove.bind(g); g.onTargetTouchEnd = g.onTargetTouchEnd.bind(g) } if (a.PointerEvents) { c.push("pointerdown", "pointermove", "pointerup", "pointercancel"); g.mousePointerType = "mouse" } else { if (a.MSPointerEvents) { c.push("MSPointerDown", "MSPointerMove", "MSPointerUp", "MSPointerCancel"); g.mousePointerType = 4 } else { if (e) { c.push("touchstart", "touchmove", "touchend", "touchcancel") } } } if (!c.length || (e && Ext.isWebKit && Ext.os.is.Desktop)) { c.push("mousedown", "mousemove", "mouseup") } g.initConfig(b); return Ext.event.publisher.Dom.prototype.constructor.call(this) }, onReady: function () { Ext.event.publisher.Dom.prototype.onReady.call(this); Ext.Array.sort(this.recognizers, function (g, e) { var d = g.priority, c = e.priority; return (d > c) ? 1 : (d < c) ? -1 : 0 }) }, registerRecognizer: function (a) { var g = this, c = a.handledEvents, e = c.length, b, d; a.setOnRecognized(g.onRecognized); a.setCallbackScope(g); for (d = 0; d < e; d++) { b = c[d]; g.handledEvents.push(b); g.eventToRecognizer[b] = a } g.registerEvents(c); g.recognizers.push(a) }, onRecognized: function (a, j, m, b, l) { var p = this, h = m.touches, q = m.changedTouches, n = q.length, s = p.events, g = !s.length, o = p.cancelEvents, r, k, d, c; b = b || {}; b.type = j; b.target = q[0].target; b.stopped = false; b.claimed = false; b.isGesture = true; m = m.chain(b); if (!p.gestureTargets) { if (n > 1) { r = []; for (d = 0; d < n; d++) { c = q[d]; r.push(c.targets) } k = p.getCommonTargets(r) } else { k = q[0].targets } p.gestureTargets = k } if (l && a.isSingleTouch && (h.length > 1)) { m.target = h[0].target; o.push(m) } else { s.push(m) } if (g) { p.publishGestures() } }, getCommonTargets: function (a) { var k = a[0], g = a.length; if (g === 1) { return k } var d = [], e = 1, h, b, c; while (true) { h = k[k.length - e]; if (!h) { return d } for (c = 1; c < g; c++) { b = a[c]; if (b[b.length - e] !== h) { return d } } d.unshift(h); e++ } return d }, invokeRecognizers: function (c, h) { var b = this.recognizers, g = b.length, d, a; if (c === "onStart") { for (d = 0; d < g; d++) { b[d].isActive = true } } for (d = 0; d < g; d++) { a = b[d]; if (a.isActive && a[c].call(a, h) === false) { a.isActive = false } } }, filterClaimed: function (k, c) { var h = this, d = h.eventToRecognizer, j = c.type, a = d[j], l, b, g, e; for (e = k.length; e--;) { g = k[e].type; if (g === j) { l = e } else { b = d[g]; if (!a || (b && (b !== a))) { k.splice(e, 1); if (l) { l-- } } } } h.claimRecognizer(a, k[0]); return l }, claimRecognizer: function (a, j) { var h = this, c = h.recognizers, d, g, b; for (d = 0, g = c.length; d < g; d++) { b = c[d]; if (b !== a) { b.isActive = false; b.cancel(j) } } if (h.events.length) { h.publishGestures(true) } }, publishGestures: function (d) { var c = this, e = c.cancelEvents, a = c.events, b = c.gestureTargets; if (e.length) { c.cancelEvents = []; c.publish(e, c.getPropagatingTargets(e[0].target), true) } if (a.length) { c.events = []; c.gestureTargets = null; c.publish(a, b || c.getPropagatingTargets(a[0].target), d) } }, updateTouches: function (k, b) { var o = this, s = k.browserEvent, g = s.changedTouches || [s], a = o.activeTouches, l = o.activeTouchesMap, q = [], n, j, d, h, c, m, r, p; for (c = 0, m = g.length; c < m; c++) { n = g[c]; if ("identifier" in n) { j = n.identifier } else { if ("pointerId" in n) { j = n.pointerId } else { j = 1 } } d = l[j]; if (!d) { h = Ext.event.Event.resolveTextNode(n.target); d = l[j] = { identifier: j, target: h, targets: o.getPropagatingTargets(h) }; a.push(d) } if (b) { delete l[j]; Ext.Array.remove(a, d) } r = n.pageX; p = n.pageY; d.pageX = r; d.pageY = p; d.point = new Ext.util.Point(r, p); q.push(d) } k.touches = Ext.Array.clone(a); k.changedTouches = q }, publishDelegatedDomEvent: function (b) { var a = this; if (!b.button || b.button < 1) { a.events = [b]; a.handlers[b.type].call(a, b) } else { Ext.event.publisher.Dom.prototype.publishDelegatedDomEvent.call(this, b) } }, onTouchStart: function (d) { var a = this, c = d.target, b = d.browserEvent.touches; if (d.browserEvent.type === "touchstart") { c.addEventListener("touchmove", a.onTargetTouchMove); c.addEventListener("touchend", a.onTargetTouchEnd); c.addEventListener("touchcancel", a.onTargetTouchEnd) } if (b && b.length <= a.activeTouches.length) { a.removeGhostTouches(b) } a.updateTouches(d); if (!a.isStarted) { if (Ext.enableGarbageCollector) { Ext.dom.GarbageCollector.pause() } a.isStarted = true; a.invokeRecognizers("onStart", d) } a.invokeRecognizers("onTouchStart", d); a.publishGestures() }, onTouchMove: function (c) { var b = this, a = b.mousePointerType; if (b.isStarted) { if (a && c.browserEvent.pointerType === a && c.buttons === 0) { c.type = Ext.dom.Element.prototype.eventMap.touchend; c.button = 0; b.onTouchEnd(c); return } b.updateTouches(c); if (c.changedTouches.length > 0) { b.invokeRecognizers("onTouchMove", c) } } b.publishGestures() }, onTouchEnd: function (c) { var b = this, a; if (!b.isStarted) { b.publishGestures(); return } b.updateTouches(c, true); a = b.activeTouches.length; try { b.invokeRecognizers(b.isCancelEvent[c.type] ? "onTouchCancel" : "onTouchEnd", c) } finally { if (!a) { b.isStarted = false; b.invokeRecognizers("onEnd", c) } b.publishGestures(); if (!a) { if (Ext.enableGarbageCollector) { Ext.dom.GarbageCollector.resume() } } } }, onTargetTouchMove: function (a) { if (Ext.elevateFunction) { Ext.elevateFunction(this.doTargetTouchMove, this, [a]) } else { this.doTargetTouchMove(a) } }, doTargetTouchMove: function (a) { if (!Ext.getBody().contains(a.target)) { this.onTouchMove(new Ext.event.Event(a)) } }, onTargetTouchEnd: function (a) { if (Ext.elevateFunction) { Ext.elevateFunction(this.doTargetTouchEnd, this, [a]) } else { this.doTargetTouchEnd(a) } }, doTargetTouchEnd: function (c) { var a = this, b = c.target; b.removeEventListener("touchmove", a.onTargetTouchMove); b.removeEventListener("touchend", a.onTargetTouchEnd); b.removeEventListener("touchcancel", a.onTargetTouchEnd); if (!Ext.getBody().contains(b)) { a.onTouchEnd(new Ext.event.Event(c)) } }, reset: function () { var e = this, b = e.recognizers, d = b.length, c, a; e.activeTouchesMap = {}; e.activeTouches = []; e.changedTouches = []; e.isStarted = false; e.gestureTargets = null; e.events = []; e.cancelEvents = []; for (c = 0; c < d; c++) { a = b[c]; a.reset(); a.isActive = false } Ext.event.publisher.Dom.prototype.reset.call(this) }, privates: { removeGhostTouches: function (e) { var c = {}, a = e.length, j = this.activeTouches, d = this.activeTouchesMap, b, h, g; for (b = 0; b < a; ++b) { c[e[b].identifier] = true } b = j.length; while (b--) { g = j[b]; h = g.identifier; if (!e[h]) { Ext.Array.remove(j, g); delete d[h] } } } } }, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, "Gesture"], function (a) { a.instance = Ext.$gesturePublisher = new a() })); Ext.define("Ext.overrides.event.publisher.Gesture", { override: "Ext.event.publisher.Gesture" }, function () { if (Ext.isIE9m) { this.override({ updateTouches: function (c, a) { var d = c.browserEvent, b = c.getXY(); d.pageX = b[0]; d.pageY = b[1]; this.callParent([c, a]) }, doDelegatedEvent: function (a) { this.callParent([Ext.event.Event.enableIEAsync(a)]) } }) } }); (Ext.cmd.derive("Ext.mixin.Templatable", Ext.Mixin, { mixinConfig: { id: "templatable" }, referenceAttributeName: "reference", referenceSelector: "[reference]", getElementConfig: function () { return { reference: "element" } }, getElementTemplate: function () { var a = document.createDocumentFragment(); a.appendChild(Ext.Element.create(this.getElementConfig(), true)); return a }, initElement: function () { var a = this.self.prototype; a.elementTemplate = this.getElementTemplate(); a.initElement = a.doInitElement; this.initElement.apply(this, arguments) }, linkElement: function (a, b) { this.link(a, b) }, doInitElement: function () { var h = this.referenceAttributeName, c, d, e, g, b, a; c = this.elementTemplate.cloneNode(true); d = c.querySelectorAll(this.referenceSelector); for (e = 0, g = d.length; e < g; e++) { b = d[e]; a = b.getAttribute(h); b.removeAttribute(h); this.linkElement(a, b) } } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "Templatable"], 0)); (Ext.cmd.derive("Ext.TaskQueue", Ext.Base, { singleton: true, pending: false, mode: true, constructor: function () { this.readQueue = []; this.writeQueue = []; this.run = Ext.Function.bind(this.run, this); if (Ext.os.is.iOS) { Ext.interval(this.watch, 500, this) } }, requestRead: function (c, b, a) { this.request(true); this.readQueue.push(arguments) }, requestWrite: function (c, b, a) { this.request(false); this.writeQueue.push(arguments) }, request: function (a) { if (!this.pending) { this.pendingTime = Date.now(); this.pending = true; this.mode = a; if (a) { Ext.defer(this.run, 1, this) } else { Ext.Function.requestAnimationFrame(this.run) } } }, watch: function () { if (this.pending && Date.now() - this.pendingTime >= 500) { this.run() } }, run: function () { this.pending = false; var k = this.readQueue, e = this.writeQueue, c = null, g; if (this.mode) { g = k; if (e.length > 0) { c = false } } else { g = e; if (k.length > 0) { c = true } } var b = g.slice(), d, h, a, j, l; g.length = 0; for (d = 0, h = b.length; d < h; d++) { a = b[d]; j = a[0]; l = a[1]; if (l && (l.destroying || l.destroyed)) { continue } if (typeof j === "string") { j = l[j] } if (a.length > 2) { j.apply(l, a[2]) } else { j.call(l) } } b.length = 0; if (c !== null) { this.request(c) } } }, 1, 0, 0, 0, 0, 0, [Ext, "TaskQueue"], 0)); (Ext.cmd.derive("Ext.util.sizemonitor.Abstract", Ext.Base, { config: { element: null, callback: Ext.emptyFn, scope: null, args: [] }, width: null, height: null, contentWidth: null, contentHeight: null, constructor: function (a) { this.refresh = Ext.Function.bind(this.refresh, this); this.info = { width: 0, height: 0, contentWidth: 0, contentHeight: 0, flag: 0 }; this.initElement(); this.initConfig(a); this.bindListeners(true) }, bindListeners: Ext.emptyFn, applyElement: function (a) { if (a) { return Ext.get(a) } }, updateElement: function (a) { a.append(this.detectorsContainer); a.addCls("x-size-monitored") }, applyArgs: function (a) { return a.concat([this.info]) }, refreshMonitors: Ext.emptyFn, forceRefresh: function () { Ext.TaskQueue.requestRead("refresh", this) }, getContentBounds: function () { return this.detectorsContainer.getBoundingClientRect() }, getContentWidth: function () { return this.detectorsContainer.clientWidth }, getContentHeight: function () { return this.detectorsContainer.clientHeight }, refreshSize: function () { var d = this.getElement(); if (!d || d.destroyed) { return false } var b = d.getWidth(), k = d.getHeight(), a = this.getContentWidth(), j = this.getContentHeight(), i = this.contentWidth, g = this.contentHeight, c = this.info, e = false, h = 0; this.width = b; this.height = k; this.contentWidth = a; this.contentHeight = j; h = ((i !== a ? 1 : 0) + (g !== j ? 2 : 0)); if (h > 0) { c.width = b; c.height = k; c.contentWidth = a; c.contentHeight = j; c.flag = h; e = true; this.getCallback().apply(this.getScope(), this.getArgs()) } return e }, refresh: function (a) { if (this.destroying || this.destroyed) { return } if (this.refreshSize() || a) { Ext.TaskQueue.requestWrite("refreshMonitors", this) } }, destroy: function () { var b = this, a = b.getElement(); b.bindListeners(false); if (a && !a.destroyed) { a.removeCls("x-size-monitored") } delete b._element; b.refresh = null; b.callParent() } }, 1, 0, 0, 0, 0, [[Ext.mixin.Templatable.prototype.mixinId || Ext.mixin.Templatable.$className, Ext.mixin.Templatable]], [Ext.util.sizemonitor, "Abstract"], 0)); (Ext.cmd.derive("Ext.util.sizemonitor.Scroll", Ext.util.sizemonitor.Abstract, { getElementConfig: function () { return { reference: "detectorsContainer", classList: ["x-size-monitors", "scroll"], children: [{ reference: "expandMonitor", className: "expand" }, { reference: "shrinkMonitor", className: "shrink" }] } }, constructor: function (a) { this.onScroll = Ext.Function.bind(this.onScroll, this); Ext.util.sizemonitor.Abstract.prototype.constructor.apply(this, arguments) }, bindListeners: function (b) { var a = b ? "addEventListener" : "removeEventListener"; this.expandMonitor[a]("scroll", this.onScroll, true); this.shrinkMonitor[a]("scroll", this.onScroll, true) }, forceRefresh: function () { Ext.TaskQueue.requestRead("refresh", this, [true]) }, onScroll: function () { Ext.TaskQueue.requestRead("refresh", this) }, refreshMonitors: function () { var b = this.expandMonitor, c = this.shrinkMonitor, a = 1000000; if (b && !b.destroyed) { b.scrollLeft = a; b.scrollTop = a } if (c && !c.destroyed) { c.scrollLeft = a; c.scrollTop = a } }, destroy: function () { this.onScroll = null; Ext.util.sizemonitor.Abstract.prototype.destroy.call(this) } }, 1, 0, 0, 0, 0, 0, [Ext.util.sizemonitor, "Scroll"], 0)); (Ext.cmd.derive("Ext.util.sizemonitor.OverflowChange", Ext.util.sizemonitor.Abstract, { constructor: function (a) { this.onExpand = Ext.Function.bind(this.onExpand, this); this.onShrink = Ext.Function.bind(this.onShrink, this); Ext.util.sizemonitor.Abstract.prototype.constructor.apply(this, arguments) }, getElementConfig: function () { return { reference: "detectorsContainer", classList: ["x-size-monitors", "overflowchanged"], children: [{ reference: "expandMonitor", className: "expand", children: [{ reference: "expandHelper" }] }, { reference: "shrinkMonitor", className: "shrink", children: [{ reference: "shrinkHelper" }] }] } }, bindListeners: function (b) { var a = b ? "addEventListener" : "removeEventListener"; this.expandMonitor[a](Ext.browser.is.Firefox ? "underflow" : "overflowchanged", this.onExpand, true); this.shrinkMonitor[a](Ext.browser.is.Firefox ? "overflow" : "overflowchanged", this.onShrink, true) }, onExpand: function (a) { if (Ext.browser.is.Webkit && a.horizontalOverflow && a.verticalOverflow) { return } Ext.TaskQueue.requestRead("refresh", this) }, onShrink: function (a) { if (Ext.browser.is.Webkit && !a.horizontalOverflow && !a.verticalOverflow) { return } Ext.TaskQueue.requestRead("refresh", this) }, refreshMonitors: function () { if (this.destroying || this.destroyed) { return } var g = this.expandHelper, e = this.shrinkHelper, b = this.getContentBounds(), d = b.width, a = b.height, c; if (g && !g.destroyed) { c = g.style; c.width = (d + 1) + "px"; c.height = (a + 1) + "px" } if (e && !e.destroyed) { c = e.style; c.width = d + "px"; c.height = a + "px" } Ext.TaskQueue.requestRead("refresh", this) }, destroy: function () { this.onExpand = this.onShrink = null; Ext.util.sizemonitor.Abstract.prototype.destroy.call(this) } }, 1, 0, 0, 0, 0, 0, [Ext.util.sizemonitor, "OverflowChange"], 0)); (Ext.cmd.derive("Ext.util.SizeMonitor", Ext.Base, { constructor: function (a) { var b = Ext.util.sizemonitor; if (Ext.browser.is.Firefox) { return new b.OverflowChange(a) } else { return new b.Scroll(a) } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "SizeMonitor"], 0)); (Ext.cmd.derive("Ext.event.publisher.ElementSize", Ext.event.publisher.Publisher, { type: "size", handledEvents: ["resize"], constructor: function () { this.monitors = {}; this.subscribers = {}; Ext.event.publisher.Publisher.prototype.constructor.apply(this, arguments) }, subscribe: function (b) { var d = b.id, c = this.subscribers, a = this.monitors; if (c[d]) { ++c[d] } else { c[d] = 1; a[d] = new Ext.util.SizeMonitor({ element: b, callback: this.onElementResize, scope: this, args: [b] }) } b.on("painted", "forceRefresh", a[d]); return true }, unsubscribe: function (c) { var e = c.id, d = this.subscribers, b = this.monitors, a; if (d[e] && !--d[e]) { delete d[e]; a = b[e]; c.un("painted", "forceRefresh", a); a.destroy(); delete b[e] } }, onElementResize: function (a, b) { Ext.TaskQueue.requestRead("fire", this, [a, "resize", [a, b]]) } }, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, "ElementSize"], function (a) { a.instance = new a() })); (Ext.cmd.derive("Ext.util.paintmonitor.Abstract", Ext.Base, { config: { element: null, callback: Ext.emptyFn, scope: null, args: [] }, eventName: "", monitorClass: "", constructor: function (a) { this.onElementPainted = Ext.Function.bind(this.onElementPainted, this); this.initConfig(a) }, bindListeners: function (a) { this.monitorElement[a ? "addEventListener" : "removeEventListener"](this.eventName, this.onElementPainted, true) }, applyElement: function (a) { if (a) { return Ext.get(a) } }, updateElement: function (a) { this.monitorElement = Ext.Element.create({ classList: ["x-paint-monitor", this.monitorClass] }, true); a.appendChild(this.monitorElement); a.addCls("x-paint-monitored"); this.bindListeners(true) }, onElementPainted: function () { }, destroy: function () { var d = this, b = d.monitorElement, a = b.parentNode, c = d.getElement(); d.bindListeners(false); delete d.monitorElement; if (c && !c.destroyed) { c.removeCls("x-paint-monitored"); delete d._element } if (a) { a.removeChild(b) } d.callParent() } }, 1, 0, 0, 0, 0, 0, [Ext.util.paintmonitor, "Abstract"], 0)); (Ext.cmd.derive("Ext.util.paintmonitor.CssAnimation", Ext.util.paintmonitor.Abstract, { eventName: Ext.browser.is.WebKit ? "webkitAnimationEnd" : "animationend", monitorClass: "cssanimation", onElementPainted: function (a) { if (a.animationName === "x-paint-monitor-helper") { this.getCallback().apply(this.getScope(), this.getArgs()) } } }, 0, 0, 0, 0, 0, 0, [Ext.util.paintmonitor, "CssAnimation"], 0)); (Ext.cmd.derive("Ext.util.PaintMonitor", Ext.Base, { constructor: function (a) { return new Ext.util.paintmonitor.CssAnimation(a) } }, 1, 0, 0, 0, 0, 0, [Ext.util, "PaintMonitor"], 0)); (Ext.cmd.derive("Ext.event.publisher.ElementPaint", Ext.event.publisher.Publisher, { type: "paint", handledEvents: ["painted"], constructor: function () { this.monitors = {}; this.subscribers = {}; Ext.event.publisher.Publisher.prototype.constructor.apply(this, arguments) }, subscribe: function (a) { var b = this, d = a.id, c = b.subscribers; if (c[d]) { ++c[d] } else { c[d] = 1; b.monitors[d] = new Ext.util.PaintMonitor({ element: a, callback: b.onElementPainted, scope: b, args: [a] }) } }, unsubscribe: function (b) { var d = b.id, c = this.subscribers, a = this.monitors; if (c[d] && !--c[d]) { delete c[d]; a[d].destroy(); delete a[d] } }, onElementPainted: function (a) { Ext.TaskQueue.requestRead("fire", this, [a, "painted", [a]]) } }, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, "ElementPaint"], function (a) { a.instance = new a() })); (Ext.cmd.derive("Ext.dom.Element", Ext.Base, function (s) { var x = window, V = document, g = V.documentElement, X = x.top, W, aj, P, l = "width", T = "height", ag = "min-width", h = "min-height", t = "max-width", G = "max-height", X = "top", ak = "right", Q = "bottom", K = "left", n = "visibility", ah = "hidden", d = "display", Z = "none", q = "z-index", ab = "position", v = "relative", w = "static", C = "-", A = /\w/g, O = /\s+/, ai = /[\s]+/, b = /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i, M = /table-row|table-.*-group/, c = /top/i, z = { t: "border-top-width", r: "border-right-width", b: "border-bottom-width", l: "border-left-width" }, af = { t: "padding-top", r: "padding-right", b: "padding-bottom", l: "padding-left" }, p = { t: "margin-top", r: "margin-right", b: "margin-bottom", l: "margin-left" }, J = [af.l, af.r, af.t, af.b], j = [z.l, z.r, z.t, z.b], ad = /\d+$/, m = /\d+(px|em|%|en|ex|pt|in|cm|mm|pc)$/i, U = "px", S = /(-[a-z])/gi, am = /([a-z0-9\-]+)\s*:\s*([^;\s]+(?:\s*[^;\s]+)*);?/gi, u = /^\d+(?:\.\d*)?px$/i, B = {}, y = "originalDisplay", aa = function (e, an) { return an.charAt(1).toUpperCase() }, N = function (ap, an) { var aq, ao, e; if (ap.nodeType === 1) { ap._extData = null; if (an) { aq = ap.childNodes; for (ao = 0, e = aq.length; ao < e; ++ao) { N(aq[ao], an) } } } }, H = "x-hidden-visibility", F = "x-hidden-display", o = "x-hidden-offsets", a = "x-hidden-clip", E = "x-sized", R = "x-unsized", L = "x-stretched", r = { style: "style", className: "className", cls: "cls", classList: "classList", text: "text", hidden: "hidden", html: "html", children: "children" }, Y = 0, ae = 0, D = false, i = false, ac, I, k; try { W = X.__elementIdCounter__ } catch (al) { X = x } X.__elementIdCounter = W = (X.__elementIdCounter__ || 0) + 1; aj = "ext-window-" + W; P = "ext-document-" + W; return { alternateClassName: ["Ext.Element"], observableType: "element", isElement: true, skipGarbageCollection: true, $applyConfigs: true, identifiablePrefix: "ext-element-", styleHooks: {}, validIdRe: Ext.validIdRe, blockedEvents: Ext.supports.EmulatedMouseOver ? { mouseover: 1 } : {}, longpressEvents: { longpress: 1, taphold: 1 }, constructor: function (an) { var e = this, ao; if (typeof an === "string") { an = V.getElementById(an) } if (!an) { return null } e.dom = an; ao = an.id; if (ao) { e.id = ao } else { ao = an.id = e.getUniqueId() } e.el = e; Ext.cache[ao] = e; e.longpressListenerCount = 0; e.mixins.observable.constructor.call(e) }, inheritableStatics: { cache: Ext.cache = {}, editableSelector: 'input,textarea,[contenteditable="true"]', VISIBILITY: 1, DISPLAY: 2, OFFSETS: 3, CLIP: 4, minKeyboardHeight: 100, unitRe: m, useDelegatedEvents: true, validNodeTypes: { 1: 1, 9: 1 }, addUnits: function (an, e) { if (typeof an === "number") { return an + (e || U) } if (an === "" || an === "auto" || an == null) { return an || "" } if (ad.test(an)) { return an + (e || U) } if (!m.test(an)) { return an || "" } return an }, create: function (ap, ao) { var av = this, an, at, aw, ay, ax, e, ar, au, aq; ap = ap || {}; if (ap.isElement) { return ao ? ap.dom : ap } else { if ("nodeType" in ap) { return ao ? ap : Ext.get(ap) } } if (typeof ap === "string") { return V.createTextNode(ap) } ay = ap.tag; if (!ay) { ay = "div" } if (ap.namespace) { at = V.createElementNS(ap.namespace, ay) } else { at = V.createElement(ay) } aw = at.style; for (e in ap) { if (e !== "tag") { ax = ap[e]; switch (e) { case r.style: if (typeof ax === "string") { at.setAttribute(e, ax) } else { for (ar in ax) { if (ax.hasOwnProperty(ar)) { aw[ar] = ax[ar] } } } break; case r.className: case r.cls: aq = ax.split(O); an = an ? an.concat(aq) : aq; break; case r.classList: an = an ? an.concat(ax) : ax; break; case r.text: at.textContent = ax; break; case r.html: at.innerHTML = ax; break; case r.hidden: if (an) { an.push(F) } else { an = [F] } break; case r.children: if (ax != null) { for (ar = 0, au = ax.length; ar < au; ar++) { at.appendChild(av.create(ax[ar], true)) } } break; default: if (ax != null) { at.setAttribute(e, ax) } } } } if (an) { at.className = an.join(" ") } if (ao) { return at } else { return av.get(at) } }, detach: function () { var e = this.dom; if (e && e.parentNode && e.tagName !== "BODY") { e.parentNode.removeChild(e) } return this }, fly: function (an, e) { return Ext.fly(an, e) }, fromPoint: (function () { var ao; if (Ext.isIE) { try { ao = window.self !== window.top } catch (an) { ao = true } } return function (ap, ar, e) { var aq = null; aq = V.elementFromPoint(ap, ar); if (!aq && ao) { aq = V.elementFromPoint(ap, ar) } return e ? aq : Ext.get(aq) } })(), fromPagePoint: function (ao, ap, an) { var e = Ext.getDoc().getScroll(); return s.fromPoint(ao - e.left, ap - e.top, an) }, get: function (ao) { var at = this, e = Ext.cache, aq, ap, an, aw, av, ar, au; if (!ao) { return null } if (ao.isFly) { ao = ao.dom } if (typeof ao === "string") { an = ao; if (e.hasOwnProperty(an)) { aw = e[an]; if (aw.skipGarbageCollection || !Ext.isGarbage(aw.dom)) { return aw } else { aw.destroy() } } if (an === aj) { return s.get(x) } else { if (an === P) { return s.get(V) } } ap = Ext.getElementById ? Ext.getElementById(an) : V.getElementById(an); if (ap) { return new s(ap) } } aq = ao.nodeType; if (aq) { av = (aq === 9); au = at.validNodeTypes[aq] } else { ar = (ao.window == ao) } if (au || ar) { an = ao.id; if (e.hasOwnProperty(an)) { aw = e[an]; if (aw.skipGarbageCollection || ao === aw.dom || !Ext.isGarbage(aw.dom)) { return aw } else { aw.destroy() } } if (ao === V) { ao.id = P } if (ao == x) { ao.id = aj } ao = new s(ao); if (ar || av) { ao.skipGarbageCollection = true } return ao } if (ao.isElement) { return ao } if (ao.isComposite) { return ao } if (Ext.isIterable(ao)) { return at.select(ao) } return null }, getActiveElement: function (e) { var an = V.activeElement; if (!an || !an.focus) { an = V.body } return e ? Ext.get(an) : an }, getDocumentHeight: function () { return Math.max(!Ext.isStrict ? V.body.scrollHeight : g.scrollHeight, this.getViewportHeight()) }, getDocumentWidth: function () { return Math.max(!Ext.isStrict ? V.body.scrollWidth : g.scrollWidth, this.getViewportWidth()) }, getOrientation: function () { if (Ext.supports.OrientationChange) { return (x.orientation == 0) ? "portrait" : "landscape" } return (x.innerHeight > x.innerWidth) ? "portrait" : "landscape" }, getViewportHeight: function () { var e = s._viewportHeight; if (Ext.isIE9m) { return V.documentElement.clientHeight } return (e != null) ? e : g.clientHeight }, getViewportWidth: function () { var e = s._viewportWidth; if (Ext.isIE9m) { return V.documentElement.clientWidth } return (e != null) ? e : g.clientWidth }, getViewportScale: function () { var e = x.top; return ((Ext.isiOS || Ext.isAndroid) ? 1 : (e.devicePixelRatio || e.screen.deviceXDPI / e.screen.logicalXDPI)) * this.getViewportTouchScale() }, getViewportTouchScale: function (ao) { var aq = 1, e = "hidden", an = x.top, ap; if (!ao) { ap = this._viewportTouchScale; if (ap) { return ap } } if (Ext.isIE10p || Ext.isEdge || Ext.isiOS) { aq = g.offsetWidth / x.innerWidth } else { if (Ext.isChromeMobile) { aq = an.outerWidth / an.innerWidth } } return aq }, getViewSize: function () { return { width: s.getViewportWidth(), height: s.getViewportHeight() } }, maskIframes: function () { var e = document.getElementsByTagName("iframe"); Ext.each(e, function (ao) { var an; an = Ext.fly(ao.parentNode).mask(); an.setStyle("background-color", "transparent") }) }, normalize: function (e) { return B[e] || (B[e] = e.replace(S, aa)) }, _onWindowFocusChange: function (an) { if (Ext.fly(an.target).is(s.editableSelector)) { Y = new Date(); D = (an.type === "focusin" || an.type === "pointerup") } }, _onWindowResize: function () { var ao = g.clientWidth, ar = g.clientHeight, aq = new Date(), an = 1000, ap, e; ap = ao - s._documentWidth; e = ar - s._documentHeight; s._windowWidth = ao; s._windowHeight = ar; if (((aq - Y) < an) || ((aq - ae) < an)) { if (ap === 0 && (D && (e <= -s.minKeyboardHeight))) { i = true; return } } if (i && (ap === 0) && (e >= s.minKeyboardHeight)) { i = false; ae = new Date() } if (i) { return } s._viewportWidth = ao; s._viewportHeight = ar }, parseBox: function (ao) { ao = ao || 0; var e = typeof ao, ap, an; if (e === "number") { return { top: ao, right: ao, bottom: ao, left: ao } } else { if (e !== "string") { return ao } } ap = ao.split(" "); an = ap.length; if (an === 1) { ap[1] = ap[2] = ap[3] = ap[0] } else { if (an === 2) { ap[2] = ap[0]; ap[3] = ap[1] } else { if (an === 3) { ap[3] = ap[1] } } } return { top: parseFloat(ap[0]) || 0, right: parseFloat(ap[1]) || 0, bottom: parseFloat(ap[2]) || 0, left: parseFloat(ap[3]) || 0 } }, parseStyles: function (an) { var e = {}, ao; if (an) { am.lastIndex = 0; while ((ao = am.exec(an))) { e[ao[1]] = ao[2] || "" } } return e }, select: function (e, ao, an) { return Ext.fly(an || V).select(e, ao) }, query: function (an, e, ao) { return Ext.fly(ao || V).query(an, e) }, unitizeBox: function (ao, e) { var an = this; ao = an.parseBox(ao); return an.addUnits(ao.top, e) + " " + an.addUnits(ao.right, e) + " " + an.addUnits(ao.bottom, e) + " " + an.addUnits(ao.left, e) }, unmaskIframes: function () { var e = document.getElementsByTagName("iframe"); Ext.each(e, function (an) { Ext.fly(an.parentNode).unmask() }) }, serializeForm: function (ap) { var aq = ap.elements || (V.forms[ap] || Ext.getDom(ap)).elements, aA = false, az = encodeURIComponent, au = "", at = aq.length, av, an, ay, aC, aB, aw, ar, ax, ao; for (aw = 0; aw < at; aw++) { av = aq[aw]; an = av.name; ay = av.type; aC = av.options; if (!av.disabled && an) { if (/select-(one|multiple)/i.test(ay)) { ax = aC.length; for (ar = 0; ar < ax; ar++) { ao = aC[ar]; if (ao.selected) { aB = ao.hasAttribute("value"); au += Ext.String.format("{0}={1}&", az(an), az(aB ? ao.value : ao.text)) } } } else { if (!(/file|undefined|reset|button/i.test(ay))) { if (!(/radio|checkbox/i.test(ay) && !av.checked) && !(ay == "submit" && aA)) { au += az(an) + "=" + az(av.value) + "&"; aA = /submit/i.test(ay) } } } } } return au.substr(0, au.length - 1) }, getCommonAncestor: function (ao, an, e) { k = k || new Ext.dom.Fly(); k.attach(Ext.getDom(ao)); while (!k.isAncestor(an)) { if (k.dom.parentNode) { k.attach(k.dom.parentNode) } else { k.attach(V.body); break } } return e ? k.dom : Ext.get(k) } }, addCls: function (av, at, ax) { var aw = this, ap = aw.getData(), ay, aq, an, ao, ar, au, e; if (!av) { return aw } if (!ap.isSynchronized) { aw.synchronize() } aq = aw.dom; an = ap.classMap; ao = ap.classList; at = at ? at + C : ""; ax = ax ? C + ax : ""; if (typeof av === "string") { av = av.split(O) } for (ar = 0, au = av.length; ar < au; ar++) { e = av[ar]; if (e) { e = at + e + ax; if (!an[e]) { an[e] = true; ao.push(e); ay = true } } } if (ay) { aq.className = ao.join(" ") } return aw }, addClsOnClick: function (ao, ar, an) { var ap = this, aq = ap.dom, e = Ext.isFunction(ar); ap.on("mousedown", function () { if (e && ar.call(an || ap, ap) === false) { return false } Ext.fly(aq).addCls(ao); var au = Ext.getDoc(), at = function () { Ext.fly(aq).removeCls(ao); au.removeListener("mouseup", at) }; au.on("mouseup", at) }); return ap }, addClsOnFocus: function (ao, ar, an) { var ap = this, aq = ap.dom, e = Ext.isFunction(ar); ap.on("focus", function () { if (e && ar.call(an || ap, ap) === false) { return false } Ext.fly(aq).addCls(ao) }); ap.on("blur", function () { Ext.fly(aq).removeCls(ao) }); return ap }, addClsOnOver: function (ao, ar, an) { var ap = this, aq = ap.dom, e = Ext.isFunction(ar); ap.hover(function () { if (e && ar.call(an || ap, ap) === false) { return } Ext.fly(aq).addCls(ao) }, function () { Ext.fly(aq).removeCls(ao) }); return ap }, addStyles: function (au, at) { var ao = 0, ar = (au || "").match(A), aq, e = ar.length, ap, an = []; if (e === 1) { ao = Math.abs(parseFloat(this.getStyle(at[ar[0]])) || 0) } else { if (e) { for (aq = 0; aq < e; aq++) { ap = ar[aq]; an.push(at[ap]) } an = this.getStyle(an); for (aq = 0; aq < e; aq++) { ap = ar[aq]; ao += parseFloat(an[at[ap]]) || 0 } } } return ao }, addUnits: function (an, e) { return s.addUnits(an, e) }, adjustDirect2DDimension: function (ao) { var au = this, an = au.dom, ar = au.getStyle("display"), aq = an.style.display, av = an.style.position, at = ao === l ? 0 : 1, e = an.currentStyle, ap; if (ar === "inline") { an.style.display = "inline-block" } an.style.position = ar.match(M) ? "absolute" : "static"; ap = (parseFloat(e[ao]) || parseFloat(e.msTransformOrigin.split(" ")[at]) * 2) % 1; an.style.position = av; if (ar === "inline") { an.style.display = aq } return ap }, animate: function (e) { e = new Ext.fx.Animation(e); e.setElement(this); this._activeAnimation = e; e.on({ animationend: this._onAnimationEnd, scope: this }); Ext.Animator.run(e); return e }, _onAnimationEnd: function () { this._activeAnimation = null }, getActiveAnimation: function () { return this._activeAnimation }, append: function () { this.appendChild.apply(this, arguments) }, appendChild: function (ap, ao) { var aq = this, at, an, ar; if (ap.nodeType || ap.dom || typeof ap === "string") { ap = Ext.getDom(ap); aq.dom.appendChild(ap); return !ao ? Ext.get(ap) : ap } else { if (ap.length) { at = Ext.fly(V.createDocumentFragment()); an = ap.length; for (ar = 0; ar < an; ar++) { at.appendChild(ap[ar], ao) } ap = Ext.Array.toArray(at.dom.childNodes); aq.dom.appendChild(at.dom); return ao ? ap : new Ext.dom.CompositeElementLite(ap) } else { return aq.createChild(ap, null, ao) } } }, appendTo: function (e) { Ext.getDom(e).appendChild(this.dom); return this }, applyStyles: function (e) { if (e) { if (typeof e === "function") { e = e.call() } if (typeof e === "string") { e = s.parseStyles(e) } if (typeof e === "object") { this.setStyle(e) } } return this }, blur: function () { var an = this, ap = an.dom; if (ap !== V.body) { try { ap.blur() } catch (ao) { } return an } else { return an.focus(undefined, ap) } }, cacheScrollValues: function () { var aq = this, ar = [], ap = [], at, ao, an, e; I = I || new Ext.dom.Fly(); at = aq.query("*"); for (an = 0, e = at.length; an < e; an++) { ao = at[an]; if (ao.scrollTop > 0 || ao.scrollLeft !== 0) { ap.push(ao); ar.push(I.attach(ao).getScroll()) } } return function () { var av, aw, au; for (aw = 0, au = ap.length; aw < au; aw++) { av = ar[aw]; I.attach(ap[aw]); I.setScrollLeft(av.left); I.setScrollTop(av.top) } } }, center: function (e) { return this.alignTo(e || V, "c-c") }, child: function (e, an) { var ao = this, ap = Ext.get(ao).id; return ao.selectNode(Ext.makeIdSelector(ap) + " > " + e, !!an) }, clone: function (e, an) { var ao = this.dom.cloneNode(e); if (Ext.supports.CloneNodeCopiesExpando) { N(ao, e) } return an ? ao : Ext.get(ao) }, constrainScrollLeft: function (e) { var an = this.dom; return Math.max(Math.min(e, an.scrollWidth - an.clientWidth), 0) }, constrainScrollTop: function (e) { var an = this.dom; return Math.max(Math.min(e, an.scrollHeight - an.clientHeight), 0) }, createChild: function (an, e, ao) { an = an || { tag: "div" }; if (e) { return Ext.DomHelper.insertBefore(e, an, ao !== true) } else { return Ext.DomHelper.append(this.dom, an, ao !== true) } }, contains: function (e) { if (!e) { return false } var an = this, ao = Ext.getDom(e); return (ao === an.dom) || an.isAncestor(ao) }, destroy: function () { var e = this, an = e.dom; if (an && an.parentNode) { an.parentNode.removeChild(an) } e.collect() }, detach: function () { var e = this.dom; if (e && e.parentNode && e.tagName !== "BODY") { e.parentNode.removeChild(e) } return this }, disableShadow: function () { var e = this.shadow; if (e) { e.hide(); e.disabled = true } }, disableShim: function () { var e = this.shim; if (e) { e.hide(); e.disabled = true } }, doReplaceWith: function (e) { var an = this.dom; an.parentNode.replaceChild(Ext.getDom(e), an) }, doScrollIntoView: function (e, aq, an, ar, ay, av) { I = I || new Ext.dom.Fly(); var aw = this, at = aw.dom, az = I.attach(e)[ay](), ax = e.scrollTop, au = aw.getScrollIntoViewXY(e, az, ax), ap = au.x, ao = au.y; if (ar) { if (an) { an = Ext.apply({ listeners: { afteranimate: function () { I.attach(at).highlight() } } }, an) } else { I.attach(at).highlight() } } if (ao !== ax) { I.attach(e).scrollTo("top", ao, an) } if (aq !== false && (ap !== az)) { I.attach(e)[av]("left", ap, an) } return aw }, down: function (e, an) { return this.selectNode(e, !!an) }, enableShadow: function (an, e) { var ao = this, aq = ao.shadow || (ao.shadow = new Ext.dom.Shadow(Ext.apply({ target: ao }, an))), ap = ao.shim; if (ap) { ap.offsets = aq.outerOffsets; ap.shadow = aq; aq.shim = ap } if (e === true || (e !== false && ao.isVisible())) { aq.show() } else { aq.hide() } aq.disabled = false }, enableShim: function (an, e) { var ao = this, aq = ao.shim || (ao.shim = new Ext.dom.Shim(Ext.apply({ target: ao }, an))), ap = ao.shadow; if (ap) { aq.offsets = ap.outerOffsets; aq.shadow = ap; ap.shim = aq } if (e === true || (e !== false && ao.isVisible())) { aq.show() } else { aq.hide() } aq.disabled = false; return aq }, findParent: function (at, an, e) { var ap = this, aq = ap.dom, ao = g, ar = 0; if (an || an === 0) { if (typeof an !== "number") { ao = Ext.getDom(an); an = Number.MAX_VALUE } } else { an = 50 } while (aq && aq.nodeType === 1 && ar < an && aq !== ao) { if (Ext.fly(aq).is(at)) { return e ? Ext.get(aq) : aq } ar++; aq = aq.parentNode } return null }, findParentNode: function (ap, an, e) { var ao = Ext.fly(this.dom.parentNode); return ao ? ao.findParent(ap, an, e) : null }, first: function (e, an) { return this.matchNode("nextSibling", "firstChild", e, an) }, focus: function (ao, an) { var e = this; an = an || e.dom; if (Number(ao)) { Ext.defer(e.focus, ao, e, [null, an]) } else { Ext.GlobalEvents.fireEvent("beforefocus", an); an.focus() } return e }, collect: function () { var e = this, an = e.dom, ap = e.shadow, ao = e.shim; if (!e.isFly) { e.mixins.observable.destroy.call(e); delete Ext.cache[e.id]; e.el = null } if (an) { an._extData = e.dom = null } if (ap) { ap.hide(); e.shadow = null } if (ao) { ao.hide(); e.shim = null } }, getAnchorToXY: function (ap, e, ao, an) { return ap.getAnchorXY(e, ao, an) }, getAttribute: function (e, an) { var ao = this.dom; return an ? (ao.getAttributeNS(an, e) || ao.getAttribute(an + ":" + e)) : (ao.getAttribute(e) || ao[e] || null) }, getAttributes: function () { var ap = this.dom.attributes, ao = {}, an, aq, e; for (aq = 0, e = ap.length; aq < e; aq++) { an = ap[aq]; ao[an.name] = an.value } return ao }, getBottom: function (e) { return (e ? this.getLocalY() : this.getY()) + this.getHeight() }, getById: function (ao, e) { var an = V.getElementById(ao) || this.dom.querySelector(Ext.makeIdSelector(ao)); return e ? an : (an ? Ext.get(an) : null) }, getBorderPadding: function () { var e = this.getStyle(J), an = this.getStyle(j); return { beforeX: (parseFloat(an[z.l]) || 0) + (parseFloat(e[af.l]) || 0), afterX: (parseFloat(an[z.r]) || 0) + (parseFloat(e[af.r]) || 0), beforeY: (parseFloat(an[z.t]) || 0) + (parseFloat(e[af.t]) || 0), afterY: (parseFloat(an[z.b]) || 0) + (parseFloat(e[af.b]) || 0) } }, getBorders: function () { var e = this.getStyle(j); return { beforeX: (parseFloat(e[z.l]) || 0), afterX: (parseFloat(e[z.r]) || 0), beforeY: (parseFloat(e[z.t]) || 0), afterY: (parseFloat(e[z.b]) || 0) } }, getBorderWidth: function (e) { return this.addStyles(e, z) }, getData: function (e) { var ao = this.dom, an; if (ao) { an = ao._extData; if (!an && !e) { ao._extData = an = {} } } return an }, getFirstChild: function () { return Ext.get(this.dom.firstElementChild) }, getHeight: function (ap, an) { var ao = this, ar = ao.dom, aq = ao.isStyle("display", "none"), e, at; if (aq) { return 0 } if (ar.nodeName === "BODY") { e = s.getViewportHeight() } else { e = ar.offsetHeight; if (e == null) { e = ar.getBoundingClientRect().height } } if (Ext.supports.Direct2DBug) { at = ao.adjustDirect2DDimension(T); if (an) { e += at } else { if (at > 0 && at < 0.5) { e++ } } } if (ap) { e -= ao.getBorderWidth("tb") + ao.getPadding("tb") } return (e < 0) ? 0 : e }, getHtml: function () { return this.dom ? this.dom.innerHTML : "" }, getLeft: function (e) { return e ? this.getLocalX() : this.getX() }, getLocalX: function () { var ao = this, an, e = ao.getStyle("left"); if (!e || e === "auto") { e = 0 } else { if (u.test(e)) { e = parseFloat(e) } else { e = ao.getX(); an = ao.dom.offsetParent; if (an) { e -= Ext.fly(an).getX() } } } return e }, getLocalXY: function () { var ap = this, ao, an = ap.getStyle(["left", "top"]), e = an.left, aq = an.top; if (!e || e === "auto") { e = 0 } else { if (u.test(e)) { e = parseFloat(e) } else { e = ap.getX(); ao = ap.dom.offsetParent; if (ao) { e -= Ext.fly(ao).getX() } } } if (!aq || aq === "auto") { aq = 0 } else { if (u.test(aq)) { aq = parseFloat(aq) } else { aq = ap.getY(); ao = ap.dom.offsetParent; if (ao) { aq -= Ext.fly(ao).getY() } } } return [e, aq] }, getLocalY: function () { var an = this, e, ao = an.getStyle("top"); if (!ao || ao === "auto") { ao = 0 } else { if (u.test(ao)) { ao = parseFloat(ao) } else { ao = an.getY(); e = an.dom.offsetParent; if (e) { ao -= Ext.fly(e).getY() } } } return ao }, getMargin: (function () { var an = { t: "top", l: "left", r: "right", b: "bottom" }, e = ["margin-top", "margin-left", "margin-right", "margin-bottom"]; return function (ap) { var ar = this, aq, ao, at; if (!ap) { aq = ar.getStyle(e); at = {}; if (aq && typeof aq === "object") { at = {}; for (ao in p) { at[ao] = at[an[ao]] = parseFloat(aq[p[ao]]) || 0 } } } else { at = ar.addStyles(ap, p) } return at } })(), getPadding: function (e) { return this.addStyles(e, af) }, getParent: function () { return Ext.get(this.dom.parentNode) }, getRight: function (e) { return (e ? this.getLocalX() : this.getX()) + this.getWidth() }, getScroll: function () { var ao = this, ar = ao.dom, an = g, aq, ap, e = V.body; if (ar === V || ar === e) { aq = an.scrollLeft || (e ? e.scrollLeft : 0); ap = an.scrollTop || (e ? e.scrollTop : 0) } else { aq = ar.scrollLeft; ap = ar.scrollTop } return { left: aq, top: ap } }, getScrollIntoViewXY: function (ar, az, ay) { var aB = this.dom, an = Ext.getDom(ar), ao = this.getOffsetsTo(an), ax = aB.offsetWidth, au = aB.offsetHeight, e = ao[0] + az, at = ao[1] + ay, aq = at + au, aD = e + ax, av = an.clientHeight, aA = an.clientWidth, aC = az, aw = ay, ap = aw + av, aE = aC + aA; if (au > av || at < aw) { ay = at } else { if (aq > ap) { ay = aq - av } } if (ax > aA || e < aC) { az = e } else { if (aD > aE) { az = aD - aA } } return { x: az, y: ay } }, getScrollLeft: function () { var e = this.dom; if (e === V || e === V.body) { return this.getScroll().left } else { return e.scrollLeft } }, getScrollTop: function () { var e = this.dom; if (e === V || e === V.body) { return this.getScroll().top } else { return e.scrollTop } }, getSize: function (e) { return { width: this.getWidth(e), height: this.getHeight(e) } }, getStyle: function (az, au) { var av = this, ap = av.dom, aC = typeof az !== "string", aA = av.styleHooks, an = az, aw = an, at = 1, ar, aB, ay, ax, ao, e, aq; if (aC) { ay = {}; an = aw[0]; aq = 0; if (!(at = aw.length)) { return ay } } if (!ap || ap.documentElement) { return ay || "" } ar = ap.style; if (au) { e = ar } else { e = ap.ownerDocument.defaultView.getComputedStyle(ap, null); if (!e) { au = true; e = ar } } do { ax = aA[an]; if (!ax) { aA[an] = ax = { name: s.normalize(an) } } if (ax.get) { ao = ax.get(ap, av, au, e) } else { aB = ax.name; ao = e[aB] } if (!aC) { return ao } ay[an] = ao; an = aw[++aq] } while (aq < at); return ay }, getStyleValue: function (e) { return this.dom.style.getPropertyValue(e) }, getTop: function (e) { return e ? this.getLocalY() : this.getY() }, getTouchAction: function () { return Ext.dom.TouchAction.get(this.dom) }, getValue: function (an) { var e = this.dom.value; return an ? parseInt(e, 10) : e }, getViewSize: function () { var e = this.dom; if (e === V || e === V.body) { return { width: s.getViewportWidth(), height: s.getViewportHeight() } } else { return { width: e.clientWidth, height: e.clientHeight } } }, getVisibilityMode: function () { var e = this, an = e.getData(), ao = an.visibilityMode; if (ao === undefined) { an.visibilityMode = ao = s.DISPLAY } return ao }, getWidth: function (e, ar) { var ap = this, at = ap.dom, aq = ap.isStyle("display", "none"), ao, an, au; if (aq) { return 0 } if (Ext.supports.BoundingClientRect) { ao = at.getBoundingClientRect(); an = (ap.vertical && !Ext.supports.RotatedBoundingClientRect) ? (ao.bottom - ao.top) : (ao.right - ao.left); an = ar ? an : Math.ceil(an) } else { an = at.offsetWidth } if (Ext.supports.Direct2DBug && !ap.vertical) { au = ap.adjustDirect2DDimension(l); if (ar) { an += au } else { if (au > 0 && au < 0.5) { an++ } } } if (e) { an -= ap.getBorderWidth("lr") + ap.getPadding("lr") } return (an < 0) ? 0 : an }, getX: function () { return this.getXY()[0] }, getXY: function () { var ao = Math.round, at = this.dom, an = V.body, e = 0, au = 0, aq, ar; if (at !== V && at !== an) { try { aq = an.getBoundingClientRect(); ar = at.getBoundingClientRect(); e = ar.left - aq.left; au = ar.top - aq.top } catch (ap) { } } return [ao(e), ao(au)] }, getY: function () { return this.getXY()[1] }, getZIndex: function () { return parseInt(this.getStyle("z-index"), 10) }, hasCls: function (e) { var an = this.getData(); if (!an.isSynchronized) { this.synchronize() } return an.classMap.hasOwnProperty(e) }, hide: function () { this.setVisible(false); return this }, insertAfter: function (e) { e = Ext.getDom(e); e.parentNode.insertBefore(this.dom, e.nextSibling); return this }, insertBefore: function (e) { e = Ext.getDom(e); e.parentNode.insertBefore(this.dom, e); return this }, insertFirst: function (an, e) { an = an || {}; if (an.nodeType || an.dom || typeof an === "string") { an = Ext.getDom(an); this.dom.insertBefore(an, this.dom.firstChild); return !e ? Ext.get(an) : an } else { return this.createChild(an, this.dom.firstChild, e) } }, insertHtml: function (an, ao, e) { var ap = Ext.DomHelper.insertHtml(an, this.dom, ao); return e ? Ext.get(ap) : ap }, insertSibling: function (ao, ar, av) { var au = this, aw = Ext.DomHelper, ax = (ar || "before").toLowerCase() === "after", aq, an, ap, at; if (Ext.isIterable(ao)) { ap = ao.length; an = Ext.fly(V.createDocumentFragment()); if (Ext.isArray(ao)) { for (at = 0; at < ap; at++) { aq = an.appendChild(ao[at], av) } } else { for (at = 0; at < ap; at++) { an.dom.appendChild(aq = ao[0]) } if (av === false) { aq = Ext.get(aq) } } au.dom.parentNode.insertBefore(an.dom, ax ? au.dom.nextSibling : au.dom); return aq } ao = ao || {}; if (ao.nodeType || ao.dom) { aq = au.dom.parentNode.insertBefore(Ext.getDom(ao), ax ? au.dom.nextSibling : au.dom); if (!av) { aq = Ext.get(aq) } } else { if (ax && !au.dom.nextSibling) { aq = aw.append(au.dom.parentNode, ao, !av) } else { aq = aw[ax ? "insertAfter" : "insertBefore"](au.dom, ao, !av) } } return aq }, is: function (e) { var ao = this.dom, an; if (!e) { an = true } else { if (!ao.tagName) { an = false } else { if (Ext.isFunction(e)) { an = e(ao) } else { an = ao[Ext.supports.matchesSelector](e) } } } return an }, isAncestor: function (an) { var e = false, ao = this.dom, ap = Ext.getDom(an); if (ao && ap) { if (ao.contains) { return ao.contains(ap) } else { if (ao.compareDocumentPosition) { return !!(ao.compareDocumentPosition(ap) & 16) } else { while ((ap = ap.parentNode)) { e = ap === ao || e } } } } return e }, isPainted: (function () { return !Ext.browser.is.IE ? function () { var e = this.dom; return Boolean(e && e.offsetParent) } : function () { var e = this.dom; return Boolean(e && (e.offsetHeight !== 0 && e.offsetWidth !== 0)) } })(), isScrollable: function () { var e = this.dom; return e.scrollHeight > e.clientHeight || e.scrollWidth > e.clientWidth }, isStyle: function (e, an) { return this.getStyle(e) === an }, isVisible: function (an) { var ao = this.dom, e; if (!ao) { return false } if (!ac) { ac = new Ext.dom.Fly() } for (e = ao.ownerDocument.documentElement; ao !== e; ao = ao.parentNode) { if (!ao || ao.nodeType === 11 || (ac.attach(ao)).isStyle(n, ah) || ac.isStyle(d, Z)) { return false } if (!an) { break } } return true }, last: function (e, an) { return this.matchNode("previousSibling", "lastChild", e, an) }, matchNode: function (an, ar, e, ao) { var ap = this.dom, aq; if (!ap) { return null } aq = ap[ar]; while (aq) { if (aq.nodeType === 1 && (!e || Ext.fly(aq, "_matchNode").is(e))) { return !ao ? Ext.get(aq) : aq } aq = aq[an] } return null }, monitorMouseLeave: function (e, ap, ao) { var aq = this, ar, an = { mouseleave: function (at) { if (Ext.isIE9m) { at.enableIEAsync() } ar = Ext.defer(ap, e, ao || aq, [at]) }, mouseenter: function () { clearTimeout(ar) }, destroy: function () { clearTimeout(ar); aq.un(an) } }; aq.on(an); return an }, next: function (e, an) { return this.matchNode("nextSibling", "nextSibling", e, an) }, parent: function (e, an) { return this.matchNode("parentNode", "parentNode", e, an) }, position: function (aq, ap, e, ao) { var an = this; if (an.dom.tagName !== "BODY") { if (!aq && an.isStyle(ab, w)) { an.setStyle(ab, v) } else { if (aq) { an.setStyle(ab, aq) } } if (ap) { an.setStyle(q, ap) } if (e || ao) { an.setXY([e || false, ao || false]) } } }, prev: function (e, an) { return this.matchNode("previousSibling", "previousSibling", e, an) }, query: function (ao, ax, av) { var aq = this.dom, at, au, aw, an, e, ar, ap; if (!aq) { return null } ax = (ax !== false); ao = ao.split(","); if (!av) { at = [] } for (ar = 0, au = ao.length; ar < au; ar++) { if (typeof ao[ar] === "string") { if (av) { an = aq.querySelector(ao[ar]); return ax ? an : Ext.get(an) } e = aq.querySelectorAll(ao[ar]); for (ap = 0, aw = e.length; ap < aw; ap++) { at.push(ax ? e[ap] : Ext.get(e[ap])) } } } return at }, radioCls: function (ap) { var aq = this.dom.parentNode.childNodes, an; ap = Ext.isArray(ap) ? ap : [ap]; for (var ao = 0, e = aq.length; ao < e; ao++) { an = aq[ao]; if (an && an.nodeType === 1) { Ext.fly(an).removeCls(ap) } } return this.addCls(ap) }, redraw: function () { var an = this.dom, e = an.style; e.display = "none"; an.offsetHeight; e.display = "" }, remove: function () { this.destroy() }, removeChild: function (e) { this.dom.removeChild(Ext.getDom(e)); return this }, removeCls: function (av, at, ax) { var aw = this, ap = aw.getData(), ay, aq, an, ao, ar, au, e; if (!av) { return aw } if (!ap.isSynchronized) { aw.synchronize() } aq = aw.dom; an = ap.classMap; ao = ap.classList; at = at ? at + C : ""; ax = ax ? C + ax : ""; if (typeof av === "string") { av = av.split(O) } for (ar = 0, au = av.length; ar < au; ar++) { e = av[ar]; if (e) { e = at + e + ax; if (an[e]) { delete an[e]; Ext.Array.remove(ao, e); ay = true } } } if (ay) { aq.className = ao.join(" ") } return aw }, repaint: function () { var e = this; e.addCls("x-repaint"); Ext.defer(function () { if (e.dom) { Ext.fly(e.dom).removeCls("x-repaint") } }, 1); return e }, replace: function (ao, an) { ao = Ext.getDom(ao); var e = ao.parentNode, aq = ao.id, ap = this.dom; if (an !== false && aq && Ext.cache[aq]) { e.insertBefore(ap, ao); Ext.get(ao).destroy() } else { e.replaceChild(ap, ao) } return this }, replaceCls: function (ao, aw, au, az) { var ax = this, ar, an, ap, at, av, e, aq = ax.getData(), ay; if (!ao && !aw) { return ax } ao = ao || []; aw = aw || []; if (!aq.isSynchronized) { ax.synchronize() } if (!az) { az = "" } ar = ax.dom; an = aq.classMap; ap = aq.classList; au = au ? au + C : ""; az = az ? C + az : ""; if (typeof ao === "string") { ao = ao.split(O) } if (typeof aw === "string") { aw = aw.split(O) } for (at = 0, av = ao.length; at < av; at++) { e = au + ao[at] + az; if (an[e]) { delete an[e]; ay = true } } for (at = 0, av = aw.length; at < av; at++) { e = au + aw[at] + az; if (!an[e]) { an[e] = true; ay = true } } if (ay) { aq.classList = ap = Ext.Object.getKeys(an); ar.className = ap.join(" ") } return ax }, replaceWith: function (ap) { var aq = this, ar = aq.dom, ao = ar.parentNode, e = Ext.cache, an; aq.clearListeners(); if (ap.nodeType || ap.dom || typeof ap === "string") { ap = Ext.get(ap); an = ao.insertBefore(ap.dom, ar) } else { an = Ext.DomHelper.insertBefore(ar, ap) } ao.removeChild(ar); aq.dom = an; if (!aq.isFly) { delete e[aq.id]; e[aq.id = Ext.id(an)] = aq } return aq }, resolveListenerScope: function (an) { var e = this.component; return e ? e.resolveListenerScope(an) : this }, scroll: function (av, e, ao) { if (!this.isScrollable()) { return false } av = av.charAt(0); var au = this, aq = au.dom, at = av === "r" || av === "l" ? "left" : "top", an = false, ap, ar; if (av === "l" || av === "t" || av === "u") { e = -e } if (at === "left") { ap = aq.scrollLeft; ar = au.constrainScrollLeft(ap + e) } else { ap = aq.scrollTop; ar = au.constrainScrollTop(ap + e) } if (ar !== ap) { this.scrollTo(at, ar, ao); an = true } return an }, scrollBy: function (an, e, ao) { var ap = this, aq = ap.dom; if (an.length) { ao = e; e = an[1]; an = an[0] } else { if (typeof an != "number") { ao = e; e = an.y; an = an.x } } if (an) { ap.scrollTo("left", ap.constrainScrollLeft(aq.scrollLeft + an), ao) } if (e) { ap.scrollTo("top", ap.constrainScrollTop(aq.scrollTop + e), ao) } return ap }, scrollChildIntoView: function (an, e) { Ext.fly(an).scrollIntoView(this, e) }, scrollIntoView: function (e, ap, ao, an) { e = Ext.getDom(e) || Ext.getBody().dom; return this.doScrollIntoView(e, ap, ao, an, "getScrollLeft", "scrollTo") }, scrollTo: function (ao, aq, e) { var ar = c.test(ao), ap = this, au = ar ? "scrollTop" : "scrollLeft", at = ap.dom, an; if (!e || !ap.anim) { at[au] = aq; at[au] = aq } else { an = { to: {} }; an.to[au] = aq; if (Ext.isObject(e)) { Ext.applyIf(an, e) } ap.animate(an) } return ap }, select: function (an, ap) { var e, ao; if (typeof an === "string") { ao = this.query(an, !ap) } else { ao = an; e = true } return ap ? new Ext.CompositeElement(ao, !e) : new Ext.CompositeElementLite(ao, true) }, selectNode: function (an, e) { return this.query(an, e, true) }, set: function (e, an) { var ap = this, ar = ap.dom, ao, aq; for (ao in e) { if (e.hasOwnProperty(ao)) { aq = e[ao]; if (ao === "style") { ap.applyStyles(aq) } else { if (ao === "cls") { ar.className = aq } else { if (an !== false) { if (aq === undefined) { ar.removeAttribute(ao) } else { ar.setAttribute(ao, aq) } } else { ar[ao] = aq } } } } } return ap }, setBottom: function (e) { this.dom.style[Q] = s.addUnits(e); return this }, setCls: function (ap) { var ar = this, ao = ar.getData(), an, aq, e, at, au; if (!ao.isSynchronized) { ar.synchronize() } if (typeof ap === "string") { ap = ap.split(O) } ao.classList = au = ap.slice(); ao.classMap = at = {}; for (an = 0, aq = au.length; an < aq; an++) { at[au[an]] = true } ar.dom.className = au.join(" ") }, setDisplayed: function (an) { var e = this; if (typeof an === "boolean") { an = an ? e._getDisplay() : Z } e.setStyle(d, an); if (e.shadow || e.shim) { e.setUnderlaysVisible(an !== Z) } return e }, setHeight: function (e) { var an = this; an.dom.style[T] = s.addUnits(e); if (an.shadow || an.shim) { an.syncUnderlays() } return an }, setHtml: function (e) { if (this.dom) { this.dom.innerHTML = e } return this }, setId: function (ap) { var ao = this, e = ao.id, an = Ext.cache; if (e) { delete an[e] } ao.dom.id = ap; ao.id = ap; an[ap] = ao; return ao }, setLeft: function (an) { var e = this; e.dom.style[K] = s.addUnits(an); if (e.shadow || e.shim) { e.syncUnderlays() } return e }, setLocalX: function (e) { var ao = this, an = ao.dom.style; an.right = "auto"; an.left = (e === null) ? "auto" : e + "px"; if (ao.shadow || ao.shim) { ao.syncUnderlays() } return ao }, setLocalXY: function (e, ap) { var ao = this, an = ao.dom.style; an.right = "auto"; if (e && e.length) { ap = e[1]; e = e[0] } if (e === null) { an.left = "auto" } else { if (e !== undefined) { an.left = e + "px" } } if (ap === null) { an.top = "auto" } else { if (ap !== undefined) { an.top = ap + "px" } } if (ao.shadow || ao.shim) { ao.syncUnderlays() } return ao }, setLocalY: function (an) { var e = this; e.dom.style.top = (an === null) ? "auto" : an + "px"; if (e.shadow || e.shim) { e.syncUnderlays() } return e }, setMargin: function (ao) { var an = this, e = an.dom.style; if (ao || ao === 0) { ao = an.self.unitizeBox((ao === true) ? 5 : ao); e.setProperty("margin", ao, "important") } else { e.removeProperty("margin-top"); e.removeProperty("margin-right"); e.removeProperty("margin-bottom"); e.removeProperty("margin-left") } }, setMaxHeight: function (e) { this.dom.style[G] = s.addUnits(e); return this }, setMaxWidth: function (e) { this.dom.style[t] = s.addUnits(e); return this }, setMinHeight: function (e) { this.dom.style[h] = s.addUnits(e); return this }, setMinWidth: function (e) { this.dom.style[ag] = s.addUnits(e); return this }, setOpacity: function (e) { var an = this; if (an.dom) { an.setStyle("opacity", e) } return an }, setPadding: function (ao) { var an = this, e = an.dom.style; if (ao || ao === 0) { ao = an.self.unitizeBox((ao === true) ? 5 : ao); e.setProperty("padding", ao, "important") } else { e.removeProperty("padding-top"); e.removeProperty("padding-right"); e.removeProperty("padding-bottom"); e.removeProperty("padding-left") } }, setRight: function (e) { this.dom.style[ak] = s.addUnits(e); return this }, setScrollLeft: function (e) { this.dom.scrollLeft = e; return this }, setScrollTop: function (e) { this.dom.scrollTop = e; return this }, setSize: function (ao, e) { var ap = this, an = ap.dom.style; if (Ext.isObject(ao)) { e = ao.height; ao = ao.width } an.width = s.addUnits(ao); an.height = s.addUnits(e); if (ap.shadow || ap.shim) { ap.syncUnderlays() } return ap }, setSizeState: function (ao) { var an = this, ap, e; if (ao === true) { ap = E; e = [R, L] } else { if (ao === false) { ap = R; e = [E, L] } else { if (ao === null) { ap = L; e = [E, R] } else { e = [E, R, L] } } } if (ap) { an.addCls(ap) } an.removeCls(e); return an }, setStyle: function (au, ar) { var ap = this, at = ap.dom, e = ap.styleHooks, ao = at.style, an = au, aq; if (typeof an === "string") { aq = e[an]; if (!aq) { e[an] = aq = { name: s.normalize(an) } } ar = (ar == null) ? "" : ar; if (aq.set) { aq.set(at, ar, ap) } else { ao[aq.name] = ar } if (aq.afterSet) { aq.afterSet(at, ar, ap) } } else { for (an in au) { if (au.hasOwnProperty(an)) { aq = e[an]; if (!aq) { e[an] = aq = { name: s.normalize(an) } } ar = au[an]; ar = (ar == null) ? "" : ar; if (aq.set) { aq.set(at, ar, ap) } else { ao[aq.name] = ar } if (aq.afterSet) { aq.afterSet(at, ar, ap) } } } } return ap }, setText: function (e) { this.dom.textContent = e }, setTop: function (an) { var e = this; e.dom.style[X] = s.addUnits(an); if (e.shadow || e.shim) { e.syncUnderlays() } return e }, setTouchAction: function (e) { Ext.dom.TouchAction.set(this.dom, e) }, setUnderlaysVisible: function (e) { var ao = this.shadow, an = this.shim; if (ao && !ao.disabled) { if (e) { ao.show() } else { ao.hide() } } if (an && !an.disabled) { if (e) { an.show() } else { an.hide() } } }, setVisibility: function (e) { var an = this.dom.style; if (e) { an.removeProperty("visibility") } else { an.setProperty("visibility", "hidden", "important") } }, setVisibilityMode: function (e) { this.getData().visibilityMode = e; return this }, setVisible: function (ao) { var e = this, an = e.getVisibilityMode(), ap = ao ? "removeCls" : "addCls"; switch (an) { case s.DISPLAY: e.removeCls([H, o, a]); e[ap](F); break; case s.VISIBILITY: e.removeCls([F, o, a]); e[ap](H); break; case s.OFFSETS: e.removeCls([H, F, a]); e[ap](o); break; case s.CLIP: e.removeCls([H, F, o]); e[ap](a); break }if (e.shadow || e.shim) { e.setUnderlaysVisible(ao) } return e }, setWidth: function (e) { var an = this; an.dom.style[l] = s.addUnits(e); if (an.shadow || an.shim) { an.syncUnderlays() } return an }, setX: function (e) { return this.setXY([e, false]) }, setXY: function (ao) { var an = this, ap = an.translatePoints(ao), e = an.dom.style, aq; an.position(); e.right = "auto"; for (aq in ap) { if (!isNaN(ap[aq])) { e[aq] = ap[aq] + "px" } } if (an.shadow || an.shim) { an.syncUnderlays() } return an }, setY: function (e) { return this.setXY([false, e]) }, setZIndex: function (e) { var an = this; if (an.shadow) { an.shadow.setZIndex(e) } if (an.shim) { an.shim.setZIndex(e) } return an.setStyle("z-index", e) }, show: function () { this.setVisible(true); return this }, swapCls: function (an, at, e, aq) { if (e === undefined) { e = true } var ap = this, ar = e ? an : at, ao = e ? at : an; if (ao) { ap.removeCls(aq ? aq + "-" + ao : ao) } if (ar) { ap.addCls(aq ? aq + "-" + ar : ar) } return ap }, synchronize: function () { var au = this, ap = au.dom, av = {}, at = ap.className, an, aq, ar, e, ao = au.getData(); if (at && at.length > 0) { an = ap.className.split(ai); for (aq = 0, ar = an.length; aq < ar; aq++) { e = an[aq]; av[e] = true } } else { an = [] } ao.classList = an; ao.classMap = av; ao.isSynchronized = true; return au }, syncUnderlays: function () { var ap = this, au = ap.shadow, e = ap.shim, an = ap.dom, av, ar, aq, at, ao; if (ap.isVisible()) { av = ap.getXY(); ar = av[0]; aq = av[1]; at = an.offsetWidth; ao = an.offsetHeight; if (au && !au.hidden) { au.realign(ar, aq, at, ao) } if (e && !e.hidden) { e.realign(ar, aq, at, ao) } } }, toggleCls: function (e, an) { if (typeof an !== "boolean") { an = !this.hasCls(e) } return an ? this.addCls(e) : this.removeCls(e) }, toggle: function () { this.setVisible(!this.isVisible()); return this }, translate: function () { var e = "webkitTransform" in V.createElement("div").style ? "webkitTransform" : "transform"; return function (an, ap, ao) { an = Math.round(an); ap = Math.round(ap); ao = Math.round(ao); this.dom.style[e] = "translate3d(" + (an || 0) + "px, " + (ap || 0) + "px, " + (ao || 0) + "px)" } }(), unwrap: function () { var at = this.dom, an = at.parentNode, ap, ar = Ext.fly(Ext.Element.getActiveElement()), aq, ao, au, e; aq = Ext.cache[ar.id]; if (aq) { ar = aq } if (this.contains(ar)) { if (aq) { aq.suspendFocusEvents() } ao = true } if (an) { ap = an.parentNode; if (ao) { e = ap.getAttribute("tabIndex"); au = Ext.fly(ap); au.set({ tabIndex: -1 }); au.suspendFocusEvents(); au.focus() } ap.insertBefore(at, an); ap.removeChild(an) } else { ap = V.createDocumentFragment(); ap.appendChild(at) } if (ao) { if (aq) { aq.focus(); aq.resumeFocusEvents() } else { Ext.fly(ar).focus() } if (au) { au.resumeFocusEvents(); au.set({ tabIndex: e }) } } return this }, up: function (ao, e, an) { return this.findParentNode(ao, e, !an) }, update: function (e) { return this.setHtml(e) }, wrap: function (ap, ax, at) { var aw = this, au = aw.dom, ar = Ext.DomHelper.insertBefore(au, ap || { tag: "div" }, !ax), av = ar, ao = Ext.Element.getActiveElement(), aq, an, e; aq = Ext.cache[ao.id]; if (aq) { ao = aq } if (at) { av = ar.selectNode(at, ax) } if (aw.contains(ao)) { if (aq) { aq.suspendFocusEvents() } e = ar.dom.getAttribute("tabIndex"); ar.set({ tabIndex: -1 }); ar.suspendFocusEvents(); ar.focus(); an = true } av.appendChild(au); if (an) { if (aq) { aq.focus(); aq.resumeFocusEvents() } else { Ext.fly(ao).focus() } ar.resumeFocusEvents(); ar.set({ tabIndex: e }) } return ar }, privates: { doAddListener: function (au, ay, aA, aC, ap, an, aq) { var ax = this, az = Ext.$gesturePublisher, av = au, aB = Ext.supports, e = aB.TouchEvents, ao = aB.PointerEvents, ar, at, aw; au = Ext.canonicalEventName(au); if (!ax.blockedEvents[au]) { ar = ax.mixins.observable.doAddListener; aC = aC || {}; if (s.useDelegatedEvents === false) { aC.delegated = aC.delegated || false } if (aC.translate !== false) { at = ax.additiveEvents[au]; if (at) { aC.type = au; au = at; ar.call(ax, au, ay, aA, aC, ap, an, aq) } aw = ax.eventMap[au]; if (aw) { aC.type = aC.type || au; if (aq) { aC.managedName = av } au = aw } } if (ar.call(ax, au, ay, aA, aC, ap, an, aq)) { if (ax.longpressEvents[au] && (++ax.longpressListenerCount === 1)) { ax.on("MSHoldVisual", "preventMsHoldVisual", ax) } } if (aq && aw) { delete aC.managedName } delete aC.type } }, doRemoveListener: function (aq, aw, ay) { var av = this, ax = Ext.$gesturePublisher, az = Ext.supports, e = az.TouchEvents, an = az.PointerEvents, ao, au, ap, at, ar; aq = Ext.canonicalEventName(aq); if (!av.blockedEvents[aq]) { ao = av.mixins.observable.doRemoveListener; ap = av.additiveEvents[aq]; if (ap) { aq = ap; ao.call(av, aq, aw, ay) } au = av.eventMap[aq]; if (au) { ar = ao.call(av, au, aw, ay) } ar = ao.call(av, aq, aw, ay) || ar; if (ar) { if (av.longpressEvents[aq] && !--av.longpressListenerCount) { av.un("MSHoldVisual", "preventMsHoldVisual", av) } } } }, _initEvent: function (e) { return (this.events[e] = new Ext.dom.ElementEvent(this, e)) }, _getDisplay: function () { var e = this.getData(), an = e[y]; if (an === undefined) { e[y] = an = "" } return an }, _getPublisher: function (e) { var ao = Ext.event.publisher.Publisher, an = ao.publishersByEvent[e]; if (!an || (this.dom === window && e === "resize")) { an = ao.publishers.dom } return an }, isFocusSuspended: function () { return !!this.getData().suspendFocusEvents }, preventMsHoldVisual: function (an) { an.preventDefault() }, suspendFocusEvents: function () { if (!this.isFly) { this.suspendEvent("focus", "blur") } this.getData().suspendFocusEvents = true }, resumeFocusEvents: function () { function e() { var an; if (!this.destroyed) { an = this.getData(); if (an) { an.suspendFocusEvents = false } if (!this.isFly) { this.resumeEvent("focus", "blur") } } } if (!this.destroyed && this.getData().suspendFocusEvents) { if (Ext.isIE) { Ext.asap(e, this) } else { e.call(this) } } } }, deprecated: { "5.0": { methods: { cssTranslate: null, getHTML: "getHtml", getOuterHeight: null, getOuterWidth: null, getPageBox: function (ao) { var ar = this, ap = ar.dom, au = ap.nodeName === "BODY", av = au ? s.getViewportWidth() : ap.offsetWidth, aq = au ? s.getViewportHeight() : ap.offsetHeight, ax = ar.getXY(), aw = ax[1], e = ax[0] + av, at = ax[1] + aq, an = ax[0]; if (ao) { return new Ext.util.Region(aw, e, at, an) } else { return { left: an, top: aw, width: av, height: aq, right: e, bottom: at } } }, getScrollParent: null, isDescendent: null, isTransparent: function (an) { var e = this.getStyle(an); return e ? b.test(e) : false }, purgeAllListeners: "clearListeners", removeAllListeners: "clearListeners", setHTML: "setHtml", setTopLeft: null } } } } }, 1, 0, 0, 0, 0, [[Ext.util.Positionable.prototype.mixinId || Ext.util.Positionable.$className, Ext.util.Positionable], [Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.dom, "Element", Ext, "Element"], function (r) { var b = document, h = b.documentElement, n = r.prototype, y = Ext.supports, F = "pointerdown", e = "pointermove", c = "pointerup", d = "pointercancel", j = "MSPointerDown", o = "MSPointerMove", B = "MSPointerUp", a = "MSPointerCancel", u = "mousedown", A = "mousemove", v = "mouseup", G = "mouseover", E = "mouseout", q = "mouseenter", g = "mouseleave", x = "touchstart", m = "touchmove", C = "touchend", i = "touchcancel", s = "click", k = "dblclick", w = "tap", D = "doubletap", l = n.eventMap = {}, t = n.additiveEvents = {}, p = Ext.id, z; Ext.id = function (J, I) { var H = Ext.getDom(J, true), K, L; if (!H) { L = p(J, I) } else { if (!(L = H.id)) { L = p(null, I || r.prototype.identifiablePrefix); if (Ext.isSandboxed) { K = Ext.sandboxPrefix || (Ext.sandboxPrefix = Ext.sandboxName.toLowerCase() + "-"); L = K + L } H.id = L } } return L }; if (y.PointerEvents) { l[u] = F; l[A] = e; l[v] = c; l[x] = F; l[m] = e; l[C] = c; l[i] = d; l[G] = "pointerover"; l[E] = "pointerout"; l[q] = "pointerenter"; if (!Ext.isIE11) { l[g] = "pointerleave" } } else { if (y.MSPointerEvents) { l[F] = j; l[e] = o; l[c] = B; l[d] = a; l[u] = j; l[A] = o; l[v] = B; l[x] = j; l[m] = o; l[C] = B; l[i] = a; l[G] = "MSPointerOver"; l[E] = "MSPointerOut" } else { if (y.TouchEvents) { l[F] = x; l[e] = m; l[c] = C; l[d] = i; l[u] = x; l[A] = m; l[v] = C; l[s] = w; l[k] = D; if (Ext.isWebKit && Ext.os.is.Desktop) { l[x] = u; l[m] = A; l[C] = v; l[i] = v; t[u] = u; t[A] = A; t[v] = v; t[x] = x; t[m] = m; t[C] = C; t[i] = i; t[F] = u; t[e] = A; t[c] = v; t[d] = v } } else { l[F] = u; l[e] = A; l[c] = v; l[d] = v; l[x] = u; l[m] = A; l[C] = v; l[i] = v } } } if (Ext.isWebKit) { l.transitionend = Ext.browser.getVendorProperyName("transitionEnd"); l.animationstart = Ext.browser.getVendorProperyName("animationStart"); l.animationend = Ext.browser.getVendorProperyName("animationEnd") } if (!Ext.supports.MouseWheel && !Ext.isOpera) { l.mousewheel = "DOMMouseScroll" } z = n.$eventOptions = Ext.Object.chain(n.$eventOptions); z.translate = z.capture = z.delegate = z.delegated = z.stopEvent = z.preventDefault = z.stopPropagation = z.element = 1; n.styleHooks.opacity = { name: "opacity", afterSet: function (J, I, H) { var K = H.shadow; if (K) { K.setOpacity(I) } } }; n.getTrueXY = n.getXY; Ext.select = r.select; Ext.query = r.query; Ext.apply(Ext, { get: function (H) { return r.get(H) }, getDom: function (H) { if (!H || !b) { return null } return typeof H === "string" ? Ext.getElementById(H) : "dom" in H ? H.dom : H }, getBody: function () { if (!Ext._bodyEl) { if (!b.body) { throw new Error("[Ext.getBody] document.body does not yet exist") } Ext._bodyEl = Ext.get(b.body) } return Ext._bodyEl }, getHead: function () { if (!Ext._headEl) { Ext._headEl = Ext.get(b.head || b.getElementsByTagName("head")[0]) } return Ext._headEl }, getDoc: function () { if (!Ext._docEl) { Ext._docEl = Ext.get(b) } return Ext._docEl }, getWin: function () { if (!Ext._winEl) { Ext._winEl = Ext.get(window) } return Ext._winEl }, removeNode: function (J) { J = J.dom || J; var K = J && J.id, I = Ext.cache[K], H; if (I) { I.destroy() } else { if (J && (J.nodeType === 3 || J.tagName.toUpperCase() !== "BODY")) { H = J.parentNode; if (H) { H.removeChild(J) } } } } }); Ext.isGarbage = function (H) { return H && H.nodeType === 1 && H.tagName !== "BODY" && H.tagName !== "HTML" && (!H.parentNode || (H.offsetParent === null && ((Ext.isIE8 ? b.all[H.id] : b.getElementById(H.id)) !== H) && !(Ext.detachedBodyEl && Ext.detachedBodyEl.isAncestor(H)))) }; if (Ext.os.is.Android || (Ext.os.is.Windows && Ext.supports.Touch)) { Ext.onReady(function () { var H = Ext.getWin(); r._documentWidth = r._viewportWidth = h.clientWidth; r._documentHeight = r._viewportHeight = h.clientHeight; H.on({ focusin: "_onWindowFocusChange", focusout: "_onWindowFocusChange", pointerup: "_onWindowFocusChange", capture: true, delegated: false, delay: 1, scope: r }); H.on({ resize: "_onWindowResize", priority: 2000, scope: r }) }) } })); (Ext.cmd.derive("Ext.util.Filter", Ext.Base, { isFilter: true, config: { property: null, value: null, filterFn: null, id: null, anyMatch: false, exactMatch: false, caseSensitive: false, disabled: false, disableOnEmpty: false, operator: null, root: null, serializer: null, convert: null }, scope: null, $configStrict: false, statics: { createFilterFn: function (a) { if (!a) { return Ext.returnTrue } return function (g) { var b = a.isCollection ? a.items : a, h = b.length, c = true, d, e; for (d = 0; c && d < h; d++) { e = b[d]; if (!e.getDisabled()) { c = e.filter(g) } } return c } }, isEqual: function (b, a) { if (b.getProperty() !== a.getProperty()) { return false } if (b.getOperator() !== a.getOperator()) { return false } if (b.getValue() === a.getValue()) { return true } else { if (Ext.isArray(b) && Ext.isArray(a) && Ext.Array.equals(b, a)) { return true } } return false }, isInvalid: function (a) { if (!a.filterFn) { if (!a.property) { return "A Filter requires either a property or a filterFn to be set" } if (!a.hasOwnProperty("value") && !a.operator) { return "A Filter requires either a property and value, or a filterFn to be set" } } return false } }, constructor: function (a) { this.initConfig(a) }, preventConvert: { "in": 1, notin: 1 }, filter: function (b) { var a = this, e = a._filterFn || a.getFilterFn(), d = a.getConvert(), c = a._value; a._filterValue = c; a.isDateValue = Ext.isDate(c); if (a.isDateValue) { a.dateValue = c.getTime() } if (d && !a.preventConvert[a.getOperator()]) { a._filterValue = d.call(a.scope || a, c) } return e.call(a.scope || a, b) }, getId: function () { var a = this._id; if (!a) { a = this.getProperty(); if (!a) { a = Ext.id(null, "ext-filter-") } this._id = a } return a }, getFilterFn: function () { var b = this, c = b._filterFn, a; if (!c) { a = b.getOperator(); if (a) { c = b.operatorFns[a] } else { c = b.createRegexFilter() } b._filterFn = c; b.generatedFilterFn = true } return c }, createRegexFilter: function () { var b = this, e = !!b.getAnyMatch(), a = !!b.getExactMatch(), c = b.getValue(), d = Ext.String.createRegex(c, !e, !e && a, !b.getCaseSensitive()); return function (g) { var h = b.getPropertyValue(g); return d ? d.test(h) : (h == null) } }, getPropertyValue: function (b) { var a = this._root, c = (a == null) ? b : b[a]; return c[this._property] }, getState: function () { var c = this.getInitialConfig(), a = {}, b; for (b in c) { if (c.hasOwnProperty(b)) { a[b] = c[b] } } delete a.root; a.value = this.getValue(); return a }, getScope: function () { return this.scope }, serialize: function () { var a = this.getState(), b = this.getSerializer(), c; delete a.id; delete a.serializer; if (b) { c = b.call(this, a); if (c) { a = c } } return a }, updateOperator: function () { if (this.generatedFilterFn) { this._filterFn = null } }, updateValue: function (a) { if (this.generatedFilterFn) { this._filterFn = null } if (this.getDisableOnEmpty()) { this.setDisabled(Ext.isEmpty(a)) } }, updateFilterFn: function (a) { delete this.generatedFilterFn }, updateDisableOnEmpty: function (a) { if (a) { this.setDisabled(Ext.isEmpty(this.getValue())) } }, privates: { getCandidateValue: function (c, b, e) { var d = this, g = d._convert, a = d.getPropertyValue(c); if (g) { a = g.call(d.scope || d, a) } else { if (!e) { a = Ext.coerce(a, b) } } return a } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "Filter"], function () { var a = this.prototype, b = (a.operatorFns = { "<": function (d) { var c = this._filterValue; return this.getCandidateValue(d, c) < c }, "<=": function (d) { var c = this._filterValue; return this.getCandidateValue(d, c) <= c }, "=": function (d) { var e = this, c = e._filterValue; d = e.getCandidateValue(d, c); if (e.isDateValue && d instanceof Date) { d = d.getTime(); c = e.dateValue } return d == c }, "===": function (d) { var e = this, c = e._filterValue; d = e.getCandidateValue(d, c, true); if (e.isDateValue && d instanceof Date) { d = d.getTime(); c = e.dateValue } return d === c }, ">=": function (d) { var c = this._filterValue; return this.getCandidateValue(d, c) >= c }, ">": function (d) { var c = this._filterValue; return this.getCandidateValue(d, c) > c }, "!=": function (d) { var e = this, c = e._filterValue; d = e.getCandidateValue(d, c); if (e.isDateValue && d instanceof Date) { d = d.getTime(); c = e.dateValue } return d != c }, "!==": function (d) { var e = this, c = e._filterValue; d = e.getCandidateValue(d, c, true); if (e.isDateValue && d instanceof Date) { d = d.getTime(); c = e.dateValue } return d !== c }, "in": function (d) { var c = this._filterValue; return Ext.Array.contains(c, this.getCandidateValue(d, c)) }, notin: function (d) { var c = this._filterValue; return !Ext.Array.contains(c, this.getCandidateValue(d, c)) }, like: function (d) { var c = this._filterValue; return c && this.getCandidateValue(d, c).toLowerCase().indexOf(c.toLowerCase()) > -1 }, "/=": function (d) { var g = this, c = g._filterValue; d = g.getCandidateValue(d, c); if (c !== g.lastRegExpSource) { g.lastRegExpSource = c; try { g.regex = new RegExp(c, "i") } catch (h) { g.regex = null } } return g.regex ? g.regex.test(d) : false } }); b["=="] = b["="]; b.gt = b[">"]; b.ge = b[">="]; b.lt = b["<"]; b.le = b["<="]; b.eq = b["="]; b.ne = b["!="] })); (Ext.cmd.derive("Ext.util.Observable", Ext.mixin.Observable, { $applyConfigs: true }, 0, 0, 0, 0, 0, 0, [Ext.util, "Observable"], function (a) { var b = Ext.mixin.Observable; a.releaseCapture = b.releaseCapture; a.capture = b.capture; a.captureArgs = b.captureArgs; a.observe = a.observeClass = b.observe })); (Ext.cmd.derive("Ext.util.AbstractMixedCollection", Ext.Base, { isMixedCollection: true, generation: 0, indexGeneration: 0, constructor: function (b, a) { var c = this; if (arguments.length === 1 && Ext.isObject(b)) { c.initialConfig = b; Ext.apply(c, b) } else { c.allowFunctions = b === true; if (a) { c.getKey = a } c.initialConfig = { allowFunctions: c.allowFunctions, getKey: c.getKey } } c.items = []; c.map = {}; c.keys = []; c.indexMap = {}; c.length = 0; c.mixins.observable.constructor.call(c) }, destroy: function () { var a = this; a.items = a.map = a.keys = a.indexMap = null; a.callParent() }, allowFunctions: false, add: function (c, d) { var a = this.length, b; if (arguments.length === 1) { b = this.insert(a, c) } else { b = this.insert(a, c, d) } return b }, getKey: function (a) { return a.id }, replace: function (c, e) { var d = this, a, b; if (arguments.length == 1) { e = arguments[0]; c = d.getKey(e) } a = d.map[c]; if (typeof c == "undefined" || c === null || typeof a == "undefined") { return d.add(c, e) } d.generation++; b = d.indexOfKey(c); d.items[b] = e; d.map[c] = e; if (d.hasListeners.replace) { d.fireEvent("replace", c, a, e) } return e }, reorder: function (d) { var h = this, b = h.items, c = 0, g = b.length, a = [], e = [], i; h.suspendEvents(); for (i in d) { a[d[i]] = b[i] } for (c = 0; c < g; c++) { if (d[c] == undefined) { e.push(b[c]) } } for (c = 0; c < g; c++) { if (a[c] == undefined) { a[c] = e.shift() } } h.clear(); h.addAll(a); h.resumeEvents() }, updateKey: function (g, h) { var d = this, e = d.map, a = d.indexOfKey(g), c = d.indexMap, b; if (a > -1) { b = e[g]; delete e[g]; delete c[g]; e[h] = b; c[h] = a; d.keys[a] = h; d.indexGeneration = ++d.generation } }, addAll: function (c) { var b = this, a; if (arguments.length > 1 || Ext.isArray(c)) { b.insert(b.length, arguments.length > 1 ? arguments : c) } else { for (a in c) { if (c.hasOwnProperty(a)) { if (b.allowFunctions || typeof c[a] != "function") { b.add(a, c[a]) } } } } }, each: function (e, d) { var b = Ext.Array.push([], this.items), c = 0, a = b.length, g; for (; c < a; c++) { g = b[c]; if (e.call(d || g, g, c, a) === false) { break } } }, eachKey: function (e, d) { var g = this.keys, b = this.items, c = 0, a = g.length; for (; c < a; c++) { e.call(d || window, g[c], b[c], c, a) } }, findBy: function (e, d) { var g = this.keys, b = this.items, c = 0, a = b.length; for (; c < a; c++) { if (e.call(d || window, b[c], g[c])) { return b[c] } } return null }, find: function () { if (Ext.isDefined(Ext.global.console)) { Ext.global.console.warn("Ext.util.MixedCollection: find has been deprecated. Use findBy instead.") } return this.findBy.apply(this, arguments) }, insert: function (b, c, d) { var a; if (Ext.isIterable(c)) { a = this.doInsert(b, c, d) } else { if (arguments.length > 2) { a = this.doInsert(b, [c], [d]) } else { a = this.doInsert(b, [c]) } a = a[0] } return a }, doInsert: function (j, o, n) { var l = this, b, c, g, k = o.length, a = k, e = l.hasListeners.add, d, h = {}, m, q, p; if (n != null) { l.useLinearSearch = true } else { n = o; o = new Array(k); for (g = 0; g < k; g++) { o[g] = this.getKey(n[g]) } } l.suspendEvents(); for (g = 0; g < k; g++) { b = o[g]; c = l.indexOfKey(b); if (c !== -1) { if (c < j) { j-- } l.removeAt(c) } if (b != null) { if (h[b] != null) { m = true; a-- } h[b] = g } } l.resumeEvents(); if (m) { q = o; p = n; o = new Array(a); n = new Array(a); g = 0; for (b in h) { o[g] = q[h[b]]; n[g] = p[h[b]]; g++ } k = a } d = j === l.length && l.indexGeneration === l.generation; Ext.Array.insert(l.items, j, n); Ext.Array.insert(l.keys, j, o); l.length += k; l.generation++; if (d) { l.indexGeneration = l.generation } for (g = 0; g < k; g++ , j++) { b = o[g]; if (b != null) { l.map[b] = n[g]; if (d) { l.indexMap[b] = j } } if (e) { l.fireEvent("add", j, n[g], b) } } return n }, remove: function (d) { var c = this, b, a; if (!c.useLinearSearch && (b = c.getKey(d))) { a = c.indexOfKey(b) } else { a = Ext.Array.indexOf(c.items, d) } return (a === -1) ? false : c.removeAt(a) }, removeAll: function (a) { var c = this, b; if (a || c.hasListeners.remove) { if (a) { for (b = a.length - 1; b >= 0; --b) { c.remove(a[b]) } } else { while (c.length) { c.removeAt(0) } } } else { c.length = c.items.length = c.keys.length = 0; c.map = {}; c.indexMap = {}; c.generation++; c.indexGeneration = c.generation } }, removeAt: function (a) { var c = this, d, b; if (a < c.length && a >= 0) { c.length--; d = c.items[a]; Ext.Array.erase(c.items, a, 1); b = c.keys[a]; if (typeof b != "undefined") { delete c.map[b] } Ext.Array.erase(c.keys, a, 1); if (c.hasListeners.remove) { c.fireEvent("remove", d, b) } c.generation++; return d } return false }, removeRange: function (h, a) { var j = this, b, k, g, e, c, d; if (h < j.length && h >= 0) { if (!a) { a = 1 } e = Math.min(h + a, j.length); a = e - h; d = e === j.length; c = d && j.indexGeneration === j.generation; for (g = h; g < e; g++) { k = j.keys[g]; if (k != null) { delete j.map[k]; if (c) { delete j.indexMap[k] } } } b = j.items[g - 1]; j.length -= a; j.generation++; if (c) { j.indexGeneration = j.generation } if (d) { j.items.length = j.keys.length = j.length } else { j.items.splice(h, a); j.keys.splice(h, a) } return b } return false }, removeAtKey: function (b) { var d = this, c = d.keys, a; if (b == null) { for (a = c.length - 1; a >= 0; a--) { if (c[a] == null) { d.removeAt(a) } } } else { return d.removeAt(d.indexOfKey(b)) } }, getCount: function () { return this.length }, indexOf: function (c) { var b = this, a; if (c != null) { if (!b.useLinearSearch && (a = b.getKey(c))) { return this.indexOfKey(a) } return Ext.Array.indexOf(b.items, c) } return -1 }, indexOfKey: function (a) { if (!this.map.hasOwnProperty(a)) { return -1 } if (this.indexGeneration !== this.generation) { this.rebuildIndexMap() } return this.indexMap[a] }, rebuildIndexMap: function () { var e = this, d = e.indexMap = {}, c = e.keys, a = c.length, b; for (b = 0; b < a; b++) { d[c[b]] = b } e.indexGeneration = e.generation }, get: function (b) { var d = this, a = d.map[b], c = a !== undefined ? a : (typeof b == "number") ? d.items[b] : undefined; return typeof c != "function" || d.allowFunctions ? c : null }, getAt: function (a) { return this.items[a] }, getByKey: function (a) { return this.map[a] }, contains: function (c) { var b = this, a; if (c != null) { if (!b.useLinearSearch && (a = b.getKey(c))) { return this.map[a] != null } return Ext.Array.indexOf(this.items, c) !== -1 } return false }, containsKey: function (a) { return this.map.hasOwnProperty(a) }, clear: function () { var a = this; if (a.generation) { a.length = 0; a.items = []; a.keys = []; a.map = {}; a.indexMap = {}; a.generation++; a.indexGeneration = a.generation } if (a.hasListeners.clear) { a.fireEvent("clear") } }, first: function () { return this.items[0] }, last: function () { return this.items[this.length - 1] }, sum: function (h, b, j, a) { var c = this.extractValues(h, b), g = c.length, e = 0, d; j = j || 0; a = (a || a === 0) ? a : g - 1; for (d = j; d <= a; d++) { e += c[d] } return e }, collect: function (k, e, h) { var l = this.extractValues(k, e), a = l.length, b = {}, c = [], j, g, d; for (d = 0; d < a; d++) { j = l[d]; g = String(j); if ((h || !Ext.isEmpty(j)) && !b[g]) { b[g] = true; c.push(j) } } return c }, extractValues: function (c, a) { var b = this.items; if (a) { b = Ext.Array.pluck(b, a) } return Ext.Array.pluck(b, c) }, hasRange: function (b, a) { return (a < this.length) }, getRange: function (i, b) { var h = this, d = h.items, c = [], a = d.length, g, e; if (a < 1) { return c } if (i > b) { e = true; g = i; i = b; b = g } if (i < 0) { i = 0 } if (b == null || b >= a) { b = a - 1 } c = d.slice(i, b + 1); if (e && c.length) { c.reverse() } return c }, filter: function (d, c, e, a) { var b = []; if (Ext.isString(d)) { b.push(new Ext.util.Filter({ property: d, value: c, anyMatch: e, caseSensitive: a })) } else { if (Ext.isArray(d) || d instanceof Ext.util.Filter) { b = b.concat(d) } } return this.filterBy(Ext.util.Filter.createFilterFn(b)) }, filterBy: function (e, d) { var j = this, a = new j.self(j.initialConfig), h = j.keys, b = j.items, g = b.length, c; a.getKey = j.getKey; for (c = 0; c < g; c++) { if (e.call(d || j, b[c], h[c])) { a.add(h[c], b[c]) } } a.useLinearSearch = j.useLinearSearch; return a }, findIndex: function (c, b, e, d, a) { if (Ext.isEmpty(b, false)) { return -1 } b = this.createValueMatcher(b, d, a); return this.findIndexBy(function (g) { return g && b.test(g[c]) }, null, e) }, findIndexBy: function (e, d, j) { var h = this, g = h.keys, b = h.items, c = j || 0, a = b.length; for (; c < a; c++) { if (e.call(d || h, b[c], g[c])) { return c } } return -1 }, createValueMatcher: function (c, e, a, b) { if (!c.exec) { var d = Ext.String.escapeRegex; c = String(c); if (e === true) { c = d(c) } else { c = "^" + d(c); if (b === true) { c += "$" } } c = new RegExp(c, a ? "" : "i") } return c }, clone: function () { var a = this, b = new a.self(a.initialConfig); b.add(a.keys, a.items); b.useLinearSearch = a.useLinearSearch; return b } }, 1, 0, 0, 0, 0, [["observable", Ext.util.Observable]], [Ext.util, "AbstractMixedCollection"], 0)); (Ext.cmd.derive("Ext.util.Sorter", Ext.Base, { isSorter: true, config: { property: null, sorterFn: null, root: null, transform: null, direction: "ASC", id: undefined }, statics: { createComparator: function (b, a) { a = a || 0; return function (c, j) { var e = b.isCollection ? b.items : b, h = e.length, d, g; for (g = 0; g < h; ++g) { d = e[g].sort(c, j); if (d) { return d } } return a && a(c, j) } } }, multiplier: 1, constructor: function (a) { this.initConfig(a) }, getId: function () { var a = this._id; if (!a) { a = this.getProperty(); if (!a) { a = Ext.id(null, "ext-sorter-") } this._id = a } return a }, sort: function (a, b) { return this.multiplier * this.sortFn(a, b) }, sortFn: function (d, c) { var g = this, e = g._transform, b = g._root, h = g._property, a, i; if (b) { d = d[b]; c = c[b] } a = d[h]; i = c[h]; if (e) { a = e(a); i = e(i) } return (a > i) ? 1 : (a < i ? -1 : 0) }, applyDirection: function (a) { return a ? a : "ASC" }, updateDirection: function (a) { this.multiplier = (a.toUpperCase() === "DESC") ? -1 : 1 }, updateProperty: function (a) { if (a) { delete this.sortFn } }, updateSorterFn: function (a) { this.sortFn = a }, toggle: function () { this.setDirection(Ext.String.toggle(this.getDirection(), "ASC", "DESC")) }, getState: function () { var b = this, a = { root: b.getRoot(), property: b.getProperty(), direction: b.getDirection() }; if (b._id) { a.id = b._id } return a }, serialize: function () { return { property: this.getProperty(), direction: this.getDirection() } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "Sorter"], 0)); (Ext.cmd.derive("Ext.util.Sortable", Ext.Base, { isSortable: true, $configPrefixed: false, $configStrict: false, config: { sorters: null }, defaultSortDirection: "ASC", multiSortLimit: 3, statics: { createComparator: function (a) { return a && a.length ? function (d, c) { var b = a[0].sort(d, c), g = a.length, e = 1; for (; !b && e < g; e++) { b = a[e].sort.call(a[e], d, c) } return b } : function () { return 0 } } }, applySorters: function (c) { var b = this, a = b.getSorters() || new Ext.util.MixedCollection(false, Ext.returnId); if (c) { a.addAll(b.decodeSorters(c)) } return a }, sort: function (h, g, a, e) { var b = this, i, d, c = b.getSorters(); if (!c) { b.setSorters(null); c = b.getSorters() } if (Ext.isArray(h)) { e = a; a = g } else { if (Ext.isObject(h)) { h = [h]; e = a; a = g } else { if (Ext.isString(h)) { i = c.get(h); if (!i) { i = { property: h, direction: g } } else { if (g == null) { i.toggle() } else { i.setDirection(g) } } h = [i] } } } if (h && h.length) { h = b.decodeSorters(h); switch (a) { case "multi": c.insert(0, h[0]); d = c.getCount() - b.multiSortLimit; if (d > 0) { c.removeRange(b.multiSortLimit, d) } break; case "prepend": c.insert(0, h); break; case "append": c.addAll(h); break; case undefined: case null: case "replace": c.clear(); c.addAll(h); break; default: } } if (e !== false) { b.fireEvent("beforesort", b, h); b.onBeforeSort(h); if (b.getSorterCount()) { b.doSort(b.generateComparator()) } } return h }, getSorterCount: function () { return this.getSorters().items.length }, generateComparator: function () { var a = this.getSorters().getRange(); return a.length ? this.createComparator(a) : this.emptyComparator }, emptyComparator: function () { return 0 }, onBeforeSort: Ext.emptyFn, decodeSorters: function (g) { if (!Ext.isArray(g)) { if (g === undefined) { g = [] } else { g = [g] } } var d = g.length, h = Ext.util.Sorter, b = this.getModel ? this.getModel() : this.model, e, a, c; for (c = 0; c < d; c++) { a = g[c]; if (!(a instanceof h)) { if (Ext.isString(a)) { a = { property: a } } Ext.applyIf(a, { root: this.sortRoot, direction: "ASC" }); if (a.fn) { a.sorterFn = a.fn } if (typeof a == "function") { a = { sorterFn: a } } if (b && !a.transform) { e = b.getField(a.property); a.transform = e && e.sortType !== Ext.identityFn ? e.sortType : undefined } g[c] = new Ext.util.Sorter(a) } } return g }, getFirstSorter: function () { var c = this.getSorters().items, a = c.length, b = 0, d; for (; b < a; ++b) { d = c[b]; if (!d.isGrouper) { return d } } return null } }, 0, 0, 0, 0, 0, 0, [Ext.util, "Sortable"], function () { this.prototype.createComparator = this.createComparator })); (Ext.cmd.derive("Ext.util.MixedCollection", Ext.util.AbstractMixedCollection, { constructor: function () { this.initConfig(); Ext.util.AbstractMixedCollection.prototype.constructor.apply(this, arguments) }, doSort: function (a) { this.sortBy(a) }, _sort: function (m, b, l) { var k = this, e, g, d = String(b).toUpperCase() == "DESC" ? -1 : 1, j = [], n = k.keys, h = k.items, a; l = l || function (i, c) { return i - c }; for (e = 0, g = h.length; e < g; e++) { j[j.length] = { key: n[e], value: h[e], index: e } } Ext.Array.sort(j, function (i, c) { return l(i[m], c[m]) * d || (i.index < c.index ? -1 : 1) }); for (e = 0, g = j.length; e < g; e++) { a = j[e]; h[e] = a.value; n[e] = a.key; k.indexMap[a.key] = e } k.generation++; k.indexGeneration = k.generation; k.fireEvent("sort", k) }, sortBy: function (b) { var j = this, a = j.items, h, g = j.keys, d, e = a.length, c; for (c = 0; c < e; c++) { a[c].$extCollectionIndex = c } Ext.Array.sort(a, function (k, i) { return b(k, i) || (k.$extCollectionIndex < i.$extCollectionIndex ? -1 : 1) }); for (c = 0; c < e; c++) { h = a[c]; d = j.getKey(h); g[c] = d; j.indexMap[d] = c; delete h.$extCollectionIndex } j.generation++; j.indexGeneration = j.generation; j.fireEvent("sort", j, a, g) }, findInsertionIndex: function (e, d) { var g = this, b = g.items, i = 0, a = b.length - 1, c, h; if (!d) { d = g.generateComparator() } while (i <= a) { c = (i + a) >> 1; h = d(e, b[c]); if (h >= 0) { i = c + 1 } else { if (h < 0) { a = c - 1 } } } return i }, reorder: function (a) { Ext.util.AbstractMixedCollection.prototype.reorder.call(this, a); this.fireEvent("sort", this) }, sortByKey: function (a, b) { this._sort("key", a, b || function (d, c) { var g = String(d).toUpperCase(), e = String(c).toUpperCase(); return g > e ? 1 : (g < e ? -1 : 0) }) } }, 1, 0, 0, 0, 0, [["sortable", Ext.util.Sortable]], [Ext.util, "MixedCollection"], 0)); (Ext.cmd.derive("Ext.util.TaskRunner", Ext.Base, { interval: 10, timerId: null, constructor: function (a) { var b = this; if (typeof a == "number") { b.interval = a } else { if (a) { Ext.apply(b, a) } } b.tasks = []; b.timerFn = Ext.Function.bind(b.onTick, b) }, newTask: function (b) { var a = new Ext.util.TaskRunner.Task(b); a.manager = this; return a }, start: function (a) { var c = this, b = Ext.Date.now(); if (!a.pending) { c.tasks.push(a); a.pending = true } a.stopped = false; a.taskStartTime = b; a.taskRunTime = a.fireOnStart !== false ? 0 : a.taskStartTime; a.taskRunCount = 0; if (!c.firing) { if (a.fireOnStart !== false) { c.startTimer(0, b) } else { c.startTimer(a.interval, b) } } return a }, stop: function (a) { if (!a.stopped) { a.stopped = true; if (a.onStop) { a.onStop.call(a.scope || a, a) } } return a }, stopAll: function () { Ext.each(this.tasks, this.stop, this) }, firing: false, nextExpires: 1e+99, onTick: function () { var p = this, g = p.tasks, r = p.fireIdleEvent, a = Ext.Date.now(), q = 1e+99, l = g.length, d = Ext.GlobalEvents, c, o, j, b, e, h, n; p.timerId = null; p.firing = true; for (j = 0; j < l || j < (l = g.length); ++j) { b = g[j]; if (!(h = b.stopped)) { c = b.taskRunTime + b.interval; if (c <= a) { e = 1; if (b.hasOwnProperty("fireIdleEvent")) { r = b.fireIdleEvent } else { r = p.fireIdleEvent } b.taskRunCount++; if (b.args) { n = b.addCountToArgs ? b.args.concat([b.taskRunCount]) : b.args } else { n = [b.taskRunCount] } try { e = b.run.apply(b.scope || b, n) } catch (k) { try { if (b.onError) { e = b.onError.call(b.scope || b, b, k) } } catch (m) { } } b.taskRunTime = a; if (e === false || b.taskRunCount === b.repeat) { p.stop(b); h = true } else { h = b.stopped; c = a + b.interval } } if (!h && b.duration && b.duration <= (a - b.taskStartTime)) { p.stop(b); h = true } } if (h) { b.pending = false; if (!o) { o = g.slice(0, j) } } else { if (o) { o.push(b) } if (q > c) { q = c } } } if (o) { p.tasks = o } p.firing = false; if (p.tasks.length) { p.startTimer(q - a, Ext.Date.now()) } if (r !== false && d.hasListeners.idle) { d.fireEvent("idle") } }, startTimer: function (e, c) { var d = this, b = c + e, a = d.timerId; if (a && d.nextExpires - b > d.interval) { clearTimeout(a); a = null } if (!a) { if (e < d.interval) { e = d.interval } d.timerId = Ext.defer(d.timerFn, e); d.nextExpires = b } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "TaskRunner"], function () { var b = this, a = b.prototype; a.destroy = a.stopAll; b.Task = new Ext.Class({ isTask: true, stopped: true, fireOnStart: false, constructor: function (c) { Ext.apply(this, c) }, restart: function (c) { if (c !== undefined) { this.interval = c } this.manager.start(this) }, start: function (c) { if (this.stopped) { this.restart(c) } }, stop: function () { this.manager.stop(this) } }); a = b.Task.prototype; a.destroy = a.stop })); (Ext.cmd.derive("Ext.fx.target.Target", Ext.Base, { isAnimTarget: true, constructor: function (a) { this.target = a; this.id = this.getId() }, getId: function () { return this.target.id }, remove: function () { Ext.destroy(this.target) } }, 1, 0, 0, 0, 0, 0, [Ext.fx.target, "Target"], 0)); (Ext.cmd.derive("Ext.fx.target.Element", Ext.fx.target.Target, { type: "element", getElVal: function (b, a, c) { if (c === undefined) { if (a === "x") { c = b.getX() } else { if (a === "y") { c = b.getY() } else { if (a === "scrollTop") { c = b.getScroll().top } else { if (a === "scrollLeft") { c = b.getScroll().left } else { if (a === "height") { c = b.getHeight() } else { if (a === "width") { c = b.getWidth() } else { c = b.getStyle(a) } } } } } } } return c }, getAttr: function (a, c) { var b = this.target; return [[b, this.getElVal(b, a, c)]] }, setAttr: function (k) { var g = k.length, d, a, h, e, c, b; for (e = 0; e < g; e++) { d = k[e].attrs; for (a in d) { if (d.hasOwnProperty(a)) { b = d[a].length; for (c = 0; c < b; c++) { h = d[a][c]; this.setElVal(h[0], a, h[1]) } } } } }, setElVal: function (b, a, c) { if (a === "x") { b.setX(c) } else { if (a === "y") { b.setY(c) } else { if (a === "scrollTop") { b.scrollTo("top", c) } else { if (a === "scrollLeft") { b.scrollTo("left", c) } else { if (a === "width") { b.setWidth(c) } else { if (a === "height") { b.setHeight(c) } else { b.setStyle(a, c) } } } } } } } }, 0, 0, 0, 0, 0, 0, [Ext.fx.target, "Element"], 0)); (Ext.cmd.derive("Ext.fx.target.ElementCSS", Ext.fx.target.Element, { setAttr: function (p, e) { var s = { attrs: [], duration: [], easing: [] }, m = p.length, n = function () { this.setStyle(Ext.supports.CSS3Prefix + "TransitionProperty", null); this.setStyle(Ext.supports.CSS3Prefix + "TransitionDuration", null); this.setStyle(Ext.supports.CSS3Prefix + "TransitionTimingFunction", null) }, q = { single: true }, g, r, k, l, c, b, h, d, a; for (h = 0; h < m; h++) { r = p[h]; c = r.duration; l = r.easing; r = r.attrs; for (k in r) { if (Ext.Array.indexOf(s.attrs, k) == -1) { s.attrs.push(k.replace(/[A-Z]/g, function (i) { return "-" + i.toLowerCase() })); s.duration.push(c + "ms"); s.easing.push(l) } } } g = s.attrs.join(","); c = s.duration.join(","); l = s.easing.join(", "); for (h = 0; h < m; h++) { r = p[h].attrs; for (k in r) { a = r[k].length; for (d = 0; d < a; d++) { b = r[k][d]; b[0].setStyle(Ext.supports.CSS3Prefix + "TransitionProperty", e ? "" : g); b[0].setStyle(Ext.supports.CSS3Prefix + "TransitionDuration", e ? "" : c); b[0].setStyle(Ext.supports.CSS3Prefix + "TransitionTimingFunction", e ? "" : l); b[0].setStyle(k, b[1]); if (e) { b = b[0].dom.offsetWidth } else { b[0].on(Ext.supports.CSS3TransitionEnd, n, b[0], q) } } } } } }, 0, 0, 0, 0, 0, 0, [Ext.fx.target, "ElementCSS"], 0)); (Ext.cmd.derive("Ext.fx.target.CompositeElement", Ext.fx.target.Element, { isComposite: true, constructor: function (a) { a.id = a.id || Ext.id(null, "ext-composite-"); Ext.fx.target.Element.prototype.constructor.call(this, a) }, getAttr: function (a, j) { var b = [], h = this.target, g = h.elements, e = g.length, c, d; for (c = 0; c < e; c++) { d = g[c]; if (d) { d = h.getElement(d); b.push([d, this.getElVal(d, a, j)]) } } return b }, setAttr: function (n) { var l = this.target, m = n.length, b = l.elements, q = b.length, o, d, p, h, c, g, e, a; for (g = 0; g < m; g++) { p = n[g].attrs; for (h in p) { if (p.hasOwnProperty(h)) { a = p[h].length; for (e = 0; e < a; e++) { o = p[h][e][1]; for (d = 0; d < q; ++d) { c = b[d]; if (c) { c = l.getElement(c); this.setElVal(c, h, o) } } } } } } }, remove: function () { this.target.destroy() } }, 1, 0, 0, 0, 0, 0, [Ext.fx.target, "CompositeElement"], 0)); (Ext.cmd.derive("Ext.fx.target.CompositeElementCSS", Ext.fx.target.CompositeElement, { setAttr: function () { return Ext.fx.target.ElementCSS.prototype.setAttr.apply(this, arguments) } }, 0, 0, 0, 0, 0, 0, [Ext.fx.target, "CompositeElementCSS"], 0)); (Ext.cmd.derive("Ext.fx.target.Sprite", Ext.fx.target.Target, { type: "draw", getFromPrim: function (b, a) { var c; switch (a) { case "rotate": case "rotation": c = b.attr.rotation; return { x: c.x || 0, y: c.y || 0, degrees: c.degrees || 0 }; case "scale": case "scaling": c = b.attr.scaling; return { x: c.x || 1, y: c.y || 1, cx: c.cx || 0, cy: c.cy || 0 }; case "translate": case "translation": c = b.attr.translation; return { x: c.x || 0, y: c.y || 0 }; default: return b.attr[a] } }, getAttr: function (a, b) { return [[this.target, b !== undefined ? b : this.getFromPrim(this.target, a)]] }, setAttr: function (m) { var g = m.length, k = [], b, e, p, r, q, o, n, d, c, l, h, a; for (d = 0; d < g; d++) { b = m[d].attrs; for (e in b) { p = b[e]; a = p.length; for (c = 0; c < a; c++) { q = p[c][0]; r = p[c][1]; if (e === "translate" || e === "translation") { n = { x: r.x, y: r.y } } else { if (e === "rotate" || e === "rotation") { l = r.x; if (isNaN(l)) { l = null } h = r.y; if (isNaN(h)) { h = null } n = { degrees: r.degrees, x: l, y: h } } else { if (e === "scale" || e === "scaling") { l = r.x; if (isNaN(l)) { l = null } h = r.y; if (isNaN(h)) { h = null } n = { x: l, y: h, cx: r.cx, cy: r.cy } } else { if (e === "width" || e === "height" || e === "x" || e === "y") { n = parseFloat(r) } else { n = r } } } } o = Ext.Array.indexOf(k, q); if (o === -1) { k.push([q, {}]); o = k.length - 1 } k[o][1][e] = n } } } g = k.length; for (d = 0; d < g; d++) { k[d][0].setAttributes(k[d][1]) } this.target.redraw() } }, 0, 0, 0, 0, 0, 0, [Ext.fx.target, "Sprite"], 0)); (Ext.cmd.derive("Ext.fx.target.CompositeSprite", Ext.fx.target.Sprite, { getAttr: function (a, h) { var b = [], g = [].concat(this.target.items), e = g.length, d, c; for (d = 0; d < e; d++) { c = g[d]; b.push([c, h !== undefined ? h : this.getFromPrim(c, a)]) } return b } }, 0, 0, 0, 0, 0, 0, [Ext.fx.target, "CompositeSprite"], 0)); (Ext.cmd.derive("Ext.fx.target.Component", Ext.fx.target.Target, { type: "component", getPropMethod: { top: function () { return this.getPosition(true)[1] }, left: function () { return this.getPosition(true)[0] }, x: function () { return this.getPosition()[0] }, y: function () { return this.getPosition()[1] }, height: function () { return this.getHeight() }, width: function () { return this.getWidth() }, opacity: function () { return this.el.getStyle("opacity") } }, setMethods: { top: "setPosition", left: "setPosition", x: "setPagePosition", y: "setPagePosition", height: "setSize", width: "setSize", opacity: "setOpacity" }, getAttr: function (a, b) { return [[this.target, b !== undefined ? b : this.getPropMethod[a].call(this.target)]] }, setAttr: function (s, g, b) { var q = this, p = s.length, v, n, c, k, e, m, d, r, u, l, a = {}, t; for (k = 0; k < p; k++) { v = s[k].attrs; for (n in v) { m = v[n].length; for (e = 0; e < m; e++) { c = v[n][e]; t = a[q.setMethods[n]] || (a[q.setMethods[n]] = {}); t.target = c[0]; t[n] = c[1] } } if (a.setPosition) { c = a.setPosition; d = (c.left === undefined) ? undefined : parseFloat(c.left); r = (c.top === undefined) ? undefined : parseFloat(c.top); c.target.setPosition(d, r) } if (a.setPagePosition) { c = a.setPagePosition; c.target.setPagePosition(c.x, c.y) } if (a.setSize) { c = a.setSize; u = (c.width === undefined) ? c.target.getWidth() : parseFloat(c.width); l = (c.height === undefined) ? c.target.getHeight() : parseFloat(c.height); c.target.el.setSize(u, l); if (b || q.dynamic) { Ext.GlobalEvents.on({ idle: Ext.Function.bind(c.target.setSize, c.target, [u, l]), single: true }) } } if (a.setOpacity) { c = a.setOpacity; c.target.el.setStyle("opacity", c.opacity) } } } }, 0, 0, 0, 0, 0, 0, [Ext.fx.target, "Component"], 0)); (Ext.cmd.derive("Ext.fx.Queue", Ext.Base, { constructor: function () { this.targets = new Ext.util.HashMap(); this.fxQueue = {} }, getFxDefaults: function (a) { var b = this.targets.get(a); if (b) { return b.fxDefaults } return {} }, setFxDefaults: function (a, c) { var b = this.targets.get(a); if (b) { b.fxDefaults = Ext.apply(b.fxDefaults || {}, c) } }, stopAnimation: function (c, b) { var g = this, a = g.getFxQueue(c), e = a.length, d; while (e) { d = a[e - 1]; if (d) { d.end(b) } e-- } }, getActiveAnimation: function (b) { var a = this.getFxQueue(b); return (a && !!a.length) ? a[0] : false }, hasFxBlock: function (b) { var a = this.getFxQueue(b); return a && a[0] && a[0].block }, getFxQueue: function (c) { if (!c) { return false } var d = this, b = d.fxQueue, a = b[c], e = d.targets.get(c); if (!e) { return false } if (!a) { d.fxQueue[c] = b[c] = []; if (e.type !== "element") { e.target.on("destroy", function () { b[c] = null; delete b[c] }) } } return d.fxQueue[c] }, queueFx: function (e) { var d = this, g = e.target, b = g.getId(), a, c; if (!g) { return } a = d.getFxQueue(b); c = a.length; if (c) { if (e.concurrent) { e.paused = false } else { a[c - 1].on("afteranimate", function () { e.paused = false }) } } else { e.paused = false } e.on("afteranimate", function () { Ext.Array.remove(a, e); if (a.length === 0) { d.targets.remove(e.target); d.fxQueue[b] = null; delete d.fxQueue[b] } if (e.remove) { if (g.type === "element") { var h = Ext.get(b); if (h) { h.destroy() } } } }, d, { single: true }); a.push(e) } }, 1, 0, 0, 0, 0, 0, [Ext.fx, "Queue"], 0)); (Ext.cmd.derive("Ext.fx.Manager", Ext.Base, { singleton: true, constructor: function () { var a = this; a.items = new Ext.util.MixedCollection(); a.targetArr = {}; a.mixins.queue.constructor.call(a); a.taskRunner = new Ext.util.TaskRunner() }, interval: 16, forceJS: true, createTarget: function (d) { var b = this, c = !b.forceJS && Ext.supports.Transitions, a; b.useCSS3 = c; if (d) { if (d.tagName || Ext.isString(d) || d.isFly) { d = Ext.get(d); a = new Ext.fx.target["Element" + (c ? "CSS" : "")](d) } else { if (d.dom) { a = new Ext.fx.target["Element" + (c ? "CSS" : "")](d) } else { if (d.isComposite) { a = new Ext.fx.target["CompositeElement" + (c ? "CSS" : "")](d) } else { if (d.isSprite) { a = new Ext.fx.target.Sprite(d) } else { if (d.isCompositeSprite) { a = new Ext.fx.target.CompositeSprite(d) } else { if (d.isComponent) { a = new Ext.fx.target.Component(d) } else { if (d.isAnimTarget) { return d } else { return null } } } } } } } b.targets.add(a); return a } else { return null } }, addAnim: function (d) { var c = this, b = c.items, a = c.task; b.add(d.id, d); if (!a && b.length) { a = c.task = { run: c.runner, interval: c.interval, scope: c }; c.taskRunner.start(a) } }, removeAnim: function (d) { var c = this, b = c.items, a = c.task; b.removeAtKey(d.id); if (a && !b.length) { c.taskRunner.stop(a); delete c.task } }, runner: function () { var d = this, b = d.items.getRange(), c = 0, a = b.length, e; d.targetArr = {}; d.timestamp = new Date(); for (; c < a; c++) { e = b[c]; if (e.isReady()) { d.startAnim(e) } } for (c = 0; c < a; c++) { e = b[c]; if (e.isRunning()) { d.runAnim(e) } } d.applyPendingAttrs(); d.targetArr = null }, startAnim: function (a) { a.start(this.timestamp) }, runAnim: function (e, a) { if (!e) { return } var d = this, h = d.useCSS3 && e.target.type === "element", b = d.timestamp - e.startTime, c = (b >= e.duration), g, i; if (a) { b = e.duration; c = true } g = this.collectTargetData(e, b, h, c); if (h) { e.target.setAttr(g.anims[e.id].attributes, true); d.collectTargetData(e, e.duration, h, c); e.paused = true; g = e.target.target; if (e.target.isComposite) { g = e.target.target.last() } i = {}; i[Ext.supports.CSS3TransitionEnd] = e.lastFrame; i.scope = e; i.single = true; g.on(i) } return g }, jumpToEnd: function (c) { var b = this, d, a; if (!b.targetArr) { b.targetArr = {}; a = true } d = b.runAnim(c, true); b.applyAnimAttrs(d, d.anims[c.id]); if (a) { b.targetArr = null } }, collectTargetData: function (c, a, e, g) { var b = c.target.getId(), d = this.targetArr[b]; if (!d) { d = this.targetArr[b] = { id: b, el: c.target, anims: {} } } d.anims[c.id] = { id: c.id, anim: c, elapsed: a, isLastFrame: g, attributes: [{ duration: c.duration, easing: (e && c.reverse) ? c.easingFn.reverse().toCSS3() : c.easing, attrs: c.runAnim(a) }] }; return d }, applyAnimAttrs: function (c, a) { var b = a.anim; if (a.attributes && b.isRunning()) { c.el.setAttr(a.attributes, false, a.isLastFrame); if (a.isLastFrame) { b.lastFrame() } } }, applyPendingAttrs: function () { var e = this.targetArr, g, c, b, d, a; for (c in e) { if (e.hasOwnProperty(c)) { g = e[c]; for (a in g.anims) { if (g.anims.hasOwnProperty(a)) { b = g.anims[a]; d = b.anim; if (b.attributes && d.isRunning()) { g.el.setAttr(b.attributes, false, b.isLastFrame); if (b.isLastFrame) { d.lastFrame() } } } } } } } }, 1, 0, 0, 0, 0, [["queue", Ext.fx.Queue]], [Ext.fx, "Manager"], 0)); (Ext.cmd.derive("Ext.fx.Animator", Ext.Base, { isAnimator: true, duration: 250, delay: 0, delayStart: 0, dynamic: false, easing: "ease", running: false, paused: false, damper: 1, iterations: 1, currentIteration: 0, keyframeStep: 0, animKeyFramesRE: /^(from|to|\d+%?)$/, constructor: function (a) { var b = this; a = Ext.apply(b, a || {}); b.config = a; b.id = Ext.id(null, "ext-animator-"); b.mixins.observable.constructor.call(b, a); b.timeline = []; b.createTimeline(b.keyframes); if (b.target) { b.applyAnimator(b.target); Ext.fx.Manager.addAnim(b) } }, sorter: function (d, c) { return d.pct - c.pct }, createTimeline: function (d) { var h = this, l = [], j = h.to || {}, b = h.duration, m, a, c, g, k, e; for (k in d) { if (d.hasOwnProperty(k) && h.animKeyFramesRE.test(k)) { e = { attrs: Ext.apply(d[k], j) }; if (k === "from") { k = 0 } else { if (k === "to") { k = 100 } } e.pct = parseInt(k, 10); l.push(e) } } Ext.Array.sort(l, h.sorter); g = l.length; for (c = 0; c < g; c++) { m = (l[c - 1]) ? b * (l[c - 1].pct / 100) : 0; a = b * (l[c].pct / 100); h.timeline.push({ duration: a - m, attrs: l[c].attrs }) } }, applyAnimator: function (d) { var h = this, j = [], l = h.timeline, g = l.length, b, e, a, k, c; if (h.fireEvent("beforeanimate", h) !== false) { for (c = 0; c < g; c++) { b = l[c]; k = b.attrs; e = k.easing || h.easing; a = k.damper || h.damper; delete k.easing; delete k.damper; b = new Ext.fx.Anim({ target: d, easing: e, damper: a, duration: b.duration, paused: true, to: k }); j.push(b) } h.animations = j; h.target = b.target; for (c = 0; c < g - 1; c++) { b = j[c]; b.nextAnim = j[c + 1]; b.on("afteranimate", function () { this.nextAnim.paused = false }); b.on("afteranimate", function () { this.fireEvent("keyframe", this, ++this.keyframeStep) }, h) } j[g - 1].on("afteranimate", function () { this.lastFrame() }, h) } }, start: function (d) { var e = this, c = e.delay, b = e.delayStart, a; if (c) { if (!b) { e.delayStart = d; return } else { a = d - b; if (a < c) { return } else { d = new Date(b.getTime() + c) } } } if (e.fireEvent("beforeanimate", e) !== false) { e.startTime = d; e.running = true; e.animations[e.keyframeStep].paused = false } }, lastFrame: function () { var c = this, a = c.iterations, b = c.currentIteration; b++; if (b < a) { c.startTime = new Date(); c.currentIteration = b; c.keyframeStep = 0; c.applyAnimator(c.target); c.animations[c.keyframeStep].paused = false } else { c.currentIteration = 0; c.end() } }, end: function () { var a = this; a.fireEvent("afteranimate", a, a.startTime, new Date() - a.startTime) }, isReady: function () { return this.paused === false && this.running === false && this.iterations > 0 }, isRunning: function () { return false } }, 1, 0, 0, 0, 0, [["observable", Ext.util.Observable]], [Ext.fx, "Animator"], 0)); (Ext.cmd.derive("Ext.fx.CubicBezier", Ext.Base, { singleton: true, cubicBezierAtTime: function (o, d, b, n, m, i) { var j = 3 * d, l = 3 * (n - d) - j, a = 1 - j - l, h = 3 * b, k = 3 * (m - b) - h, p = 1 - h - k; function g(q) { return ((a * q + l) * q + j) * q } function c(q, s) { var r = e(q, s); return ((p * r + k) * r + h) * r } function e(q, y) { var w, v, t, r, u, s; for (t = q, s = 0; s < 8; s++) { r = g(t) - q; if (Math.abs(r) < y) { return t } u = (3 * a * t + 2 * l) * t + j; if (Math.abs(u) < 0.000001) { break } t = t - r / u } w = 0; v = 1; t = q; if (t < w) { return w } if (t > v) { return v } while (w < v) { r = g(t); if (Math.abs(r - q) < y) { return t } if (q > r) { w = t } else { v = t } t = (v - w) / 2 + w } return t } return c(o, 1 / (200 * i)) }, cubicBezier: function (b, e, a, c) { var d = function (g) { return Ext.fx.CubicBezier.cubicBezierAtTime(g, b, e, a, c, 1) }; d.toCSS3 = function () { return "cubic-bezier(" + [b, e, a, c].join(",") + ")" }; d.reverse = function () { return Ext.fx.CubicBezier.cubicBezier(1 - a, 1 - c, 1 - b, 1 - e) }; return d } }, 0, 0, 0, 0, 0, 0, [Ext.fx, "CubicBezier"], 0)); (Ext.cmd.derive("Ext.fx.Easing", Ext.Base, function () { var e = Math, h = e.PI, d = e.pow, b = e.sin, g = e.sqrt, a = e.abs, c = 1.70158; return { singleton: true, linear: Ext.identityFn, ease: function (r) { var l = 0.07813 - r / 2, k = g(0.0066 + l * l), i = k - l, p = d(a(i), 1 / 3) * (i < 0 ? -1 : 1), o = -k - l, m = d(a(o), 1 / 3) * (o < 0 ? -1 : 1), j = p + m + 0.25; return d(1 - j, 2) * 3 * j * 0.1 + (1 - j) * 3 * j * j + j * j * j }, easeIn: function (i) { return d(i, 1.7) }, easeOut: function (i) { return d(i, 0.48) }, easeInOut: function (r) { var l = 0.48 - r / 1.04, k = g(0.1734 + l * l), i = k - l, p = d(a(i), 1 / 3) * (i < 0 ? -1 : 1), o = -k - l, m = d(a(o), 1 / 3) * (o < 0 ? -1 : 1), j = p + m + 0.5; return (1 - j) * 3 * j * j + j * j * j }, backIn: function (i) { return i * i * ((c + 1) * i - c) }, backOut: function (i) { i = i - 1; return i * i * ((c + 1) * i + c) + 1 }, elasticIn: function (k) { if (k === 0 || k === 1) { return k } var j = 0.3, i = j / 4; return d(2, -10 * k) * b((k - i) * (2 * h) / j) + 1 }, elasticOut: function (i) { return 1 - Ext.fx.Easing.elasticIn(1 - i) }, bounceIn: function (i) { return 1 - Ext.fx.Easing.bounceOut(1 - i) }, bounceOut: function (m) { var j = 7.5625, k = 2.75, i; if (m < (1 / k)) { i = j * m * m } else { if (m < (2 / k)) { m -= (1.5 / k); i = j * m * m + 0.75 } else { if (m < (2.5 / k)) { m -= (2.25 / k); i = j * m * m + 0.9375 } else { m -= (2.625 / k); i = j * m * m + 0.984375 } } } return i } } }, 0, 0, 0, 0, 0, 0, [Ext.fx, "Easing"], function (b) { var c = b.self, a = c.prototype; c.addMembers({ "back-in": a.backIn, "back-out": a.backOut, "ease-in": a.easeIn, "ease-out": a.easeOut, "elastic-in": a.elasticIn, "elastic-out": a.elasticOut, "bounce-in": a.bounceIn, "bounce-out": a.bounceOut, "ease-in-out": a.easeInOut }) })); (Ext.cmd.derive("Ext.fx.DrawPath", Ext.Base, { singleton: true, pathToStringRE: /,?([achlmqrstvxz]),?/gi, pathCommandRE: /([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig, pathValuesRE: /(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig, stopsRE: /^(\d+%?)$/, radian: Math.PI / 180, is: function (b, a) { a = String(a).toLowerCase(); return (a == "object" && b === Object(b)) || (a == "undefined" && typeof b == a) || (a == "null" && b === null) || (a == "array" && Array.isArray && Array.isArray(b)) || (Object.prototype.toString.call(b).toLowerCase().slice(8, -1)) == a }, path2string: function () { return this.join(",").replace(Ext.fx.DrawPath.pathToStringRE, "$1") }, pathToString: function (a) { return a.join(",").replace(Ext.fx.DrawPath.pathToStringRE, "$1") }, parsePathString: function (a) { if (!a) { return null } var d = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, c = [], b = this; if (b.is(a, "array") && b.is(a[0], "array")) { c = b.pathClone(a) } if (!c.length) { String(a).replace(b.pathCommandRE, function (g, e, j) { var i = [], h = e.toLowerCase(); j.replace(b.pathValuesRE, function (l, k) { if (k) { i.push(+k) } }); if (h == "m" && i.length > 2) { c.push([e].concat(Ext.Array.splice(i, 0, 2))); h = "l"; e = (e == "m") ? "l" : "L" } while (i.length >= d[h]) { c.push([e].concat(Ext.Array.splice(i, 0, d[h]))); if (!d[h]) { break } } }) } c.toString = b.path2string; return c }, pathClone: function (g) { var c = [], a, e, b, d; if (!this.is(g, "array") || !this.is(g && g[0], "array")) { g = this.parsePathString(g) } for (b = 0, d = g.length; b < d; b++) { c[b] = []; for (a = 0, e = g[b].length; a < e; a++) { c[b][a] = g[b][a] } } c.toString = this.path2string; return c }, pathToAbsolute: function (c) { if (!this.is(c, "array") || !this.is(c && c[0], "array")) { c = this.parsePathString(c) } var k = [], m = 0, l = 0, o = 0, n = 0, g = 0, h = c.length, b, d, e, a; if (h && c[0][0] == "M") { m = +c[0][1]; l = +c[0][2]; o = m; n = l; g++; k[0] = ["M", m, l] } for (; g < h; g++) { b = k[g] = []; d = c[g]; if (d[0] != d[0].toUpperCase()) { b[0] = d[0].toUpperCase(); switch (b[0]) { case "A": b[1] = d[1]; b[2] = d[2]; b[3] = d[3]; b[4] = d[4]; b[5] = d[5]; b[6] = +(d[6] + m); b[7] = +(d[7] + l); break; case "V": b[1] = +d[1] + l; break; case "H": b[1] = +d[1] + m; break; case "M": o = +d[1] + m; n = +d[2] + l; default: e = 1; a = d.length; for (; e < a; e++) { b[e] = +d[e] + ((e % 2) ? m : l) } } } else { e = 0; a = d.length; for (; e < a; e++) { k[g][e] = d[e] } } switch (b[0]) { case "Z": m = o; l = n; break; case "H": m = b[1]; break; case "V": l = b[1]; break; case "M": d = k[g]; a = d.length; o = d[a - 2]; n = d[a - 1]; default: d = k[g]; a = d.length; m = d[a - 2]; l = d[a - 1] } } k.toString = this.path2string; return k }, interpolatePaths: function (r, l) { var j = this, d = j.pathToAbsolute(r), m = j.pathToAbsolute(l), n = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, a = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, b = function (p, s) { if (p[s].length > 7) { p[s].shift(); var t = p[s]; while (t.length) { Ext.Array.splice(p, s++, 0, ["C"].concat(Ext.Array.splice(t, 0, 6))) } Ext.Array.erase(p, s, 1); o = Math.max(d.length, m.length || 0) } }, c = function (v, u, s, p, t) { if (v && u && v[t][0] == "M" && u[t][0] != "M") { Ext.Array.splice(u, t, 0, ["M", p.x, p.y]); s.bx = 0; s.by = 0; s.x = v[t][1]; s.y = v[t][2]; o = Math.max(d.length, m.length || 0) } }, h, o, g, q, e, k; for (h = 0, o = Math.max(d.length, m.length || 0); h < o; h++) { d[h] = j.command2curve(d[h], n); b(d, h); (m[h] = j.command2curve(m[h], a)); b(m, h); c(d, m, n, a, h); c(m, d, a, n, h); g = d[h]; q = m[h]; e = g.length; k = q.length; n.x = g[e - 2]; n.y = g[e - 1]; n.bx = parseFloat(g[e - 4]) || n.x; n.by = parseFloat(g[e - 3]) || n.y; a.bx = (parseFloat(q[k - 4]) || a.x); a.by = (parseFloat(q[k - 3]) || a.y); a.x = q[k - 2]; a.y = q[k - 1] } return [d, m] }, command2curve: function (c, b) { var a = this; if (!c) { return ["C", b.x, b.y, b.x, b.y, b.x, b.y] } if (c[0] != "T" && c[0] != "Q") { b.qx = b.qy = null } switch (c[0]) { case "M": b.X = c[1]; b.Y = c[2]; break; case "A": c = ["C"].concat(a.arc2curve.apply(a, [b.x, b.y].concat(c.slice(1)))); break; case "S": c = ["C", b.x + (b.x - (b.bx || b.x)), b.y + (b.y - (b.by || b.y))].concat(c.slice(1)); break; case "T": b.qx = b.x + (b.x - (b.qx || b.x)); b.qy = b.y + (b.y - (b.qy || b.y)); c = ["C"].concat(a.quadratic2curve(b.x, b.y, b.qx, b.qy, c[1], c[2])); break; case "Q": b.qx = c[1]; b.qy = c[2]; c = ["C"].concat(a.quadratic2curve(b.x, b.y, c[1], c[2], c[3], c[4])); break; case "L": c = ["C"].concat(b.x, b.y, c[1], c[2], c[1], c[2]); break; case "H": c = ["C"].concat(b.x, b.y, c[1], b.y, c[1], b.y); break; case "V": c = ["C"].concat(b.x, b.y, b.x, c[1], b.x, c[1]); break; case "Z": c = ["C"].concat(b.x, b.y, b.X, b.Y, b.X, b.Y); break }return c }, quadratic2curve: function (b, d, h, e, a, c) { var g = 1 / 3, i = 2 / 3; return [g * b + i * h, g * d + i * e, g * a + i * h, g * c + i * e, a, c] }, rotate: function (b, h, a) { var d = Math.cos(a), c = Math.sin(a), g = b * d - h * c, e = b * c + h * d; return { x: g, y: e } }, arc2curve: function (s, af, H, F, z, n, g, r, ae, A) { var v = this, d = Math.PI, w = v.radian, E = d * 120 / 180, b = w * (+z || 0), M = [], J = Math, T = J.cos, a = J.sin, V = J.sqrt, u = J.abs, o = J.asin, I, O, N, aa, c, R, U, C, B, m, l, q, j, ad, e, ac, P, S, Q, ab, Z, Y, W, L, X, K, D, G, p; if (!A) { I = v.rotate(s, af, -b); s = I.x; af = I.y; I = v.rotate(r, ae, -b); r = I.x; ae = I.y; O = (s - r) / 2; N = (af - ae) / 2; aa = (O * O) / (H * H) + (N * N) / (F * F); if (aa > 1) { aa = V(aa); H = aa * H; F = aa * F } c = H * H; R = F * F; U = (n == g ? -1 : 1) * V(u((c * R - c * N * N - R * O * O) / (c * N * N + R * O * O))); C = U * H * N / F + (s + r) / 2; B = U * -F * O / H + (af + ae) / 2; m = o(((af - B) / F).toFixed(7)); l = o(((ae - B) / F).toFixed(7)); m = s < C ? d - m : m; l = r < C ? d - l : l; if (m < 0) { m = d * 2 + m } if (l < 0) { l = d * 2 + l } if (g && m > l) { m = m - d * 2 } if (!g && l > m) { l = l - d * 2 } } else { m = A[0]; l = A[1]; C = A[2]; B = A[3] } q = l - m; if (u(q) > E) { D = l; G = r; p = ae; l = m + E * (g && l > m ? 1 : -1); r = C + H * T(l); ae = B + F * a(l); M = v.arc2curve(r, ae, H, F, z, 0, g, G, p, [l, D, C, B]) } q = l - m; j = T(m); ad = a(m); e = T(l); ac = a(l); P = J.tan(q / 4); S = 4 / 3 * H * P; Q = 4 / 3 * F * P; ab = [s, af]; Z = [s + S * ad, af - Q * j]; Y = [r + S * ac, ae - Q * e]; W = [r, ae]; Z[0] = 2 * ab[0] - Z[0]; Z[1] = 2 * ab[1] - Z[1]; if (A) { return [Z, Y, W].concat(M) } else { M = [Z, Y, W].concat(M).join().split(","); L = []; K = M.length; for (X = 0; X < K; X++) { L[X] = X % 2 ? v.rotate(M[X - 1], M[X], b).y : v.rotate(M[X], M[X + 1], b).x } return L } } }, 0, 0, 0, 0, 0, 0, [Ext.fx, "DrawPath"], 0)); (Ext.cmd.derive("Ext.fx.PropertyHandler", Ext.Base, { statics: { defaultHandler: { pixelDefaultsRE: /width|height|top$|bottom$|left$|right$/i, unitRE: /^(-?\d*\.?\d*){1}(em|ex|px|in|cm|mm|pt|pc|%)*$/, scrollRE: /^scroll/i, computeDelta: function (j, c, a, g, i) { a = (typeof a == "number") ? a : 1; var h = this.unitRE, d = h.exec(j), b, e; if (d) { j = d[1]; e = d[2]; if (!this.scrollRE.test(i) && !e && this.pixelDefaultsRE.test(i)) { e = "px" } } j = +j || 0; d = h.exec(c); if (d) { c = d[1]; e = d[2] || e } c = +c || 0; b = (g != null) ? g : j; return { from: j, delta: (c - b) * a, units: e } }, get: function (o, b, a, n, k) { var m = o.length, d = [], e, h, l, c, g; for (e = 0; e < m; e++) { if (n) { h = n[e][1].from } if (Ext.isArray(o[e][1]) && Ext.isArray(b)) { l = []; c = 0; g = o[e][1].length; for (; c < g; c++) { l.push(this.computeDelta(o[e][1][c], b[c], a, h, k)) } d.push([o[e][0], l]) } else { d.push([o[e][0], this.computeDelta(o[e][1], b, a, h, k)]) } } return d }, set: function (l, g) { var h = l.length, c = [], d, a, k, e, b; for (d = 0; d < h; d++) { a = l[d][1]; if (Ext.isArray(a)) { k = []; b = 0; e = a.length; for (; b < e; b++) { k.push(a[b].from + a[b].delta * g + (a[b].units || 0)) } c.push([l[d][0], k]) } else { c.push([l[d][0], a.from + a.delta * g + (a.units || 0)]) } } return c } }, stringHandler: { computeDelta: function (e, b, d, c, a) { return { from: e, delta: b } }, get: function (k, b, a, j, g) { var h = k.length, c = [], d, e; for (d = 0; d < h; d++) { c.push([k[d][0], this.computeDelta(k[d][1], b, a, e, g)]) } return c }, set: function (a, g) { var d = a.length, b = [], c, e; for (c = 0; c < d; c++) { e = a[c][1]; b.push([a[c][0], e.delta]) } return b } }, color: { rgbRE: /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i, hexRE: /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i, hex3RE: /^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i, parseColor: function (e, a) { a = (typeof a == "number") ? a : 1; var g = false, c = [this.hexRE, this.rgbRE, this.hex3RE], d = c.length, j, b, k, h; for (h = 0; h < d; h++) { k = c[h]; b = (h % 2 === 0) ? 16 : 10; j = k.exec(e); if (j && j.length === 4) { if (h === 2) { j[1] += j[1]; j[2] += j[2]; j[3] += j[3] } g = { red: parseInt(j[1], b), green: parseInt(j[2], b), blue: parseInt(j[3], b) }; break } } return g || e }, computeDelta: function (h, a, e, c) { h = this.parseColor(h); a = this.parseColor(a, e); var g = c ? c : h, b = typeof g, d = typeof a; if (b === "string" || b === "undefined" || d === "string" || d === "undefined") { return a || g } return { from: h, delta: { red: Math.round((a.red - g.red) * e), green: Math.round((a.green - g.green) * e), blue: Math.round((a.blue - g.blue) * e) } } }, get: function (j, a, g, d) { var h = j.length, c = [], e, b; for (e = 0; e < h; e++) { if (d) { b = d[e][1].from } c.push([j[e][0], this.computeDelta(j[e][1], a, g, b)]) } return c }, set: function (k, e) { var g = k.length, c = [], d, b, a, h, j; for (d = 0; d < g; d++) { b = k[d][1]; if (b) { h = b.from; j = b.delta; b = (typeof b === "object" && "red" in b) ? "rgb(" + b.red + ", " + b.green + ", " + b.blue + ")" : b; b = (typeof b === "object" && b.length) ? b[0] : b; if (typeof b === "undefined") { return [] } a = typeof b === "string" ? b : "rgb(" + [(h.red + Math.round(j.red * e)) % 256, (h.green + Math.round(j.green * e)) % 256, (h.blue + Math.round(j.blue * e)) % 256].join(",") + ")"; c.push([k[d][0], a]) } } return c } }, object: { interpolate: function (d, b) { b = (typeof b === "number") ? b : 1; var a = {}, c; for (c in d) { a[c] = parseFloat(d[c]) * b } return a }, computeDelta: function (h, a, c, b) { h = this.interpolate(h); a = this.interpolate(a, c); var g = b ? b : h, e = {}, d; for (d in a) { e[d] = a[d] - g[d] } return { from: h, delta: e } }, get: function (j, a, g, d) { var h = j.length, c = [], e, b; for (e = 0; e < h; e++) { if (d) { b = d[e][1].from } c.push([j[e][0], this.computeDelta(j[e][1], a, g, b)]) } return c }, set: function (l, g) { var h = l.length, c = [], e = {}, d, j, k, b, a; for (d = 0; d < h; d++) { b = l[d][1]; j = b.from; k = b.delta; for (a in j) { e[a] = j[a] + k[a] * g } c.push([l[d][0], e]) } return c } }, path: { computeDelta: function (e, a, c, b) { c = (typeof c === "number") ? c : 1; var d; e = +e || 0; a = +a || 0; d = (b != null) ? b : e; return { from: e, delta: (a - d) * c } }, forcePath: function (a) { if (!Ext.isArray(a) && !Ext.isArray(a[0])) { a = Ext.fx.DrawPath.parsePathString(a) } return a }, get: function (b, l, a, q) { var c = this.forcePath(l), n = [], s = b.length, d, h, o, g, p, m, e, t, r; for (o = 0; o < s; o++) { r = this.forcePath(b[o][1]); g = Ext.fx.DrawPath.interpolatePaths(r, c); r = g[0]; c = g[1]; d = r.length; t = []; for (m = 0; m < d; m++) { g = [r[m][0]]; h = r[m].length; for (e = 1; e < h; e++) { p = q && q[0][1][m][e].from; g.push(this.computeDelta(r[m][e], c[m][e], a, p)) } t.push(g) } n.push([b[o][0], t]) } return n }, set: function (p, n) { var o = p.length, e = [], h, g, d, l, m, c, a, b; for (h = 0; h < o; h++) { c = p[h][1]; l = []; a = c.length; for (g = 0; g < a; g++) { m = [c[g][0]]; b = c[g].length; for (d = 1; d < b; d++) { m.push(c[g][d].from + c[g][d].delta * n) } l.push(m.join(",")) } e.push([p[h][0], l.join(",")]) } return e } } } }, 0, 0, 0, 0, 0, 0, [Ext.fx, "PropertyHandler"], function () { var b = ["outlineColor", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "fill", "stroke"], c = b.length, a = 0, d; for (; a < c; a++) { d = b[a]; this[d] = this.color } b = ["cursor"]; c = b.length; a = 0; for (; a < c; a++) { d = b[a]; this[d] = this.stringHandler } })); (Ext.cmd.derive("Ext.fx.Anim", Ext.Base, { isAnimation: true, duration: 250, delay: 0, delayStart: 0, dynamic: false, easing: "ease", damper: 1, bezierRE: /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/, reverse: false, running: false, paused: false, iterations: 1, autoEnd: false, alternate: false, currentIteration: 0, startTime: 0, frameCount: 0, constructor: function (a) { var b = this, c; a = a || {}; if (a.keyframes) { return new Ext.fx.Animator(a) } Ext.apply(b, a); if (b.from === undefined) { b.from = {} } b.propHandlers = {}; b.config = a; b.target = Ext.fx.Manager.createTarget(b.target); b.easingFn = Ext.fx.Easing[b.easing]; b.target.dynamic = b.dynamic; if (!b.easingFn) { b.easingFn = String(b.easing).match(b.bezierRE); if (b.easingFn && b.easingFn.length === 5) { c = b.easingFn; b.easingFn = Ext.fx.CubicBezier.cubicBezier(+c[1], +c[2], +c[3], +c[4]) } } b.id = Ext.id(null, "ext-anim-"); b.mixins.observable.constructor.call(b); Ext.fx.Manager.addAnim(b); if (a.autoEnd) { b.running = true; b.jumpToEnd() } }, setAttr: function (a, b) { return Ext.fx.Manager.items.get(this.id).setAttr(this.target, a, b) }, initAttrs: function () { var e = this, h = e.from, i = e.to, g = e.initialFrom || {}, c = {}, a, b, j, d; for (d in i) { if (i.hasOwnProperty(d)) { a = e.target.getAttr(d, h[d]); b = i[d]; if (!Ext.fx.PropertyHandler[d]) { if (Ext.isObject(b)) { j = e.propHandlers[d] = Ext.fx.PropertyHandler.object } else { j = e.propHandlers[d] = Ext.fx.PropertyHandler.defaultHandler } } else { j = e.propHandlers[d] = Ext.fx.PropertyHandler[d] } c[d] = j.get(a, b, e.damper, g[d], d) } } e.currentAttrs = c }, start: function (d) { var e = this, c = e.delay, b = e.delayStart, a; if (c) { if (!b) { e.delayStart = d; return } else { a = d - b; if (a < c) { return } else { d = new Date(b.getTime() + c) } } } if (e.fireEvent("beforeanimate", e) !== false) { e.startTime = d; if (!e.paused && !e.currentAttrs) { e.initAttrs() } e.running = true; e.frameCount = 0 } }, jumpToEnd: function () { var a = this; if (!a.endWasCalled) { if (!a.currentAttrs) { a.initAttrs() } Ext.fx.Manager.jumpToEnd(a); a.end() } }, runAnim: function (l) { var i = this, k = i.currentAttrs, d = i.duration, c = i.easingFn, b = i.propHandlers, g = {}, h, j, e, a; if (l >= d) { l = d; a = true } if (i.reverse) { l = d - l } for (e in k) { if (k.hasOwnProperty(e)) { j = k[e]; h = a ? 1 : c(l / d); g[e] = b[e].set(j, h) } } i.frameCount++; return g }, lastFrame: function () { var c = this, a = c.iterations, b = c.currentIteration; b++; if (b < a) { if (c.alternate) { c.reverse = !c.reverse } c.startTime = new Date(); c.currentIteration = b; c.paused = false } else { c.currentIteration = 0; c.end(); c.fireEvent("lastframe", c, c.startTime) } }, endWasCalled: 0, end: function (a) { var b = this; if (b.endWasCalled++) { return } b.startTime = 0; b.paused = false; b.running = false; Ext.fx.Manager.removeAnim(b); if (!a) { b.fireEvent("afteranimate", b, b.startTime); Ext.callback(b.callback, b.scope, [b, b.startTime]) } if (b.remove) { b.target.destroy() } }, isReady: function () { return this.paused === false && this.running === false && this.iterations > 0 }, isRunning: function () { return this.paused === false && this.running === true && this.isAnimator !== true } }, 1, 0, 0, 0, 0, [["observable", Ext.util.Observable]], [Ext.fx, "Anim"], 0)); Ext.enableFx = true; (Ext.cmd.derive("Ext.util.Animate", Ext.Base, { mixinId: "animate", isAnimate: true, animate: function (a) { var b = this; if (Ext.fx.Manager.hasFxBlock(b.id)) { return b } Ext.fx.Manager.queueFx(new Ext.fx.Anim(b.anim(a))); return this }, anim: function (a) { if (!Ext.isObject(a)) { return (a) ? {} : false } var b = this; if (a.stopAnimation) { b.stopAnimation() } Ext.applyIf(a, Ext.fx.Manager.getFxDefaults(b.id)); return Ext.apply({ target: b, paused: true }, a) }, getAnimationProps: function () { var b = this, a = b.layout; return a && a.animate ? a.animate : {} }, stopFx: Ext.Function.alias(Ext.util.Animate, "stopAnimation"), stopAnimation: function (a) { Ext.fx.Manager.stopAnimation(this.id, a); return this }, syncFx: function () { Ext.fx.Manager.setFxDefaults(this.id, { concurrent: true }); return this }, sequenceFx: function () { Ext.fx.Manager.setFxDefaults(this.id, { concurrent: false }); return this }, hasActiveFx: Ext.Function.alias(Ext.util.Animate, "getActiveAnimation"), getActiveAnimation: function () { return Ext.fx.Manager.getActiveAnimation(this.id) } }, 0, 0, 0, 0, 0, 0, [Ext.util, "Animate"], 0)); (Ext.cmd.derive("Ext.dom.Fly", Ext.dom.Element, { alternateClassName: "Ext.dom.Element.Fly", validNodeTypes: { 1: 1, 9: 1, 11: 1 }, isFly: true, constructor: function (a) { this.dom = a; this.el = this }, attach: function (b) { var a = this; if (!b) { return a.detach() } a.dom = b; if (!Ext.cache[b.id]) { a.getData().isSynchronized = false } return a }, detach: function () { this.dom = null }, addListener: null, removeListener: null }, 1, 0, 0, 0, 0, 0, [Ext.dom, "Fly", Ext.dom.Element, "Fly"], function (a) { var b = {}, c; a.cache = b; Ext.fly = function (j, e) { var h = null, g = Ext.fly, d, i; e = e || (g.caller && g.caller.$name) || "_global"; j = Ext.getDom(j); if (j) { d = j.nodeType; if (a.prototype.validNodeTypes[d] || (!d && (j.window == j))) { h = Ext.cache[j.id]; if (!h || h.dom !== j) { h = b[e] || (b[e] = new a()); h.dom = j; i = h.getData(true); if (i) { i.isSynchronized = false } } } } return h }; Ext.getDetachedBody = function () { if (!c) { Ext.detachedBodyEl = c = new a(document.createElement("div")); c.isDetachedBody = true } return c } })); (Ext.cmd.derive("Ext.dom.CompositeElementLite", Ext.Base, { alternateClassName: ["Ext.CompositeElementLite"], isComposite: true, isLite: true, statics: { importElementMethods: function () { var a = Ext.dom.Element, b = this.prototype; Ext.Object.each(a.prototype, function (c, d) { if (typeof d === "function" && !b[c]) { b[c] = function () { return this.invoke(c, arguments) } } }) } }, constructor: function (b, a) { if (a) { this.elements = b || [] } else { this.elements = []; this.add(b) } }, getElement: function (b) { var a = this._fly || (this._fly = new Ext.dom.Fly()); return a.attach(b) }, transformElement: function (a) { return Ext.getDom(a) }, getCount: function () { return this.elements.length }, add: function (c, a) { var e = this.elements, b, d; if (!c) { return this } if (typeof c == "string") { c = Ext.fly(a || document).query(c) } else { if (c.isComposite) { c = c.elements } else { if (!Ext.isIterable(c)) { c = [c] } } } for (b = 0, d = c.length; b < d; ++b) { e.push(this.transformElement(c[b])) } return this }, invoke: function (e, b) { var h = this, j = h.elements, g = j.length, a, d, c; if (c !== 0) { a = (h.isLite ? Ext.dom.Fly : Ext.dom.Element).prototype; for (c = 0; c < g; c++) { d = j[c]; if (d) { a[e].apply(h.getElement(d), b) } } } return h }, item: function (b) { var c = this.elements[b], a = null; if (c) { a = this.getElement(c) } return a }, slice: function (b, a) { return Ext.Array.slice(this.elements, b, a) }, each: function (g, d) { var h = this, c = h.elements, a = c.length, b, j; for (b = 0; b < a; b++) { j = c[b]; if (j) { j = this.getElement(j); if (g.call(d || j, j, h, b) === false) { break } } } return h }, fill: function (a) { var b = this; b.elements = []; b.add(a); return b }, insert: function (b, a) { Ext.Array.insert(this.elements, b, a) }, filter: function (b) { var h = this, c = h.elements, g = c.length, d = [], e = 0, j = typeof b == "function", k, a; for (; e < g; e++) { a = c[e]; k = false; if (a) { a = h.getElement(a); if (j) { k = b.call(a, a, h, e) !== false } else { k = a.is(b) } if (k) { d.push(h.transformElement(a)) } } } h.elements = d; return h }, indexOf: function (a) { return Ext.Array.indexOf(this.elements, this.transformElement(a)) }, replaceElement: function (e, c, a) { var b = !isNaN(e) ? e : this.indexOf(e), g; if (b > -1) { c = Ext.getDom(c); if (a) { g = this.elements[b]; g.parentNode.insertBefore(c, g); Ext.removeNode(g) } Ext.Array.splice(this.elements, b, 1, c) } return this }, clear: function (d) { var c = this, b = c.elements, a = b.length - 1; if (d) { for (; a >= 0; a--) { Ext.removeNode(b[a]) } } this.elements = [] }, addElements: function (d, b) { if (!d) { return this } if (typeof d === "string") { d = Ext.dom.Element.selectorFunction(d, b) } var c = this.elements, a = d.length, g; for (g = 0; g < a; g++) { c.push(Ext.get(d[g])) } return this }, first: function () { return this.item(0) }, last: function () { return this.item(this.getCount() - 1) }, contains: function (a) { return this.indexOf(a) != -1 }, removeElement: function (e, i) { e = [].concat(e); var d = this, g = d.elements, c = e.length, h, b, a; for (a = 0; a < c; a++) { h = e[a]; if ((b = (g[h] || g[h = d.indexOf(h)]))) { if (i) { if (b.dom) { b.destroy() } else { Ext.removeNode(b) } } Ext.Array.erase(g, h, 1) } } return d }, destroy: function () { return this.invoke("destroy", arguments); this.callParent() } }, 1, 0, 0, 0, 0, 0, [Ext.dom, "CompositeElementLite", Ext, "CompositeElementLite"], function (b) { var a = b.prototype; b.importElementMethods(); a.on = a.addListener })); Ext.define("Ext.overrides.dom.Element", (function () { var j, l = window, E = document, M = "hidden", q = "isClipped", K = "overflow", u = "overflow-x", t = "overflow-y", x = "originalClip", C = "height", e = "width", g = "visibility", a = "display", G = "none", O = "offsets", c = "clip", m = "originalDisplay", H = "visibilityMode", y = "isVisible", k = "x-hidden-offsets", p = "x-hidden-clip", P = ['<div class="{0}-tl" role="presentation">', '<div class="{0}-tr" role="presentation">', '<div class="{0}-tc" role="presentation"></div>', "</div>", "</div>", '<div class="{0}-ml" role="presentation">', '<div class="{0}-mr" role="presentation">', '<div class="{0}-mc" role="presentation"></div>', "</div>", "</div>", '<div class="{0}-bl" role="presentation">', '<div class="{0}-br" role="presentation">', '<div class="{0}-bc" role="presentation"></div>', "</div>", "</div>"].join(""), J = /(?:<script([^>]*)?>)((\n|\r|.)*?)(?:<\/script>)/ig, D = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig, b = /\ssrc=([\'\"])(.*?)\1/i, o = /\S/, i = /\stype=([\'\"])(.*?)\1/i, A = /^-ms-/, B = /(-[a-z])/gi, I = function (Q, R) { return R.charAt(1).toUpperCase() }, n = "x-masked", z = "x-masked-relative", v = "x-mask-msg", s = /^body/i, r = {}, w = function (R) { var S = R.getData(), Q = S[H]; if (Q === undefined) { S[H] = Q = j.VISIBILITY } return Q }, N = E.createRange ? E.createRange() : null, F = { INPUT: true, TEXTAREA: true }; if (Ext.isIE8) { var h = E.createElement("div"), L = [], d = Ext.Function.createBuffered(function () { var Q = L.length, R; for (R = 0; R < Q; R++) { h.appendChild(L[R]) } h.innerHTML = ""; L.length = 0 }, 10) } return { override: "Ext.dom.Element", mixins: ["Ext.util.Animate"], skipGarbageCollection: false, _init: function (Q) { j = Q; Q.tabbableSelector += ",[" + Q.tabbableSavedCounterAttribute + "]" }, statics: { selectableCls: "x-selectable", unselectableCls: "x-unselectable", tabbableSelector: Ext.supports.CSS3NegationSelector ? 'a[href],button,iframe,input,select,textarea,[tabindex]:not([tabindex="-1"]),[contenteditable="true"]' : 'a[href],button,iframe,input,select,textarea,[tabindex],[contenteditable="true"]', naturallyFocusableTags: { BUTTON: true, IFRAME: true, EMBED: true, INPUT: true, OBJECT: true, SELECT: true, TEXTAREA: true, HTML: Ext.isIE ? true : false, BODY: Ext.isIE ? false : true }, naturallyTabbableTags: { BUTTON: true, IFRAME: true, INPUT: true, SELECT: true, TEXTAREA: true, OBJECT: Ext.isIE8m ? true : false }, tabbableSavedCounterAttribute: "data-tabindex-counter", tabbableSavedValueAttribute: "data-tabindex-value", normalize: function (Q) { if (Q === "float") { Q = Ext.supports.Float ? "cssFloat" : "styleFloat" } return r[Q] || (r[Q] = Q.replace(A, "ms-").replace(B, I)) } }, addKeyListener: function (R, T, S) { var Q; if (typeof R !== "object" || Ext.isArray(R)) { Q = { target: this, key: R, fn: T, scope: S } } else { Q = { target: this, key: R.key, shift: R.shift, ctrl: R.ctrl, alt: R.alt, fn: T, scope: S } } return new Ext.util.KeyMap(Q) }, addKeyMap: function (Q) { return new Ext.util.KeyMap(Ext.apply({ target: this }, Q)) }, afterAnimate: function () { var Q = this.shadow; if (Q && !Q.disabled && !Q.animate) { Q.show() } }, anchorAnimX: function (Q) { var R = (Q === "l") ? "right" : "left"; this.dom.style[R] = "0px" }, anim: function (Q) { if (!Ext.isObject(Q)) { return (Q) ? {} : false } var R = this, S = Q.duration || Ext.fx.Anim.prototype.duration, U = Q.easing || "ease", T; if (Q.stopAnimation) { R.stopAnimation() } Ext.applyIf(Q, Ext.fx.Manager.getFxDefaults(R.id)); Ext.fx.Manager.setFxDefaults(R.id, { delay: 0 }); T = { target: R.dom, remove: Q.remove, alternate: Q.alternate || false, duration: S, easing: U, callback: Q.callback, listeners: Q.listeners, iterations: Q.iterations || 1, scope: Q.scope, block: Q.block, concurrent: Q.concurrent, delay: Q.delay || 0, paused: true, keyframes: Q.keyframes, from: Q.from || {}, to: Ext.apply({}, Q), userConfig: Q }; Ext.apply(T.to, Q.to); delete T.to.to; delete T.to.from; delete T.to.remove; delete T.to.alternate; delete T.to.keyframes; delete T.to.iterations; delete T.to.listeners; delete T.to.target; delete T.to.paused; delete T.to.callback; delete T.to.scope; delete T.to.duration; delete T.to.easing; delete T.to.concurrent; delete T.to.block; delete T.to.stopAnimation; delete T.to.delay; return T }, animate: function (Q) { this.addAnimation(Q); return this }, addAnimation: function (S) { var U = this, R = U.dom.id || Ext.id(U.dom), T, V, Q; if (!Ext.fx.Manager.hasFxBlock(R)) { if (S.listeners) { T = S.listeners; delete S.listeners } if (S.internalListeners) { S.listeners = S.internalListeners; delete S.internalListeners } Q = S.autoEnd; delete S.autoEnd; V = new Ext.fx.Anim(U.anim(S)); V.on({ afteranimate: "afterAnimate", beforeanimate: "beforeAnimate", scope: U, single: true }); if (T) { V.on(T) } Ext.fx.Manager.queueFx(V); if (Q) { V.jumpToEnd() } } return V }, beforeAnimate: function () { var Q = this.shadow; if (Q && !Q.disabled && !Q.animate) { Q.hide() } }, boxWrap: function (Q) { Q = Q || "x-box"; var R = Ext.get(this.insertHtml("beforeBegin", "<div class='" + Q + "' role='presentation'>" + Ext.String.format(P, Q) + "</div>")); R.selectNode("." + Q + "-mc").appendChild(this.dom); return R }, clean: function (R) { var T = this, V = T.dom, U = T.getData(), W = V.firstChild, S = -1, Q; if (U.isCleaned && R !== true) { return T } while (W) { Q = W.nextSibling; if (W.nodeType === 3) { if (!(o.test(W.nodeValue))) { V.removeChild(W) } else { if (Q && Q.nodeType === 3) { W.appendData(Ext.String.trim(Q.data)); V.removeChild(Q); Q = W.nextSibling; W.nodeIndex = ++S } } } else { Ext.fly(W, "_clean").clean(); W.nodeIndex = ++S } W = Q } U.isCleaned = true; return T }, empty: N ? function () { var Q = this.dom; if (Q.firstChild) { N.setStartBefore(Q.firstChild); N.setEndAfter(Q.lastChild); N.deleteContents() } } : function () { var Q = this.dom; while (Q.lastChild) { Q.removeChild(Q.lastChild) } }, clearListeners: function () { this.removeAnchor(); arguments.callee.$previous.call(this) }, clearPositioning: function (Q) { Q = Q || ""; return this.setStyle({ left: Q, right: Q, top: Q, bottom: Q, "z-index": "", position: "static" }) }, createProxy: function (Q, U, T) { Q = (typeof Q === "object") ? Q : { tag: "div", role: "presentation", cls: Q }; var S = this, R = U ? Ext.DomHelper.append(U, Q, true) : Ext.DomHelper.insertBefore(S.dom, Q, true); R.setVisibilityMode(j.DISPLAY); R.hide(); if (T && S.setBox && S.getBox) { R.setBox(S.getBox()) } return R }, clearOpacity: function () { return this.setOpacity("") }, clip: function () { var R = this, S = R.getData(), Q; if (!S[q]) { S[q] = true; Q = R.getStyle([K, u, t]); S[x] = { o: Q[K], x: Q[u], y: Q[t] }; R.setStyle(K, M); R.setStyle(u, M); R.setStyle(t, M) } return R }, destroy: function () { var S = this, U = S.dom, T = S.getData(), R, Q; if (U) { if (S.isAnimate) { S.stopAnimation() } S.removeAnchor() } arguments.callee.$previous.call(this); if (U && Ext.isIE8 && (U.window != U) && (U.nodeType !== 9) && (U.tagName !== "BODY") && (U.tagName !== "HTML")) { L[L.length] = U; d() } if (T) { R = T.maskEl; Q = T.maskMsg; if (R) { R.destroy() } if (Q) { Q.destroy() } } }, enableDisplayMode: function (R) { var Q = this; Q.setVisibilityMode(j.DISPLAY); if (R !== undefined) { Q.getData()[m] = R } return Q }, fadeIn: function (S) { var Q = this, R = Q.dom; Q.animate(Ext.apply({}, S, { opacity: 1, internalListeners: { beforeanimate: function (U) { var T = Ext.fly(R, "_anim"); if (T.isStyle("display", "none")) { T.setDisplayed("") } else { T.show() } } } })); return this }, fadeOut: function (S) { var Q = this, R = Q.dom; S = Ext.apply({ opacity: 0, internalListeners: { afteranimate: function (U) { if (R && U.to.opacity === 0) { var T = Ext.fly(R, "_anim"); if (S.useDisplay) { T.setDisplayed(false) } else { T.hide() } } } } }, S); Q.animate(S); return Q }, fixDisplay: function () { var Q = this; if (Q.isStyle(a, G)) { Q.setStyle(g, M); Q.setStyle(a, Q._getDisplay()); if (Q.isStyle(a, G)) { Q.setStyle(a, "block") } } }, frame: function (Q, T, U) { var S = this, V = S.dom, R; Q = Q || "#C3DAF9"; T = T || 1; U = U || {}; R = function () { var Z = Ext.fly(V, "_anim"), Y = this, aa, X, W; Z.show(); aa = Z.getBox(); X = Ext.getBody().createChild({ role: "presentation", id: Z.dom.id + "-anim-proxy", style: { position: "absolute", "pointer-events": "none", "z-index": 35000, border: "0px solid " + Q } }); W = new Ext.fx.Anim({ target: X, duration: U.duration || 1000, iterations: T, from: { top: aa.y, left: aa.x, borderWidth: 0, opacity: 1, height: aa.height, width: aa.width }, to: { top: aa.y - 20, left: aa.x - 20, borderWidth: 10, opacity: 0, height: aa.height + 40, width: aa.width + 40 } }); W.on("afteranimate", function () { X.destroy(); Y.end() }) }; S.animate({ duration: (Math.max(U.duration, 500) * 2) || 2000, listeners: { beforeanimate: { fn: R } }, callback: U.callback, scope: U.scope }); return S }, getColor: function (R, S, X) { var U = this.getStyle(R), T = X || X === "" ? X : "#", W, Q, V = 0; if (!U || (/transparent|inherit/.test(U))) { return S } if (/^r/.test(U)) { U = U.slice(4, U.length - 1).split(","); Q = U.length; for (; V < Q; V++) { W = parseInt(U[V], 10); T += (W < 16 ? "0" : "") + W.toString(16) } } else { U = U.replace("#", ""); T += U.length === 3 ? U.replace(/^(\w)(\w)(\w)$/, "$1$1$2$2$3$3") : U } return (T.length > 5 ? T.toLowerCase() : S) }, getLoader: function () { var R = this, S = R.getData(), Q = S.loader; if (!Q) { S.loader = Q = new Ext.ElementLoader({ target: R }) } return Q }, getPositioning: function (R) { var Q = this.getStyle(["left", "top", "position", "z-index"]), S = this.dom; if (R) { if (Q.left === "auto") { Q.left = S.offsetLeft + "px" } if (Q.top === "auto") { Q.top = S.offsetTop + "px" } } return Q }, ghost: function (Q, T) { var S = this, U = S.dom, R; Q = Q || "b"; R = function () { var Y = Ext.fly(U, "_anim"), X = Y.getWidth(), W = Y.getHeight(), Z = Y.getXY(), V = Y.getPositioning(), aa = { opacity: 0 }; switch (Q) { case "t": aa.y = Z[1] - W; break; case "l": aa.x = Z[0] - X; break; case "r": aa.x = Z[0] + X; break; case "b": aa.y = Z[1] + W; break; case "tl": aa.x = Z[0] - X; aa.y = Z[1] - W; break; case "bl": aa.x = Z[0] - X; aa.y = Z[1] + W; break; case "br": aa.x = Z[0] + X; aa.y = Z[1] + W; break; case "tr": aa.x = Z[0] + X; aa.y = Z[1] - W; break }this.to = aa; this.on("afteranimate", function () { var ab = Ext.fly(U, "_anim"); if (ab) { ab.hide(); ab.clearOpacity(); ab.setPositioning(V) } }) }; S.animate(Ext.applyIf(T || {}, { duration: 500, easing: "ease-out", listeners: { beforeanimate: R } })); return S }, hide: function (Q) { if (typeof Q === "string") { this.setVisible(false, Q); return this } this.setVisible(false, this.anim(Q)); return this }, highlight: function (T, R) { var X = this, U = X.dom, Z = {}, W, aa, V, S, Q, Y; R = R || {}; S = R.listeners || {}; V = R.attr || "backgroundColor"; Z[V] = T || "ffff9c"; if (!R.to) { aa = {}; aa[V] = R.endColor || X.getColor(V, "ffffff", "") } else { aa = R.to } R.listeners = Ext.apply(Ext.apply({}, S), { beforeanimate: function () { W = U.style[V]; var ab = Ext.fly(U, "_anim"); ab.clearOpacity(); ab.show(); Q = S.beforeanimate; if (Q) { Y = Q.fn || Q; return Y.apply(Q.scope || S.scope || l, arguments) } }, afteranimate: function () { if (U) { U.style[V] = W } Q = S.afteranimate; if (Q) { Y = Q.fn || Q; Y.apply(Q.scope || S.scope || l, arguments) } } }); X.animate(Ext.apply({}, R, { duration: 1000, easing: "ease-in", from: Z, to: aa })); return X }, hover: function (R, Q, T, S) { var U = this; U.on("mouseenter", R, T || U.dom, S); U.on("mouseleave", Q, T || U.dom, S); return U }, initDD: function (S, R, T) { var Q = new Ext.dd.DD(Ext.id(this.dom), S, R); return Ext.apply(Q, T) }, initDDProxy: function (S, R, T) { var Q = new Ext.dd.DDProxy(Ext.id(this.dom), S, R); return Ext.apply(Q, T) }, initDDTarget: function (S, R, T) { var Q = new Ext.dd.DDTarget(Ext.id(this.dom), S, R); return Ext.apply(Q, T) }, isFocusable: function () { var R = this.dom, Q = false, S; if (R && !R.disabled) { S = R.nodeName; Q = !!Ext.Element.naturallyFocusableTags[S] || ((S === "A" || S === "LINK") && !!R.href) || R.getAttribute("tabIndex") != null || R.contentEditable === "true"; if (Ext.isIE8 && S === "INPUT" && R.type === "hidden") { Q = false } Q = Q && this.isVisible(true) } return Q }, isInputField: function () { var R = this.dom, Q = R.contentEditable; if ((F[R.tagName] && R.type !== "button") || (Q === "" || Q === "true")) { return true } return false }, isTabbable: function (S) { var T = this.dom, V = false, U, R, Q; if (T && !T.disabled) { U = T.nodeName; Q = T.getAttribute("tabIndex"); R = Q != null; Q -= 0; if (U === "A" || U === "LINK") { if (T.href) { V = R && Q < 0 ? false : true } else { if (T.contentEditable === "true") { V = !R || (R && Q >= 0) ? true : false } else { V = R && Q >= 0 ? true : false } } } else { if (T.contentEditable === "true" || Ext.Element.naturallyTabbableTags[U]) { V = R && Q < 0 ? false : true } else { if (R && Q >= 0) { V = true } } } if (Ext.isIE8 && U === "INPUT" && T.type === "hidden") { V = false } V = V && (S || ((!this.component || this.component.isVisible(true)) && this.isVisible(true))) } return V }, isMasked: function (Q) { var U = this, W = U.getData(), T = W.maskEl, R = W.maskMsg, V = false, S; if (T && T.isVisible()) { if (R) { R.center(U) } V = true } else { if (Q) { S = U.findParentNode(); if (S) { return Ext.fly(S).isMasked(Q) } } } return V }, load: function (Q) { this.getLoader().load(Q); return this }, mask: function (X, V, Q) { var T = this, W = T.dom, U = T.getData(), S = U.maskEl, R; if (!(s.test(W.tagName) && T.getStyle("position") === "static")) { T.addCls(z) } if (S) { S.destroy() } S = Ext.DomHelper.append(W, { role: "presentation", cls: "x-mask x-border-box", children: { role: "presentation", cls: V ? v + " " + V : v, cn: { tag: "div", role: "presentation", cls: "x-mask-msg-inner", cn: { tag: "div", role: "presentation", cls: "x-mask-msg-text", html: X || "" } } } }, true); R = Ext.get(S.dom.firstChild); U.maskEl = S; T.addCls(n); S.setDisplayed(true); if (typeof X === "string") { R.setDisplayed(true); R.center(T) } else { R.setDisplayed(false) } if (W === E.body) { S.addCls("x-mask-fixed") } T.saveTabbableState({ skipSelf: W === E.body }); if (Ext.isIE9m && W !== E.body && T.isStyle("height", "auto")) { S.setSize(undefined, Q || T.getHeight()) } return S }, puff: function (U) { var T = this, V = T.dom, R, S = T.getBox(), Q = T.getStyle(["width", "height", "left", "right", "top", "bottom", "position", "z-index", "font-size", "opacity"], true); U = Ext.applyIf(U || {}, { easing: "ease-out", duration: 500, useDisplay: false }); R = function () { var W = Ext.fly(V, "_anim"); W.clearOpacity(); W.show(); this.to = { width: S.width * 2, height: S.height * 2, x: S.x - (S.width / 2), y: S.y - (S.height / 2), opacity: 0, fontSize: "200%" }; this.on("afteranimate", function () { var X = Ext.fly(V, "_anim"); if (X) { if (U.useDisplay) { X.setDisplayed(false) } else { X.hide() } X.setStyle(Q); Ext.callback(U.callback, U.scope) } }) }; T.animate({ duration: U.duration, easing: U.easing, listeners: { beforeanimate: { fn: R } } }); return T }, selectable: function () { var Q = this; Q.dom.unselectable = ""; Q.removeCls(j.unselectableCls); Q.addCls(j.selectableCls); return Q }, setCapture: function () { var Q = this.dom; if (Ext.isIE9m && Q.setCapture) { Q.setCapture() } }, setHeight: function (Q, R) { var S = this; if (!R || !S.anim) { arguments.callee.$previous.apply(this, arguments) } else { if (!Ext.isObject(R)) { R = {} } S.animate(Ext.applyIf({ to: { height: Q } }, R)) } return S }, setHorizontal: function () { var R = this, Q = R.verticalCls; delete R.vertical; if (Q) { delete R.verticalCls; R.removeCls(Q) } delete R.setWidth; delete R.setHeight; if (!Ext.isIE8) { delete R.getWidth; delete R.getHeight } delete R.styleHooks }, updateText: function (T) { var Q = this, S, R; if (S) { R = S.firstChild; if (!R || (R.nodeType !== 3 || R.nextSibling)) { R = E.createTextNode(); Q.empty(); S.appendChild(R) } if (T) { R.data = T } } }, setHtml: function (S, R, X, T) { var U = this, W, V, Q; if (!U.dom) { return U } S = S || ""; V = U.dom; if (R !== true) { V.innerHTML = S; Ext.callback(X, U); return U } W = Ext.id(); S += '<span id="' + W + '" role="presentation"></span>'; Q = Ext.interval(function () { var ae, ab, aa, Z, Y, ad, ac; if (!(ad = E.getElementById(W))) { return false } clearInterval(Q); Ext.removeNode(ad); ae = Ext.getHead().dom; while ((ab = J.exec(S))) { aa = ab[1]; Z = aa ? aa.match(b) : false; if (Z && Z[2]) { ac = E.createElement("script"); ac.src = Z[2]; Y = aa.match(i); if (Y && Y[2]) { ac.type = Y[2] } ae.appendChild(ac) } else { if (ab[2] && ab[2].length > 0) { if (T) { Ext.functionFactory(ab[2]).call(T) } else { Ext.globalEval(ab[2]) } } } } Ext.callback(X, T || U) }, 20); V.innerHTML = S.replace(D, ""); return U }, setOpacity: function (R, Q) { var S = this; if (!S.dom) { return S } if (!Q || !S.anim) { S.setStyle("opacity", R) } else { if (typeof Q != "object") { Q = { duration: 350, easing: "ease-in" } } S.animate(Ext.applyIf({ to: { opacity: R } }, Q)) } return S }, setPositioning: function (Q) { return this.setStyle(Q) }, setVertical: function (T, Q) { var S = this, R = j.prototype; S.vertical = true; if (Q) { S.addCls(S.verticalCls = Q) } S.setWidth = R.setHeight; S.setHeight = R.setWidth; if (!Ext.isIE8) { S.getWidth = R.getHeight; S.getHeight = R.getWidth } S.styleHooks = (T === 270) ? R.verticalStyleHooks270 : R.verticalStyleHooks90 }, setSize: function (S, Q, R) { var T = this; if (Ext.isObject(S)) { R = Q; Q = S.height; S = S.width } if (!R || !T.anim) { T.dom.style.width = j.addUnits(S); T.dom.style.height = j.addUnits(Q); if (T.shadow || T.shim) { T.syncUnderlays() } } else { if (R === true) { R = {} } T.animate(Ext.applyIf({ to: { width: S, height: Q } }, R)) } return T }, setVisible: function (U, Q) { var S = this, T = S.dom, R = w(S); if (typeof Q === "string") { switch (Q) { case a: R = j.DISPLAY; break; case g: R = j.VISIBILITY; break; case O: R = j.OFFSETS; break; case c: R = j.CLIP; break }S.setVisibilityMode(R); Q = false } if (!Q || !S.anim) { if (R === j.DISPLAY) { return S.setDisplayed(U) } else { if (R === j.OFFSETS) { S[U ? "removeCls" : "addCls"](k) } else { if (R === j.CLIP) { S[U ? "removeCls" : "addCls"](p) } else { if (R === j.VISIBILITY) { S.fixDisplay(); T.style.visibility = U ? "" : M } } } } } else { if (U) { S.setOpacity(0.01); S.setVisible(true) } if (!Ext.isObject(Q)) { Q = { duration: 350, easing: "ease-in" } } S.animate(Ext.applyIf({ callback: function () { if (!U) { Ext.fly(T).setVisible(false).setOpacity(1) } }, to: { opacity: (U) ? 1 : 0 } }, Q)) } S.getData()[y] = U; if (S.shadow || S.shim) { S.setUnderlaysVisible(U) } return S }, setWidth: function (R, Q) { var S = this; if (!Q || !S.anim) { arguments.callee.$previous.apply(this, arguments) } else { if (!Ext.isObject(Q)) { Q = {} } S.animate(Ext.applyIf({ to: { width: R } }, Q)) } return S }, setX: function (Q, R) { return this.setXY([Q, this.getY()], R) }, setXY: function (S, Q) { var R = this; if (!Q || !R.anim) { arguments.callee.$previous.call(this, S) } else { if (!Ext.isObject(Q)) { Q = {} } R.animate(Ext.applyIf({ to: { x: S[0], y: S[1] } }, Q)) } return this }, setY: function (R, Q) { return this.setXY([this.getX(), R], Q) }, show: function (Q) { if (typeof Q === "string") { this.setVisible(true, Q); return this } this.setVisible(true, this.anim(Q)); return this }, slideIn: function (T, S, U) { var W = this, R = W.dom, Z = R.style, Y, Q, V, X; T = T || "t"; S = S || {}; Y = function () { var ae = this, ad = S.listeners, ac = Ext.fly(R, "_anim"), af, aa, ag, ab; if (!U) { ac.fixDisplay() } af = ac.getBox(); if ((T == "t" || T == "b") && af.height === 0) { af.height = R.scrollHeight } else { if ((T == "l" || T == "r") && af.width === 0) { af.width = R.scrollWidth } } aa = ac.getStyle(["width", "height", "left", "right", "top", "bottom", "position", "z-index"], true); ac.setSize(af.width, af.height); if (S.preserveScroll) { V = ac.cacheScrollValues() } ab = ac.wrap({ role: "presentation", id: Ext.id() + "-anim-wrap-for-" + ac.dom.id, style: { visibility: U ? "visible" : "hidden" } }); X = ab.dom.parentNode; ab.setPositioning(ac.getPositioning()); if (ab.isStyle("position", "static")) { ab.position("relative") } ac.clearPositioning("auto"); ab.clip(); if (V) { V() } ac.setStyle({ visibility: "", position: "absolute" }); if (U) { ab.setSize(af.width, af.height) } switch (T) { case "t": ag = { from: { width: af.width + "px", height: "0px" }, to: { width: af.width + "px", height: af.height + "px" } }; Z.bottom = "0px"; break; case "l": ag = { from: { width: "0px", height: af.height + "px" }, to: { width: af.width + "px", height: af.height + "px" } }; W.anchorAnimX(T); break; case "r": ag = { from: { x: af.x + af.width, width: "0px", height: af.height + "px" }, to: { x: af.x, width: af.width + "px", height: af.height + "px" } }; W.anchorAnimX(T); break; case "b": ag = { from: { y: af.y + af.height, width: af.width + "px", height: "0px" }, to: { y: af.y, width: af.width + "px", height: af.height + "px" } }; break; case "tl": ag = { from: { x: af.x, y: af.y, width: "0px", height: "0px" }, to: { width: af.width + "px", height: af.height + "px" } }; Z.bottom = "0px"; W.anchorAnimX("l"); break; case "bl": ag = { from: { y: af.y + af.height, width: "0px", height: "0px" }, to: { y: af.y, width: af.width + "px", height: af.height + "px" } }; W.anchorAnimX("l"); break; case "br": ag = { from: { x: af.x + af.width, y: af.y + af.height, width: "0px", height: "0px" }, to: { x: af.x, y: af.y, width: af.width + "px", height: af.height + "px" } }; W.anchorAnimX("r"); break; case "tr": ag = { from: { x: af.x + af.width, width: "0px", height: "0px" }, to: { x: af.x, width: af.width + "px", height: af.height + "px" } }; Z.bottom = "0px"; W.anchorAnimX("r"); break }ab.show(); Q = Ext.apply({}, S); delete Q.listeners; Q = new Ext.fx.Anim(Ext.applyIf(Q, { target: ab, duration: 500, easing: "ease-out", from: U ? ag.to : ag.from, to: U ? ag.from : ag.to })); Q.on("afteranimate", function () { var ah = Ext.fly(R, "_anim"); ah.setStyle(aa); if (U) { if (S.useDisplay) { ah.setDisplayed(false) } else { ah.hide() } } if (ab.dom) { if (ab.dom.parentNode) { ab.dom.parentNode.insertBefore(ah.dom, ab.dom) } else { X.appendChild(ah.dom) } ab.destroy() } if (V) { V() } ae.end() }); if (ad) { Q.on(ad) } }; W.animate({ duration: S.duration ? Math.max(S.duration, 500) * 2 : 1000, listeners: { beforeanimate: Y } }); return W }, slideOut: function (R, Q) { return this.slideIn(R, Q, true) }, swallowEvent: function (R, S) { var U = this, V, Q, T = function (W) { W.stopPropagation(); if (S) { W.preventDefault() } }; if (Ext.isArray(R)) { Q = R.length; for (V = 0; V < Q; V++) { U.on(R[V], T) } return U } U.on(R, T); return U }, switchOff: function (Q) { var S = this, T = S.dom, R; Q = Ext.applyIf(Q || {}, { easing: "ease-in", duration: 500, remove: false, useDisplay: false }); R = function () { var Y = Ext.fly(T, "_anim"), X = this, W = Y.getSize(), Z = Y.getXY(), V, U; Y.clearOpacity(); Y.clip(); U = Y.getPositioning(); V = new Ext.fx.Animator({ target: T, duration: Q.duration, easing: Q.easing, keyframes: { 33: { opacity: 0.3 }, 66: { height: 1, y: Z[1] + W.height / 2 }, 100: { width: 1, x: Z[0] + W.width / 2 } } }); V.on("afteranimate", function () { var aa = Ext.fly(T, "_anim"); if (Q.useDisplay) { aa.setDisplayed(false) } else { aa.hide() } aa.clearOpacity(); aa.setPositioning(U); aa.setSize(W); X.end() }) }; S.animate({ duration: (Math.max(Q.duration, 500) * 2), listeners: { beforeanimate: { fn: R } }, callback: Q.callback, scope: Q.scope }); return S }, syncContent: function (R) { R = Ext.getDom(R); var S = R.childNodes, ad = S.length, ab = this.dom, ac = ab.childNodes, Z = ac.length, X, aa, U, W, T, Q, Y, V = ab._extData; if (Ext.isIE9m && ab.mergeAttributes) { ab.mergeAttributes(R, true); ab.src = R.src } else { T = R.attributes; Q = T.length; for (X = 0; X < Q; X++) { Y = T[X].name; if (Y !== "id") { ab.setAttribute(Y, T[X].value) } } } if (V) { V.isSynchronized = false } if (ad !== Z) { ab.innerHTML = R.innerHTML; return } for (X = 0; X < ad; X++) { U = S[X]; aa = ac[X]; W = U.nodeType; if (W !== aa.nodeType || (W === 1 && U.tagName !== aa.tagName)) { ab.innerHTML = R.innerHTML; return } if (W === 3) { aa.data = U.data } else { if (U.id && aa.id !== U.id) { aa.id = U.id } aa.style.cssText = U.style.cssText; aa.className = U.className; Ext.fly(aa, "_syncContent").syncContent(U) } } }, toggle: function (Q) { var R = this; R.setVisible(!R.isVisible(), R.anim(Q)); return R }, unmask: function () { var S = this, T = S.getData(), R = T.maskEl, Q; if (R) { Q = R.dom.style; if (Q.clearExpression) { Q.clearExpression("width"); Q.clearExpression("height") } if (R) { R.destroy(); delete T.maskEl } S.removeCls([n, z]) } S.restoreTabbableState(S.dom === E.body) }, unclip: function () { var R = this, S = R.getData(), Q; if (S[q]) { S[q] = false; Q = S[x]; if (Q.o) { R.setStyle(K, Q.o) } if (Q.x) { R.setStyle(u, Q.x) } if (Q.y) { R.setStyle(t, Q.y) } } return R }, translate: function (Q, S, R) { if (Ext.supports.CssTransforms && !Ext.isIE9m) { arguments.callee.$previous.apply(this, arguments) } else { if (Q != null) { this.dom.style.left = Q + "px" } if (S != null) { this.dom.style.top = S + "px" } } }, unselectable: function () { var Q = this; if (Ext.isOpera) { Q.dom.unselectable = "on" } Q.removeCls(j.selectableCls); Q.addCls(j.unselectableCls); return Q }, privates: { findTabbableElements: function (af) { var Q, aa, ac, U, V, Y = this.dom, X = Ext.Element.tabbableSavedCounterAttribute, ae = [], ad = 0, R, T, W, Z, ab, S; if (!Y) { return ae } if (af) { Q = af.skipSelf; aa = af.skipChildren; ac = af.excludeRoot; U = af.includeSaved; V = af.includeHidden } ac = ac && Ext.getDom(ac); if (ac && ac.contains(Y)) { return ae } if (!Q && ((U && Y.hasAttribute(X)) || this.isTabbable(V))) { ae[ad++] = Y } if (aa) { return ae } R = Y.querySelectorAll(Ext.Element.tabbableSelector); ab = R.length; if (!ab) { return ae } W = new Ext.dom.Fly(); for (Z = 0; Z < ab; Z++) { T = R[Z]; S = +T.getAttribute("tabIndex"); if (((U && T.hasAttribute(X)) || (!(S < 0) && W.attach(T).isTabbable(V))) && !(ac && (ac === T || ac.contains(T)))) { ae[ad++] = T } } return ae }, saveTabbableState: function (U) { var X = Ext.Element.tabbableSavedCounterAttribute, T = Ext.Element.tabbableSavedValueAttribute, R, S, W, V, Q; if (!U || U.includeSaved == null) { U = Ext.Object.chain(U || null); U.includeSaved = true } S = this.findTabbableElements(U); for (V = 0, Q = S.length; V < Q; V++) { W = S[V]; R = +W.getAttribute(X); if (R > 0) { W.setAttribute(X, ++R) } else { if (W.hasAttribute("tabIndex")) { W.setAttribute(T, W.getAttribute("tabIndex")) } else { W.setAttribute(T, "none") } W.setAttribute("tabIndex", "-1"); W.setAttribute(X, "1") } } return S }, restoreTabbableState: function (Q, W) { var U = this.dom, Y = Ext.Element.tabbableSavedCounterAttribute, Z = Ext.Element.tabbableSavedValueAttribute, S = [], aa, R, S, T, V, X; if (!U) { return this } if (!W) { S = Ext.Array.from(U.querySelectorAll("[" + Y + "]")) } if (!Q) { S.unshift(U) } for (V = 0, X = S.length; V < X; V++) { T = S[V]; if (!T.hasAttribute(Y) || !T.hasAttribute(Z)) { continue } R = +T.getAttribute(Y); if (R > 1) { T.setAttribute(Y, --R); continue } aa = T.getAttribute(Z); if (aa === "none") { T.removeAttribute("tabIndex") } else { T.setAttribute("tabIndex", aa) } T.removeAttribute(Z); T.removeAttribute(Y) } return S } }, deprecated: { "4.0": { methods: { pause: function (Q) { var R = this; Ext.fx.Manager.setFxDefaults(R.id, { delay: Q }); return R }, scale: function (Q, R, S) { this.animate(Ext.apply({}, S, { width: Q, height: R })); return this }, shift: function (Q) { this.animate(Q); return this } } }, "4.2": { methods: { moveTo: function (Q, S, R) { return this.setXY([Q, S], R) }, setBounds: function (R, U, T, Q, S) { return this.setBox({ x: R, y: U, width: T, height: Q }, S) }, setLeftTop: function (T, S) { var R = this, Q = R.dom.style; Q.left = j.addUnits(T); Q.top = j.addUnits(S); if (R.shadow || R.shim) { R.syncUnderlays() } return R }, setLocation: function (Q, S, R) { return this.setXY([Q, S], R) } } }, "5.0": { methods: { getAttributeNS: function (R, Q) { return this.getAttribute(Q, R) }, getCenterXY: function () { return this.getAlignToXY(E, "c-c") }, getComputedHeight: function () { return Math.max(this.dom.offsetHeight, this.dom.clientHeight) || parseFloat(this.getStyle(C)) || 0 }, getComputedWidth: function () { return Math.max(this.dom.offsetWidth, this.dom.clientWidth) || parseFloat(this.getStyle(e)) || 0 }, getStyleSize: function () { var U = this, V = this.dom, R = (V === E || V === E.body), T, Q, S; if (R) { return { width: j.getViewportWidth(), height: j.getViewportHeight() } } T = U.getStyle(["height", "width"], true); if (T.width && T.width !== "auto") { Q = parseFloat(T.width) } if (T.height && T.height !== "auto") { S = parseFloat(T.height) } return { width: Q || U.getWidth(true), height: S || U.getHeight(true) } }, isBorderBox: function () { return true }, isDisplayed: function () { return !this.isStyle("display", "none") }, focusable: "isFocusable" } } } } })(), function () { var q = Ext.dom.Element, p = q.prototype, w = !Ext.isIE8, b = document, m = b.defaultView, v = /alpha\(opacity=(.*)\)/i, h = /^\s+|\s+$/g, x = p.styleHooks, t = Ext.supports, e, o, d, s, g, y, c; p._init(q); delete p._init; Ext.plainTableCls = "x-table-plain"; Ext.plainListCls = "x-list-plain"; if (Ext.CompositeElementLite) { Ext.CompositeElementLite.importElementMethods() } if (!t.Opacity && Ext.isIE) { Ext.apply(x.opacity, { get: function (B) { var A = B.style.filter, z, k; if (A.match) { z = A.match(v); if (z) { k = parseFloat(z[1]); if (!isNaN(k)) { return k ? k / 100 : 0 } } } return 1 }, set: function (B, z) { var k = B.style, A = k.filter.replace(v, "").replace(h, ""); k.zoom = 1; if (typeof (z) === "number" && z >= 0 && z < 1) { z *= 100; k.filter = A + (A.length ? " " : "") + "alpha(opacity=" + z + ")" } else { k.filter = A } } }) } if (!t.matchesSelector) { var j = /^([a-z]+|\*)?(?:\.([a-z][a-z\-_0-9]*))?$/i, l = /\-/g, a, u = function (k, z) { var A = new RegExp("(?:^|\\s+)" + z.replace(l, "\\-") + "(?:\\s+|$)"); if (k && k !== "*") { k = k.toUpperCase(); return function (B) { return B.tagName === k && A.test(B.className) } } return function (B) { return A.test(B.className) } }, r = function (k) { k = k.toUpperCase(); return function (z) { return z.tagName === k } }, n = {}; p.matcherCache = n; p.is = function (k) { if (!k) { return true } var z = this.dom, F, B, E, D, C, A, G; if (z.nodeType !== 1) { return false } if (!(E = Ext.isFunction(k) ? k : n[k])) { if (!(B = k.match(j))) { D = z.parentNode; if (!D) { C = true; D = a || (a = b.createDocumentFragment()); a.appendChild(z) } A = Ext.Array.indexOf(Ext.fly(D, "_is").query(k), z) !== -1; if (C) { a.removeChild(z) } return A } G = B[1]; F = B[2]; n[k] = E = F ? u(G, F) : r(G) } return E(z) } } if (!m || !m.getComputedStyle) { p.getStyle = function (M, H) { var I = this, D = I.dom, O = typeof M !== "string", A = M, J = A, G = 1, B = H, z = I.styleHooks, N, F, L, K, C, k, E; if (O) { L = {}; A = J[0]; E = 0; if (!(G = J.length)) { return L } } if (!D || D.documentElement) { return L || "" } F = D.style; if (H) { k = F } else { k = D.currentStyle; if (!k) { B = true; k = F } } do { K = z[A]; if (!K) { z[A] = K = { name: q.normalize(A) } } if (K.get) { C = K.get(D, I, B, k) } else { N = K.name; C = k[N] } if (!O) { return C } L[A] = C; A = J[++E] } while (E < G); return L } } if (Ext.isIE8) { c = function (B, z, A, k) { if (k[this.styleName] === "none") { return "0px" } return k[this.name] }; d = ["Top", "Right", "Bottom", "Left"]; s = d.length; while (s--) { g = d[s]; y = "border" + g + "Width"; x["border-" + g.toLowerCase() + "-width"] = x[y] = { name: y, styleName: "border" + g + "Style", get: c } } var i = "x-sync-repaint"; p.syncRepaint = function () { this.addCls(i); this.getWidth(); this.removeCls(i) } } if (Ext.isIE10m) { Ext.override(q, { focus: function (C, B) { var A = this, z; B = B || A.dom; if (Number(C)) { Ext.defer(A.focus, C, A, [null, B]) } else { Ext.GlobalEvents.fireEvent("beforefocus", B); if (B && (B.tagName === "INPUT" || B.tagname === "TEXTAREA")) { Ext.synchronouslyFocusing = document.activeElement } try { B.focus() } catch (k) { z = k } if (Ext.synchronouslyFocusing && document.activeElement !== B && !z) { B.focus() } Ext.synchronouslyFocusing = null } return A } }) } Ext.apply(Ext, { enableGarbageCollector: true, isBorderBox: true, useShims: false, getElementById: function (A) { var z = b.getElementById(A), k; if (!z && (k = Ext.detachedBodyEl)) { z = k.dom.querySelector(Ext.makeIdSelector(A)) } return z }, addBehaviors: function (C) { if (!Ext.isReady) { Ext.onInternalReady(function () { Ext.addBehaviors(C) }) } else { var z = {}, B, k, A; for (k in C) { if ((B = k.split("@"))[1]) { A = B[0]; if (!z[A]) { z[A] = Ext.fly(document).select(A, true) } z[A].on(B[1], C[k]) } } z = null } } }); if (Ext.isIE9m) { Ext.getElementById = function (A) { var z = b.getElementById(A), k; if (!z && (k = Ext.detachedBodyEl)) { z = k.dom.all[A] } return z }; p.getById = function (D, k) { var C = this.dom, z = null, B, A; if (C) { A = (w && b.getElementById(D)) || C.all[D]; if (A) { if (k) { z = A } else { B = Ext.cache[D]; if (B) { if (B.skipGarbageCollection || !Ext.isGarbage(B.dom)) { z = B } else { B.destroy() } } z = z || new Ext.Element(A) } } } return z } } else { if (!b.querySelector) { Ext.getDetachedBody = Ext.getBody; Ext.getElementById = function (k) { return b.getElementById(k) }; p.getById = function (A, k) { var z = b.getElementById(A); return k ? z : (z ? Ext.get(z) : null) } } } if (Ext.isIE && !(Ext.isIE9p && b.documentMode >= 9)) { p.getAttribute = function (k, A) { var B = this.dom, z; if (A) { z = typeof B[A + ":" + k]; if (z !== "undefined" && z !== "unknown") { return B[A + ":" + k] || null } return null } if (k === "for") { k = "htmlFor" } return B[k] || null } } Ext.onInternalReady(function () { var B = /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i, z = [], G = p.setWidth, H = p.setHeight, L = p.setSize, M = /^\d+(?:\.\d*)?px$/i, F, D, k, K; if (t.FixedTableWidthBug) { x.width = { name: "width", set: function (S, R, P) { var O = S.style, N = P._needsTableWidthFix, Q = O.display; if (N) { O.display = "none" } O.width = R; if (N) { S.scrollWidth; O.display = Q } } }; p.setWidth = function (Q, O) { var S = this, T = S.dom, P = T.style, N = S._needsTableWidthFix, R = P.display; if (N && !O) { P.display = "none" } G.call(S, Q, O); if (N && !O) { T.scrollWidth; P.display = R } return S }; p.setSize = function (R, O, P) { var T = this, U = T.dom, Q = U.style, N = T._needsTableWidthFix, S = Q.display; if (N && !P) { Q.display = "none" } L.call(T, R, O, P); if (N && !P) { U.scrollWidth; Q.display = S } return T } } if (Ext.isIE8) { x.height = { name: "height", set: function (S, R, P) { var O = P.component, Q, N; if (O && O._syncFrameHeight && P === O.el) { N = O.frameBody.dom.style; if (M.test(R)) { Q = O.getFrameInfo(); if (Q) { N.height = (parseInt(R, 10) - Q.height) + "px" } } else { if (!R || R === "auto") { N.height = "" } } } S.style.height = R } }; p.setHeight = function (N, P) { var Q = this.component, R, O; if (Q && Q._syncFrameHeight && this === Q.el) { O = Q.frameBody.dom.style; if (!N || N === "auto") { O.height = "" } else { R = Q.getFrameInfo(); if (R) { O.height = (N - R.height) + "px" } } } return H.call(this, N, P) }; p.setSize = function (R, N, P) { var Q = this.component, S, O; if (Q && Q._syncFrameHeight && this === Q.el) { O = Q.frameBody.dom.style; if (!N || N === "auto") { O.height = "" } else { S = Q.getFrameInfo(); if (S) { O.height = (N - S.height) + "px" } } } return L.call(this, R, N, P) } } Ext.getDoc().on("selectstart", function (R, S) { var Q = q.selectableCls, P = q.unselectableCls, N = S && S.tagName; N = N && N.toLowerCase(); if (N === "input" || N === "textarea") { return } while (S && S.nodeType === 1 && S !== b.documentElement) { var O = Ext.fly(S); if (O.hasCls(Q)) { return } if (O.hasCls(P)) { R.stopEvent(); return } S = S.parentNode } }); function E(R, O, Q, N) { var P = N[this.name] || ""; return B.test(P) ? "transparent" : P } function J(O, P, N) { return function () { O.selectionStart = P; O.selectionEnd = N } } function I(R) { var P = t.DisplayChangeInputSelectionBug, Q = t.DisplayChangeTextAreaSelectionBug, S, N, T, O; if (P || Q) { S = q.getActiveElement(); N = S && S.tagName; if ((Q && N === "TEXTAREA") || (P && N === "INPUT" && S.type === "text")) { if (Ext.fly(R).isAncestor(S)) { T = S.selectionStart; O = S.selectionEnd; if (Ext.isNumber(T) && Ext.isNumber(O)) { return J(S, T, O) } } } } return Ext.emptyFn } function C(T, Q, S, P) { var N = P.marginRight, O, R; if (N !== "0px") { O = T.style; R = O.display; O.display = "inline-block"; N = (S ? P : T.ownerDocument.defaultView.getComputedStyle(T, null)).marginRight; O.display = R } return N } function A(U, R, T, Q) { var N = Q.marginRight, P, O, S; if (N !== "0px") { P = U.style; O = I(U); S = P.display; P.display = "inline-block"; N = (T ? Q : U.ownerDocument.defaultView.getComputedStyle(U, "")).marginRight; P.display = S; O() } return N } if (!t.RightMargin) { x.marginRight = x["margin-right"] = { name: "marginRight", get: (t.DisplayChangeInputSelectionBug || t.DisplayChangeTextAreaSelectionBug) ? A : C } } if (!t.TransparentColor) { F = ["background-color", "border-color", "color", "outline-color"]; for (D = F.length; D--;) { k = F[D]; K = q.normalize(k); x[k] = x[K] = { name: K, get: E } } } p.verticalStyleHooks90 = e = Ext.Object.chain(x); p.verticalStyleHooks270 = o = Ext.Object.chain(x); e.width = x.height || { name: "height" }; e.height = x.width || { name: "width" }; e["margin-top"] = { name: "marginLeft" }; e["margin-right"] = { name: "marginTop" }; e["margin-bottom"] = { name: "marginRight" }; e["margin-left"] = { name: "marginBottom" }; e["padding-top"] = { name: "paddingLeft" }; e["padding-right"] = { name: "paddingTop" }; e["padding-bottom"] = { name: "paddingRight" }; e["padding-left"] = { name: "paddingBottom" }; e["border-top"] = { name: "borderLeft" }; e["border-right"] = { name: "borderTop" }; e["border-bottom"] = { name: "borderRight" }; e["border-left"] = { name: "borderBottom" }; o.width = x.height || { name: "height" }; o.height = x.width || { name: "width" }; o["margin-top"] = { name: "marginRight" }; o["margin-right"] = { name: "marginBottom" }; o["margin-bottom"] = { name: "marginLeft" }; o["margin-left"] = { name: "marginTop" }; o["padding-top"] = { name: "paddingRight" }; o["padding-right"] = { name: "paddingBottom" }; o["padding-bottom"] = { name: "paddingLeft" }; o["padding-left"] = { name: "paddingTop" }; o["border-top"] = { name: "borderRight" }; o["border-right"] = { name: "borderBottom" }; o["border-bottom"] = { name: "borderLeft" }; o["border-left"] = { name: "borderTop" }; if (!Ext.scopeCss) { z.push("x-body") } if (t.Touch) { z.push("x-touch") } if (Ext.isIE && Ext.isIE9m) { z.push("x-ie", "x-ie9m"); z.push("x-ie8p"); if (Ext.isIE8) { z.push("x-ie8") } else { z.push("x-ie9", "x-ie9p") } if (Ext.isIE8m) { z.push("x-ie8m") } } if (Ext.isIE10) { z.push("x-ie10") } if (Ext.isIE10p) { z.push("x-ie10p") } if (Ext.isIE11) { z.push("x-ie11") } if (Ext.isEdge) { z.push("x-edge") } if (Ext.isGecko) { z.push("x-gecko") } if (Ext.isOpera) { z.push("x-opera") } if (Ext.isOpera12m) { z.push("x-opera12m") } if (Ext.isWebKit) { z.push("x-webkit") } if (Ext.isSafari) { z.push("x-safari") } if (Ext.isChrome) { z.push("x-chrome") } if (Ext.isMac) { z.push("x-mac") } if (Ext.isLinux) { z.push("x-linux") } if (!t.CSS3BorderRadius) { z.push("x-nbr") } if (!t.CSS3LinearGradient) { z.push("x-nlg") } if (t.Touch) { z.push("x-touch") } if (Ext.os.deviceType) { z.push("x-" + Ext.os.deviceType.toLowerCase()) } Ext.getBody().addCls(z) }, null, { priority: 1500 }) }); (Ext.cmd.derive("Ext.GlobalEvents", Ext.mixin.Observable, { alternateClassName: "Ext.globalEvents", observableType: "global", singleton: true, resizeBuffer: 100, idleEventMask: { mousemove: 1, touchmove: 1, pointermove: 1, MSPointerMove: 1, unload: 1 }, constructor: function () { var a = this; a.callParent(); Ext.onInternalReady(function () { a.attachListeners() }) }, attachListeners: function () { Ext.get(window).on("resize", this.fireResize, this, { buffer: this.resizeBuffer }); Ext.getDoc().on("mousedown", this.fireMouseDown, this) }, fireMouseDown: function (a) { this.fireEvent("mousedown", a) }, fireResize: function () { var d = this, b = Ext.Element, a = b.getViewportWidth(), c = b.getViewportHeight(); if (d.curHeight !== c || d.curWidth !== a) { d.curHeight = c; d.curWidth = a; d.fireEvent("resize", a, c) } } }, 1, 0, 0, 0, 0, 0, [Ext, "GlobalEvents", Ext, "globalEvents"], function (a) { Ext.on = function () { return a.addListener.apply(a, arguments) }; Ext.un = function () { return a.removeListener.apply(a, arguments) }; Ext.fireEvent = function () { return a.fireEvent.apply(a, arguments) } })); Ext.define("Ext.overrides.GlobalEvents", { override: "Ext.GlobalEvents", deprecated: { 5: { methods: { addListener: function (d, h, i, j, c, b, e) { var a, g; if (d === "ready") { g = h } else { if (typeof d !== "string") { for (a in d) { if (a === "ready") { g = d[a] } } } } if (g) { Ext.onReady(g) } this.callParent([d, h, i, j, c, b, e]) } } } } }); (Ext.cmd.derive("Ext.Glyph", Ext.Base, { isGlyph: true, constructor: function (a) { a && this.setGlyph(a) }, setGlyph: function (b) { var a; this.glyphConfig = b; if (typeof b === "string") { a = b.split("@"); if (isNaN(b = isNaN(a[0]) ? parseInt("0" + a[0], 16) : parseInt(a[0], 10)) || !b) { b = a[0].charCodeAt(0) } this.fontFamily = a[1] || Ext._glyphFontFamily } else { this.fontFamily = Ext._glyphFontFamily } this.codepoint = b; this.character = Ext.String.fromCodePoint(this.codepoint); return this }, getStyle: function () { return { "font-family": this.fontFamily } }, isEqual: function (a) { return a && a.isGlyph && a.codepoint === this.codepoint && a.fontFamily === this.fontFamily }, statics: (function () { var a; return { fly: function (b) { return b.isGlyph ? b : (a || (a = new Ext.Glyph())).setGlyph(b) } } })() }, 1, 0, 0, 0, 0, 0, [Ext, "Glyph"], 0)); Ext.USE_NATIVE_JSON = false; Ext.JSON = (new (function () { var me = this, hasNative = window.JSON && JSON.toString() === "[object JSON]", useHasOwn = !!{}.hasOwnProperty, pad = function (n) { return n < 10 ? "0" + n : n }, doDecode = function (json) { return eval("(" + json + ")") }, doEncode = function (o, newline) { if (o === null || o === undefined) { return "null" } else { if (Ext.isDate(o)) { return me.encodeDate(o) } else { if (Ext.isString(o)) { if (Ext.isMSDate(o)) { return me.encodeMSDate(o) } else { return me.encodeString(o) } } else { if (typeof o === "number") { return isFinite(o) ? String(o) : "null" } else { if (Ext.isBoolean(o)) { return String(o) } else { if (o.toJSON) { return o.toJSON() } else { if (Ext.isArray(o)) { return encodeArray(o, newline) } else { if (Ext.isObject(o)) { return encodeObject(o, newline) } else { if (typeof o === "function") { return "null" } } } } } } } } } return "undefined" }, m = { "\b": "\\b", "\t": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\", "\v": "\\u000b" }, charToReplace = /[\\\"\x00-\x1f\x7f-\uffff]/g, encodeString = function (s) { return '"' + s.replace(charToReplace, function (a) { var c = m[a]; return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4) }) + '"' }, encodeMSDate = function (o) { return '"' + o + '"' }, encodeArrayPretty = function (o, newline) { var len = o.length, cnewline = newline + "   ", sep = "," + cnewline, a = ["[", cnewline], i; for (i = 0; i < len; i += 1) { a.push(me.encodeValue(o[i], cnewline), sep) } a[a.length - 1] = newline + "]"; return a.join("") }, encodeObjectPretty = function (o, newline) { var cnewline = newline + "   ", sep = "," + cnewline, a = ["{", cnewline], i, val; for (i in o) { val = o[i]; if (!useHasOwn || o.hasOwnProperty(i)) { if (typeof val === "function" || val === undefined) { continue } a.push(me.encodeValue(i) + ": " + me.encodeValue(val, cnewline), sep) } } a[a.length - 1] = newline + "}"; return a.join("") }, encodeArray = function (o, newline) { if (newline) { return encodeArrayPretty(o, newline) } var a = ["[", ""], len = o.length, i; for (i = 0; i < len; i += 1) { a.push(me.encodeValue(o[i]), ",") } a[a.length - 1] = "]"; return a.join("") }, encodeObject = function (o, newline) { if (newline) { return encodeObjectPretty(o, newline) } var a = ["{", ""], i, val; for (i in o) { val = o[i]; if (!useHasOwn || o.hasOwnProperty(i)) { if (typeof val === "function" || val === undefined) { continue } a.push(me.encodeValue(i), ":", me.encodeValue(val), ",") } } a[a.length - 1] = "}"; return a.join("") }; me.encodeString = encodeString; me.encodeValue = doEncode; me.encodeDate = function (o) { return '"' + o.getFullYear() + "-" + pad(o.getMonth() + 1) + "-" + pad(o.getDate()) + "T" + pad(o.getHours()) + ":" + pad(o.getMinutes()) + ":" + pad(o.getSeconds()) + '"' }; me.encode = function (o) { if (hasNative && Ext.USE_NATIVE_JSON) { return JSON.stringify(o) } return me.encodeValue(o) }; me.decode = function (json, safe) { try { if (hasNative && Ext.USE_NATIVE_JSON) { return JSON.parse(json) } return doDecode(json) } catch (e) { if (safe) { return null } Ext.raise({ sourceClass: "Ext.JSON", sourceMethod: "decode", msg: "You're trying to decode an invalid JSON String: " + json }) } }; me.encodeMSDate = encodeMSDate; if (!Ext.util) { Ext.util = {} } Ext.util.JSON = me; Ext.encode = me.encode; Ext.decode = me.decode })()); (Ext.cmd.derive("Ext.mixin.Inheritable", Ext.Mixin, { mixinConfig: { id: "inheritable" }, getInherited: function (j) { var e = this, h = (j && e.inheritedStateInner) || e.inheritedState, b = e.getRefOwner(), a = e.isContainer, i, c, d, g; if (!h || h.invalid) { i = e.getRefOwner(); g = e.ownerLayout; if (b) { d = g ? g === b.layout : true } e.inheritedState = h = Ext.Object.chain(i ? i.getInherited(d) : Ext.rootInheritedState); if (a) { e.inheritedStateInner = c = Ext.Object.chain(h) } e.initInheritedState(h, c); h = (a && j) ? e.inheritedStateInner : e.inheritedState } return h }, getInheritedConfig: function (e, a) { var d = this.inheritedState, b, c; if (!d || d.invalid) { d = this.getInherited() } c = d[e]; if (a && d.hasOwnProperty(e)) { b = c; delete d[e]; c = d[e]; d[e] = b } return c }, resolveListenerScope: function (g, a) { var d = this, e = (typeof a === "boolean"), c = Ext._namedScopes[g], b; if (!c) { b = d.getInheritedConfig("defaultListenerScope", e ? a : true) || g || d } else { if (c.isController) { b = d.getInheritedConfig("controller", e ? a : !c.isSelf) } else { if (c.isSelf) { b = d.getInheritedConfig("defaultListenerScope", e && a) || d } else { if (c.isThis) { b = d } } } } return b || null }, resolveSatelliteListenerScope: function (c, e) { var d = this, b = Ext._namedScopes[e], a; if (!b) { a = d.getInheritedConfig("defaultListenerScope") || e || d } else { if (b.isController) { a = d.getInheritedConfig("controller") } else { if (b.isSelf) { a = d.getInheritedConfig("defaultListenerScope") || c } else { if (b.isThis) { a = c } } } } return a || null }, lookupReferenceHolder: function (a) { return this.getInheritedConfig("referenceHolder", a !== false) || null }, getRefOwner: function () { var a = this; return a.ownerCt || a.parent || a.$initParent || a.ownerCmp || a.floatParent }, invalidateInheritedState: function () { var a = this.inheritedState; if (a) { a.invalid = true; delete this.inheritedState } }, privates: { fixReference: function () { var a = this, b; if (a.getReference()) { b = a.lookupReferenceHolder(); if (b) { b.attachReference(a) } } }, onInheritedAdd: function (b, a) { var c = this; if (c.inheritedState && a) { c.invalidateInheritedState() } if (c.getReference()) { Ext.ComponentManager.markReferencesDirty() } }, onInheritedRemove: function (b) { var a = this, c; if (a.getReference()) { c = a.lookupReferenceHolder(); if (c) { c.clearReference(a) } } if (a.inheritedState && !b) { a.invalidateInheritedState() } } } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "Inheritable"], function () { Ext.rootInheritedState = {} })); (Ext.cmd.derive("Ext.mixin.Bindable", Ext.Base, { mixinId: "bindable", config: { bind: { $value: null, lazy: true }, controller: null, defaultListenerScope: false, publishes: { $value: null, lazy: true, merge: function (b, a) { return this.mergeSets(b, a) } }, reference: null, session: { $value: null, lazy: true }, twoWayBindable: { $value: null, lazy: true, merge: function (b, a) { return this.mergeSets(b, a) } }, viewModel: { $value: null, lazy: true } }, defaultBindProperty: null, validRefRe: /^[a-z_][a-z0-9_]*$/i, initInheritedState: function (d) { var e = this, a = e.getReference(), b = e.getController(), c = e.getConfig("viewModel", true), h = e.getConfig("session", true), g = e.getDefaultListenerScope(); if (b) { d.controller = b } if (g) { d.defaultListenerScope = e } else { if (b) { d.defaultListenerScope = b } } if (c) { if (!c.isViewModel) { c = e } d.viewModel = c } if (h) { if (!h.isSession) { h = e } d.session = h } if (a) { e.referenceKey = (d.referencePath || "") + a; e.viewModelKey = (d.viewModelPath || "") + a } }, lookupController: function (a) { return this.getInheritedConfig("controller", a) || null }, lookupSession: function (a) { var b = a ? null : this.getSession(); if (!b) { b = this.getInheritedConfig("session", a); if (b && !b.isSession) { b = b.getInherited().session = b.getSession() } } return b || null }, lookupViewModel: function (a) { var b = a ? null : this.getViewModel(); if (!b) { b = this.getInheritedConfig("viewModel", a); if (b && !b.isViewModel) { b = b.getInherited().viewModel = b.getViewModel() } } return b || null }, publishState: function (k, j) { var i = this, b = i.publishedState, e = i.getBind(), h = e && k && e[k], g = 0, c, a, d, l; if (h && !h.syncing && !h.isReadOnly()) { if (!(h.calls === 0 && (j == null || j === i.getInitialConfig()[k]))) { h.setValue(j) } } if (!(a = i.getPublishes())) { return } if (!(d = i.lookupViewModel())) { return } if (!(l = i.viewModelKey)) { return } if (k && b) { if (!a[k]) { return } if (!(j && j.constructor === Object) && !(j instanceof Array)) { if (b[k] === j) { return } } l += "."; l += k } else { b = b || (i.publishedState = {}); for (c in a) { ++g; if (c === k) { b[c] = j } else { b[c] = i[c] } } if (!g) { return } j = b } d.set(l, j) }, privates: { addBindableUpdater: function (c) { var b = this, d = b.self.$config.configs, a = d[c], e; if (a && !b.hasOwnProperty(e = a.names.update)) { b[e] = a.bindableUpdater || (a.root.bindableUpdater = b.makeBindableUpdater(a)) } }, applyBind: function (d, l) { if (!d) { return d } var g = this, j = g.lookupViewModel(), e = g.getTwoWayBindable(), a = g._getBindTemplateScope, h, k, c, i; g.$hasBinds = true; if (!l || typeof l === "string") { l = {} } if (Ext.isString(d)) { h = d; d = {}; d[g.defaultBindProperty] = h } for (k in d) { c = d[k]; h = l[k]; if (h && typeof h !== "string") { h.destroy(); h = null; i = true } if (c) { h = j.bind(c, g.onBindNotify, g); h._config = Ext.Config.get(k); h.getTemplateScope = a } if (i) { delete l[k] } else { l[k] = h } if (e && e[k]) { if (i) { g.clearBindableUpdater(k) } else { if (!h.isReadOnly()) { g.addBindableUpdater(k) } } } } return l }, applyController: function (a) { if (a) { a = Ext.Factory.controller(a); a.setView(this) } return a }, applyPublishes: function (a) { if (this.lookupViewModel()) { for (var b in a) { this.addBindableUpdater(b) } } return a }, applySession: function (c) { if (!c) { return null } if (!c.isSession) { var b = this.lookupSession(true), a = (c === true) ? {} : c; if (b) { c = b.spawn(a) } else { c = new Ext.data.Session(a) } } return c }, applyViewModel: function (b) { var c = this, a, d; if (!b) { return null } if (!b.isViewModel) { a = { parent: c.lookupViewModel(true), view: c }; a.session = c.getSession(); if (!d && !a.parent) { a.session = c.lookupSession() } if (b) { if (b.constructor === Object) { Ext.apply(a, b) } else { if (typeof b === "string") { a.type = b } } } b = Ext.Factory.viewModel(a) } return b }, _getBindTemplateScope: function () { return this.scope.resolveListenerScope() }, clearBindableUpdater: function (c) { var b = this, d = b.self.$config.configs, a = d[c], e; if (a && b.hasOwnProperty(e = a.names.update)) { if (b[e].$bindableUpdater) { delete b[e] } } }, destroyBindable: function () { var c = this, b = c.getConfig("viewModel", true), d = c.getConfig("session", true), a = c.getController(); if (b && b.isViewModel) { b.destroy(); c.setViewModel(null) } if (d && d.isSession) { if (d.getAutoDestroy()) { d.destroy() } c.setSession(null) } if (a) { c.setController(null); a.destroy() } }, initBindable: function () { this.initBindable = Ext.emptyFn; this.getBind(); this.getPublishes() }, makeBindableUpdater: function (a) { var c = a.names.update, b = function (g, d) { var e = this, h = e.self.prototype[c]; if (h) { h.call(e, g, d) } e.publishState(a.name, g) }; b.$bindableUpdater = true; return b }, isSyncing: function (b) { var d = this.getBind(), a = false, c; if (d) { c = d[b]; if (c) { a = c.syncing > 0 } } return a }, onBindNotify: function (b, a, c) { c.syncing = (c.syncing + 1) || 1; this[c._config.names.set](b); --c.syncing }, removeBindings: function () { var b = this, d, a, c; if (b.$hasBinds) { d = b.getBind(); if (d && typeof d !== "string") { for (a in d) { c = d[a]; c.destroy(); c._config = c.getTemplateScope = null } } } b.setBind(null) }, updateSession: function (b) { var a = this.getInherited(); if (b) { a.session = b } else { delete a.session } }, updateViewModel: function (b) { var c = this.getInherited(), a = this.getController(); if (b) { c.viewModel = b; b.setView(this); if (a) { a.initViewModel(b) } } else { delete c.viewModel } } } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "Bindable"], 0)); (Ext.cmd.derive("Ext.mixin.ComponentDelegation", Ext.Mixin, { mixinConfig: { id: "componentDelegation" }, privates: { addDelegatedListener: function (g, i, k, l, d, c, e) { var h = this, b, a, j; g = Ext.canonicalEventName(g); d = d || l.order; if (d) { j = (l && l.priority); if (!j) { l = l ? Ext.Object.chain(l) : {}; l.priority = h.$orderToPriority[d] } } b = h.$delegatedEvents || (h.$delegatedEvents = {}); a = b[g] || (b[g] = new Ext.util.Event(h, g)); if (a.addListener(i, k, l, c, e)) { h.$hasDelegatedListeners._incr_(g) } }, clearDelegatedListeners: function () { var d = this, b = d.$delegatedEvents, a, c, e; if (b) { for (a in b) { c = b[a]; e = c.listeners.length; c.clearListeners(); d.$hasDelegatedListeners._decr_(a, e); delete b[a] } } }, doFireDelegatedEvent: function (b, d) { var h = this, c = true, a, e, g; if (h.$hasDelegatedListeners[b]) { a = h.getRefOwner(); while (a) { e = a.$delegatedEvents; if (e) { g = e[b]; if (g) { c = g.fireDelegated(h, d); if (c === false) { break } } } a = a.getRefOwner() } } return c }, removeDelegatedListener: function (a, d, c) { var g = this, b = g.$delegatedEvents, e; if (b) { e = b[a]; if (e && e.removeListener(d, c)) { g.$hasDelegatedListeners._decr_(a); if (e.listeners.length === 0) { delete b[a] } } } }, destroyComponentDelegation: function () { if (this.clearPropertiesOnDestroy) { this.$delegatedEvents = null } } }, onClassMixedIn: function (a) { function b() { } a.prototype.HasListeners = a.HasListeners = b; b.prototype = a.hasListeners = new Ext.mixin.ComponentDelegation.HasDelegatedListeners() } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "ComponentDelegation"], function (b) { function a() { } b.HasDelegatedListeners = a; a.prototype = b.prototype.$hasDelegatedListeners = new Ext.mixin.Observable.HasListeners() })); (Ext.cmd.derive("Ext.mixin.Pluggable", Ext.Base, function (b) { var a = []; return { config: { plugins: null }, addPlugin: function (e) { var d = this, c = d.getPlugins(); if (c) { e = d.createPlugin(e); e.init(d); c.push(e) } else { d.setPlugins(e) } return e }, destroyPlugin: function (c) { return this.removePlugin(c, true) }, findPlugin: function (g) { var c = this.getPlugins(), j = c && c.length, e, h, d; for (e = 0; e < j && !d; e++) { h = c[e]; if (h.type === g || h.ptype === g) { d = h } } return d || null }, getPlugin: function (j) { var c = this.getPlugins(), h = c && c.length, e, g, d; for (e = 0; e < h && !d; e++) { g = c[e]; if (g.id === j || g.pluginId === j) { d = g } } return d || null }, removePlugin: function (g, e) { var c = this.getPlugins(), d = c && c.length || 0, h; while (d-- > 0) { h = c[d]; if (h === g || h.id === g) { c.splice(d, 1); if (e) { if (h.destroy) { h.destroy() } } else { if (h.detachCmp) { h.detachCmp(); if (h.setCmp) { h.setCmp(null) } } } break } h = null } return h }, privates: { statics: { idSeed: 0 }, activatePlugin: function (h) { var j = this, e = j.initialConfig, c = e && e.plugins, d = null, g, k; if (c) { c = a.concat(c); for (g = c.length; g-- > 0;) { k = c[g]; if (k === h || k.type === h) { j.initialConfig = e = Ext.apply({}, e); e.plugins = c; c[g] = d = j.createPlugin(k); break } } } return d }, applyPlugins: function (d, c) { var k = this, e = c && c.length || 0, j, g, h; d = d ? a.concat(d) : null; j = d && d.length || 0; for (g = 0; g < e; ++g) { c[g].$dead = true } for (g = 0; g < j; ++g) { d[g] = k.createPlugin(d[g]) } for (g = 0; g < j; ++g) { h = d[g]; if (h.$dead) { delete h.$dead } else { h.init(k) } } for (g = 0; g < e; ++g) { if ((h = c[g]).$dead) { delete h.$dead; Ext.destroy(h) } } return d }, createPlugin: function (d) { if (typeof d === "string") { d = { type: d } } var c = d; if (!d.isInstance) { d.cmp = this; c = Ext.factory(d, null, null, "plugin"); delete d.cmp } if (!c.id) { c.id = ++b.idSeed } if (c.setCmp) { c.setCmp(this) } return c } } } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "Pluggable"], 0)); (Ext.cmd.derive("Ext.Widget", Ext.Evented, { alternateClassName: "Ext.Gadget", isWidget: true, element: { reference: "element" }, observableType: "component", cachedConfig: { baseCls: true, cls: null, style: null, border: null, touchAction: null }, config: { ui: null, userCls: null }, eventedConfig: { width: null, height: null, hidden: null }, template: [], classCls: null, classClsRoot: true, clearPropertiesOnDestroy: "async", noBorderCls: "x-noborder-trbl", constructor: function (b) { var c = this, a; c.initId(b); c.initElement(); c.mixins.observable.constructor.call(c, b); Ext.ComponentManager.register(c); a = c.getController(); if (a) { a.init(c) } }, afterCachedConfig: function () { var j = this, k = j.self.prototype, l = j.referenceList, c = j.renderElement, g, d, e, h, b, a; k.renderTemplate = g = document.createDocumentFragment(); g.appendChild(c.clone(true, true)); a = g.querySelectorAll("[id]"); for (e = 0, h = a.length; e < h; e++) { d = a[e]; d.removeAttribute("id") } for (e = 0, h = l.length; e < h; e++) { b = l[e]; j[b].dom.removeAttribute("reference") } }, addCls: function (a) { this.el.addCls(a) }, applyBaseCls: function (a) { var b = "x-", c = this.xtype; if (a === true) { a = this.classCls || (b + c) } else { if (!a) { a = b + c } } return a }, applyCls: function (a) { if (typeof a == "string") { a = [a] } if (!a || !a.length) { a = null } return a }, applyHidden: function (a) { return !!a }, applyTouchAction: function (a, b) { if (b != null) { a = Ext.merge({}, b, a) } return a }, applyWidth: function (a) { return this.filterLengthValue(a) }, applyHeight: function (a) { return this.filterLengthValue(a) }, updateBorder: function (a) { a = a || a === null; this.el.toggleCls(this.noBorderCls, !a) }, clearListeners: function () { var a = this; a.mixins.observable.clearListeners.call(a); a.mixins.componentDelegation.clearDelegatedListeners.call(a) }, destroy: function () { var a = this; a.isDestroying = a.destroying = true; a.doDestroy(); a.clearListeners(); a.isDestroying = a.destroying = false; a.mixins.componentDelegation.destroyComponentDelegation.call(a); Ext.Evented.prototype.destroy.call(this) }, doDestroy: function () { var e = this, b = e.referenceList, c, d, a; for (c = 0, d = b.length; c < d; c++) { a = b[c]; if (e.hasOwnProperty(a)) { e[a].destroy(); e[a] = null } } e.destroyBindable(); Ext.ComponentManager.unregister(e) }, doFireEvent: function (b, d, a) { var e = this, c = e.mixins.observable.doFireEvent.call(e, b, d, a); if (c !== false) { c = e.mixins.componentDelegation.doFireDelegatedEvent.call(e, b, d) } return c }, getBubbleTarget: function () { return this.getRefOwner() }, getElementConfig: function () { var b = this, a = b.element; if (!("children" in a)) { a = Ext.apply({ children: b.getTemplate() }, a) } return a }, getSize: function () { return { width: this.getWidth(), height: this.getHeight() } }, getTemplate: function () { return this.template }, getClassCls: function () { var e = this.self.prototype, a = e, c, g, b, d; while (a) { g = a.classCls; if (g) { if (g instanceof Array) { for (b = 0, d = g.length; b < d; b++) { (c || (c = [])).push(g[b]) } } else { (c || (c = [])).push(g) } } if (a.classClsRoot && a.hasOwnProperty("classClsRoot")) { break } a = a.superclass } if (c) { e.classClsList = c } return c }, hide: function () { this.setHidden(true) }, initElement: function () { var o = this, p = o.self.prototype, a = o.getId(), q = o.referenceList = o.referenceList = [], c = true, l = !p.hasOwnProperty("renderTemplate"), j, e, h, b, g, n, m, d, k; if (l) { c = false; j = document.createDocumentFragment(); e = Ext.Element.create(o.processElementConfig.call(p), true); j.appendChild(e) } else { j = o.renderTemplate.cloneNode(true); e = j.firstChild } b = j.querySelectorAll("[reference]"); for (g = 0, n = b.length; g < n; g++) { m = b[g]; d = m.getAttribute("reference"); if (c) { m.removeAttribute("reference") } if (d === "element") { m.id = a; h = o.el = o.addElementReference(d, m); h.dom.setAttribute("data-componentid", a); if (l) { k = o.getClassCls(); if (k) { h.addCls(k) } } } else { o.addElementReferenceOnDemand(d, m) } q.push(d) } if (e === h.dom) { o.renderElement = h } else { o.addElementReferenceOnDemand("renderElement", e) } }, is: function (a) { return Ext.ComponentQuery.is(this, a) }, isHidden: function (b) { var c = !!this.getHidden(), a; if (!c && b) { a = this.getRefOwner(); while (a && a !== b) { c = !!a.getHidden(); if (c) { break } a = a.getRefOwner() } } return c }, isVisible: function (a) { return !this.isHidden(a) }, isXType: function (b, a) { return a ? (Ext.Array.indexOf(this.xtypes, b) !== -1) : !!this.xtypesMap[b] }, lookupTpl: function (a) { return Ext.XTemplate.getTpl(this, a) }, removeCls: function (a) { this.el.removeCls(a) }, toggleCls: function (a, b) { this.element.toggleCls(a, b) }, resolveListenerScope: function (b, a) { return this.mixins.inheritable.resolveListenerScope.call(this, b, a) }, setSize: function (b, a) { if (b && typeof b === "object") { return this.setSize(b.width, b.height) } if (b !== undefined) { this.setWidth(b) } if (a !== undefined) { this.setHeight(a) } }, show: function () { this.setHidden(false) }, updateBaseCls: function (a, b) { var d = this, c = d.element; if (b) { c.removeCls(b) } if (a) { c.addCls(a) } if (!d.isConfiguring) { d.syncUiCls() } }, updateCls: function (b, a) { this.element.replaceCls(a, b) }, updateHidden: function (b) { var a = this.renderElement; if (a && !a.destroyed) { if (b) { a.hide() } else { a.show() } } }, applyStyle: function (b, a) { if (a && b === a && Ext.isObject(a)) { b = Ext.apply({}, b) } return b }, updateStyle: function (a) { this.element.applyStyles(a) }, updateTouchAction: function (e) { var b, a, c, d; for (b in e) { a = this[b]; c = e[b]; if (a && a.isElement) { a.setTouchAction(c) } else { d = true } } if (d) { this.el.setTouchAction(e) } }, updateUi: function () { this.syncUiCls() }, updateWidth: function (a) { this.element.setWidth(a) }, updateHeight: function (a) { this.element.setHeight(a) }, up: function (d, e) { var c = this.getRefOwner(), b = typeof e === "string", h = typeof e === "number", a = e && e.isComponent, g = 0; if (d) { for (; c; c = c.getRefOwner()) { g++; if (d.isComponent || d.isWidget) { if (c === d) { return c } } else { if (Ext.ComponentQuery.is(c, d)) { return c } } if (b && c.is(e)) { return } if (h && g === e) { return } if (a && c === e) { return } } } return c }, updateLayout: Ext.emptyFn, onFocusEnter: Ext.emptyFn, onFocusLeave: Ext.emptyFn, isAncestor: function () { return false }, privates: { addElementReferenceOnDemand: function (a, b) { if (this._elementListeners[a]) { this.addElementReference(a, b) } else { Ext.Object.defineProperty(this, a, { get: function () { delete this[a]; return this.addElementReference(a, b) }, configurable: true }) } }, addElementReference: function (c, e) { var g = this, b = g[c] = Ext.get(e), d = g._elementListeners[c], a, h; b.skipGarbageCollection = true; b.component = g; if (d) { d = Ext.clone(d); for (a in d) { h = d[a]; if (typeof h === "object") { h.scope = g } } d.scope = g; b.on(d) } return b }, detachFromBody: function () { Ext.getDetachedBody().appendChild(this.element); this.isDetached = true }, doAddListener: function (a, k, l, n, c, b, e) { var j = this, m = n && n.element, i = n && n.delegate, h, d, g; if (m) { h = {}; h[a] = k; if (l) { h.scope = l } d = Ext.Element.prototype.$eventOptions; for (g in n) { if (d[g]) { h[g] = n[g] } } j.mon(j[m], h); return } else { if (i) { j.mixins.componentDelegation.addDelegatedListener.call(j, a, k, l, n, c, b, e); return } } Ext.Evented.prototype.doAddListener.call(this, a, k, l, n, c, b, e) }, doRemoveListener: function (a, c, b) { var d = this; d.mixins.observable.doRemoveListener.call(d, a, c, b); d.mixins.componentDelegation.removeDelegatedListener.call(d, a, c, b) }, filterLengthValue: function (a) { if (a === "auto" || (!a && a !== 0)) { return null } return a }, getFocusEl: function () { return this.element }, initElementListeners: function (m) { var l = this, d = l.self.superclass, c = d._elementListeners, e = m.reference, a = m.children, h, k, b, j, g; if (l.hasOwnProperty("_elementListeners")) { h = l._elementListeners } else { h = l._elementListeners = (c ? Ext.Object.chain(c) : {}) } if (e) { k = m.listeners; if (k) { if (c) { b = c[e]; if (b) { k = Ext.Object.chain(b); Ext.apply(k, m.listeners) } } h[e] = k; m.listeners = null } } if (a) { for (g = 0, j = a.length; g < j; g++) { l.initElementListeners(a[g]) } } }, initId: function (b) { var c = this, a = c.config, d = (b && b.id) || (a && a.id); if (d) { c.setId(d); c.id = d } else { c.getId() } }, processElementConfig: function () { var a = this, c = a.self.superclass, b; if (a.hasOwnProperty("_elementConfig")) { b = a._elementConfig } else { b = a._elementConfig = a.getElementConfig(); if (c.isWidget) { a.processElementConfig.call(c) } a.initElementListeners(b) } return b }, reattachToBody: function () { this.isDetached = false }, addUi: function (g) { var d = this, e = d.getUi(), c, b, a; if (g) { g = g.split(" "); a = g.length; e = (e && e.split(" ")) || []; for (c = 0; c < a; c++) { b = g[c]; if (e.indexOf(b) === -1) { e.push(b) } } d.setUi(e.join(" ")) } }, removeUi: function (h) { var e = this, g = e.getUi(), d, b, c, a; if (h) { h = h.split(" "); a = h.length; g = (g && g.split(" ")) || []; for (d = 0; d < a; d++) { b = h[d]; c = g.indexOf(b); if (c !== -1) { g.splice(c, 1) } } e.setUi(g.join(" ")) } }, syncUiCls: function () { var m = this, n = m.getUi(), g = m.currentUiCls, e = m.element, h = m.getBaseCls(), o = m.classClsList, d = [], a, c, k, b, l; if (g) { e.removeCls(g) } if (n) { n = n.split(" "); for (c = 0, k = n.length; c < k; c++) { a = "-" + n[c]; if (h && (h !== m.classCls)) { d.push(h + a) } if (o) { for (b = 0, l = o.length; b < l; b++) { d.push(o[b] + a) } } } e.addCls(d); m.currentUiCls = d } }, updateUserCls: function (b, a) { this.element.replaceCls(a, b) } } }, 1, ["widget"], ["widget"], { widget: true }, ["widget.widget"], [[Ext.mixin.Inheritable.prototype.mixinId || Ext.mixin.Inheritable.$className, Ext.mixin.Inheritable], [Ext.mixin.Bindable.prototype.mixinId || Ext.mixin.Bindable.$className, Ext.mixin.Bindable], [Ext.mixin.ComponentDelegation.prototype.mixinId || Ext.mixin.ComponentDelegation.$className, Ext.mixin.ComponentDelegation], [Ext.mixin.Pluggable.prototype.mixinId || Ext.mixin.Pluggable.$className, Ext.mixin.Pluggable]], [Ext, "Widget", Ext, "Gadget"], function (b) { var a = b.prototype; (a.$elementEventOptions = Ext.Object.chain(Ext.Element.prototype.$eventOptions)).element = 1; (a.$eventOptions = Ext.Object.chain(a.$eventOptions)).delegate = 1 })); Ext.define("Ext.overrides.Widget", { override: "Ext.Widget", $configStrict: false, isComponent: true, liquidLayout: true, rendered: true, rendering: true, config: { renderTo: null }, constructor: function (a) { var b = this, c; (arguments.callee.$previous || Ext.Evented.prototype.constructor).call(this, a); b.getComponentLayout(); c = b.getRenderTo(); if (c) { b.render(c) } }, addClsWithUI: function (a) { this.el.addCls(a) }, afterComponentLayout: Ext.emptyFn, updateLayout: function () { var a = this.getRefOwner(); if (a) { a.updateLayout() } }, destroy: function () { var b = this, a = b.ownerCt; if (a && a.remove) { a.remove(b, false) } (arguments.callee.$previous || Ext.Evented.prototype.destroy).call(this) }, finishRender: function () { this.rendering = false; this.initBindable() }, getAnimationProps: function () { return {} }, getComponentLayout: function () { var b = this, a = b.componentLayout; if (!a) { a = b.componentLayout = new Ext.layout.component.Auto(); a.setOwner(b) } return a }, getEl: function () { return this.element }, getTdCls: function () { return "x-" + this.getTdType() + "-" + (this.ui || "default") + "-cell" }, getTdType: function () { return this.xtype }, getItemId: function () { return this.itemId || this.id }, getSizeModel: function () { return Ext.Component.prototype.getSizeModel.apply(this, arguments) }, onAdded: function (b, d, a) { var c = this; c.ownerCt = b; c.onInheritedAdd(c, a) }, onRemoved: function (b) { var a = this; if (!b) { a.removeBindings() } a.onInheritedRemove(b); a.ownerCt = a.ownerLayout = null }, parseBox: function (a) { return Ext.Element.parseBox(a) }, removeClsWithUI: function (a) { this.el.removeCls(a) }, render: function (b, a) { var e = this, c = e.element, d = Ext.Component.prototype, g; if (!e.ownerCt || e.floating) { if (Ext.scopeCss) { c.addCls(d.rootCls) } c.addCls(d.borderBoxCls) } if (a) { g = b.childNodes[a]; if (g) { Ext.fly(b).insertBefore(c, g); return } } Ext.fly(b).appendChild(c) }, setPosition: function (a, b) { this.el.setLocalXY(a, b) }, up: function () { return Ext.Component.prototype.up.apply(this, arguments) }, isAncestor: function () { return Ext.Component.prototype.isAncestor.apply(this, arguments) }, onFocusEnter: function () { return Ext.Component.prototype.onFocusEnter.apply(this, arguments) }, onFocusLeave: function () { return Ext.Component.prototype.onFocusLeave.apply(this, arguments) }, isLayoutChild: function (b) { var a = this.ownerCt; return a ? (a === b || a.isLayoutChild(b)) : false }, privates: { doAddListener: function (d, h, g, c, a, b, e) { if (d == "painted" || d == "resize") { this.element.doAddListener(d, h, g || this, c, a) } (arguments.callee.$previous || Ext.Evented.prototype.doAddListener).call(this, d, h, g, c, a, b, e) }, doRemoveListener: function (a, c, b) { if (a == "painted" || a == "resize") { this.element.doRemoveListener(a, c, b) } (arguments.callee.$previous || Ext.Evented.prototype.doRemoveListener).call(this, a, c, b) } } }, function (b) { var a = b.prototype; if (Ext.isIE9m) { a.addElementReferenceOnDemand = a.addElementReference } }); (Ext.cmd.derive("Ext.ProgressBase", Ext.Base, { mixinId: "progressbase", config: { value: 0, textTpl: null }, applyTextTpl: function (a) { if (!a.isTemplate) { a = new Ext.XTemplate(a) } return a }, applyValue: function (a) { return a || 0 } }, 0, 0, 0, 0, 0, 0, [Ext, "ProgressBase"], 0)); (Ext.cmd.derive("Ext.Progress", Ext.Gadget, { alternateClassName: "Ext.ProgressBarWidget", config: { text: null, animate: false }, cachedConfig: { baseCls: "x-progress", textCls: "x-progress-text", cls: null }, template: [{ reference: "backgroundEl" }, { reference: "barEl", children: [{ reference: "textEl" }] }], defaultBindProperty: "value", updateCls: function (a, c) { var b = this.element; if (c) { b.removeCls(c) } if (a) { b.addCls(a) } }, updateUi: function (e, d) { var c = this.element, a = this.barEl, b = this.getBaseCls() + "-"; if (d) { c.removeCls(b + d); a.removeCls(b + "bar-" + d) } c.addCls(b + e); a.addCls(b + "bar-" + e) }, updateBaseCls: function (b, a) { this.element.addCls(b); this.barEl.addCls(b + "-bar") }, updateTextCls: function (a) { this.backgroundEl.addCls(a + " " + a + "-back"); this.textEl.addCls(a) }, updateValue: function (e, b) { var d = this, a = d.barEl, c = d.getTextTpl(); if (c) { d.setText(c.apply({ value: e, percent: Math.round(e * 100) })) } if (d.getAnimate()) { a.stopAnimation(); a.animate(Ext.apply({ from: { width: (b * 100) + "%" }, to: { width: (e * 100) + "%" } }, d.animate)) } else { a.setStyle("width", (e * 100) + "%") } }, updateText: function (a) { this.backgroundEl.setHtml(a); this.textEl.setHtml(a) } }, 0, ["progress", "progressbarwidget"], ["widget", "progress", "progressbarwidget"], { widget: true, progress: true, progressbarwidget: true }, ["widget.progress", "widget.progressbarwidget"], [[Ext.ProgressBase.prototype.mixinId || Ext.ProgressBase.$className, Ext.ProgressBase]], [Ext, "Progress", Ext, "ProgressBarWidget"], 0)); Ext.define("Ext.overrides.Progress", { override: "Ext.Progress", config: { ui: "default" }, updateWidth: function (b, a) { var c = this; (arguments.callee.$previous || Ext.Widget.prototype.updateWidth).call(this, b, a); b -= c.element.getBorderWidth("lr"); c.backgroundEl.setWidth(b); c.textEl.setWidth(b) } }); (Ext.cmd.derive("Ext.util.Format", Ext.Base, function () { var a; return { singleton: true, defaultDateFormat: "m/d/Y", thousandSeparator: ",", decimalSeparator: ".", currencyPrecision: 2, currencySign: "$", currencySpacer: "", percentSign: "%", currencyAtEnd: false, stripTagsRe: /<\/?[^>]+>/gi, stripScriptsRe: /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig, nl2brRe: /\r?\n/g, hashRe: /#+$/, allHashes: /^#+$/, formatPattern: /[\d,\.#]+/, formatCleanRe: /[^\d\.#]/g, I18NFormatCleanRe: null, formatFns: {}, constructor: function () { a = this }, nbsp: function (c, b) { b = b !== false; if (b ? c === "" || c == null : !c) { c = "\xa0" } return c }, undef: function (b) { return b !== undefined ? b : "" }, defaultValue: function (c, b) { return c !== undefined && c !== "" ? c : b }, substr: "ab".substr(-1) != "b" ? function (c, e, b) { var d = String(c); return (e < 0) ? d.substr(Math.max(d.length + e, 0), b) : d.substr(e, b) } : function (c, d, b) { return String(c).substr(d, b) }, lowercase: function (b) { return String(b).toLowerCase() }, uppercase: function (b) { return String(b).toUpperCase() }, usMoney: function (b) { return a.currency(b, "$", 2) }, currency: function (d, g, c, b, k) { var j = "", h = ",0", e = 0; d = d - 0; if (d < 0) { d = -d; j = "-" } c = Ext.isDefined(c) ? c : a.currencyPrecision; h += (c > 0 ? "." : ""); for (; e < c; e++) { h += "0" } d = a.number(d, h); if (k == null) { k = a.currencySpacer } if ((b || a.currencyAtEnd) === true) { return Ext.String.format("{0}{1}{2}{3}", j, d, k, g || a.currencySign) } else { return Ext.String.format("{0}{1}{2}{3}", j, g || a.currencySign, k, d) } }, date: function (b, c) { if (!b) { return "" } if (!Ext.isDate(b)) { b = new Date(Date.parse(b)) } return Ext.Date.dateFormat(b, c || Ext.Date.defaultFormat) }, dateRenderer: function (b) { return function (c) { return a.date(c, b) } }, hex: function (d, c) { var b = parseInt(d || 0, 10).toString(16); if (c) { if (c < 0) { c = -c; if (b.length > c) { b = b.substring(b.length - c) } } while (b.length < c) { b = "0" + b } } return b }, or: function (c, b) { return c || b }, pick: function (d, c, e) { if (Ext.isNumber(d)) { var b = arguments[d + 1]; if (b) { return b } } return d ? e : c }, lessThanElse: function (i, c, j, b, h) { var d = Ext.Number.from(i, 0), g = Ext.Number.from(c, 0), e = !Ext.isDefined(h); return d < g ? j : (d > g ? b : (e ? b : h)) }, sign: function (e, c, b, d) { if (d === undefined) { d = b } return a.lessThanElse(e, 0, c, b, d) }, stripTags: function (b) { return !b ? b : String(b).replace(a.stripTagsRe, "") }, stripScripts: function (b) { return !b ? b : String(b).replace(a.stripScriptsRe, "") }, fileSize: (function () { var b = 1024, c = 1048576, d = 1073741824; return function (g) { var e; if (g < b) { if (g === 1) { e = "1 byte" } else { e = g + " bytes" } } else { if (g < c) { e = (Math.round(((g * 10) / b)) / 10) + " KB" } else { if (g < d) { e = (Math.round(((g * 10) / c)) / 10) + " MB" } else { e = (Math.round(((g * 10) / d)) / 10) + " GB" } } } return e } })(), math: (function () { var b = {}; return function (d, c) { if (!b[c]) { b[c] = Ext.functionFactory("v", "return v " + c + ";") } return b[c](d) } }()), round: function (d, c) { var b = Number(d); if (typeof c === "number") { c = Math.pow(10, c); b = Math.round(d * c) / c } else { if (c === undefined) { b = Math.round(b) } } return b }, number: function (m, g) { if (!g) { return m } if (isNaN(m)) { return "" } var e = a.formatFns[g]; if (!e) { var j = g, p = a.thousandSeparator, n = a.decimalSeparator, h = 0, d = "", c, k, l, o, b, i; if (g.substr(g.length - 2) === "/i") { if (!a.I18NFormatCleanRe || a.lastDecimalSeparator !== n) { a.I18NFormatCleanRe = new RegExp("[^\\d\\" + n + "#]", "g"); a.lastDecimalSeparator = n } g = g.substr(0, g.length - 2); c = g.indexOf(p) !== -1; k = g.replace(a.I18NFormatCleanRe, "").split(n) } else { c = g.indexOf(",") !== -1; k = g.replace(a.formatCleanRe, "").split(".") } l = g.replace(a.formatPattern, ""); if (k.length > 2) { } else { if (k.length === 2) { h = k[1].length; o = k[1].match(a.hashRe); if (o) { i = o[0].length; d = 'trailingZeroes=new RegExp(Ext.String.escapeRegex(utilFormat.decimalSeparator) + "*0{0,' + i + '}$")' } } } b = ["var utilFormat=Ext.util.Format,extNumber=Ext.Number,neg,absVal,fnum,parts" + (c ? ",thousandSeparator,thousands=[],j,n,i" : "") + (l ? ',formatString="' + g + '",formatPattern=/[\\d,\\.#]+/' : "") + ',trailingZeroes;return function(v){if(typeof v!=="number"&&isNaN(v=extNumber.from(v,NaN)))return"";neg=v<0;', "absVal=Math.abs(v);", "fnum=Ext.Number.toFixed(absVal, " + h + ");", d, ";"]; if (c) { if (h) { b[b.length] = 'parts=fnum.split(".");'; b[b.length] = "fnum=parts[0];" } b[b.length] = "if(absVal>=1000) {"; b[b.length] = "thousandSeparator=utilFormat.thousandSeparator;thousands.length=0;j=fnum.length;n=fnum.length%3||3;for(i=0;i<j;i+=n){if(i!==0){n=3;}thousands[thousands.length]=fnum.substr(i,n);}fnum=thousands.join(thousandSeparator);}"; if (h) { b[b.length] = "fnum += utilFormat.decimalSeparator+parts[1];" } } else { if (h) { b[b.length] = 'if(utilFormat.decimalSeparator!=="."){parts=fnum.split(".");fnum=parts[0]+utilFormat.decimalSeparator+parts[1];}' } } b[b.length] = 'if(neg&&fnum!=="' + (h ? "0." + Ext.String.repeat("0", h) : "0") + '") { fnum="-"+fnum; }'; if (o) { b[b.length] = 'fnum=fnum.replace(trailingZeroes,"");' } b[b.length] = "return "; if (l) { b[b.length] = "formatString.replace(formatPattern, fnum);" } else { b[b.length] = "fnum;" } b[b.length] = "};"; e = a.formatFns[j] = Ext.functionFactory("Ext", b.join(""))(Ext) } return e(m) }, numberRenderer: function (b) { return function (c) { return a.number(c, b) } }, percent: function (c, b) { return a.number(c * 100, b || "0") + a.percentSign }, attributes: function (c) { if (typeof c === "object") { var b = [], d; for (d in c) { if (c.hasOwnProperty(d)) { b.push(d, '="', d === "style" ? Ext.DomHelper.generateStyles(c[d], null, true) : Ext.htmlEncode(c[d]), '" ') } } c = b.join("") } return c || "" }, plural: function (d, c, b) { return d + " " + (d === 1 ? c : (b ? b : c + "s")) }, nl2br: function (b) { return Ext.isEmpty(b) ? "" : b.replace(a.nl2brRe, "<br/>") }, capitalize: Ext.String.capitalize, uncapitalize: Ext.String.uncapitalize, ellipsis: Ext.String.ellipsis, escape: Ext.String.escape, escapeRegex: Ext.String.escapeRegex, htmlDecode: Ext.String.htmlDecode, htmlEncode: Ext.String.htmlEncode, leftPad: Ext.String.leftPad, toggle: Ext.String.toggle, trim: Ext.String.trim, parseBox: function (c) { c = c || 0; if (typeof c === "number") { return { top: c, right: c, bottom: c, left: c } } var d = c.split(" "), b = d.length; if (b === 1) { d[1] = d[2] = d[3] = d[0] } else { if (b === 2) { d[2] = d[0]; d[3] = d[1] } else { if (b === 3) { d[3] = d[1] } } } return { top: parseInt(d[0], 10) || 0, right: parseInt(d[1], 10) || 0, bottom: parseInt(d[2], 10) || 0, left: parseInt(d[3], 10) || 0 } }, uri: function (b) { return encodeURI(b) }, uriCmp: function (b) { return encodeURIComponent(b) }, wordBreakRe: /[\W\s]+/, word: function (e, c, b) { var d = b ? (typeof b === "string" ? new RegExp(b) : b) : a.wordBreakRe, g = (e || "").split(d); return g[c || 0] || "" } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "Format"], 0)); (Ext.cmd.derive("Ext.Template", Ext.Base, { inheritableStatics: { from: function (b, a) { b = Ext.getDom(b); return new this(b.value || b.innerHTML, a || "") } }, useEval: Ext.isGecko, constructor: function (d) { var g = this, b = arguments, a = [], c, e = b.length, h; g.initialConfig = {}; if (e === 1 && Ext.isArray(d)) { b = d; e = b.length } if (e > 1) { for (c = 0; c < e; c++) { h = b[c]; if (typeof h === "object") { Ext.apply(g.initialConfig, h); Ext.apply(g, h) } else { a.push(h) } } } else { a.push(d) } g.html = a.join("") }, isTemplate: true, disableFormats: false, tokenRe: /\{(?:(?:(\d+)|([a-z_][\w\-]*))(?::([a-z_\.]+)(?:\(([^\)]*?)?\))?)?)\}/gi, apply: function (a) { var b = this; if (b.compiled) { if (!b.fn) { b.compile() } return b.fn(a).join("") } return b.evaluate(a) }, evaluate: function (a) { var g = this, c = !g.disableFormats, e = Ext.util.Format, b = g; function d(k, j, i, l, h) { if (i == null || i === "") { i = j } if (l && c) { if (h) { h = [a[i]].concat(Ext.functionFactory("return [" + h + "];")()) } else { h = [a[i]] } if (l.substr(0, 5) === "this.") { return b[l.substr(5)].apply(b, h) } else { if (e[l]) { return e[l].apply(e, h) } else { return k } } } else { return a[i] !== undefined ? a[i] : "" } } return g.html.replace(g.tokenRe, d) }, applyOut: function (a, b) { var c = this; if (c.compiled) { if (!c.fn) { c.compile() } b.push.apply(b, c.fn(a)) } else { b.push(c.apply(a)) } return b }, applyTemplate: function () { return this.apply.apply(this, arguments) }, set: function (a, c) { var b = this; b.html = a; b.compiled = !!c; b.fn = null; return b }, compileARe: /\\/g, compileBRe: /(\r\n|\n)/g, compileCRe: /'/g, compile: function () { var b = this, a; a = b.html.replace(b.compileARe, "\\\\").replace(b.compileBRe, "\\n").replace(b.compileCRe, "\\'").replace(b.tokenRe, b.regexReplaceFn.bind(b)); a = (this.disableFormats !== true ? "var fm=Ext.util.Format;" : "") + (b.useEval ? "$=" : "return") + " function(v){return ['" + a + "'];};"; b.fn = b.useEval ? b.evalCompiled(a) : (new Function("Ext", a))(Ext); b.compiled = true; return b }, evalCompiled: function ($) { eval($); return $ }, regexReplaceFn: function (d, c, b, e, a) { if (c == null || c === "") { c = '"' + b + '"' } else { if (this.stringFormat) { c = parseInt(c) + 1 } } if (e && this.disableFormats !== true) { a = a ? "," + a : ""; if (e.substr(0, 5) === "this.") { e = e + "(" } else { if (Ext.util.Format[e]) { e = "fm." + e + "(" } else { return d } } return "'," + e + "v[" + c + "]" + a + "),'" } else { return "',v[" + c + "] == undefined ? '' : v[" + c + "],'" } }, insertFirst: function (b, a, c) { return this.doInsert("afterBegin", b, a, c) }, insertBefore: function (b, a, c) { return this.doInsert("beforeBegin", b, a, c) }, insertAfter: function (b, a, c) { return this.doInsert("afterEnd", b, a, c) }, append: function (b, a, c) { return this.doInsert("beforeEnd", b, a, c) }, doInsert: function (b, d, a, e) { var c = Ext.DomHelper.insertHtml(b, Ext.getDom(d), this.apply(a)); return e ? Ext.get(c) : c }, overwrite: function (c, a, d) { var b = Ext.DomHelper.overwrite(Ext.getDom(c), this.apply(a)); return d ? Ext.get(b) : b } }, 1, 0, 0, 0, 0, 0, [Ext, "Template"], function (d) { var c = /\{\d+\}/, a = function (g) { if (c.test(g)) { g = new d(g, b); return function () { return g.apply(arguments) } } else { return function () { return g } } }, b = { useFormat: false, compiled: true, stringFormat: true }, e = {}; Ext.String.format = Ext.util.Format.format = function (h) { var g = e[h] || (e[h] = a(h)); return g.apply(this, arguments) }; Ext.String.formatEncode = function () { return Ext.String.htmlEncode(Ext.String.format.apply(this, arguments)) } })); (Ext.cmd.derive("Ext.util.XTemplateParser", Ext.Base, { constructor: function (a) { Ext.apply(this, a) }, doTpl: Ext.emptyFn, parse: function (n) { var w = this, q = n.length, p = { elseif: "elif" }, r = w.topRe, c = w.actionsRe, e, d, j, o, h, k, i, v, u, b, g, a, l; w.level = 0; w.stack = d = []; for (e = 0; e < q; e = b) { r.lastIndex = e; o = r.exec(n); if (!o) { w.doText(n.substring(e, q)); break } u = o.index; b = r.lastIndex; if (e < u) { j = n.substring(e, u); if (!(l && Ext.String.trim(j) === "")) { w.doText(j) } } l = false; if (o[1]) { b = n.indexOf("%}", u + 2); w.doEval(n.substring(u + 2, b)); b += 2 } else { if (o[2]) { b = n.indexOf("]}", u + 2); w.doExpr(n.substring(u + 2, b)); b += 2 } else { if (o[3]) { w.doTag(o[3]) } else { if (o[4]) { g = null; while ((v = c.exec(o[4])) !== null) { j = v[2] || v[3]; if (j) { j = Ext.String.htmlDecode(j); h = v[1]; h = p[h] || h; g = g || {}; k = g[h]; if (typeof k == "string") { g[h] = [k, j] } else { if (k) { g[h].push(j) } else { g[h] = j } } } } if (!g) { if (w.elseRe.test(o[4])) { w.doElse() } else { if (w.defaultRe.test(o[4])) { w.doDefault() } else { w.doTpl(); d.push({ type: "tpl" }) } } } else { if (g["if"]) { w.doIf(g["if"], g); d.push({ type: "if" }) } else { if (g["switch"]) { w.doSwitch(g["switch"], g); d.push({ type: "switch" }); l = true } else { if (g["case"]) { w.doCase(g["case"], g) } else { if (g.elif) { w.doElseIf(g.elif, g) } else { if (g["for"]) { ++w.level; if (a = w.propRe.exec(o[4])) { g.propName = a[1] || a[2] } w.doFor(g["for"], g); d.push({ type: "for", actions: g }) } else { if (g.foreach) { ++w.level; if (a = w.propRe.exec(o[4])) { g.propName = a[1] || a[2] } w.doForEach(g.foreach, g); d.push({ type: "foreach", actions: g }) } else { if (g.exec) { w.doExec(g.exec, g); d.push({ type: "exec", actions: g }) } } } } } } } } } else { if (o[0].length === 5) { d.push({ type: "tpl" }) } else { i = d.pop(); w.doEnd(i.type, i.actions); if (i.type == "for" || i.type == "foreach") { --w.level } } } } } } } }, topRe: /(?:(\{\%)|(\{\[)|\{([^{}]+)\})|(?:<tpl([^>]*)\>)|(?:<\/tpl>)/g, actionsRe: /\s*(elif|elseif|if|for|foreach|exec|switch|case|eval|between)\s*\=\s*(?:(?:"([^"]*)")|(?:'([^']*)'))\s*/g, propRe: /prop=(?:(?:"([^"]*)")|(?:'([^']*)'))/, defaultRe: /^\s*default\s*$/, elseRe: /^\s*else\s*$/ }, 1, 0, 0, 0, 0, 0, [Ext.util, "XTemplateParser"], 0)); (Ext.cmd.derive("Ext.util.XTemplateCompiler", Ext.util.XTemplateParser, { useEval: Ext.isGecko, useIndex: Ext.isIE8m, useFormat: true, propNameRe: /^[\w\d\$]*$/, compile: function (a) { var c = this, b = c.generate(a); return c.useEval ? c.evalTpl(b) : (new Function("Ext", b))(Ext) }, generate: function (a) { var d = this, b = "var fm=Ext.util.Format,ts=Object.prototype.toString;", c; d.maxLevel = 0; d.body = ["var c0=values, a0=" + d.createArrayTest(0) + ", p0=parent, n0=xcount, i0=xindex, k0, v;\n"]; if (d.definitions) { if (typeof d.definitions === "string") { d.definitions = [d.definitions, b] } else { d.definitions.push(b) } } else { d.definitions = [b] } d.switches = []; d.parse(a); d.definitions.push((d.useEval ? "$=" : "return") + " function (" + d.fnArgs + ") {", d.body.join(""), "}"); c = d.definitions.join("\n"); d.definitions.length = d.body.length = d.switches.length = 0; delete d.definitions; delete d.body; delete d.switches; return c }, doText: function (c) { var b = this, a = b.body; c = c.replace(b.aposRe, "\\'").replace(b.newLineRe, "\\n"); if (b.useIndex) { a.push("out[out.length]='", c, "'\n") } else { a.push("out.push('", c, "')\n") } }, doExpr: function (b) { var a = this.body; a.push("if ((v=" + b + ") != null) out"); if (this.useIndex) { a.push("[out.length]=v+''\n") } else { a.push(".push(v+'')\n") } }, doTag: function (a) { var b = this.parseTag(a); if (b) { this.doExpr(b) } else { this.doText("{" + a + "}") } }, doElse: function () { this.body.push("} else {\n") }, doEval: function (a) { this.body.push(a, "\n") }, doIf: function (b, c) { var a = this; if (b === ".") { a.body.push("if (values) {\n") } else { if (a.propNameRe.test(b)) { a.body.push("if (", a.parseTag(b), ") {\n") } else { a.body.push("if (", a.addFn(b), a.callFn, ") {\n") } } if (c.exec) { a.doExec(c.exec) } }, doElseIf: function (b, c) { var a = this; if (b === ".") { a.body.push("else if (values) {\n") } else { if (a.propNameRe.test(b)) { a.body.push("} else if (", a.parseTag(b), ") {\n") } else { a.body.push("} else if (", a.addFn(b), a.callFn, ") {\n") } } if (c.exec) { a.doExec(c.exec) } }, doSwitch: function (c) { var b = this, a; if (c === "." || c === "#") { a = c === "." ? "values" : "xindex"; b.body.push("switch (", a, ") {\n") } else { if (b.propNameRe.test(c)) { b.body.push("switch (", b.parseTag(c), ") {\n") } else { b.body.push("switch (", b.addFn(c), b.callFn, ") {\n") } } b.switches.push(0) }, doCase: function (e) { var d = this, c = Ext.isArray(e) ? e : [e], g = d.switches.length - 1, a, b; if (d.switches[g]) { d.body.push("break;\n") } else { d.switches[g]++ } for (b = 0, g = c.length; b < g; ++b) { a = d.intRe.exec(c[b]); c[b] = a ? a[1] : ("'" + c[b].replace(d.aposRe, "\\'") + "'") } d.body.push("case ", c.join(": case "), ":\n") }, doDefault: function () { var a = this, b = a.switches.length - 1; if (a.switches[b]) { a.body.push("break;\n") } else { a.switches[b]++ } a.body.push("default:\n") }, doEnd: function (b, d) { var c = this, a = c.level - 1; if (b == "for" || b == "foreach") { if (d.exec) { c.doExec(d.exec) } c.body.push("}\n"); c.body.push("parent=p", a, ";values=r", a + 1, ";xcount=n" + a + ";xindex=i", a, "+1;xkey=k", a, ";\n") } else { if (b == "if" || b == "switch") { c.body.push("}\n") } } }, doFor: function (e, h) { var d = this, c, b = d.level, a = b - 1, g; if (e === ".") { c = "values" } else { if (d.propNameRe.test(e)) { c = d.parseTag(e) } else { c = d.addFn(e) + d.callFn } } if (d.maxLevel < b) { d.maxLevel = b; d.body.push("var ") } if (e == ".") { g = "c" + b } else { g = "a" + a + "?c" + a + "[i" + a + "]:c" + a } d.body.push("i", b, "=0,n", b, "=0,c", b, "=", c, ",a", b, "=", d.createArrayTest(b), ",r", b, "=values,p", b, ",k", b, ";\n", "p", b, "=parent=", g, "\n", "if (c", b, "){if(a", b, "){n", b, "=c", b, ".length;}else if (c", b, ".isMixedCollection){c", b, "=c", b, ".items;n", b, "=c", b, ".length;}else if(c", b, ".isStore){c", b, "=c", b, ".data.items;n", b, "=c", b, ".length;}else{c", b, "=[c", b, "];n", b, "=1;}}\n", "for (xcount=n", b, ";i", b, "<n" + b + ";++i", b, "){\n", "values=c", b, "[i", b, "]"); if (h.propName) { d.body.push(".", h.propName) } d.body.push("\n", "xindex=i", b, "+1\n"); if (h.between) { d.body.push('if(xindex>1){ out.push("', h.between, '"); } \n') } }, doForEach: function (e, h) { var d = this, c, b = d.level, a = b - 1, g; if (e === ".") { c = "values" } else { if (d.propNameRe.test(e)) { c = d.parseTag(e) } else { c = d.addFn(e) + d.callFn } } if (d.maxLevel < b) { d.maxLevel = b; d.body.push("var ") } if (e == ".") { g = "c" + b } else { g = "a" + a + "?c" + a + "[i" + a + "]:c" + a } d.body.push("i", b, "=-1,n", b, "=0,c", b, "=", c, ",a", b, "=", d.createArrayTest(b), ",r", b, "=values,p", b, ",k", b, ";\n", "p", b, "=parent=", g, "\n", "for(k", b, " in c", b, "){\n", "xindex=++i", b, "+1;\n", "xkey=k", b, ";\n", "values=c", b, "[k", b, "];"); if (h.propName) { d.body.push(".", h.propName) } if (h.between) { d.body.push('if(xindex>1){ out.push("', h.between, '"); } \n') } }, createArrayTest: ("isArray" in Array) ? function (a) { return "Array.isArray(c" + a + ")" } : function (a) { return "ts.call(c" + a + ')==="[object Array]"' }, doExec: function (d, e) { var c = this, a = "f" + c.definitions.length, b = c.guards[c.strict ? 0 : 1]; c.definitions.push("function " + a + "(" + c.fnArgs + ") {", b.doTry, " var $v = values; with($v) {", "  " + d, " }", b.doCatch, "}"); c.body.push(a + c.callFn + "\n") }, guards: [{ doTry: "", doCatch: "" }, { doTry: "try { ", doCatch: " } catch(e) {\n}" }], addFn: function (a) { var d = this, b = "f" + d.definitions.length, c = d.guards[d.strict ? 0 : 1]; if (a === ".") { d.definitions.push("function " + b + "(" + d.fnArgs + ") {", " return values", "}") } else { if (a === "..") { d.definitions.push("function " + b + "(" + d.fnArgs + ") {", " return parent", "}") } else { d.definitions.push("function " + b + "(" + d.fnArgs + ") {", c.doTry, " var $v = values; with($v) {", "  return(" + a + ")", " }", c.doCatch, "}") } } return b }, parseTag: function (b) { var h = this, a = h.tagRe.exec(b), e, i, d, g, c; if (!a) { return null } e = a[1]; i = a[2]; d = a[3]; g = a[4]; if (e == ".") { if (!h.validTypes) { h.definitions.push("var validTypes={string:1,number:1,boolean:1};"); h.validTypes = true } c = 'validTypes[typeof values] || ts.call(values) === "[object Date]" ? values : ""' } else { if (e == "#") { c = "xindex" } else { if (e == "$") { c = "xkey" } else { if (e.substr(0, 7) == "parent.") { c = e } else { if (isNaN(e) && e.indexOf("-") == -1 && e.indexOf(".") != -1) { c = "values." + e } else { c = "values['" + e + "']" } } } } } if (g) { c = "(" + c + g + ")" } if (i && h.useFormat) { d = d ? "," + d : ""; if (i.substr(0, 5) != "this.") { i = "fm." + i + "(" } else { i += "(" } } else { return c } return i + c + d + ")" }, evalTpl: function ($) { eval($); return $ }, newLineRe: /\r\n|\r|\n/g, aposRe: /[']/g, intRe: /^\s*(\d+)\s*$/, tagRe: /^([\w-\.\#\$]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?(\s?[\+\-\*\/]\s?[\d\.\+\-\*\/\(\)]+)?$/ }, 0, 0, 0, 0, 0, 0, [Ext.util, "XTemplateCompiler"], function () { var a = this.prototype; a.fnArgs = "out,values,parent,xindex,xcount,xkey"; a.callFn = ".call(this," + a.fnArgs + ")" })); (Ext.cmd.derive("Ext.XTemplate", Ext.Template, { isXTemplate: true, emptyObj: {}, fn: null, strict: false, apply: function (a, b, c, d) { return this.applyOut(a, [], b, c, d).join("") }, applyOut: function (a, b, d, h, j) { var g = this, c; if (!g.fn) { c = new Ext.util.XTemplateCompiler({ useFormat: g.disableFormats !== true, definitions: g.definitions, strict: g.strict }); g.fn = c.compile(g.html) } h = h || 1; j = j || 1; if (g.strict) { g.fn(b, a, d || g.emptyObj, h, j) } else { try { g.fn(b, a, d || g.emptyObj, h, j) } catch (i) { } } return b }, compile: function () { return this }, statics: { getTpl: function (b, d) { var c = b[d], a; if (c && !c.isTemplate) { c = Ext.ClassManager.dynInstantiate("Ext.XTemplate", c); if (b.hasOwnProperty(d)) { a = b } else { for (a = b.self.prototype; a && !a.hasOwnProperty(d); a = a.superclass) { } } a[d] = c; c.owner = a } return c || null } } }, 0, 0, 0, 0, 0, 0, [Ext, "XTemplate"], 0)); (Ext.cmd.derive("Ext.app.EventDomain", Ext.Base, { statics: { instances: {} }, isEventDomain: true, isInstance: false, constructor: function () { var a = this; if (!a.isInstance) { Ext.app.EventDomain.instances[a.type] = a } a.bus = {}; a.monitoredClasses = [] }, dispatch: function (j, n, l) { n = Ext.canonicalEventName(n); var m = this, k = m.bus, o = k[n], e, c, b, d, p, h, g, a; if (!o) { return true } for (e in o) { if (o.hasOwnProperty(e) && m.match(j, e, m.controller)) { c = o[e]; for (b in c) { if (c.hasOwnProperty(b)) { d = c[b]; if (d.controller.isActive()) { p = d.list; h = p.length; for (g = 0; g < h; g++) { a = p[g]; if (a.fire.apply(a, l) === false) { return false } } } } } } } return true }, listen: function (d, n) { var w = this, m = w.bus, h = w.idProperty, j = w.monitoredClasses, e = j.length, l = n.getId(), v = (w.type === "component"), q = v ? n.getRefMap() : null, s, k, t, r, b, c, a, p, o, u, g; for (r in d) { o = d[r]; if (v) { r = q[r] || r } if (o) { if (h) { r = r === "*" ? r : r.substring(1) } for (u in o) { b = null; c = o[u]; a = n; u = Ext.canonicalEventName(u); p = new Ext.util.Event(n, u); if (Ext.isObject(c)) { b = c; c = b.fn; a = b.scope || n; delete b.fn; delete b.scope } if (typeof c === "string") { c = a[c] } p.addListener(c, a, b); for (s = 0; s < e; ++s) { g = j[s].hasListeners; if (g) { g._incr_(u) } } k = m[u] || (m[u] = {}); k = k[r] || (k[r] = {}); t = k[l] || (k[l] = { controller: n, list: [] }); t.list.push(p) } } } }, match: function (c, a) { var b = this.idProperty; if (b) { return a === "*" || c[b] === a } return false }, monitor: function (c) { var b = this, a = c.isInstance ? c : c.prototype, d = a.doFireEvent; b.monitoredClasses.push(c); a.doFireEvent = function (i, g) { var h = this, e; e = d.apply(h, arguments); if (e !== false && !h.destroyed && !h.isSuspended(i)) { e = b.dispatch(h, i, g) } return e } }, unlisten: function (d) { var n = this.bus, a = d, r = this.monitoredClasses, l = r.length, b, o, s, m, q, e, p, k, h, c, g; if (d.isController) { a = d.getId() } for (o in n) { o = Ext.canonicalEventName(o); if (n.hasOwnProperty(o) && (p = n[o])) { for (e in p) { b = p[e]; c = b[a]; if (c) { s = c.list; if (s) { for (k = 0, m = s.length; k < m; ++k) { q = s[k]; q.clearListeners(); for (h = 0; h < l; ++h) { g = r[h].hasListeners; if (g) { g._decr_(q.name) } } } delete b[a] } } } } } }, destroy: function () { this.monitoredClasses = this.bus = null; this.callParent() } }, 1, 0, 0, 0, 0, 0, [Ext.app, "EventDomain"], 0)); (Ext.cmd.derive("Ext.app.domain.Component", Ext.app.EventDomain, { singleton: true, type: "component", constructor: function () { this.callParent(); this.monitor(Ext.Widget) }, dispatch: function (g, d, c) { var b = g.lookupController(false), e, a; while (b) { e = b.compDomain; if (e) { if (e.dispatch(g, d, c) === false) { return false } } a = b.getView(); b = a ? a.lookupController(true) : null } return this.callParent(arguments) }, match: function (b, a) { return b.is(a) } }, 1, 0, 0, 0, 0, 0, [Ext.app.domain, "Component"], 0)); (Ext.cmd.derive("Ext.util.ProtoElement", Ext.Base, function () { var b = Ext.String.splitWords, a = Ext.Array.toMap; return { isProtoEl: true, clsProp: "cls", styleProp: "style", removedProp: "removed", styleIsText: false, constructor: function (d) { var g = this, c, e; if (d) { Ext.apply(g, d); c = g.cls; e = g.style; delete g.cls } g.classList = c ? b(c) : []; g.classMap = c ? a(g.classList) : {}; if (e) { if (typeof e === "string") { g.style = Ext.Element.parseStyles(e) } else { if (Ext.isFunction(e)) { g.styleFn = e; delete g.style } else { g.style = Ext.apply({}, e) } } } }, flush: function () { this.flushClassList = []; this.removedClasses = {}; delete this.style; delete this.unselectableAttr }, addCls: function (n) { if (!n) { return this } var l = this, m = (typeof n === "string") ? b(n) : n, e = m.length, j = l.classList, d = l.classMap, g = l.flushClassList, h = 0, k; for (; h < e; ++h) { k = m[h]; if (!d[k]) { d[k] = true; j.push(k); if (g) { g.push(k); delete l.removedClasses[k] } } } return l }, hasCls: function (c) { return c in this.classMap }, removeCls: function (o) { var n = this, l = n.classList, g = (n.classList = []), j = a(b(o)), e = l.length, d = n.classMap, k = n.removedClasses, h, m; for (h = 0; h < e; ++h) { m = l[h]; if (j[m]) { if (k) { if (d[m]) { k[m] = true; Ext.Array.remove(n.flushClassList, m) } } delete d[m] } else { g.push(m) } } return n }, setStyle: function (g, e) { var d = this, c = d.style || (d.style = {}); if (typeof g === "string") { if (arguments.length === 1) { d.setStyle(Ext.Element.parseStyles(g)) } else { c[g] = e } } else { Ext.apply(c, g) } return d }, unselectable: function () { this.addCls(Ext.dom.Element.unselectableCls); if (Ext.isOpera) { this.unselectableAttr = true } }, writeTo: function (h) { var e = this, g = e.flushClassList || e.classList, d = e.removedClasses, c; if (e.styleFn) { c = Ext.apply({}, e.styleFn()); Ext.apply(c, e.style) } else { c = e.style } h[e.clsProp] = g.join(" "); if (c) { h[e.styleProp] = e.styleIsText ? Ext.DomHelper.generateStyles(c, null, true) : c } if (d) { d = Ext.Object.getKeys(d); if (d.length) { h[e.removedProp] = d.join(" ") } } if (e.unselectableAttr) { h.unselectable = "on" } return h } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "ProtoElement"], 0)); (Ext.cmd.derive("Ext.dom.CompositeElement", Ext.dom.CompositeElementLite, { alternateClassName: "Ext.CompositeElement", isLite: false, getElement: function (a) { return a }, transformElement: function (a) { return Ext.get(a) } }, 0, 0, 0, 0, 0, 0, [Ext.dom, "CompositeElement", Ext, "CompositeElement"], 0)); (Ext.cmd.derive("Ext.util.CSS", Ext.Base, function () { var c, e = null, d = document, b = /(-[a-z])/gi, a = function (g, h) { return h.charAt(1).toUpperCase() }; return { singleton: true, rules: e, initialized: false, constructor: function () { c = this }, createStyleSheet: function (i, k) { var h, g = d.getElementsByTagName("head")[0], j = d.createElement("style"); j.setAttribute("type", "text/css"); if (k) { j.setAttribute("id", k) } h = j.styleSheet; if (h) { g.appendChild(j); h.cssText = i } else { j.appendChild(d.createTextNode(i)); g.appendChild(j); h = j.sheet } c.cacheStyleSheet(h); return h }, removeStyleSheet: function (g) { var h = (typeof g === "string") ? d.getElementById(g) : g.ownerNode; if (h) { h.parentNode.removeChild(h) } }, swapStyleSheet: function (i, g) { var h; c.removeStyleSheet(i); h = d.createElement("link"); h.setAttribute("rel", "stylesheet"); h.setAttribute("type", "text/css"); h.setAttribute("id", i); h.setAttribute("href", g); d.getElementsByTagName("head")[0].appendChild(h) }, cacheStyleSheet: function (m) { if (!e) { e = c.rules = {} } try { var p = m.cssRules || m.rules, l = p.length - 1, h = m.imports, g = h ? h.length : 0, o, k; for (k = 0; k < g; ++k) { c.cacheStyleSheet(h[k]) } for (; l >= 0; --l) { o = p[l]; if (o.styleSheet) { c.cacheStyleSheet(o.styleSheet) } c.cacheRule(o, m) } } catch (n) { } }, cacheRule: function (h, l) { if (h.styleSheet) { return c.cacheStyleSheet(h.styleSheet) } var k = h.selectorText, i, g; if (k) { k = k.split(","); i = k.length; for (g = 0; g < i; g++) { e[Ext.String.trim(k[g]).toLowerCase()] = { parentStyleSheet: l, cssRule: h } } } }, getRules: function (i) { var h = {}, g; if (e === null || i) { c.refreshCache() } for (g in e) { h[g] = e[g].cssRule } return h }, refreshCache: function () { var j = d.styleSheets, h = 0, g = j.length; e = c.rules = {}; for (; h < g; h++) { try { if (!j[h].disabled) { c.cacheStyleSheet(j[h]) } } catch (k) { } } }, getRule: function (h, k, j) { var l, g; if (!e || k) { c.refreshCache() } if (!Ext.isArray(h)) { g = e[h.toLowerCase()]; if (g && !j) { g = g.cssRule } return g || null } for (l = 0; l < h.length; l++) { if (e[h[l]]) { return j ? e[h[l].toLowerCase()] : e[h[l].toLowerCase()].cssRule } } return null }, createRule: function (l, h, j) { var g, k = l.cssRules || l.rules, i = k.length; if (l.insertRule) { l.insertRule(h + " {" + j + "}", i) } else { l.addRule(h, j || " ") } c.cacheRule(g = k[i], l); return g }, updateRule: function (g, l, k) { var m, h, j; if (!Ext.isArray(g)) { m = c.getRule(g); if (m) { if (arguments.length === 2) { j = Ext.Element.parseStyles(l); for (l in j) { m.style[l.replace(b, a)] = j[l] } } else { m.style[l.replace(b, a)] = k } return true } } else { for (h = 0; h < g.length; h++) { if (c.updateRule(g[h], l, k)) { return true } } } return false }, deleteRule: function (g) { var i = c.getRule(g, false, true), j, h; if (i) { j = i.parentStyleSheet; h = Ext.Array.indexOf(j.cssRules || j.rules, i.cssRule); if (j.deleteRule) { j.deleteRule(h) } else { j.removeRule(h) } delete e[g] } } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "CSS"], 0)); (Ext.cmd.derive("Ext.fx.easing.Abstract", Ext.Base, { config: { startTime: 0, startValue: 0 }, isEasing: true, isEnded: false, constructor: function (a) { this.initConfig(a); return this }, applyStartTime: function (a) { if (!a) { a = Ext.Date.now() } return a }, updateStartTime: function (a) { this.reset() }, reset: function () { this.isEnded = false }, getValue: Ext.emptyFn }, 1, 0, 0, 0, 0, 0, [Ext.fx.easing, "Abstract"], 0)); (Ext.cmd.derive("Ext.fx.easing.Linear", Ext.fx.easing.Abstract, { config: { duration: 0, endValue: 0 }, updateStartValue: function (a) { this.distance = this.getEndValue() - a }, updateEndValue: function (a) { this.distance = a - this.getStartValue() }, getValue: function () { var a = Ext.Date.now() - this.getStartTime(), b = this.getDuration(); if (a > b) { this.isEnded = true; return this.getEndValue() } else { return this.getStartValue() + ((a / b) * this.distance) } } }, 0, 0, 0, 0, ["easing.linear"], 0, [Ext.fx.easing, "Linear"], 0)); (Ext.cmd.derive("Ext.util.translatable.Abstract", Ext.Evented, { config: { useWrapper: null, easing: null, easingX: { duration: 300 }, easingY: { duration: 300 } }, x: 0, y: 0, activeEasingX: null, activeEasingY: null, isAnimating: false, isTranslatable: true, constructor: function (a) { this.mixins.observable.constructor.call(this, a); this.position = { x: 0, y: 0 } }, factoryEasing: function (a) { return Ext.factory(a, Ext.fx.easing.Linear, null, "easing") }, applyEasing: function (a) { if (!this.getEasingX()) { this.setEasingX(this.factoryEasing(a)) } if (!this.getEasingY()) { this.setEasingY(this.factoryEasing(a)) } }, applyEasingX: function (a) { return this.factoryEasing(a) }, applyEasingY: function (a) { return this.factoryEasing(a) }, doTranslate: function (a, b) { if (this.hasListeners.translate) { this.fireEvent("translate", this, a, b) } }, translate: function (a, c, b) { if (b) { return this.translateAnimated(a, c, b) } if (this.isAnimating) { this.stopAnimation() } if (!isNaN(a) && typeof a == "number") { this.x = a } if (!isNaN(c) && typeof c == "number") { this.y = c } this.doTranslate(a, c) }, translateAxis: function (b, d, c) { var a, e; if (b == "x") { a = d } else { e = d } return this.translate(a, e, c) }, getPosition: function () { var b = this, a = b.position; a.x = -b.x; a.y = -b.y; return a }, animate: function (b, a) { this.activeEasingX = b; this.activeEasingY = a; this.isAnimating = true; this.lastX = null; this.lastY = null; Ext.AnimationQueue.start(this.doAnimationFrame, this); this.fireEvent("animationstart", this, this.x, this.y); return this }, translateAnimated: function (b, i, g) { var e = this; if (!Ext.isObject(g)) { g = {} } if (e.isAnimating) { e.stopAnimation() } e.callback = g.callback; e.callbackScope = g.scope; var d = Ext.Date.now(), h = g.easing, c = (typeof b == "number") ? (g.easingX || h || e.getEasingX() || true) : null, a = (typeof i == "number") ? (g.easingY || h || e.getEasingY() || true) : null; if (c) { c = e.factoryEasing(c); c.setStartTime(d); c.setStartValue(e.x); c.setEndValue(b); if ("duration" in g) { c.setDuration(g.duration) } } if (a) { a = e.factoryEasing(a); a.setStartTime(d); a.setStartValue(e.y); a.setEndValue(i); if ("duration" in g) { a.setDuration(g.duration) } } return e.animate(c, a) }, doAnimationFrame: function () { var e = this, c = e.activeEasingX, b = e.activeEasingY, d = Date.now(), a, g; if (!e.isAnimating) { return } e.lastRun = d; if (c === null && b === null) { e.stopAnimation(); return } if (c !== null) { e.x = a = Math.round(c.getValue()); if (c.isEnded) { e.activeEasingX = null; e.fireEvent("axisanimationend", e, "x", a) } } else { a = e.x } if (b !== null) { e.y = g = Math.round(b.getValue()); if (b.isEnded) { e.activeEasingY = null; e.fireEvent("axisanimationend", e, "y", g) } } else { g = e.y } if (e.lastX !== a || e.lastY !== g) { e.doTranslate(a, g); e.lastX = a; e.lastY = g } e.fireEvent("animationframe", e, a, g) }, stopAnimation: function () { var a = this; if (!a.isAnimating) { return } a.activeEasingX = null; a.activeEasingY = null; a.isAnimating = false; Ext.AnimationQueue.stop(a.doAnimationFrame, a); if (!a.destroying) { a.fireEvent("animationend", a, a.x, a.y); if (a.callback) { a.callback.call(a.callbackScope); a.callback = null } } }, refresh: function () { this.translate(this.x, this.y) }, destroy: function () { var a = this; a.destroying = true; if (a.isAnimating) { a.stopAnimation() } Ext.Evented.prototype.destroy.call(this); a.destroying = false; a.destroyed = true } }, 1, 0, 0, 0, 0, 0, [Ext.util.translatable, "Abstract"], 0)); (Ext.cmd.derive("Ext.util.translatable.Dom", Ext.util.translatable.Abstract, { config: { element: null }, applyElement: function (a) { if (!a) { return } return Ext.get(a) }, updateElement: function () { this.refresh() } }, 0, 0, 0, 0, 0, 0, [Ext.util.translatable, "Dom"], 0)); (Ext.cmd.derive("Ext.util.translatable.ScrollPosition", Ext.util.translatable.Dom, { type: "scrollposition", constructor: function (a) { if (a && a.element) { this.x = a.element.getScrollLeft(); this.y = a.element.getScrollTop() } Ext.util.translatable.Dom.prototype.constructor.call(this, a) }, translateAnimated: function () { var a = this.getElement(); this.x = a.getScrollLeft(); this.y = a.getScrollTop(); Ext.util.translatable.Dom.prototype.translateAnimated.apply(this, arguments) }, doTranslate: function (a, c) { var b = this.getElement(); b.setScrollLeft(Math.round(a)); b.setScrollTop(Math.round(c)) }, getPosition: function () { var c = this, a = c.position, b = c.getElement(); a.x = b.getScrollLeft(); a.y = b.getScrollTop(); return a } }, 1, 0, 0, 0, 0, 0, [Ext.util.translatable, "ScrollPosition"], 0)); (Ext.cmd.derive("Ext.scroll.Scroller", Ext.Evented, { factoryConfig: { defaultType: "scroller" }, isScroller: true, config: { direction: undefined, element: undefined, scrollbars: null, snapSelector: null, snapOffset: null, msSnapInterval: null, x: true, y: true, scrollElement: null, size: null, spacerXY: null }, snappableCls: "x-scroller-snappable", elementCls: "x-scroller", spacerCls: "x-scroller-spacer", noScrollbarsCls: "x-no-scrollbars", statics: { create: function (a, b) { return Ext.Factory.scroller(a, b) }, getScrollingElement: function () { var e = document, a = this.$standardScrollElement, d = e.scrollingElement, c, b; if (d) { return d } if (a === undefined) { c = document.createElement("iframe"); c.style.height = "1px"; document.body.appendChild(c); b = c.contentWindow.document; b.write('<!DOCTYPE html><div style="height:9999em">x</div>'); b.close(); a = b.documentElement.scrollHeight > b.body.scrollHeight; c.parentNode.removeChild(c); this.$standardScrollElement = a } return a ? e.documentElement : e.body } }, constructor: function (a) { var b = this; b.position = { x: 0, y: 0 }; Ext.Evented.prototype.constructor.call(this, a); b.onDomScrollEnd = Ext.Function.createBuffered(b.onDomScrollEnd, 100, b) }, destroy: function () { var a = this; a.setX(Ext.emptyString); a.setY(Ext.emptyString); a.setElement(null); a.setScrollElement(null); a.onDomScrollEnd = a._partners = a.component = null; if (a._translatable) { a._translatable.destroy(); a._translatable = null } a.removeSnapStylesheet(); Ext.Evented.prototype.destroy.call(this) }, addPartner: function (d, b) { var c = this, e = c._partners || (c._partners = {}), a = d._partners || (d._partners = {}); e[d.getId()] = { scroller: d, axis: b }; a[c.getId()] = { scroller: c, axis: b } }, applyElement: function (b, a) { var d = this, c, e, g; if (a) { d.scrollListener.destroy() } if (b) { if (b.isElement) { c = b } else { c = Ext.get(b) } if (c.dom === document.documentElement || c.dom === document.body) { e = Ext.getWin(); g = Ext.scroll.Scroller.getScrollingElement() } else { g = e = c } d.setScrollElement(Ext.get(g)); d.scrollListener = e.on({ scroll: d.onDomScroll, scope: d, destroyable: true }); return c } }, applySize: function (b, c) { var a, d; if (b === null || typeof b === "number") { a = d = b } else { if (b) { a = b.x; d = b.y } } if (a === null) { a = 0 } else { if (a === undefined) { a = (c ? c.x : 0) } } if (d === null) { d = 0 } else { if (d === undefined) { d = (c ? c.y : 0) } } return { x: a, y: d } }, getClientSize: function () { var a = this.getElement().dom; return { x: a.clientWidth, y: a.clientHeight } }, getScrollbarSize: function () { var g = this, b = 0, k = 0, e = g.getElement(), d, j, i, h, c, a; if (e && !e.destroyed) { j = g.getX(); i = g.getY(); d = e.dom; if (j || i) { a = Ext.getScrollbarSize() } if (j === "scroll") { h = true } else { if (j) { h = d.scrollWidth > d.clientWidth } } if (i === "scroll") { c = true } else { if (i) { c = d.scrollHeight > d.clientHeight } } if (h) { k = a.height } if (c) { b = a.width } } return { width: b, height: k } }, getPosition: function () { var a = this; if (a.positionDirty) { a.updateDomScrollPosition() } return a.position }, getSize: function () { var b = this.getElement(), a, c; if (b && !b.destroyed) { c = b.dom; a = { x: c.scrollWidth, y: c.scrollHeight } } else { a = { x: 0, y: 0 } } return a }, getMaxPosition: function () { var b = this.getElement(), a = 0, d = 0, c; if (b && !b.destroyed) { c = b.dom; a = c.scrollWidth - c.clientWidth; d = c.scrollHeight - c.clientHeight } return { x: a, y: d } }, getMaxUserPosition: function () { var c = this, b = c.getElement(), a = 0, e = 0, d; if (b && !b.destroyed) { d = b.dom; if (c.getX()) { a = d.scrollWidth - d.clientWidth } if (c.getY()) { e = d.scrollHeight - d.clientHeight } } return { x: a, y: e } }, refresh: function () { this.positionDirty = true; this.fireEvent("refresh", this); return this }, removePartner: function (b) { var c = this._partners, a = b._partners; if (c) { delete c[b.getId()] } if (a) { delete (a[this.getId()]) } }, scrollBy: function (c, b, d) { var a = this.getPosition(); if (c) { if (c.length) { d = b; b = c[1]; c = c[0] } else { if (typeof c !== "number") { d = b; b = c.y; c = c.x } } } c = (typeof c === "number") ? c + a.x : null; b = (typeof b === "number") ? b + a.y : null; return this.doScrollTo(c, b, d) }, scrollIntoView: function (d, e, b, h) { var j = this, i = j.getPosition(), g, a, k, c = j.getElement(); if (d) { g = Ext.fly(d).getScrollIntoViewXY(c, i.x, i.y); a = (e === false) ? i.x : g.x; k = g.y; if (k !== i.y || a !== i.x) { if (h) { j.on({ scrollend: "doHighlight", scope: j, single: true, args: [d, h] }) } j.doScrollTo(a, k, b) } else { if (h) { j.doHighlight(d, h) } } } }, isInView: function (a) { return this.doIsInView(a) }, scrollTo: function (a, d, b) { var c; if (a) { if (a.length) { b = d; d = a[1]; a = a[0] } else { if (typeof a !== "number") { b = d; d = a.y; a = a.x } } } if (a < 0 || d < 0) { c = this.getMaxPosition(); if (a < 0) { a += c.x } if (d < 0) { d += c.y } } this.doScrollTo(a, d, b) }, updateDirection: function (c) { var b = this, a, d; if (!c) { a = b.getX(); d = b.getY(); if (a && d) { c = (d === "scroll" && a === "scroll") ? "both" : "auto" } else { if (d) { c = "vertical" } else { if (a) { c = "horizontal" } } } b._direction = c } else { if (c === "auto") { a = true; d = true } else { if (c === "vertical") { a = false; d = true } else { if (c === "horizontal") { a = true; d = false } else { if (c === "both") { a = "scroll"; d = "scroll" } } } } b.setX(a); b.setY(d) } }, updateScrollbars: function (a, b) { this.syncScrollbarCls() }, updateSize: function (d) { var e = this, c = e.getElement(), a = d.x, g = d.y, b; if (c) { e.positionDirty = true; b = e.getSpacer(); if (!a && !g) { b.hide() } else { if (a > 0) { a -= 1 } if (g > 0) { g -= 1 } e.setSpacerXY({ x: a, y: g }); b.show() } } }, updateMsSnapInterval: function () { this.initMsSnapInterval() }, updateSnapSelector: function () { this.initSnap() }, updateSnapOffset: function () { this.initSnap() }, updateElement: function (a) { var b = this; b.initXStyle(); b.initYStyle(); a.addCls(b.elementCls); b.initSnap(); b.initMsSnapInterval(); b.syncScrollbarCls() }, updateX: function (a) { this.initXStyle() }, updateY: function (a) { this.initYStyle() }, deprecated: { "5": { methods: { getScroller: function () { return this } } }, "5.1.0": { methods: { scrollToTop: function (a) { return this.scrollTo(0, 0, a) }, scrollToEnd: function (a) { return this.scrollTo(Infinity, Infinity, a) } } } }, privates: { getSpacer: function () { var c = this, a = c._spacer, b; if (!a) { b = c.getElement(); a = c._spacer = b.createChild({ cls: c.spacerCls, role: "presentation" }, b.dom.firstChild); a.setVisibilityMode(2); a.hide(); b.position() } return a }, applySpacerXY: function (b, a) { if (a && b.x === a.x && b.y === a.y) { b = undefined } return b }, updateSpacerXY: function (g) { var c = this, a = c.getSpacer(), e = a.dom.style, b = g.y, d; e.marginTop = ""; c.translateSpacer(g.x, c.constrainScrollRange(b)); e.lineHeight = Number(!parseInt(e.lineHeight, 10)) + "px"; d = b - c.getElement().dom.scrollHeight; if (d > 0) { e.marginTop = Math.min(d, c.maxSpacerMargin || 0) + "px" } }, translateSpacer: function (a, b) { this.getSpacer().translate(a, b) }, doIsInView: function (d, g) { var e = this, j = e.component, a = { x: false, y: false }, h, i = e.getElement(), b; if (d && (g || (i.contains(d) || (j && j.owns(d))))) { b = i.getRegion(); h = Ext.fly(d).getRegion(); a.x = h.right > b.left && h.left < b.right; a.y = h.bottom > b.top && h.top < b.bottom } return a }, constrainScrollRange: function (c) { if (c < 1000000) { return c } if (!this.maxSpacerTranslate) { var b = Math.pow(2, 32), h = b, e = 500, a = Ext.getBody().createChild({ style: { position: "absolute", left: "-10000px", top: "0", width: "500px", height: "500px" }, cn: { cls: this.spacerCls } }, null, true), d = Ext.get(a.firstChild), g = d.dom.style; d.translate(0, b - 1); g.lineHeight = Number(!parseInt(g.lineHeight, 10)) + "px"; while (h !== e + 1) { d.translate(0, (b = e + Math.floor((h - e) / 2))); g.lineHeight = Number(!parseInt(g.lineHeight, 10)) + "px"; if (a.scrollHeight < b) { h = b } else { e = b } } d.translate(0, Ext.scroll.Scroller.prototype.maxSpacerTranslate = e); h = e * 2; while (h !== e + 1) { d.dom.style.marginTop = ((b = e + Math.floor((h - e) / 2))) + "px"; g.lineHeight = Number(!parseInt(g.lineHeight, 10)) + "px"; if (a.scrollHeight < b) { h = b } else { e = b } } Ext.fly(a).destroy(); Ext.scroll.Scroller.prototype.maxSpacerMargin = e - Ext.scroll.Scroller.prototype.maxSpacerTranslate } return Math.min(c, this.maxSpacerTranslate) }, convertX: function (a) { return a }, doHighlight: function (b, a) { if (a !== true) { Ext.fly(b).highlight(a) } else { Ext.fly(b).highlight() } }, doScrollTo: function (k, j, a) { var h = this, d = h.getScrollElement(), e, b, l, g, c; if (d && !d.destroyed) { b = d.dom; l = (k === Infinity); g = (j === Infinity); if (l || g) { e = h.getMaxPosition(); if (l) { k = e.x } if (g) { j = e.y } } k = h.convertX(k); if (a) { if (!this._translatable) { this._translatable = new Ext.util.translatable.ScrollPosition({ element: d }) } this._translatable.translate(k, j, a) } else { if (j != null) { b.scrollTop = j } if (k != null) { b.scrollLeft = k; if (Ext.isIE8) { c = b.scrollLeft; b.scrollLeft = k } } } h.positionDirty = true } }, fireScrollStart: function (a, d) { var c = this, b = c.component; c.invokePartners("onPartnerScrollStart", a, d); if (c.hasListeners.scrollstart) { c.fireEvent("scrollstart", c, a, d) } if (b && b.onScrollStart) { b.onScrollStart(a, d) } Ext.GlobalEvents.fireEvent("scrollstart", c, a, d) }, fireScroll: function (a, d) { var c = this, b = c.component; c.invokePartners("onPartnerScroll", a, d); if (c.hasListeners.scroll) { c.fireEvent("scroll", c, a, d) } if (b && b.onScrollMove) { b.onScrollMove(a, d) } Ext.GlobalEvents.fireEvent("scroll", c, a, d) }, fireScrollEnd: function (a, d) { var c = this, b = c.component; c.invokePartners("onPartnerScrollEnd", a, d); if (c.hasListeners.scrollend) { c.fireEvent("scrollend", c, a, d) } if (b && b.onScrollEnd) { b.onScrollEnd(a, d) } Ext.GlobalEvents.fireEvent("scrollend", c, a, d) }, getElementScroll: function (a) { return a.getScroll() }, initSnap: function () { var d = this, h = d.getSnapOffset(), e = d.getSnapSelector(), c = d.getElement(), a, g, b; if (c && e) { c.addCls(d.snappableCls); d.removeSnapStylesheet(); if (h) { a = h.x || 0; g = h.y || 0; if (a) { a = -a + "px" } if (g) { g = -g + "px" } } b = a + " " + g + ";"; d.snapStylesheet = Ext.util.CSS.createStyleSheet("#" + c.id + " " + e + "{-webkit-scroll-snap-coordinate:" + b + "scroll-snap-coordinate:" + b + "}") } }, initMsSnapInterval: function () { var c = this.getElement(), b, a, e, d; if (c) { b = this.getMsSnapInterval(); if (b) { a = b.x; e = b.y; d = c.dom.style; if (a) { d["-ms-scroll-snap-points-x"] = "snapInterval(0px, " + a + "px)" } if (e) { d["-ms-scroll-snap-points-y"] = "snapInterval(0px, " + e + "px)" } } } }, initXStyle: function () { var b = this.getElement(), a = this.getX(); if (b && b.dom) { if (!a) { a = "hidden" } else { if (a === true) { a = "auto" } } b.setStyle("overflow-x", a) } }, initYStyle: function () { var a = this.getElement(), b = this.getY(); if (a && a.dom) { if (!b) { b = "hidden" } else { if (b === true) { b = "auto" } } a.setStyle("overflow-y", b) } }, invokePartners: function (i, a, h) { var c = this, e = c._partners, b, g, d = i === "onPartnerScrollEnd"; if (!c.suspendSync & !c.isReflecting) { for (g in e) { b = e[g].scroller; b.isReflecting = true; b[i](c, a, h); if (d) { b.isReflecting = false } } } }, clearReflecting: function () { this.isReflecting = false }, suspendPartnerSync: function () { this.suspendSync = (this.suspendSync || 0) + 1 }, resumePartnerSync: function (c) { var b = this, a; if (b.suspendSync) { b.suspendSync-- } if (!b.suspendSync && c) { a = b.getPosition(); b.invokePartners("onPartnerScroll", a.x, a.y); b.invokePartners("onPartnerScrollEnd", a.x, a.y) } }, updateDomScrollPosition: function () { var d = this, c = d.getScrollElement(), b, a = d.position; if (c && !c.destroyed) { b = d.getElementScroll(c); a.x = b.left; a.y = b.top } d.positionDirty = false; return a }, syncWithPartners: function () { var c = this, d = c._partners, e, b, a; c.isReflecting = true; for (e in d) { b = d[e].scroller; a = b.getPosition(); c.onPartnerScroll(b, a.x, a.y) } c.isReflecting = false }, syncScrollbarCls: function () { var a = this.getElement(); if (a) { a.toggleCls(this.noScrollbarsCls, this.getScrollbars() === false) } }, onDomScroll: function () { var c = this, b, a, d; b = c.updateDomScrollPosition(); if (c.restoring) { return } a = b.x; d = b.y; if (!c.isScrolling) { c.isScrolling = Ext.isScrolling = true; c.fireScrollStart(a, d) } c.fireScroll(a, d); c.onDomScrollEnd() }, onDomScrollEnd: function () { var c = this, b, a, d; if (c.destroying || c.destroyed) { return } b = c.getPosition(); a = b.x; d = b.y; c.isScrolling = Ext.isScrolling = false; c.trackingScrollLeft = a; c.trackingScrollTop = d; c.fireScrollEnd(a, d) }, onPartnerScroll: function (c, a, d) { var b = c._partners[this.getId()].axis; if (b) { if (b === "x") { d = null } else { if (b === "y") { a = null } } } this.doScrollTo(a, d, false, true) }, onPartnerScrollStart: Ext.privateFn, onPartnerScrollEnd: Ext.privateFn, removeSnapStylesheet: function () { var a = this.snapStylesheet; if (a) { Ext.util.CSS.removeStyleSheet(a); this.snapStylesheet = null } }, restoreState: function () { var b = this, a = b.getScrollElement(); if (a) { if (b.trackingScrollTop !== undefined) { b.restoring = true; Ext.defer(function () { b.restoring = false }, 50); b.doScrollTo(b.trackingScrollLeft, b.trackingScrollTop, false) } } } } }, 1, 0, 0, 0, ["scroller.scroller"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.scroll, "Scroller"], function (a) { Ext.getViewportScroller = function () { return a.viewport || (a.viewport = new a()) }; Ext.setViewportScroller = function (b) { if (a.viewport !== b) { Ext.destroy(a.viewport); a.viewport = b.isScroller ? b : new a(b) } }; Ext.onReady(function () { Ext.defer(function () { var b = Ext.getViewportScroller(); if (!b.getElement()) { b.setElement(Ext.getBody()) } }, 100) }) })); (Ext.cmd.derive("Ext.util.Floating", Ext.Base, { mixinId: "floating", focusOnToFront: true, shadow: "sides", animateShadow: false, constrain: false, alignOnScroll: true, config: { activeCounter: 0, alwaysOnTop: false }, preventDefaultAlign: false, _visModeMap: { visibility: 1, display: 2, offsets: 3 }, constructor: function () { var d = this, c = d.el, e = d.shadow, a, b; if (e) { b = { mode: (e === true) ? "sides" : e }; a = d.shadowOffset; if (a) { b.offset = a } b.animate = d.animateShadow; b.fixed = d.fixed; c.enableShadow(b, false) } if (d.shim || Ext.useShims) { c.enableShim({ fixed: d.fixed }, false) } c.setVisibilityMode(d._visModeMap[d.hideMode]); d.el.on({ mousedown: d.onMouseDown, scope: d, capture: true }); d.registerWithOwnerCt(); d.initHierarchyEvents() }, alignTo: function (c, g, b, a, j) { var i = this, m, l, e, d, k, h; if (c.isComponent) { m = c.el; l = c.destroyed } else { m = c = Ext.get(c); e = m.dom; l = !e || Ext.isGarbage(e) } if (l) { i._lastAlignTarget = null; if (i.alignListeners) { i.alignListeners.destroy() } return } i.mixins.positionable.alignTo.call(i, m, g, b, a, j !== false); d = i.getXY(); k = c.getXY(); i.alignVector = [d[0] - k[0], d[1] - k[1]]; i._lastAlignTarget = c; i._lastAlignToPos = g; i._lastAlignToOffsets = b; i._topAlignTarget = i.getTopAlignTarget(); i.clearClip(); if (!i.alignListeners) { h = { resize: { fn: i.alignOnResize, buffer: 100 }, scope: i, destroyable: true }; if (i.alignOnScroll && !m.contains(i.el)) { h.scroll = i.doRealign } i.alignListeners = Ext.on(h) } }, initFloatConstrain: function () { var a = this, b = a.floatParent; if ((a.constrain || a.constrainHeader) && !a.constrainTo) { a.constrainTo = b ? b.getTargetEl() : a.container } }, initHierarchyEvents: function () { var b = this, a = this.syncHidden; if (!b.hasHierarchyEventListeners) { b.mon(Ext.GlobalEvents, { hide: a, collapse: a, show: a, expand: a, added: a, scope: b }); b.hasHierarchyEventListeners = true } }, registerWithOwnerCt: function () { var c = this, b = c.ownerCt, a = c.zIndexParent; if (a) { a.unregisterFloatingItem(c) } a = c.zIndexParent = c.up("[floating]"); c.floatParent = b || a; c.initFloatConstrain(); delete c.ownerCt; if (a) { a.registerFloatingItem(c) } else { Ext.WindowManager.register(c) } }, onMouseDown: function (h) { var c = this, b = c.focusTask, a = c.getRefOwner(), d = h.pointerType === "touch", g, i, j; if (c.floating && (!b || !b.id)) { if (c.owns(Ext.Element.getActiveElement())) { d = true } g = h.target; i = c.el.dom; while (!d && g && g !== i) { if (Ext.fly(g).isFocusable()) { d = true } g = g.parentNode } j = Ext.WindowManager.getActive() === c && (g === i || d); if (!j) { c.toFront(d) } if (!d && a && a.containsFocus) { h.preventDefault() } } }, onBeforeFloatLayout: function () { this.el.preventSync = true }, onAfterFloatLayout: function () { var a = this.el; if (a.shadow || a.shim) { a.setUnderlaysVisible(true); a.syncUnderlays() } }, syncHidden: function () { var c = this, d = c.hidden || !c.rendered, a = c.hierarchicallyHidden = c.isHierarchicallyHidden(), b = c.pendingShow; if (d !== a) { if (a) { c.hide(); c.pendingShow = true } else { if (b) { delete c.pendingShow; if (b.length) { c.show.apply(c, b) } else { c.show() } } } } }, setZIndex: function (a) { var b = this; b.el.setZIndex(a); a += 10; if (b.floatingDescendants) { a = Math.floor(b.floatingDescendants.setBase(a) / 100) * 100 + 10000 } return a }, doConstrain: function (a) { var b = this, c = b.calculateConstrainedPosition(a, null, true); if (c) { b.setPosition(c) } }, updateActiveCounter: function (a) { var b = this, c = b.zIndexParent; if (c && c !== c.zIndexManager.front && b.bringParentToFront !== false) { c.setActiveCounter(++Ext.ZIndexManager.activeCounter) } c = b.zIndexManager; if (c) { c.onComponentUpdate(b) } }, updateAlwaysOnTop: function (a) { var b = this.zIndexManager; if (b) { b.onComponentUpdate(this) } }, toFront: function (b) { var a = this; if (a.zIndexManager.bringToFront(a, b || !a.focusOnToFront)) { if (a.hasListeners.tofront) { a.fireEvent("tofront", a, a.el.getZIndex()) } } return a }, setActive: function (d, b) { var c = this, a; if (d) { if (c.el.shadow && c.el.getData().isVisible !== false && !c.maximized) { c.el.enableShadow(null, true) } if (b) { a = Ext.ComponentManager.getActiveComponent(); if (!a || !a.up(c)) { c.focus() } } c.fireEvent("activate", c) } else { c.fireEvent("deactivate", c) } }, toBack: function () { this.zIndexManager.sendToBack(this); return this }, center: function () { var a = this, b; if (a.isVisible()) { b = a.getAlignToXY(a.container, "c-c"); a.setPagePosition(b) } else { a.needsCenter = true } return a }, onFloatShow: function () { var a = this; if (a.needsCenter) { a.center() } else { if (a._lastAlignTarget) { a.alignTo(a._lastAlignTarget, a._lastAlignToPos, a._lastAlignToOffsets, false, !a.fixed) } } a.needsCenter = false }, fitContainer: function (c) { var g = this, e = g.floatParent, b = e ? e.getTargetEl() : g.container, a = b.getViewSize(), d = e || (b.dom !== document.body) ? [0, 0] : b.getXY(); a.x = d[0]; a.y = d[1]; g.setBox(a, c) }, privates: { onFloatDestroy: function () { this.clearAlignEl() }, getTopAlignTarget: function () { var b = this._lastAlignTarget, a = b; while (b && (a = b) && b.isComponent) { if (a.isFloating()) { b = a._lastAlignTarget } else { b = a.up("{isFloating()}"); b = b && b._lastAlignTarget } } return a }, clearAlignEl: function () { var a = this; if (a._lastAlignTarget) { a.alignListeners = Ext.destroy(a.alignListeners); Ext.un("scroll", a.doRealign, a); a._lastAlignToPos = a._lastAlignTarget = a._lastAlignToOffsets = a._topAlignTarget = null } }, alignOnResize: function () { this.doRealign() }, doRealign: function (a) { var e = this, c = e._lastAlignTarget.el, d, g, h, b; if (c && e.isVisible()) { if (c.isComponent) { d = c.destroyed } else { g = c.dom; d = !g || Ext.isGarbage(g) } if (d) { e.clearAlignEl() } else { if (!a || (a.getElement().contains(e._topAlignTarget.el) && !a.getElement().contains(e.el))) { h = c.getXY(); b = [h[0] + e.alignVector[0], h[1] + e.alignVector[1]]; e.setXY(b); if (a) { e.clipToScroller(a) } } } } }, clipToScroller: function (a) { var d = this, e = d._topAlignTarget.getBox(), b = a.getElement().getConstrainRegion(), c = 0; if (e.top < b.top) { c = 1 } if (e.right > b.right) { c = c | 2 } if (e.bottom > b.bottom) { c = c | 4 } if (e.left < b.left) { c = c | 8 } if (c) { d.clipTo(b, c) } else { d.clearClip() } } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "Floating"], 0)); (Ext.cmd.derive("Ext.util.ElementContainer", Ext.Base, { mixinId: "elementCt", config: { childEls: { $value: {}, cached: true, lazy: true, merge: function (g, a, e, d) { var c = a ? Ext.Object.chain(a) : {}, b, h; if (g instanceof Array) { for (b = g.length; b--;) { h = g[b]; if (!d || !(h in c)) { if (typeof h === "string") { c[h] = { name: h, itemId: h } } else { c[h.name] = h } } } } else { if (g) { if (g.constructor === Object) { for (b in g) { if (!d || !(b in c)) { h = g[b]; if (h === true) { c[b] = { itemId: b } } else { if (typeof h === "string") { c[b] = { itemId: h } } else { c[b] = h; if (!("itemId" in h)) { h.itemId = b } } } c[b].name = b } } } else { if (!d || !(g in c)) { c[g] = { name: g, itemId: g } } } } } return c } } }, destroy: function () { var c = this, b = c.getChildEls(), d, a; for (a in b) { d = c[a]; if (d) { if (d.destroy) { d.component = null; d.destroy() } c[a] = null } } }, privates: { addChildEl: function (a) { var c = this, b = c.getChildEls(); if (!c.hasOwnProperty("childEls")) { c.childEls = b = Ext.Object.chain(b) } if (typeof a === "string") { a = { name: a, itemId: a } } b[a.name] = a }, afterClassMixedIn: function (c) { var b = c.prototype, a = b.childEls; if (a) { delete b.childEls; c.getConfigurator().add({ childEls: a }) } }, attachChildEls: function (d, c) { var i = this, j = i.getChildEls(), h = c || i, o = h.id + "-", n = !h.frame, p, a, m, g, e, l, b; for (p in j) { m = j[p]; if (n && m.frame) { continue } e = m.select; if (e) { l = d.select(e, true) } else { if (!(e = m.selectNode)) { if (!(b = m.id)) { b = o + m.itemId; l = Ext.cache[b] } else { l = Ext.cache[b] || d.getById(b) } } else { l = d.selectNode(e, false) } } if (l) { if (l.isElement) { l.component = h } else { if (l.isComposite && !l.isLite) { a = l.elements; for (g = a.length; g--;) { a[g].component = h } } } } i[p] = l || null } } } }, 0, 0, 0, 0, 0, 0, [Ext.util, "ElementContainer"], 0)); (Ext.cmd.derive("Ext.util.Renderable", Ext.Base, { mixinId: "renderable", frameCls: "x-frame", frameIdRegex: /[\-]frame\d+[TMB][LCR]$/, frameElNames: ["TL", "TC", "TR", "ML", "MC", "MR", "BL", "BC", "BR", "Table"], frameTpl: ["<tpl if=\"hasTabGuard\">{% this.renderTabGuard(out, values, 'before'); %}</tpl>", '<tpl if="top">', '<tpl if="left"><div id="{fgid}TL" data-ref="frameTL" class="{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tl</tpl>{frameElCls}" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}TR" data-ref="frameTR" class="{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tr</tpl>{frameElCls}" role="presentation"></tpl>', '<div id="{fgid}TC" data-ref="frameTC" class="{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tc</tpl>{frameElCls}" role="presentation"></div>', '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', "</tpl>", '<tpl if="left"><div id="{fgid}ML" data-ref="frameML" class="{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-ml</tpl>{frameElCls}" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}MR" data-ref="frameMR" class="{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mr</tpl>{frameElCls}" role="presentation"></tpl>', '<div id="{fgid}Body" data-ref="frameBody" class="{frameBodyCls} {frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mc</tpl>{frameElCls}" role="presentation">', "{%this.applyRenderTpl(out, values)%}", "</div>", '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', '<tpl if="bottom">', '<tpl if="left"><div id="{fgid}BL" data-ref="frameBL" class="{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bl</tpl>{frameElCls}" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}BR" data-ref="frameBR" class="{frameCls}-br {baseCls}-br {baseCls}-{ui}-br<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-br</tpl>{frameElCls}" role="presentation"></tpl>', '<div id="{fgid}BC" data-ref="frameBC" class="{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bc</tpl>{frameElCls}" role="presentation"></div>', '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', "</tpl>", "<tpl if=\"hasTabGuard\">{% this.renderTabGuard(out, values, 'after'); %}</tpl>"], frameTableTpl: ["<tpl if=\"hasTabGuard\">{% this.renderTabGuard(out, values, 'before'); %}</tpl>", '<table id="{fgid}Table" data-ref="frameTable" class="{frameCls} ', 'x-table-plain" cellpadding="0" role="presentation">', '<tpl if="top">', '<tr role="presentation">', '<tpl if="left"><td id="{fgid}TL" data-ref="frameTL" class="{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tl</tpl>{frameElCls}" role="presentation"></td></tpl>', '<td id="{fgid}TC" data-ref="frameTC" class="{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tc</tpl>{frameElCls}" role="presentation"></td>', '<tpl if="right"><td id="{fgid}TR" data-ref="frameTR" class="{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tr</tpl>{frameElCls}" role="presentation"></td></tpl>', "</tr>", "</tpl>", '<tr role="presentation">', '<tpl if="left"><td id="{fgid}ML" data-ref="frameML" class="{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-ml</tpl>{frameElCls}" role="presentation"></td></tpl>', '<td id="{fgid}Body" data-ref="frameBody" class="{frameBodyCls} {frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mc</tpl>{frameElCls}" style="{mcStyle}" role="presentation">', "{%this.applyRenderTpl(out, values)%}", "</td>", '<tpl if="right"><td id="{fgid}MR" data-ref="frameMR" class="{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mr</tpl>{frameElCls}" role="presentation"></td></tpl>', "</tr>", '<tpl if="bottom">', '<tr role="presentation">', '<tpl if="left"><td id="{fgid}BL" data-ref="frameBL" class="{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bl</tpl>{frameElCls}" role="presentation"></td></tpl>', '<td id="{fgid}BC" data-ref="frameBC" class="{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bc</tpl>{frameElCls}" role="presentation"></td>', '<tpl if="right"><td id="{fgid}BR" data-ref="frameBR" class="{frameCls}-br {baseCls}-br {baseCls}-{ui}-br<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-br</tpl>{frameElCls}" role="presentation"></td></tpl>', "</tr>", "</tpl>", "</table>", "<tpl if=\"hasTabGuard\">{% this.renderTabGuard(out, values, 'after'); %}</tpl>"], _renderState: 0, ariaEl: "el", _layerCls: "x-layer", _fixedLayerCls: "x-fixed-layer", ariaStaticRoles: { presentation: true, article: true, definition: true, directory: true, document: true, img: true, heading: true, math: true, note: true, banner: true, complementary: true, contentinfo: true, navigation: true, search: true, "undefined": true, "null": true }, statics: { makeRenderSetter: function (a, c) { var b = a.name; return function (e) { var d = this, h = (d.renderConfigs || (d.renderConfigs = {})), g = h[c]; if (d._renderState >= c) { (a.setter || a.getSetter()).call(d, e) } else { if (!g) { h[c] = g = {} } if (!(b in g)) { g[b] = d[b] } d[b] = e } return d } }, processRenderConfig: function (a, l, c) { var h = this.prototype, e = this.getConfigurator(), m = Ext.util.Renderable, k = m.makeRenderSetter, d = a[l], i, j, b, g; for (b in d) { j = Ext.Config.get(b); if (!h[g = j.names.set]) { i = (j.renderSetter || (j.renderSetter = {})); h[g] = i[c] || (i[c] = k(j, c)) } } delete a[l]; e.add(d) } }, onClassMixedIn: function (c) { var a = c.override, e = this.processRenderConfig, d = function (g) { if (g.beforeRenderConfig) { this.processRenderConfig(g, "beforeRenderConfig", 1) } if (g.renderConfig) { this.processRenderConfig(g, "renderConfig", 3) } a.call(this, g) }, b = function (h, g) { h.override = d; h.processRenderConfig = e; if (g.beforeRenderConfig) { h.processRenderConfig(g, "beforeRenderConfig", 1) } if (g.renderConfig) { h.processRenderConfig(g, "renderConfig", 3) } }; b(c, c.prototype); c.onExtended(b) }, afterRender: function () { var i = this, d = {}, b = i.protoEl, h = i.el, e, j, c, g, a; i.finishRenderChildren(); i._renderState = 4; if (i.contentEl) { c = "x-"; g = c + "hidden-"; a = i.contentEl = Ext.get(i.contentEl); a.component = i; a.removeCls([c + "hidden", g + "display", g + "offsets"]); i.getContentTarget().appendChild(a.dom) } b.writeTo(d); j = d.removed; if (j) { h.removeCls(j) } j = d.cls; if (j.length) { h.addCls(j) } j = d.style; if (d.style) { h.setStyle(j) } i.protoEl = null; if (!i.ownerCt && !i.skipLayout) { i.updateLayout() } if (!(i.x && i.y) && (i.pageX || i.pageY)) { i.setPagePosition(i.pageX, i.pageY) } if (i.disableOnRender) { i.onDisable() } e = i.controller; if (e && e.afterRender) { e.afterRender(i) } }, afterFirstLayout: function (d, l) { var g = this, k = g.x, i = g.y, j = g.defaultAlign, b = g.alignOffset, e, c, a, h, m; if (!g.ownerLayout) { c = k !== undefined; a = i !== undefined } if (g.floating && !g.preventDefaultAlign && (!c || !a)) { if (g.floatParent) { h = g.floatParent.getTargetEl().getViewRegion(); m = g.el.getAlignToXY(g.alignTarget || g.floatParent.getTargetEl(), j, b); h.x = m[0] - h.x; h.y = m[1] - h.y } else { m = g.el.getAlignToXY(g.alignTarget || g.container, j, b); h = g.el.translateXY(m[0], m[1]) } k = c ? k : h.x; i = a ? i : h.y; c = a = true } if (c || a) { g.setPosition(k, i) } g.onBoxReady(d, l); e = g.controller; if (e && e.boxReady) { e.boxReady(g, d, l) } }, beforeRender: function () { var d = this, e = d.floating, c = d.getComponentLayout(), b = d.userCls, a; d._renderState = 1; d.ariaUsesMainElement = d.ariaEl === "el"; a = d.controller; if (a && a.beforeRender) { a.beforeRender(d) } d.initBindable(); if (d.renderConfigs) { d.flushRenderConfigs() } if (d.reference) { d.publishState() } if (b) { d.addCls(b) } if (e) { d.addCls(d.fixed ? d._fixedLayerCls : d._layerCls); b = e.cls; if (b) { d.addCls(b) } } d.frame = d.frame || d.alwaysFramed; if (!c.initialized) { c.initLayout() } d.initOverflow(); d.setUI(d.ui) }, doApplyRenderTpl: function (c, a) { var d = a.$comp, b; if (!d.rendered) { b = d.initRenderTpl(); b.applyOut(a.renderData, c) } }, getElConfig: function () { var e = this, h = e.autoEl, d = e.getFrameInfo(), b = { tag: "div", tpl: d ? e.initFramingTpl(d.table) : e.initRenderTpl() }, i = e.layoutTargetCls, g = e.protoEl, a = e.ariaRole, c; e.initStyles(g); if (i && !d) { g.addCls(i) } g.writeTo(b); g.flush(); if (h) { if (Ext.isString(h)) { b.tag = h } else { Ext.apply(b, h) } } if (a && e.ariaUsesMainElement) { b.role = a; if (!e.ariaStaticRoles[a]) { b["aria-hidden"] = !!e.hidden; b["aria-disabled"] = !!e.disabled; if (e.ariaLabel && !e.ariaLabelledBy) { b["aria-label"] = e.ariaLabel } if (e.collapsible) { b["aria-expanded"] = !e.collapsed } if (e.ariaRenderAttributes) { Ext.apply(b, e.ariaRenderAttributes) } if (e.config.ariaAttributes) { Ext.apply(b, e.getAriaAttributes()) } } } b.id = e.id; if (b.tpl) { if (d) { b.tplData = c = e.getFrameRenderData(); c.renderData = e.initRenderData() } else { b.tplData = e.initRenderData() } } e.ariaRenderAttributes = null; return b }, getInsertPosition: function (a) { if (a !== undefined) { if (Ext.isNumber(a)) { a = this.container.dom.childNodes[a] } else { a = Ext.getDom(a) } } return a }, getRenderTree: function () { var b = this, a = null; if (!b.hasListeners.beforerender || b.fireEvent("beforerender", b) !== false) { b._renderState = 1; b.beforeRender(); b.rendering = true; b._renderState = 2; a = b.getElConfig(); if (b.el) { a.id = b.$pid = Ext.id(null, b.el.identifiablePrefix) } } return a }, initRenderData: function () { var c = this, a = c.ariaRole, d, b; d = Ext.apply({ $comp: c, id: c.id, ui: c.ui, uiCls: c.uiCls, baseCls: c.baseCls, componentCls: c.componentCls, frame: c.frame, hasTabGuard: !!c.tabGuard, scrollerCls: c.scrollerCls, childElCls: "", ariaEl: c.ariaEl }, c.renderData); if (a && !c.ariaUsesMainElement) { b = { role: a }; if (!c.ariaStaticRoles[a]) { b["aria-hidden"] = !!c.hidden; b["aria-disabled"] = !!c.disabled; if (c.ariaLabel && !c.ariaLabelledBy) { b["aria-label"] = c.ariaLabel } if (c.collapsible) { b["aria-expanded"] = !c.collapsed } if (c.ariaRenderAttributes) { Ext.apply(b, c.ariaRenderAttributes) } if (c.config.ariaAttributes) { Ext.apply(b, c.getAriaAttributes()) } } d.ariaAttributes = b } return d }, onRender: function (d, e) { var h = this, j = h.x, i = h.y, c = null, b = h.el, g = h.scrollable, a, k; h.applyRenderSelectors(); if (g && g.isScroller) { g.setElement(h.getOverflowEl()); if (Ext.isIE) { h.showListenerIE = Ext.on("show", h.onGlobalShow, h, { destroyable: true }) } } h.rendering = null; h.rendered = true; h._renderState = 3; if (h.renderConfigs) { h.flushRenderConfigs() } if (j != null) { c = { x: j } } if (i != null) { (c = c || {}).y = i } if (!h.getFrameInfo()) { a = h.width; k = h.height; if (typeof a === "number") { c = c || {}; c.width = a } if (typeof k === "number") { c = c || {}; c.height = k } } h.lastBox = b.lastBox = c }, render: function (c, b) { var e = this, d = e.el, i = e.ownerLayout, h, a, g; if (d && !d.isElement) { e.wrapPrimaryEl(d); d = e.el } if (!e.skipLayout) { Ext.suspendLayouts() } c = e.initContainer(c); g = e.getInsertPosition(b); if (!d) { a = e.getRenderTree(); if (i && i.transformItemRenderTree) { a = i.transformItemRenderTree(a) } if (a) { if (g) { d = Ext.DomHelper.insertBefore(g, a) } else { d = Ext.DomHelper.append(c, a) } e.wrapPrimaryEl(d); e.cacheRefEls(d) } } else { if (!e.hasListeners.beforerender || e.fireEvent("beforerender", e) !== false) { e.beforeRender(); e.needsRenderTpl = e.rendering = true; e._renderState = 2; e.initStyles(d); if (e.allowDomMove !== false) { if (g) { c.dom.insertBefore(d.dom, g) } else { c.dom.appendChild(d.dom) } } } else { h = true } } if (d && !h) { e.finishRender(b) } if (!e.skipLayout) { Ext.resumeLayouts(!e.hidden && !c.isDetachedBody) } }, ensureAttachedToBody: function (c) { var b = this, a; while (b.ownerCt) { b = b.ownerCt } if (b.container.isDetachedBody) { b.container = a = Ext.getBody(); a.appendChild(b.el.dom); if (c) { b.updateLayout() } if (typeof b.x === "number" || typeof b.y === "number") { b.setPosition(b.x, b.y) } } }, privates: { applyRenderSelectors: function () { var d = this, b = d.renderSelectors, c = d.el, e, a; d.attachChildEls(c); d.ariaEl = d[d.ariaEl] || d.el; if (b) { for (a in b) { e = b[a]; if (e) { d[a] = c.selectNode(e, false) } } } }, cacheRefEls: function (e) { e = e || this.el; var c = Ext.cache, h = Ext.dom.Element, j = e.isElement ? e.dom : e, b = j.querySelectorAll("[data-ref]"), a = b.length, g, d; for (d = 0; d < a; d++) { g = b[d]; if (!c[g.id]) { new h(g) } } }, doAutoRender: function () { var a = this; if (!a.rendered) { if (a.floating) { a.render(a.renderTo || document.body) } else { a.render(Ext.isBoolean(a.autoRender) ? Ext.getBody() : a.autoRender) } } }, doRenderContent: function (a, d) { var b = d.$comp, c = b.data; if (b.html) { Ext.DomHelper.generateMarkup(b.html, a); delete b.html } if (b.tpl) { if (!b.tpl.isTemplate) { b.tpl = new Ext.XTemplate(b.tpl) } if (c) { b.data = c = c.isEntity ? c.getData(true) : c; b.tpl.applyOut(c, a) } } }, doRenderFramingTabGuard: function (b, d, a) { var c = d.$comp.layout; d.renderData.$skipTabGuards = true; if (c && c.doRenderTabGuard) { c.doRenderTabGuard.call(this, b, d, a) } }, flushRenderConfigs: function () { var d = this, h = d.renderConfigs, g = d._renderState, j, c, b, a, e; if (h) { for (c = 0; c <= g; ++c) { j = h[c]; if (j) { h[c] = null; for (b in j) { e = j[b]; (a || (a = {}))[b] = d[b]; d[b] = e } } } if (a) { d.setConfig(a) } } }, finishRender: function (h) { var k = this, a = Ext.cache, j, g, b, i, e, d, c; if (!k.el || k.$pid) { if (k.container) { c = a[k.id]; d = c ? c.dom : k.container.getById(k.id, true) } else { b = k.$pid || k.id; c = a[b]; d = c ? c.dom : Ext.getDom(b) } if (!k.el) { k.wrapPrimaryEl(d) } else { delete k.$pid; if (!k.el.dom) { k.wrapPrimaryEl(k.el) } d.parentNode.insertBefore(k.el.dom, d); j = d; d = k.el.dom; g = d.firstChild; while (j.firstChild) { d.insertBefore(j.firstChild, g) } k.el.addCls(j.className); Ext.removeNode(j) } } else { if (k.needsRenderTpl) { i = k.initRenderTpl(); if (i) { e = k.initRenderData(); i.insertFirst(k.getTargetEl(), e) } k.cacheRefEls() } } k.el.component = k; if (!k.container) { k.container = Ext.get(k.el.dom.parentNode) } if (k.ctCls) { k.container.addCls(k.ctCls) } k.onRender(k.container, h); if (!k.overflowInited) { k.initOverflow() } k.el.setVisibilityMode(Ext.Element[k.hideMode.toUpperCase()]); if (k.overCls) { k.el.hover(k.addOverCls, k.removeOverCls, k) } if (k.hasListeners.render) { k.fireEvent("render", k) } k.afterRender(); if (k.hasListeners.afterrender) { k.fireEvent("afterrender", k) } k.initEvents(); if (k.hidden) { k.el.hide() } }, finishRenderChildren: function () { var a = this.getComponentLayout(); a.finishRender() }, getFrameRenderData: function () { var c = this, b = c.frameSize, a = ""; if (c._syncFrameHeight && c.height) { a = "height:" + (c.height - b.height) + "px" } return { $comp: c, id: c.id, fgid: c.id + "-frame", ui: c.ui, uiCls: c.uiCls, frameCls: c.frameCls, frameBodyCls: c.layoutTargetCls || "", baseCls: c.baseCls, hasTabGuard: c.tabGuard, top: !!b.top, left: !!b.left, right: !!b.right, bottom: !!b.bottom, mcStyle: a, frameElCls: "" } }, getFrameInfo: function () { if (Ext.supports.CSS3BorderRadius || !this.frame) { return false } var p = this, j = p.frameInfoCache, c = p.getFramingInfoCls() + "-frameInfo", q = j[c], i, l, h, r, d, e, k, s, o, b, m, a, g, n; if (q == null) { i = Ext.fly(p.getStyleProxy(c), "frame-style-el"); l = i.getStyle("font-family"); if (l) { l = l.split("-"); h = parseInt(l[1], 10); r = parseInt(l[2], 10); d = parseInt(l[3], 10); e = parseInt(l[4], 10); k = parseInt(l[5], 10); s = parseInt(l[6], 10); o = parseInt(l[7], 10); b = parseInt(l[8], 10); m = parseInt(l[9], 10); a = parseInt(l[10], 10); g = parseInt(l[11], 10); n = parseInt(l[12], 10); q = { table: l[0].charAt(0) === "t", vertical: l[0].charAt(1) === "v", top: h, right: r, bottom: d, left: e, width: e + r, height: h + d, border: { top: k, right: s, bottom: o, left: b, width: b + s, height: k + o }, padding: { top: m, right: a, bottom: g, left: n, width: n + a, height: m + g } } } else { q = false } j[c] = q } p.frame = !!q; p.frameSize = q; return q }, getFramingInfoCls: function () { return this.baseCls + "-" + this.ui }, getStyleProxy: function (b) { var a = this.styleProxyEl || (Ext.Component.prototype.styleProxyEl = Ext.getBody().createChild({ role: "presentation", style: { position: "absolute", top: "-10000px" } }, null, true)); a.className = b; return a }, getFrameTpl: function (a) { return this.lookupTpl(a ? "frameTableTpl" : "frameTpl") }, initContainer: function (a) { var b = this; if (!a && b.el) { a = b.el.dom.parentNode; b.allowDomMove = false } b.container = a.dom ? a : Ext.get(a); return b.container }, initOverflow: function () { var c = this, a = c.getOverflowStyle(), e = c.scrollFlags, d = c.getOverflowEl(), b = (e.y || e.x); if (!b || !d || !d.isElement) { return } c.overflowInited = true; d.setStyle(a) }, initFramingTpl: function (b) { var a = this.getFrameTpl(b); if (a && !a.applyRenderTpl) { this.setupFramingTpl(a) } return a }, initRenderTpl: function () { var a = this.lookupTpl("renderTpl"); if (a && !a.renderContent) { this.setupRenderTpl(a) } return a }, setupFramingTpl: function (a) { a.applyRenderTpl = this.doApplyRenderTpl; a.renderTabGuard = this.doRenderFramingTabGuard }, setupRenderTpl: function (a) { a.renderBody = a.renderContent = this.doRenderContent }, updateFrame: function () { if (Ext.supports.CSS3BorderRadius || !this.frame) { return } var n = this, h = n.el.dom, m = n.frameTable, c = n.frameBody, p = c.dom, l = n.getFrameInfo(), q, g, b, e, k, r, s, d, j, a, o; b = document.createElement("div"); r = n.getFrameRenderData(); r.hasTabGuard = false; d = n.getFrameTpl(l.table); d.insertFirst(b, r); o = b.querySelectorAll("[data-ref]"); a = b.querySelector('[data-ref="frameBody"]'); for (k = p; k.parentNode !== h;) { k = k.parentNode } while (b.firstChild) { h.insertBefore(b.firstChild, k) } a.parentNode.replaceChild(p, a); p.className = a.className; c.setSize(); q = n.getChildEls(); if (m) { m.destroy(); n.frameTable = null } for (g in q) { if (q[g].frame) { e = n[g]; if (e && e !== c) { e.destroy(); n[g] = null } } } for (j = o.length; j--;) { g = (s = o[j]).getAttribute("data-ref"); if (g !== "frameBody") { n[g] = new Ext.dom.Element(s) } } }, frameInfoCache: {} } }, 0, 0, 0, 0, 0, 0, [Ext.util, "Renderable"], 0)); (Ext.cmd.derive("Ext.state.Provider", Ext.Base, { prefix: "ext-", constructor: function (a) { var b = this; Ext.apply(b, a); b.state = {}; b.mixins.observable.constructor.call(b) }, get: function (c, a) { var b = this.state[c]; return b === undefined ? a : b }, clear: function (a) { var b = this; delete b.state[a]; b.fireEvent("statechange", b, a, null) }, set: function (a, c) { var b = this; b.state[a] = c; b.fireEvent("statechange", b, a, c) }, decodeValue: function (g) { var c = this, k = /^(a|n|d|b|s|o|e)\:(.*)$/, b = k.exec(unescape(g)), h, d, a, j, e, i; if (!b || !b[1]) { return } d = b[1]; g = b[2]; switch (d) { case "e": return null; case "n": return parseFloat(g); case "d": return new Date(Date.parse(g)); case "b": return (g === "1"); case "a": h = []; if (g) { j = g.split("^"); e = j.length; for (i = 0; i < e; i++) { g = j[i]; h.push(c.decodeValue(g)) } } return h; case "o": h = {}; if (g) { j = g.split("^"); e = j.length; for (i = 0; i < e; i++) { g = j[i]; a = g.split("="); h[a[0]] = c.decodeValue(a[1]) } } return h; default: return g } }, encodeValue: function (e) { var g = "", d = 0, b, a, c; if (e == null) { return "e:1" } else { if (typeof e === "number") { b = "n:" + e } else { if (typeof e === "boolean") { b = "b:" + (e ? "1" : "0") } else { if (Ext.isDate(e)) { b = "d:" + e.toUTCString() } else { if (Ext.isArray(e)) { for (a = e.length; d < a; d++) { g += this.encodeValue(e[d]); if (d !== a - 1) { g += "^" } } b = "a:" + g } else { if (typeof e === "object") { for (c in e) { if (typeof e[c] !== "function" && e[c] !== undefined) { g += c + "=" + this.encodeValue(e[c]) + "^" } } b = "o:" + g.substring(0, g.length - 1) } else { b = "s:" + e } } } } } } return escape(b) } }, 1, 0, 0, 0, 0, [["observable", Ext.util.Observable]], [Ext.state, "Provider"], 0)); (Ext.cmd.derive("Ext.state.Manager", Ext.Base, { singleton: true, constructor: function () { this.provider = new Ext.state.Provider() }, setProvider: function (a) { this.provider = a }, get: function (b, a) { return this.provider.get(b, a) }, set: function (a, b) { this.provider.set(a, b) }, clear: function (a) { this.provider.clear(a) }, getProvider: function () { return this.provider } }, 1, 0, 0, 0, 0, 0, [Ext.state, "Manager"], 0)); (Ext.cmd.derive("Ext.state.Stateful", Ext.Base, { mixinId: "state", config: { stateful: null }, saveDelay: 100, constructor: function () { var a = this; if (!a.stateEvents) { a.stateEvents = [] } if (a.stateful) { a.addStateEvents(a.stateEvents); a.initState() } }, addStateEvents: function (d) { var g = this, c, e, b, a; if (g.stateful && g.getStateId()) { a = (typeof d === "string") ? arguments : d; b = g.stateEventsByName || (g.stateEventsByName = {}); for (c = a.length; c--;) { e = a[c]; if (e && !b[e]) { b[e] = 1; g.on(e, g.onStateChange, g) } } } }, onStateChange: function () { var c = this, a = c.saveDelay, d, b; if (!c.stateful) { return } if (a) { if (!c.stateTask) { d = Ext.state.Stateful; b = d.runner || (d.runner = new Ext.util.TaskRunner()); c.stateTask = b.newTask({ run: c.saveState, scope: c, interval: a, repeat: 1, fireIdleEvent: false }) } c.stateTask.start() } else { c.saveState() } }, saveState: function () { var m = this, c = m.getStateful(), b = c && m.getStateId(), l = m.hasListeners, j, k, d, g, e, h, a, n; if (b) { a = m.getState() || {}; if (Ext.isObject(c)) { k = m.self.getConfigurator(); k = k.configs; for (e in c) { if (c[e]) { if (!(e in a)) { j = k[e]; a[e] = j ? m[j.get]() : m[e] } } else { delete a[e] } } } d = m.getPlugins() || []; for (e = 0, h = d.length; e < h; e++) { g = d[e]; if (g && g.getState) { n = g.getState(a); if (n && !a[g.ptype]) { a[g.ptype] = n } } } if (!l.beforestatesave || m.fireEvent("beforestatesave", m, a) !== false) { Ext.state.Manager.set(b, a); if (l.statesave) { m.fireEvent("statesave", m, a) } } } }, getState: function () { return null }, applyState: function (a) { if (a) { Ext.apply(this, a) } }, getStateId: function () { var a = this; return a.stateId || (a.autoGenId ? null : a.id) }, initState: function () { var k = this, b = k.stateful && k.getStateId(), j = k.hasListeners, a, l, e, h, d, g, c; if (b) { l = Ext.state.Manager.get(b); if (l) { a = Ext.apply({}, l); if (!j.beforestaterestore || k.fireEvent("beforestaterestore", k, l) !== false) { d = k.getPlugins() || []; for (e = 0, h = d.length; e < h; e++) { g = d[e]; if (g) { c = g.ptype; if (g.applyState) { g.applyState(a[c], l) } delete a[c] } } k.applyState(a); if (j.staterestore) { k.fireEvent("staterestore", k, l) } } } } }, savePropToState: function (g, e, d) { var b = this, c = b[g], a = b.initialConfig; if (b.hasOwnProperty(g)) { if (!a || a[g] !== c) { if (e) { e[d || g] = c } return true } } return false }, savePropsToState: function (e, c) { var b = this, a, d; if (typeof e === "string") { b.savePropToState(e, c) } else { for (a = 0, d = e.length; a < d; ++a) { b.savePropToState(e[a], c) } } return c }, destroy: function () { var a = this.stateTask; if (a) { a.destroy(); this.stateTask = null } } }, 1, 0, 0, 0, 0, 0, [Ext.state, "Stateful"], 0)); (Ext.cmd.derive("Ext.util.Focusable", Ext.Base, { mixinId: "focusable", hasFocus: false, focusable: false, focusCls: "focus", initFocusable: Ext.emptyFn, initFocusableEvents: function () { this.initFocusableElement() }, getFocusClsEl: function () { return this.getFocusEl() }, getFocusEl: function () { return this.element || this.el }, destroyFocusable: function () { var a = this; Ext.destroy(a.focusListeners); a.focusListeners = a.focusEnterEvent = a.focusTask = null; a.focusEl = a.ariaEl = null }, enableFocusable: Ext.emptyFn, disableFocusable: function () { var d = this, b, c = d.focusCls, a; if (d.hasFocus) { b = d.findFocusTarget(); if (b) { b.focus() } } a = d.getFocusClsEl(); if (c && a) { a.removeCls(d.removeClsWithUI(c, true)) } }, isFocusable: function (a) { var c = this, b; if (!c.focusable && (!c.isContainer || !a)) { return false } b = c.getFocusEl(); if (b && c.canFocus()) { return b.isFocusable(a) } return false }, canFocus: function (b, d) { var c = this, a; a = (c.isContainer || c.focusable) && c.rendered && !c.destroying && !c.destroyed && !c.disabled && (b || c.isVisible(true)); return a || (d && !!c.findFocusTarget()) }, focus: function (g, c, i, d) { var e = this, a, h, b; if ((!e.focusable && !e.isContainer) || e.destroyed || e.destroying) { return } if (c) { e.getFocusTask().delay(Ext.isNumber(c) ? c : 10, e.focus, e, [g, false, i, d]); return e } e.cancelFocus(); if (e.canFocus()) { if (a = e.getFocusEl()) { if (a.isComponent) { return a.focus(g, c, i, d) } h = a.dom; if (h) { if (e.floating) { b = e.container.dom.scrollTop } a.focus(); if (g) { if (Ext.isArray(g)) { if (e.selectText) { e.selectText.apply(e, g) } } else { if (h.select) { h.select() } else { if (e.selectText) { e.selectText() } } } } Ext.callback(i, d) } if (e.floating) { if (b !== undefined) { e.container.dom.scrollTop = b } } } } else { a = e.findFocusTarget(); if (a) { return a.focus(g, c, i, d) } } return e }, cancelFocus: function () { var a = this.getFocusTask(); if (a) { a.cancel() } }, beforeBlur: Ext.emptyFn, onBlur: function (g) { var d = this, b = d.focusableContainer, c = d.focusCls, a; if (!d.focusable || d.destroying) { return } d.hasFocus = false; d.beforeBlur(g); if (b) { b.beforeFocusableChildBlur(d, g) } a = d.getFocusClsEl(); if (c && a) { a.removeCls(d.removeClsWithUI(c, true)) } d.fireEvent("blur", d, g); d.postBlur(g); if (b) { b.afterFocusableChildBlur(d, g) } }, postBlur: Ext.emptyFn, beforeFocus: Ext.emptyFn, onFocus: function (g) { var d = this, b = d.focusableContainer, c = d.focusCls, a; if (!d.focusable) { return } if (d.canFocus()) { d.beforeFocus(g); if (b) { b.beforeFocusableChildFocus(d, g) } a = d.getFocusClsEl(); if (c && a) { a.addCls(d.addClsWithUI(c, true)) } if (!d.hasFocus) { d.hasFocus = true; d.fireEvent("focus", d, g) } d.postFocus(g); if (b) { b.afterFocusableChildFocus(d, g) } } }, postFocus: Ext.emptyFn, getTabIndex: function () { var c = this, b, a; if (!c.focusable) { return } b = c.rendered && c.getFocusEl(); if (b) { if (b.isComponent) { a = b.getTabIndex() } else { if (b.isElement) { a = b.getAttribute("tabIndex") } else { return } } c.tabIndex = a } else { a = c.tabIndex } return a - 0 }, setTabIndex: function (d, a) { var c = this, b; if (!c.focusable) { return } c.tabIndex = d; if (!c.rendered) { return } b = a || c.getFocusEl(); if (b) { if (b.isComponent) { b.setTabIndex(d) } else { if (b.isElement) { b.set({ tabIndex: d }) } } } }, onFocusEnter: function (b) { var a = this; if (a.destroying || a.destroyed) { return } if (a.floating && a !== a.zIndexManager.getActive()) { a.toFront(true) } a.focusEnterEvent = b; a.containsFocus = true; a.fireEvent("focusenter", a, b) }, onFocusLeave: function (b) { var a = this; if (a.destroying || a.destroyed) { return } a.focusEnterEvent = null; a.containsFocus = false; a.fireEvent("focusleave", a, b) }, privates: { revertFocus: function () { var c = this, b = c.focusEnterEvent, a; if (c.preventRefocus || !c.el.contains(Ext.Element.getActiveElement()) || !b) { return } a = b && b.relatedTarget; if (Ext.getDoc().contains(a) && Ext.fly(a).isFocusable()) { a.focus() } else { if (b.fromComponent && b.fromComponent.focus) { b.fromComponent.focus() } } }, findFocusTarget: function () { var b = this, a, c, d; for (a = b.up(":visible(true):not([disabled]):not([destroying])"); a; a = a.up(":visible(true):not([disabled]):not([destroying])")) { c = Ext.ComponentQuery.query(":canfocus()", a); if (c.length) { d = Ext.Array.indexOf(c, Ext.ComponentManager.getActiveComponent()); return c[d + 1] || c[d - 1] || c[0] } if (a.isFocusable && a.isFocusable()) { return a } } }, initFocusableElement: function () { var c = this, a = c.tabIndex, b = c.getFocusEl(); if (b && !b.isComponent) { c.focusEl = b; if (a != null && c.canFocus(true)) { c.setTabIndex(a, b) } b.dom.setAttribute("data-componentid", c.id) } }, getFocusTask: function () { if (!this.focusTask) { this.focusTask = Ext.focusTask } return this.focusTask }, handleFocusEvent: function (b) { var a; if (this.isFocusing(b)) { a = new Ext.event.Event(b.event); a.type = "focus"; a.relatedTarget = b.fromElement; a.target = b.toElement; this.onFocus(a) } }, handleBlurEvent: function (b) { var a; if (this.isBlurring(b)) { a = new Ext.event.Event(b.event); a.type = "blur"; a.target = b.fromElement; a.relatedTarget = b.toElement; this.onBlur(a) } }, isFocusing: function (b) { var a; if (this.focusable) { a = this.getFocusEl(); if (a) { if (a.isComponent) { return a.isFocusing(b) } else { return b.toElement === a.dom && b.fromElement !== b.toElement } } } return false }, isBlurring: function (b) { var a; if (this.focusable) { a = this.getFocusEl(); if (a) { if (a.isComponent) { return a.isBlurring(b) } else { return b.fromElement === a.dom && b.fromElement !== b.toElement } } } return false }, blur: function () { var b = this, a; if (!b.focusable || !b.canFocus()) { return } a = b.getFocusEl(); if (a) { b.blurring = true; a.blur(); delete b.blurring } return b }, disableTabbing: function () { var c = this, b = c.el, a; if (b) { b.saveTabbableState() } a = c.getFocusEl(); if (a) { if (a.isComponent) { a.disableTabbing() } else { if (a.isElement && b && !b.contains(a)) { a.saveTabbableState() } } } }, enableTabbing: function () { var c = this, b = c.el, a; a = c.getFocusEl(); if (a) { if (a.isComponent) { a.enableTabbing() } else { if (a.isElement && b && !b.contains(a)) { a.restoreTabbableState() } } } if (b) { b.restoreTabbableState() } }, updateMaskState: function (e, a) { var c = this, b = c.ariaEl.dom, d; if (e) { c.disableTabbing(); c.setMasked(true); if (b) { b.setAttribute("aria-busy", "true"); d = b.getAttribute("aria-describedby"); if (d) { c._savedAriaDescribedBy = d } b.setAttribute("aria-describedby", a.ariaEl.id) } } else { c.enableTabbing(); c.setMasked(false); if (b) { b.removeAttribute("aria-busy"); d = b.getAttribute("aria-describedby"); b.removeAttribute("aria-describedby"); if (d === a.ariaEl.id && c._savedAriaDescribedBy) { b.setAttribute("aria-describedby", c._savedAriaDescribedBy); delete c._savedAriaDescribedBy } } } } } }, 0, 0, 0, 0, 0, 0, [Ext.util, "Focusable"], function () { if (!Ext.focusTask) { Ext.focusTask = new Ext.util.DelayedTask() } })); (Ext.cmd.derive("Ext.mixin.Accessible", Ext.Mixin, { mixinConfig: { id: "accessible" }, config: { ariaAttributes: { $value: null, lazy: true } }, privates: { getAriaLabelEl: function (c) { var e = [], h, d, b, g, a; if (c) { if (Ext.isFunction(c)) { return c.call(this) } else { if (!Ext.isArray(c)) { c = [c] } h = this.lookupReferenceHolder(); if (h) { for (d = 0, b = c.length; d < b; d++) { g = h.lookupReference(c[d]); if (g) { e.push(g.ariaEl.id) } } } } } return e.length ? e.join(" ") : null } } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "Accessible"], 0)); (Ext.cmd.derive("Ext.mixin.Keyboard", Ext.Mixin, function (a) { return { mixinConfig: { id: "keyboard" }, config: { keyMap: { $value: null, cached: true, merge: function (d, b, k, i) { if (d === null) { return d } var c = b ? Ext.Object.chain(b) : {}, e, h, g, j; for (e in d) { if (e !== "scope") { h = e.toUpperCase(); if (!i || c[h] === undefined) { g = d[e]; if (g) { if (typeof g === "string" || typeof g === "function") { g = { handler: g } } else { g = Ext.apply({ handler: g.fn }, g) } j = g.scope || d.scope || "self"; g.scope = (j === "controller") ? "self.controller" : j } c[h] = g } } } return c } }, keyMapEnabled: null }, keyMapTarget: "el", applyKeyMap: function (i, g) { var e = this, h, d, c, b; if (i) { if (g && e.isConfiguring) { g = Ext.apply({}, g) } h = i.scope || "controller"; for (c in i) { if (c === "scope") { continue } if (!(b = i[c])) { if (!g) { continue } } else { if (typeof b === "string" || typeof b === "function") { b = { handler: b, scope: h } } else { if (b) { b = Ext.apply({ handler: b.fn, scope: h }, b) } } g = g || {} } if (a.parseEntry(c, d = b || {})) { g[d.name] = b } } } else { g = null } if (e._keyMapReady) { e.setKeyMapListener(g && e.getKeyMapEnabled()) } return g || null }, initKeyMap: function () { var c = this, b = c.getKeyMapEnabled(); c._keyMapReady = true; if (b === null) { c.setKeyMapEnabled(true) } else { c.setKeyMapListener(b && c.getKeyMap()) } }, updateKeyMapEnabled: function (b) { this.setKeyMapListener(b && this._keyMapReady && this.getKeyMap()) }, privates: { _keyMapReady: false, callKeyMapEntry: function (b, c) { return b && Ext.callback(b.handler, b.scope, [c, this], 0, this) }, findKeyMapEntry: function (g) { var d = this, h = d.getKeyMap(), b, c; if (h) { for (b in h) { if (a.matchEntry(b, c = h[b], g)) { return c } } } return null }, onKeyMapEvent: function (d) { var c = this, b = c.getKeyMapEnabled() ? c.findKeyMapEntry(d) : null; return c.callKeyMapEntry(b, d) }, setKeyMapListener: function (b) { var c = this, e = c._keyMapListener, d; if (e) { e.destroy(); e = null } if (b) { d = c[c.keyMapTarget]; if (typeof d === "function") { d = d.call(c) } e = d.on({ destroyable: true, scope: c, keydown: "onKeyMapEvent", keypress: "onKeyMapEvent" }) } c._keyMapListener = e || null }, statics: { _charCodeRe: /^#([\d]+)$/, _hyphenRe: /^[a-z]+\-/i, _keyMapEvents: { charCode: "keypress", keyCode: "keydown" }, matchEntry: function (b, g, h) { var d = h.browserEvent, c; if (h.type !== g.event) { return false } if (!(c = g.charCode)) { if (g.keyCode !== h.keyCode || !g.shiftKey !== !d.shiftKey) { return false } } else { if (h.getCharCode() !== c) { return false } } return !g.ctrlKey === !d.ctrlKey && !g.altKey === !d.altKey && !g.metaKey === !d.metaKey }, parseEntry: function (r, q) { r = r.toUpperCase(); var m = this, s = Ext.event.Event, p = s.keyFlags, d = m._hyphenRe.test(r) ? "-" : "+", o = (r === d) ? [d] : r.split(d), e = o.length - 1, g = o[e], b = g, l = "keyCode", c, h, j; for (h = 0; h < e; h++) { q[p[o[h]]] = true } if (e) { b = q.ctrlKey ? "CTRL+" : ""; b += q.altKey ? "ALT+" : ""; b += q.metaKey ? "META+" : ""; b += q.shiftKey ? "SHIFT+" : ""; b += g } q.name = b; if (isNaN(c = s[g])) { if (!(j = m._charCodeRe.exec(g))) { if (g.length === 1) { c = g.charCodeAt(0) } } else { c = +j[1] } if (c) { l = "charCode" } else { c = +g } } q.event = q.event || m._keyMapEvents[l]; return !isNaN(c) && (q[l] = c) } } } } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "Keyboard"], 0)); (Ext.cmd.derive("Ext.Component", Ext.Base, { alternateClassName: "Ext.AbstractComponent", statics: { AUTO_ID: 1000, pendingLayouts: null, layoutSuspendCount: 0, DIRECTION_TOP: "top", DIRECTION_RIGHT: "right", DIRECTION_BOTTOM: "bottom", DIRECTION_LEFT: "left", VERTICAL_DIRECTION_Re: /^(?:top|bottom)$/, INVALID_ID_CHARS_Re: /[\.,\s]/g, ariaHighContrastModeCls: "x-aria-highcontrast", cancelLayout: function (a, c) { var b = this.runningLayoutContext || this.pendingLayouts; if (b) { b.cancelComponent(a, false, c) } }, fromElement: function (c, b, a) { return Ext.ComponentManager.fromElement(c, b, a) }, flushLayouts: function () { var b = this, a = b.pendingLayouts; if (a && a.invalidQueue.length) { b.pendingLayouts = null; b.runningLayoutContext = a; Ext.override(a, { runComplete: function () { b.runningLayoutContext = null; var e = Ext.scroll.Scroller, d = Ext.GlobalEvents, c; if (e.viewport) { e.viewport.restoreState() } c = this.callParent(); if (d.hasListeners.afterlayout) { d.fireEvent("afterlayout") } return c } }); a.run() } }, resumeLayouts: function (a) { if (this.layoutSuspendCount && !--this.layoutSuspendCount) { if (a) { this.flushLayouts() } if (Ext.GlobalEvents.hasListeners.resumelayouts) { Ext.GlobalEvents.fireEvent("resumelayouts") } } }, suspendLayouts: function () { ++this.layoutSuspendCount }, updateLayout: function (b, e) { var c = this, a = c.runningLayoutContext, d; if (a) { a.queueInvalidate(b) } else { d = c.pendingLayouts || (c.pendingLayouts = new Ext.layout.Context()); d.queueInvalidate(b); if (!e && !c.layoutSuspendCount && !b.isLayoutSuspended()) { c.flushLayouts() } } } }, $configPrefixed: false, $configStrict: false, clearPropertiesOnDestroy: "async", manageLayoutScroll: true, config: { data: null, maxHeight: null, maxWidth: null, minHeight: null, minWidth: null, scrollable: null }, renderConfig: { touchAction: null }, defaultBindProperty: "html", alignTarget: null, autoRender: false, autoShow: false, baseCls: "x-component", childEls: { frameTable: { frame: true }, frameTL: { frame: "tl" }, frameTC: { frame: "tc" }, frameTR: { frame: "tr" }, frameML: { frame: "ml" }, frameBody: { frame: "mc" }, frameMR: { frame: "mr" }, frameBL: { frame: "bl" }, frameBC: { frame: "bc" }, frameBR: { frame: "br" } }, componentLayout: "autocomponent", defaultAlign: "c-c", disabled: false, disabledRe: /^(?:button|input|select|textarea|optgroup|option|fieldset)$/i, nonMaskableRe: (function () { var a = ["input", "select", "textarea", "optgroup", "option", "table"]; if (Ext.isIE9m && !(Ext.isIE9 && !Ext.isIEQuirks)) { a.push("p") } return new RegExp("^(?:" + a.join("|") + ")$", "i") }()), disabledCls: "x-item-disabled", draggable: false, floating: false, hidden: false, hideMode: "display", maskElement: null, renderTpl: "{%this.renderContent(out,values)%}", resizeHandles: "all", shrinkWrap: 2, toFrontOnShow: true, synthetic: false, tplWriteMode: "overwrite", ui: "default", uiCls: [], userCls: null, weight: null, allowDomMove: true, autoGenId: false, borderBoxCls: "x-border-box", componentLayoutCounter: 0, contentPaddingProperty: "padding", deferLayouts: false, frameSize: null, horizontalPosProp: "left", isComponent: true, _isLayoutRoot: false, layoutSuspendCount: 0, liquidLayout: false, maskOnDisable: true, rendered: false, rootCls: "x-body", scrollerCls: "x-scroll-scroller", _scrollFlags: { auto: { auto: { overflowX: "auto", overflowY: "auto", x: true, y: true, both: true }, "false": { overflowX: "auto", overflowY: "hidden", x: true, y: false, both: false }, scroll: { overflowX: "auto", overflowY: "scroll", x: true, y: true, both: true } }, "false": { auto: { overflowX: "hidden", overflowY: "auto", x: false, y: true, both: false }, "false": { overflowX: "hidden", overflowY: "hidden", x: false, y: false, both: false }, scroll: { overflowX: "hidden", overflowY: "scroll", x: false, y: true, both: false } }, scroll: { auto: { overflowX: "scroll", overflowY: "auto", x: true, y: true, both: true }, "false": { overflowX: "scroll", overflowY: "hidden", x: true, y: false, both: false }, scroll: { overflowX: "scroll", overflowY: "scroll", x: true, y: true, both: true } }, none: { overflowX: "", overflowY: "", x: false, y: false, both: false } }, _scrollableCfg: { x: { x: true, y: false }, y: { x: false, y: true }, horizontal: { x: true, y: false }, vertical: { x: false, y: true }, both: { x: true, y: true }, "true": { x: true, y: true } }, validIdRe: Ext.validIdRe, constructor: function (a) { var h = this, c, g, j, e, l, d, b, k; a = a || {}; if (a.initialConfig) { if (a.isAction) { h.baseAction = a } a = a.initialConfig } else { if (a.tagName || a.dom || Ext.isString(a)) { a = { applyTo: a, id: a.id || a } } } h.initialConfig = a; h.getId(); h.protoEl = new Ext.util.ProtoElement(); h.initConfig(a); if (h.scrollable == null) { l = h.autoScroll; if (l) { k = !!l } else { d = h.overflowX; b = h.overflowY; if (d || b) { k = { x: (d && d !== "hidden") ? d : false, y: (b && b !== "hidden") ? b : false } } } if (k) { h.setScrollable(k) } } j = h.xhooks; if (j) { delete h.xhooks; Ext.override(h, j) } h.mixins.elementCt.constructor.call(h); h.setupProtoEl(); if (h.cls) { h.initialCls = h.cls; h.protoEl.addCls(h.cls) } if (h.style) { h.initialStyle = h.style; h.protoEl.setStyle(h.style) } h.renderData = h.renderData || {}; h.initComponent(); if (!h.preventRegister) { Ext.ComponentManager.register(h) } h.mixins.state.constructor.call(h); h.addStateEvents("resize"); e = h.getController(); if (e) { e.init(h) } if (h.plugins) { for (c = 0, g = h.plugins.length; c < g; c++) { h.plugins[c] = h.initPlugin(h.plugins[c]) } } h.loader = h.getLoader(); if (h.disabled) { h.disabled = false; h.disable(true) } if (h.renderTo) { h.render(h.renderTo) } if (h.autoShow && !h.$initParent) { h.show() } if (h.baseAction) { h.baseAction.addComponent(h) } }, beforeInitConfig: function () { this.mixins.observable.constructor.call(this) }, addCls: function (a) { var c = this, b = c.rendered ? c.el : c.protoEl; b.addCls.apply(b, arguments); return c }, addClsWithUI: function (c, j) { var h = this, g = [], e = 0, d = h.uiCls = Ext.Array.clone(h.uiCls), b = h.activeUI, a, k; if (typeof c === "string") { c = (c.indexOf(" ") < 0) ? [c] : Ext.String.splitWords(c) } a = c.length; for (; e < a; e++) { k = c[e]; if (k && !h.hasUICls(k)) { d.push(k); if (b) { g = g.concat(h.addUIClsToElement(k)) } } } if (j !== true && b) { h.addCls(g) } return g }, afterComponentLayout: function (d, b, c, g) { var e = this, a = e.scrollable; if (++e.componentLayoutCounter === 1) { e.afterFirstLayout(d, b) } else { if (e.manageLayoutScroll && a) { a.restoreState() } } if (d !== c || b !== g) { e.onResize(d, b, c, g) } if (e.floating) { e.onAfterFloatLayout() } }, addPlugin: function (b) { var a = this; b = a.constructPlugin(b); if (a.plugins) { a.plugins.push(b) } else { a.plugins = [b] } if (a.pluginsInitialized) { a.initPlugin(b) } return b }, addPropertyToState: function (e, d, c) { var b = this, a = arguments.length; if (a === 3 || b.hasOwnProperty(d)) { if (a < 3) { c = b[d] } if (c !== b.initialConfig[d]) { (e || (e = {}))[d] = c } } return e }, addUIClsToElement: function (i) { var e = this, b = e.baseCls + "-" + e.ui + "-" + i, a = ["x-" + i, e.baseCls + "-" + i, b], d, h, c, g; if (e.rendered && e.frame && !Ext.supports.CSS3BorderRadius) { b += "-"; d = e.getChildEls(); for (h in d) { g = d[h].frame; if (g && g !== true) { c = e[h]; if (c) { c.addCls(b + g) } } } } return a }, removeUIClsFromElement: function (i) { var e = this, b = e.baseCls + "-" + e.ui + "-" + i, a = ["x-" + i, e.baseCls + "-" + i, b], d, h, c, g; if (e.rendered && e.frame && !Ext.supports.CSS3BorderRadius) { b += "-"; d = e.getChildEls(); for (h in d) { g = d[h].frame; if (g && g !== true) { c = e[h]; if (c) { c.removeCls(b + g) } } } } return a }, adjustPosition: function (a, d) { var b = this, c; if (b.isContainedFloater()) { c = b.floatParent.getTargetEl().getViewRegion(); a += c.left; d += c.top } return { x: a, y: d } }, afterHide: function (d, b) { var c = this, a = c.focusableContainer; delete c.getInherited().topmostFocusEvent; c.hiddenByLayout = null; if (c.ownerLayout) { c.updateLayout({ isRoot: false }) } if (a) { a.onFocusableChildHide(c) } c.fireHierarchyEvent("hide"); c.fireEvent("hide", c); Ext.callback(d, b || c) }, afterSetPosition: function (a, c) { var b = this; b.onPosition(a, c); if (b.hasListeners.move) { b.fireEvent("move", b, a, c) } }, afterShow: function (g, i, d) { var e = this, h = e.el, a, b, c; g = e.getAnimateTarget(g); if (!e.ghost) { g = null } if (g) { b = { x: h.getX(), y: h.getY(), width: h.dom.offsetWidth, height: h.dom.offsetHeight }; a = { x: g.getX(), y: g.getY(), width: g.dom.offsetWidth, height: g.dom.offsetHeight }; e.fireHierarchyEvent("show"); c = e.ghost(); c.el.stopAnimation(); c.setX(-10000); e.ghostBox = b; c.el.animate({ from: a, to: b, listeners: { afteranimate: function () { if (!e.destroying) { c.componentLayout.lastComponentSize = null; e.unghost(); e.ghostBox = null; e.onShowComplete(i, d) } } } }) } else { e.onShowComplete(i, d); e.fireHierarchyEvent("show") } }, animate: function (c) { var t = this, g, l, k, a, d, b, s, p, m, e, q, n, i, o, r, j; c = c || {}; d = c.to || {}; if (Ext.fx.Manager.hasFxBlock(t.id)) { return t } g = Ext.isDefined(d.width); if (g) { a = Ext.Number.constrain(d.width, t.minWidth, t.maxWidth) } l = Ext.isDefined(d.height); if (l) { k = Ext.Number.constrain(d.height, t.minHeight, t.maxHeight) } if (!c.dynamic && (g || l)) { p = (c.from ? c.from.width : undefined) || t.getWidth(); m = p; e = (c.from ? c.from.height : undefined) || t.getHeight(); q = e; n = false; if (l && k > e) { q = k; n = true } if (g && a > p) { m = a; n = true } if (l || g) { j = t.el.getStyle("overflow"); if (j !== "hidden") { t.el.setStyle("overflow", "hidden") } } if (n) { b = !Ext.isNumber(t.width); s = !Ext.isNumber(t.height); t.setSize(m, q); t.el.setSize(p, e); if (b) { delete t.width } if (s) { delete t.height } } if (g) { d.width = a } if (l) { d.height = k } } i = t.constrain; o = t.constrainHeader; if (i || o) { t.constrain = t.constrainHeader = false; r = c.callback; c.callback = function () { t.constrain = i; t.constrainHeader = o; if (r) { r.call(c.scope || t, arguments) } if (j !== "hidden") { t.el.setStyle("overflow", j) } } } return t.mixins.animate.animate.apply(t, arguments) }, applyScrollable: function (b, c) { var a = this, e = a.rendered, d; if (b) { if (b === true || typeof b === "string") { d = a._scrollableCfg[b]; b = d } if (c) { c.setConfig(b); b = c } else { b = Ext.Object.chain(b); if (e) { b.element = a.getOverflowEl() } b = Ext.scroll.Scroller.create(b, a.scrollableType); b.component = a } } else { if (c) { b = c; c.setConfig({ x: false, y: false }) } } if (a.rendered && !a.destroying && !a.destroyed) { if (b) { a.getOverflowStyle() } else { a.scrollFlags = a._scrollFlags.none } a.updateLayout() } return b }, applyTouchAction: function (a, b) { if (b != null) { a = Ext.merge({}, b, a) } return a }, beforeDestroy: Ext.emptyFn, beforeLayout: function () { if (this.floating) { this.onBeforeFloatLayout() } }, beforeSetPosition: function (j, h, b) { var g = this, i = null, d, c, a, e; if (j) { if (Ext.isNumber(d = j[0])) { b = h; h = j[1]; j = d } else { if ((d = j.x) !== undefined) { b = h; h = j.y; j = d } } } if (g.constrain || g.constrainHeader) { i = g.calculateConstrainedPosition(null, [j, h], true); if (i) { j = i[0]; h = i[1] } } c = (j !== undefined); a = (h !== undefined); if (c || a) { g.x = j; g.y = h; e = g.adjustPosition(j, h); i = { x: e.x, y: e.y, anim: b, hasX: c, hasY: a } } return i }, beforeShow: Ext.emptyFn, bubble: function (c, b, a) { var d = this; while (d) { if (c.apply(b || d, a || [d]) === false) { break } d = d.getBubbleTarget() } return this }, clearListeners: function () { var a = this; a.mixins.observable.clearListeners.call(a); a.mixins.componentDelegation.clearDelegatedListeners.call(a) }, cloneConfig: function (c) { c = c || {}; var d = c.id || Ext.id(), a = Ext.applyIf(c, this.initialConfig), b; a.id = d; b = Ext.getClass(this); return new b(a) }, destroy: function () { var a = this; if (!a.hasListeners.beforedestroy || a.fireEvent("beforedestroy", a) !== false) { a.isDestroying = a.destroying = true; a.doDestroy(); a.clearListeners(); a.isDestroying = a.destroying = false; a.callParent(); a.mixins.componentDelegation.destroyComponentDelegation.call(a); a.mixins.observable.destroyObservable.call(a, true) } }, doDestroy: function () { var g = this, b = g.focusableContainer, c = g.renderSelectors, a, e, d; e = g.floatParent || g.ownerCt; if (g.floating) { delete g.floatParent; if (g.zIndexManager && !g.zIndexManager.destroyed) { g.zIndexManager.unregister(g) } g.floating = true } g.removeBindings(); if (!g.beforeDestroy.$emptyFn) { g.beforeDestroy() } g.destroyBindable(); if (e && e.remove) { e.remove(g, false) } g.stopAnimation(); if (g.rendered) { Ext.destroy(g.loadMask, g.dd, g.resizer, g.proxy, g.proxyWrap, g.resizerComponent, g.scrollable, g.contentEl) } if (b) { b.onFocusableChildDestroy(g) } if (g.focusable) { g.destroyFocusable() } Ext.destroy(g.componentLayout, g.loadMask, g.floatingDescendants); if (!g.onDestroy.$emptyFn) { g.onDestroy() } Ext.destroy(g.plugins); if (g.rendered) { Ext.Component.cancelLayout(g, true) } g.componentLayout = null; if (g.hasListeners.destroy) { g.fireEvent("destroy", g) } if (!g.preventRegister) { Ext.ComponentManager.unregister(g) } g.mixins.state.destroy.call(g); if (g.floating) { g.onFloatDestroy() } if (g.rendered) { if (g.showListenerIE) { g.showListenerIE.destroy(); g.showListenerIE = null } if (!g.preserveElOnDestroy) { g.el.destroy() } g.el.component = null; g.mixins.elementCt.destroy.call(g); if (c) { for (a in c) { if (c.hasOwnProperty(a)) { d = g[a]; if (d) { delete g[a]; d.destroy() } } } } g.rendered = false } }, disable: function (c, e) { var d = this, b = d.focusableContainer, a = d.getInherited(); if (!e) { a.disabled = true; d.savedDisabled = true } if (d.maskOnDisable) { a.disableMask = true } if (!d.disabled) { if (b) { b.beforeFocusableChildDisable(d) } d.addCls(d.disabledCls); if (d.rendered) { d.onDisable() } else { d.disableOnRender = true } d.disabled = true; if (c !== true) { d.fireEvent("disable", d) } if (b) { b.onFocusableChildDisable(d) } } return d }, doFireEvent: function (b, d, a) { var e = this, c; c = e.mixins.observable.doFireEvent.call(e, b, d, a); if (c !== false && !e.destroyed) { c = e.mixins.componentDelegation.doFireDelegatedEvent.call(e, b, d) } return c }, enable: function (c, e) { var d = this, b = d.focusableContainer, a = d.getInherited(); if (!e) { delete d.getInherited().disabled; d.savedDisabled = false } if (d.maskOnDisable) { delete a.disableMask } if (d.disabled) { if (!(e && a.hasOwnProperty("disabled"))) { if (b) { b.beforeFocusableChildEnable(d) } d.disableOnRender = false; d.removeCls(d.disabledCls); if (d.rendered) { d.onEnable() } d.disabled = false; if (c !== true) { d.fireEvent("enable", d) } if (b) { b.onFocusableChildEnable(d) } } } return d }, findParentBy: function (a) { var b; for (b = this.getRefOwner(); b && !a(b, this); b = b.getRefOwner()) { } return b || null }, findParentByType: function (a) { return Ext.isFunction(a) ? this.findParentBy(function (b) { return b.self === a || b.constructor === a }) : this.up(a) }, findPlugin: function (d) { var b, a = this.plugins, c = a && a.length; for (b = 0; b < c; b++) { if (a[b].ptype === d) { return a[b] } } }, getAnimateTarget: function (a) { a = a || this.animateTarget; if (a) { a = a.isComponent ? a.getEl() : Ext.get(a) } return a || null }, getBubbleTarget: function () { return this.getRefOwner() }, getComponentLayout: function () { var a = this; if (!a.componentLayout || !a.componentLayout.isLayout) { a.setComponentLayout(Ext.layout.Layout.create(a.componentLayout, "autocomponent")) } return a.componentLayout }, getEl: function () { return this.el }, getHeight: function () { return this.el.getHeight() }, initInheritedState: function (a) { var c = this, b = c.componentLayout; if (c.hidden) { a.hidden = true } if (c.collapseImmune) { a.collapseImmune = true } if (c.modelValidation !== undefined) { a.modelValidation = c.modelValidation } if (c.savedDisabled) { a.disabled = true } c.mixins.bindable.initInheritedState.call(c, a); if (b && b.initInheritedState) { b.initInheritedState(a) } }, getId: function () { var a = this, b; if (!(a.id || (a.id = a.initialConfig.id))) { b = a.getXType(); if (b) { b = b.replace(Ext.Component.INVALID_ID_CHARS_Re, "-") } else { b = Ext.name.toLowerCase() + "-comp" } a.id = b + "-" + a.getAutoId() } return a.id }, getItemId: function () { return this.itemId || this.id }, getLoader: function () { var b = this, a = b.loader; if (a) { if (!a.isLoader) { b.loader = new Ext.ComponentLoader(Ext.apply({ target: b }, a)) } else { a.setTarget(b) } return b.loader } return null }, getMaskTarget: function () { return this.maskElement ? this[this.maskElement] : null }, getPlugin: function (e) { var b, a = this.plugins, d = a && a.length, c; for (b = 0; b < d; b++) { c = a[b]; if (c.id === e || c.pluginId === e) { return c } } return null }, getPosition: function (a) { var b = this, d, c = b.isContainedFloater(), e; if ((a === true) && !c) { return [b.getLocalX(), b.getLocalY()] } d = b.getXY(); if ((a === true) && c) { e = b.floatParent.getTargetEl().getViewRegion(); d[0] -= e.left; d[1] -= e.top } return d }, getScrollX: function () { var a = this.getScrollable(); return a ? a.getPosition().x : 0 }, getScrollY: function () { var a = this.getScrollable(); return a ? a.getPosition().y : 0 }, getSize: function (a) { return this.el.getSize(a) }, getSizeModel: function (k) { var o = this, a = Ext.layout.SizeModel, d = o.componentLayout.ownerContext, b = o.width, q = o.height, r, c, h, g, i, p, m, n, l, j, e = o.floating || o.floated; if (d) { j = d.widthModel; i = d.heightModel } if (!j || !i) { h = ((r = typeof b) === "number"); g = ((c = typeof q) === "number"); l = e || !(p = o.ownerLayout); if (l) { m = Ext.layout.Layout.prototype.autoSizePolicy; n = e ? 3 : o.shrinkWrap; if (h) { j = a.configured } if (g) { i = a.configured } } else { m = p.getItemSizePolicy(o, k); n = p.isItemShrinkWrap(o) } if (d) { d.ownerSizePolicy = m } n = (n === true) ? 3 : (n || 0); if (l && n) { if (b && r === "string") { n &= 2 } if (q && c === "string") { n &= 1 } } if (n !== 3) { if (!k) { k = o.ownerCt && o.ownerCt.getSizeModel() } if (k) { n |= (k.width.shrinkWrap ? 1 : 0) | (k.height.shrinkWrap ? 2 : 0) } } if (!j) { if (!m.setsWidth) { if (h) { j = a.configured } else { j = (n & 1) ? a.shrinkWrap : a.natural } } else { if (m.readsWidth) { if (h) { j = a.calculatedFromConfigured } else { j = (n & 1) ? a.calculatedFromShrinkWrap : a.calculatedFromNatural } } else { j = a.calculated } } } if (!i) { if (!m.setsHeight) { if (g) { i = a.configured } else { i = (n & 2) ? a.shrinkWrap : a.natural } } else { if (m.readsHeight) { if (g) { i = a.calculatedFromConfigured } else { i = (n & 2) ? a.calculatedFromShrinkWrap : a.calculatedFromNatural } } else { i = a.calculated } } } } return j.pairsByHeightOrdinal[i.ordinal] }, getState: function () { var b = this, c = null, a = b.getSizeModel(); if (a.width.configured) { c = b.addPropertyToState(c, "width") } if (a.height.configured) { c = b.addPropertyToState(c, "height") } return c }, getUserCls: function () { return this.userCls }, setUserCls: function (a) { var b = this, c = b.userCls; if (a !== c) { b.userCls = a; if (b.rendered) { b.el.replaceCls(c, a) } } return c }, getWidth: function () { return this.el.getWidth() }, getXType: function () { return this.self.xtype }, getXTypes: function () { var c = this.self, d, b, a; if (!c.xtypes) { d = []; b = this; while (b) { a = b.xtypes; if (a !== undefined) { d.unshift.apply(d, a) } b = b.superclass } c.xtypeChain = d; c.xtypes = d.join("/") } return c.xtypes }, hasCls: function (b) { var a = this.rendered ? this.el : this.protoEl; return a.hasCls.apply(a, arguments) }, hasUICls: function (a) { var b = this, c = b.uiCls || []; return Ext.Array.contains(c, a) }, hide: function (d, e, b) { var c = this, a = c.focusableContainer; if (c.pendingShow) { c.pendingShow = false } if (!(c.rendered && !c.isVisible())) { if (!c.hasListeners.beforehide || c.fireEvent("beforehide", c) !== false || c.hierarchicallyHidden) { c.getInherited().hidden = c.hidden = true; if (a) { a.beforeFocusableChildHide(c) } c.fireHierarchyEvent("beforehide"); if (c.rendered) { c.onHide.apply(c, arguments) } } } return c }, initComponent: function () { var c = this, b = c.width, a = c.height; if (c.plugins && !c.plugins.processed) { c.plugins = c.constructPlugins() } c.pluginsInitialized = true; if (b != null || a != null) { c.setSize(b, a) } if (c.listeners) { c.on(c.listeners); c.listeners = null } if (c.focusable) { c.initFocusable() } }, initEvents: function () { var e = this, h = e.afterRenderEvents, b, d, g, c, a; if (h) { for (g in h) { d = e[g]; if (d && d.on) { b = h[g]; for (c = 0, a = b.length; c < a; ++c) { e.mon(d, b[c]) } } } } if (e.focusable) { e.initFocusableEvents() } e.initKeyMap() }, is: function (a) { return Ext.ComponentQuery.is(this, a) }, isDescendantOf: function (a) { var b; for (b = this.getRefOwner(); b && b !== a; b = b.getRefOwner()) { } return b || null }, isAncestor: function (a) { while (a) { if (a.getRefOwner() === this) { return true } a = a.getRefOwner() } }, isDisabled: function () { return this.disabled }, isDraggable: function () { return !!this.draggable }, isDroppable: function () { return !!this.droppable }, isFloating: function () { return this.floating }, isHidden: function () { return this.hidden }, isHierarchicallyHidden: function () { var d = this, c = false, a, b; for (; (a = d.ownerCt || d.floatParent); d = a) { b = a.getInherited(); if (b.hidden) { c = true; break } if (d.getInherited().collapseImmune) { if (a.collapsed && !d.collapseImmune) { c = true; break } } else { c = !!b.collapsed; break } } return c }, isLayoutChild: function (a) { return !this.floating && !!this.up(a) }, isLayoutRoot: function () { var a = this, b = a.ownerLayout; if (!b || a._isLayoutRoot || a.floating) { return true } return b.isItemLayoutRoot(a) }, isLayoutSuspended: function () { var a = this, b; while (a) { if (a.layoutSuspendCount || a.suspendLayout) { return true } b = a.ownerLayout; if (!b) { break } a = b.owner } return false }, isVisible: function (a) { var b = this, c; if (b.hidden || !b.rendered || b.destroyed) { c = true } else { if (a) { c = b.isHierarchicallyHidden() } } return !c }, isXType: function (b, a) { return a ? (Ext.Array.indexOf(this.xtypes, b) !== -1) : !!this.xtypesMap[b] }, isMasked: function (a) { var b = this; return !!(b.masked || (b.loadMask && b.loadMask.isVisible()) || (a && b.getInherited().masked)) }, lookupTpl: function (a) { return Ext.XTemplate.getTpl(this, a) }, setMasked: function (c) { var b = this, a = b.focusableContainer; if (c) { b.masked = true; b.getInherited().masked = c } else { b.masked = false; delete b.getInherited().masked } if (a) { a.onFocusableChildMasked(b, c) } return b }, mask: function (e, c, a) { var b = this.lastBox, d = this.getMaskTarget() || this.el; if (b) { a = b.height } d.mask(e, c, a); this.setMasked(true) }, nextNode: function (d, j) { var b = this, c = b.ownerCt, k, e, h, g, a; if (j && b.is(d)) { return b } if (c) { for (e = c.items.items, g = Ext.Array.indexOf(e, b) + 1, h = e.length; g < h; g++) { a = e[g]; if (a.is(d)) { return a } if (a.down) { k = a.down(d); if (k) { return k } } } return c.nextNode(d) } return null }, nextSibling: function (b) { var g = this.ownerCt, d, e, a, h; if (g) { d = g.items; a = d.indexOf(this) + 1; if (a) { if (b) { for (e = d.getCount(); a < e; a++) { if ((h = d.getAt(a)).is(b)) { return h } } } else { if (a < d.getCount()) { return d.getAt(a) } } } } return null }, onAdded: function (b, d, a) { var c = this; c.ownerCt = b; c.onInheritedAdd(c, a); if (c.hasListeners && c.hasListeners.added) { c.fireEvent("added", c, b, d) } if (Ext.GlobalEvents.hasListeners.added) { c.fireHierarchyEvent("added") } }, onRemoved: function (c) { var b = this, d, a; if (!b.isLayoutMoving && b.el && b.el.contains(Ext.Element.getActiveElement())) { a = b.findFocusTarget(); if (a) { a.focus() } } if (Ext.GlobalEvents.hasListeners.removed) { b.fireHierarchyEvent("removed") } if (b.hasListeners.removed) { b.fireEvent("removed", b, b.ownerCt) } if (!c) { b.removeBindings() } b.onInheritedRemove(c); b.ownerCt = b.ownerLayout = null }, onBoxReady: function (c, a) { var d = this, b; if (d.ariaLabelledBy || d.ariaDescribedBy) { if (d.ariaLabelledBy) { b = d.getAriaLabelEl(d.ariaLabelledBy); if (b) { d.ariaEl.dom.setAttribute("aria-labelledby", b) } } if (d.ariaDescribedBy) { b = d.getAriaLabelEl(d.ariaDescribedBy); if (b) { d.ariaEl.dom.setAttribute("aria-describedby", b) } } } if (d.resizable) { d.initResizable(d.resizable) } if (d.draggable) { d.initDraggable() } if (d.hasListeners.boxready) { d.fireEvent("boxready", d, c, a) } }, onDestroy: Ext.emptyFn, onDisable: function () { var a = this, b, c; if (a.focusable) { a.disableFocusable() } if (!a.ariaStaticRoles[a.ariaRole]) { a.ariaEl.dom.setAttribute("aria-disabled", true) } if (a.maskOnDisable && !a.getInheritedConfig("disableMask", true)) { b = a.el.dom; c = b.nodeName; if (a.disabledRe.test(c)) { b.disabled = true } if (!a.nonMaskableRe.test(c)) { a.mask() } } }, onEnable: function () { var a = this, b, c; if (a.focusable) { a.enableFocusable() } if (!a.ariaStaticRoles[a.ariaRole]) { a.ariaEl.dom.setAttribute("aria-disabled", false) } if (a.maskOnDisable && a.getInherited().hasOwnProperty("masked")) { b = a.el.dom; c = b.nodeName; if (a.disabledRe.test(c)) { b.disabled = false } if (!a.nonMaskableRe.test(c)) { a.unmask() } } }, onGlobalShow: function (a) { if (this.up(a)) { this.getScrollable().restoreState() } }, onHide: function (h, a, e) { var g = this, c, d, b; if (!g.ariaStaticRoles[g.ariaRole] && !g.destroying && !g.destroyed) { g.ariaEl.dom.setAttribute("aria-hidden", true) } g.revertFocus(); h = g.getAnimateTarget(h); if (!g.ghost) { h = null } if (h) { b = { x: h.getX(), y: h.getY(), width: h.dom.offsetWidth, height: h.dom.offsetHeight }; c = g.ghost(); c.el.stopAnimation(); d = g.getSize(); c.el.animate({ to: b, listeners: { afteranimate: function () { if (!g.destroying) { c.componentLayout.lastComponentSize = null; g.unghost(false); c.el.setSize(d); g.afterHide(a, e) } } } }) } else { g.el.hide() } if (!h) { g.afterHide(a, e) } }, onPosition: Ext.emptyFn, onResize: function (c, a, b, e) { var d = this; if (d.floating && d.constrain) { d.doConstrain() } if (d.hasListeners.resize) { d.fireEvent("resize", d, c, a, b, e) } }, onShow: function () { var a = this; if (!a.ariaStaticRoles[a.ariaRole]) { a.ariaEl.dom.setAttribute("aria-hidden", false) } a.el.show(); a.updateLayout({ isRoot: false, context: a._showContext }); if (a.floating) { if (a.maximized) { a.fitContainer() } else { if (a.constrain) { a.doConstrain() } } } }, _showContext: { show: true }, onShowComplete: function (a, c) { var d = this, b = d.focusableContainer; if (d.floating) { d.onFloatShow() } Ext.callback(a, c || d); d.fireEvent("show", d); if (b) { b.onFocusableChildShow(d) } delete d.hiddenByLayout }, onShowVeto: Ext.emptyFn, previousNode: function (b, d) { var j = this, h = j.ownerCt, a, g, e, c; if (d && j.is(b)) { return j } if (h) { for (g = h.items.items, e = Ext.Array.indexOf(g, j) - 1; e > -1; e--) { c = g[e]; if (c.query) { a = c.query(b); a = a[a.length - 1]; if (a) { return a } } if (c.is(b)) { return c } } return h.previousNode(b, true) } return null }, previousSibling: function (b) { var e = this.ownerCt, d, a, g; if (e) { d = e.items; a = d.indexOf(this); if (a !== -1) { if (b) { for (--a; a >= 0; a--) { if ((g = d.getAt(a)).is(b)) { return g } } } else { if (a) { return d.getAt(--a) } } } } return null }, registerFloatingItem: function (b) { var a = this; if (!a.floatingDescendants) { a.floatingDescendants = new Ext.ZIndexManager(a) } a.floatingDescendants.register(b) }, removeCls: function (a) { var c = this, b = c.rendered ? c.el : c.protoEl; b.removeCls.apply(b, arguments); return c }, removeClsWithUI: function (d, l) { var k = this, j = [], g = 0, a = Ext.Array, h = a.remove, e = k.uiCls = a.clone(k.uiCls), c = k.activeUI, b, m; if (typeof d === "string") { d = (d.indexOf(" ") < 0) ? [d] : Ext.String.splitWords(d) } b = d.length; for (g = 0; g < b; g++) { m = d[g]; if (m && k.hasUICls(m)) { h(e, m); if (c) { j = j.concat(k.removeUIClsFromElement(m)) } } } if (l !== true && c) { k.removeCls(j) } return j }, resumeLayouts: function (b) { var a = this; if (!a.rendered) { return } if (a.layoutSuspendCount && !--a.layoutSuspendCount) { a.suspendLayout = false; if (b && !a.isLayoutSuspended()) { a.updateLayout(b) } } }, scrollBy: function (c, b, d) { var a = this.getScrollable(); if (a) { a.scrollBy(c, b, d) } }, scrollTo: function (b, d, c) { var a = this.getScrollable(); if (a) { a.scrollTo(b, d, c) } }, setAutoScroll: function (a) { this.setScrollable(!!a); return this }, setBorder: function (b, d) { var c = this, a = !!d; if (c.rendered || a) { if (!a) { d = c.el } if (!b) { b = 0 } else { if (b === true) { b = "1px" } else { b = this.unitizeBox(b) } } d.setStyle("border-width", b); if (!a) { c.updateLayout() } } c.border = b }, setDock: function (c) { var b = this, a = b.ownerCt; if (c !== b.dock) { if (a && a.moveDocked) { a.moveDocked(b, c) } else { b.dock = c } } return b }, setDisabled: function (a) { return this[a ? "disable" : "enable"]() }, setFlex: function (a) { this.flex = a }, setHeight: function (a) { return this.setSize(undefined, a) }, setLoading: function (c, d) { var b = this, a = { target: b }; if (b.rendered) { if (c !== false) { if (Ext.isString(c)) { a.msg = c } else { Ext.apply(a, c) } if (!b.loadMask || !b.loadMask.isLoadMask) { if (d && a.useTargetEl == null) { a.useTargetEl = true } b.loadMask = new Ext.LoadMask(a) } else { Ext.apply(b.loadMask, a) } if (b.loadMask.isVisible()) { b.loadMask.syncMaskState() } else { b.loadMask.show() } } else { if (b.loadMask && b.loadMask.isLoadMask) { b.loadMask.hide() } } } return b.loadMask }, setMargin: function (c, b) { var a = this; if (a.rendered) { if (!c && c !== 0) { c = "" } else { if (c === true) { c = 5 } c = this.unitizeBox(c) } a.margin = c; a.margin$ = null; a.getEl().setStyle("margin", c); if (!b) { a.updateLayout(a._notAsLayoutRoot) } } else { a.margin = c } }, setOverflowXY: function (b, a) { this.setScrollable({ x: (b && b !== "hidden") ? b : false, y: (a && a !== "hidden") ? a : false }); return this }, setPagePosition: function (a, g, b) { var c = this, d, e; if (Ext.isArray(a)) { g = a[1]; a = a[0] } c.pageX = a; c.pageY = g; if (c.floating) { if (c.isContainedFloater()) { e = c.floatParent.getTargetEl().getViewRegion(); if (Ext.isNumber(a) && Ext.isNumber(e.left)) { a -= e.left } if (Ext.isNumber(g) && Ext.isNumber(e.top)) { g -= e.top } } else { d = c.el.translateXY(a, g); a = d.x; g = d.y } c.setPosition(a, g, b) } else { d = c.el.translateXY(a, g); c.setPosition(d.x, d.y, b) } return c }, setPosition: function (a, e, b) { var c = this, d = c.beforeSetPosition.apply(c, arguments); if (d && c.rendered) { a = d.x; e = d.y; if (b) { if (a !== c.getLocalX() || e !== c.getLocalY()) { c.stopAnimation(); c.animate(Ext.apply({ duration: 1000, listeners: { afteranimate: Ext.Function.bind(c.afterSetPosition, c, [a, e]) }, to: { left: a, top: e } }, b)) } } else { c.setLocalXY(a, e); c.afterSetPosition(a, e) } } return c }, setScrollX: function (b, c) { var a = this.getScrollable(); if (a) { a.scrollTo(b, null, c) } }, setScrollY: function (c, b) { var a = this.getScrollable(); if (a) { a.scrollTo(null, c, b) } }, setSize: function (d, a) { var e = this, b = e.width, h = e.height, g, c; if (d && typeof d === "object") { a = d.height; d = d.width } if (typeof d === "number") { e.width = Ext.Number.constrain(d, e.minWidth, e.maxWidth) } else { if (d === null) { delete e.width } else { if (typeof d === "string") { g = true; e.width = d } } } if (typeof a === "number") { e.height = Ext.Number.constrain(a, e.minHeight, e.maxHeight) } else { if (a === null) { delete e.height } else { if (typeof a === "string") { c = true; e.height = a } } } if (e.rendered && e.isVisible()) { if (b !== e.width || h !== e.height) { if (e.liquidLayout || g || c) { e.el.setSize(e.width, e.height) } e.updateLayout(e._notAsLayoutRoot) } } return e }, setStyle: function (c, b) { var a = this.el || this.protoEl; a.setStyle(c, b); return this }, setUI: function (c) { var b = this, e = b.uiCls, d = b.activeUI, a; if (c === d) { return } if (d) { a = b.removeClsWithUI(e, true); if (a.length) { b.removeCls(a) } b.removeUIFromElement() } else { b.uiCls = [] } b.ui = c; b.activeUI = c; b.addUIToElement(); a = b.addClsWithUI(e, true); if (a.length) { b.addCls(a) } if (b.rendered) { b.updateLayout() } }, setVisible: function (a) { return this[a ? "show" : "hide"]() }, setHidden: function (a) { return this.setVisible(!a) }, setWidth: function (a) { return this.setSize(a) }, show: function (e, a, c) { var d = this, g = d.rendered, b = d.focusableContainer; if (d.hierarchicallyHidden || (d.floating && !g && d.isHierarchicallyHidden())) { if (!g) { d.initHierarchyEvents() } if (arguments.length > 1) { arguments[0] = null; d.pendingShow = arguments } else { d.pendingShow = true } } else { if (g && d.isVisible()) { if (d.floating) { d.onFloatShow() } } else { if (d.fireEvent("beforeshow", d) !== false) { d.hidden = false; delete this.getInherited().hidden; if (b) { b.beforeFocusableChildShow(d) } Ext.suspendLayouts(); if (!g && (d.autoRender || d.floating)) { d.doAutoRender(); g = d.rendered } if (g) { d.beforeShow(); Ext.resumeLayouts(); d.onShow.apply(d, arguments); d.afterShow.apply(d, arguments) } else { Ext.resumeLayouts(true) } } else { d.onShowVeto() } } } return d }, showAt: function (a, d, b) { var c = this; if (!c.rendered && (c.autoRender || c.floating)) { c.x = a; c.y = d; return c.show() } if (c.floating) { c.setPosition(a, d, b) } else { c.setPagePosition(a, d, b) } return c.show() }, showBy: function (b, d, c) { var a = this; if (a.floating && b) { a._lastAlignTarget = b; a._lastAlignToPos = d || a.defaultAlign; a._lastAlignToOffsets = c || a.alignOffset; a.show() } return a }, suspendLayouts: function () { var a = this; if (!a.rendered) { return } if (++a.layoutSuspendCount === 1) { a.suspendLayout = true } }, toggleCls: function (a, b) { if (b === undefined) { b = !this.hasCls(a) } return this[b ? "addCls" : "removeCls"](a) }, unitizeBox: function (a) { return Ext.Element.unitizeBox(a) }, unmask: function () { (this.getMaskTarget() || this.el).unmask(); this.setMasked(false) }, unregisterFloatingItem: function (b) { var a = this; if (a.floatingDescendants) { a.floatingDescendants.unregister(b) } }, up: function (d, e) { var c = this.getRefOwner(), b = typeof e === "string", h = typeof e === "number", a = e && e.isComponent, g = 0; if (d) { for (; c && !c.destroyed; c = c.getRefOwner()) { g++; if (d.isComponent) { if (c === d) { return c } } else { if (Ext.ComponentQuery.is(c, d)) { return c } } if (b && c.is(e)) { return } if (h && g === e) { return } if (a && c === e) { return } } } return c }, update: function (d, h, j, b) { var i = this, k = (i.tpl && !Ext.isString(d)), c = i.focusableContainer, g, a, e; if (k) { i.data = (d && d.isEntity) ? d.getData(true) : d } else { i.html = Ext.isObject(d) ? Ext.DomHelper.markup(d) : d } if (i.rendered) { g = i.getSizeModel(); a = g.width.shrinkWrap || g.height.shrinkWrap; if (i.isContainer) { e = i.layout.getRenderTarget(); a = a || i.items.items.length > 0 } else { e = i.getTargetEl() } if (k) { i.tpl[i.tplWriteMode](e, i.data || {}) } else { e.setHtml(i.html, h, j, b || i) } if (a) { i.updateLayout() } if (c) { c.onFocusableChildUpdate(i) } } }, setHtml: function (b, a, c) { this.update(b, a, null, c) }, applyData: function (a) { this.update(a) }, updateBox: function (a) { this.setSize(a.width, a.height); this.setPagePosition(a.x, a.y); return this }, _asLayoutRoot: { isRoot: true }, _notAsLayoutRoot: { isRoot: false }, updateLayout: function (c) { var e = this, g, b = e.lastBox, a = c && c.isRoot, d = c && c.context; if (b) { b.invalid = true } if (!e.rendered || e.layoutSuspendCount || e.suspendLayout) { return } if (e.hidden) { Ext.Component.cancelLayout(e) } else { if (typeof a !== "boolean") { a = e.isLayoutRoot() } } if (a || !e.ownerLayout || !e.ownerLayout.onContentChange(e, d)) { if (!e.isLayoutSuspended()) { g = (c && c.hasOwnProperty("defer")) ? c.defer : e.deferLayouts; Ext.Component.updateLayout(e, g) } } }, updateMaxHeight: function (b, a) { this.changeConstraint(b, a, "min", "max-height", "height") }, updateMaxWidth: function (b, a) { this.changeConstraint(b, a, "min", "max-width", "width") }, updateMinHeight: function (b, a) { this.changeConstraint(b, a, "max", "min-height", "height") }, updateMinWidth: function (a, b) { this.changeConstraint(a, b, "max", "min-width", "width") }, updateTouchAction: function (e) { var b, a, c, d; for (b in e) { a = this[b]; c = e[b]; if (a && a.isElement) { a.setTouchAction(c) } else { d = true } } if (d) { this.el.setTouchAction(e) } }, getAnchorToXY: function (d, a, c, b) { return d.getAnchorXY(a, c, b) }, getBorderPadding: function () { return this.el.getBorderPadding() }, getLocalX: function () { return this.el.getLocalX() }, getLocalXY: function () { return this.el.getLocalXY() }, getLocalY: function () { return this.el.getLocalY() }, getX: function () { return this.el.getX() }, getXY: function () { return this.el.getXY() }, getY: function () { return this.el.getY() }, setLocalX: function (a) { this.el.setLocalX(a) }, setLocalXY: function (a, b) { this.el.setLocalXY(a, b) }, setLocalY: function (a) { this.el.setLocalY(a) }, setX: function (a, b) { this.el.setX(a, b) }, setXY: function (b, a) { this.el.setXY(b, a) }, setY: function (b, a) { this.el.setY(b, a) }, privates: { addOverCls: function () { var a = this; if (!a.disabled) { a.el.addCls(a.overCls) } }, addUIToElement: function () { var d = this, a = d.baseCls + "-" + d.ui, c, g, b, e; d.addCls(a); if (d.rendered && d.frame && !Ext.supports.CSS3BorderRadius) { a += "-"; c = d.getChildEls(); for (g in c) { e = c[g].frame; if (e && e !== true) { b = d[g]; if (b) { b.addCls(a + e) } } } } }, changeConstraint: function (h, c, a, e, b) { var g = this, d = g[b]; if (h != null && typeof d === "number") { g[b] = Math[a](d, h) } if (g.liquidLayout) { if (h != null) { g.setStyle(e, h + "px") } else { if (c) { g.setStyle(e, "") } } } if (g.rendered) { g.updateLayout() } }, constructPlugin: function (b) { var a = this; if (typeof b === "string") { b = Ext.PluginManager.create({}, b, a) } else { b = Ext.PluginManager.create(b, null, a) } return b }, constructPlugins: function () { var e = this, c = e.plugins, b, d, a; if (c) { b = []; b.processed = true; if (!Ext.isArray(c)) { c = [c] } for (d = 0, a = c.length; d < a; d++) { b[d] = e.constructPlugin(c[d]) } } e.pluginsInitialized = true; return b }, detachFromBody: function () { Ext.getDetachedBody().appendChild(this.el); Ext.Component.cancelLayout(this); this.isDetached = true }, doAddListener: function (d, l, m, o, b, a, e) { var k = this, j, h, c, n, g, i; if (Ext.isObject(l) || (o && o.element)) { if (o.element) { n = o.element; j = {}; j[d] = l; if (m) { j.scope = m } c = k.$elementEventOptions; for (h in o) { if (c[h]) { j[h] = o[h] } } } else { j = l; n = d } g = k[n]; if (g && g.isObservable) { k.mon(g, j) } else { k.afterRenderEvents = k.afterRenderEvents || {}; if (!k.afterRenderEvents[n]) { k.afterRenderEvents[n] = [] } k.afterRenderEvents[n].push(j) } return } if (o) { i = o.delegate; if (i) { k.mixins.componentDelegation.addDelegatedListener.call(k, d, l, m, o, b, a, e); return } } k.mixins.observable.doAddListener.call(k, d, l, m, o, b, a, e) }, doRemoveListener: function (a, c, b) { var d = this; d.mixins.observable.doRemoveListener.call(d, a, c, b); d.mixins.componentDelegation.removeDelegatedListener.call(d, a, c, b) }, fireHierarchyEvent: function (b) { var a = Ext.GlobalEvents; if (a.hasListeners[b]) { a.fireEvent(b, this) } }, getActionEl: function () { return this.el }, getAutoId: function () { this.autoGenId = true; return ++Ext.Component.AUTO_ID }, getContentTarget: function () { return this.el }, getDragEl: function () { return this.el }, getOverflowEl: function () { return this.getTargetEl() }, getOverflowStyle: function () { var d = this, b = d.getScrollable(), c = d._scrollFlags, a, g, e; if (b) { a = b.getX(); if (a === true) { a = "auto" } g = b.getY(); if (g === true) { g = "auto" } e = c[a][g] } else { e = c.none } d.scrollFlags = e; return { overflowX: e.overflowX, overflowY: e.overflowY } }, getPlugins: function () { var a = this.plugins; a = (a && a.processed) ? a : this.constructPlugins(); return a || null }, getProxy: function () { var a = this, b; if (!a.proxy) { b = Ext.getBody(); a.proxy = a.el.createProxy("x-proxy-el", b, true) } return a.proxy }, getTargetEl: function () { return this.frameBody || this.el }, getTdCls: function () { return "x-" + this.getTdType() + "-" + this.ui + "-cell" }, getTdType: function () { return this.xtype }, getTpl: function (a) { return this.lookupTpl(a) }, initCls: function () { var b = this, a = [b.baseCls], c = b.getComponentLayout().targetCls; if (c) { a.push(c) } if (Ext.isDefined(b.cmpCls)) { if (Ext.isDefined(Ext.global.console)) { Ext.global.console.warn("Ext.Component: cmpCls has been deprecated. Please use componentCls.") } b.componentCls = b.cmpCls; delete b.cmpCls } if (b.componentCls) { a.push(b.componentCls) } else { b.componentCls = b.baseCls } return a }, initDraggable: function () { var c = this, a = (c.resizer && c.resizer.el !== c.el) ? c.resizerComponent = new Ext.Component({ el: c.resizer.el, rendered: true, container: c.container }) : c, b = Ext.applyIf({ el: a.getDragEl(), constrainTo: (c.constrain || c.draggable.constrain) ? (c.constrainTo || (c.floatParent ? c.floatParent.getTargetEl() : c.container)) : undefined }, c.draggable); if (c.constrain || c.constrainDelegate) { b.constrain = c.constrain; b.constrainDelegate = c.constrainDelegate } c.dd = new Ext.util.ComponentDragger(a, b) }, initPadding: function (c) { var a = this, b = a.padding; if (b != null) { if (a.layout && a.layout.managePadding && a.contentPaddingProperty === "padding") { c.setStyle("padding", 0) } else { c.setStyle("padding", this.unitizeBox((b === true) ? 5 : b)) } } }, initPlugin: function (a) { a.init(this); return a }, initResizable: function (a) { var b = this; a = Ext.apply({ target: b, dynamic: false, constrainTo: (b.constrain || (a && a.constrain)) ? (b.constrainTo || (b.floatParent ? b.floatParent.getTargetEl() : b.container)) : undefined, handles: b.resizeHandles }, a); a.target = b; b.resizer = new Ext.resizer.Resizer(a) }, initStyles: function (k) { var g = this, d = g.margin, e = g.border, l = g.cls, a = g.style, i = g.x, h = g.y, c = g.liquidLayout, b, j; g.initPadding(k); if (d != null) { k.setStyle("margin", this.unitizeBox((d === true) ? 5 : d)) } if (e != null) { g.setBorder(e, k) } if (l && l !== g.initialCls) { k.addCls(l); g.cls = g.initialCls = null } if (a && a !== g.initialStyle) { k.setStyle(a); g.style = g.initialStyle = null } if (i != null) { k.setStyle(g.horizontalPosProp, (typeof i === "number") ? (i + "px") : i) } if (h != null) { k.setStyle("top", (typeof h === "number") ? (h + "px") : h) } if (!g.ownerCt || g.floating) { if (Ext.scopeCss) { k.addCls(g.rootCls) } k.addCls(g.borderBoxCls) } if (c || !g.getFrameInfo()) { b = g.width; j = g.height; if (b != null) { if (typeof b === "number") { k.setStyle("width", b + "px") } else { k.setStyle("width", b) } } if (j != null) { if (typeof j === "number") { k.setStyle("height", j + "px") } else { k.setStyle("height", j) } } } }, isContainedFloater: function () { return (this.floating && this.floatParent) }, isDescendant: function (a) { if (a.isContainer) { for (var b = this.ownerCt; b; b = b.ownerCt) { if (b === a) { return true } } } return false }, owns: function (b) { var a = false, c; if (b.isEvent) { b = b.target } else { if (b.isElement) { b = b.dom } } c = Ext.Component.fromElement(b); if (c) { a = (c === this) || (!!c.up(this)) } return a }, parseBox: function (a) { return Ext.Element.parseBox(a) }, reattachToBody: function () { this.isDetached = false }, removeManagedListenerItem: function (b, a, i, d, g, e) { var h = this, c = a.options ? a.options.element : null; if (c) { c = h[c]; if (c && c.un) { if (b || (a.item === i && a.ename === d && (!g || a.fn === g) && (!e || a.scope === e))) { c.un(a.ename, a.fn, a.scope); if (!b) { Ext.Array.remove(h.managedListeners, a) } } } } else { return h.mixins.observable.removeManagedListenerItem.apply(h, arguments) } }, removeOverCls: function () { this.el.removeCls(this.overCls) }, removePlugin: function (a) { Ext.Array.remove(this.plugins, a); a.destroy() }, removeUIFromElement: function () { var d = this, a = d.baseCls + "-" + d.ui, c, g, b, e; d.removeCls(a); if (d.rendered && d.frame && !Ext.supports.CSS3BorderRadius) { a += "-"; c = d.getChildEls(); for (g in c) { e = c[g].frame; if (e && e !== true) { b = d[g]; if (b) { b.removeCls(a + e) } } } } }, setComponentLayout: function (b) { var a = this.componentLayout; if (a && a.isLayout && a !== b) { a.setOwner(null) } this.componentLayout = b; b.setOwner(this) }, setHiddenState: function (d) { var c = this, b = c.getInherited(), a = c.zIndexManager; c.hidden = d; if (d) { b.hidden = true } else { delete b.hidden } if (a) { a.onComponentShowHide(c) } }, setupProtoEl: function () { var a = this.initCls(); this.protoEl.addCls(a) }, wrapPrimaryEl: function (c) { var b = this, a = b.el; if (!a || !a.isElement) { b.el = Ext.get(c) } if (b.floating) { this.mixins.floating.constructor.call(this) } } }, deprecated: { 5: { methods: { addClass: "addCls", doComponentLayout: function () { this.updateLayout(); return this }, removeClass: "removeCls", forceComponentLayout: "updateLayout", setDocked: "setDock" } } } }, 1, ["component", "box"], ["component", "box"], { component: true, box: true }, ["widget.box", "widget.component"], [[Ext.mixin.Inheritable.prototype.mixinId || Ext.mixin.Inheritable.$className, Ext.mixin.Inheritable], [Ext.util.Floating.prototype.mixinId || Ext.util.Floating.$className, Ext.util.Floating], [Ext.util.Positionable.prototype.mixinId || Ext.util.Positionable.$className, Ext.util.Positionable], [Ext.util.Observable.prototype.mixinId || Ext.util.Observable.$className, Ext.util.Observable], [Ext.mixin.ComponentDelegation.prototype.mixinId || Ext.mixin.ComponentDelegation.$className, Ext.mixin.ComponentDelegation], [Ext.mixin.Bindable.prototype.mixinId || Ext.mixin.Bindable.$className, Ext.mixin.Bindable], [Ext.util.Animate.prototype.mixinId || Ext.util.Animate.$className, Ext.util.Animate], [Ext.util.ElementContainer.prototype.mixinId || Ext.util.ElementContainer.$className, Ext.util.ElementContainer], [Ext.util.Renderable.prototype.mixinId || Ext.util.Renderable.$className, Ext.util.Renderable], [Ext.state.Stateful.prototype.mixinId || Ext.state.Stateful.$className, Ext.state.Stateful], [Ext.util.Focusable.prototype.mixinId || Ext.util.Focusable.$className, Ext.util.Focusable], [Ext.mixin.Accessible.prototype.mixinId || Ext.mixin.Accessible.$className, Ext.mixin.Accessible], [Ext.mixin.Keyboard.prototype.mixinId || Ext.mixin.Keyboard.$className, Ext.mixin.Keyboard]], [Ext, "Component", Ext, "AbstractComponent"], function (b) { var a = b.prototype; (a.$elementEventOptions = Ext.Object.chain(Ext.Element.prototype.$eventOptions)).element = 1; (a.$eventOptions = Ext.Object.chain(a.$eventOptions)).delegate = 1; b.createAlias({ on: "addListener", prev: "previousSibling", next: "nextSibling" }); Ext.resumeLayouts = function (c) { b.resumeLayouts(c) }; Ext.suspendLayouts = function () { b.suspendLayouts() }; Ext.batchLayouts = function (d, c) { b.suspendLayouts(); try { d.call(c) } finally { b.resumeLayouts(true) } }; Ext.setGlyphFontFamily = function (c) { Ext._glyphFontFamily = c }; b.hierarchyEventSource = a.hierarchyEventSource = Ext.GlobalEvents; Ext.onReady(function () { if (Ext.supports.HighContrastMode) { Ext.getBody().addCls(b.ariaHighContrastModeCls) } }) })); Ext.define("Ext.layout.container.border.Region", { override: "Ext.Component", initBorderRegion: function () { var a = this; if (!a._borderRegionInited) { a._borderRegionInited = true; a.addStateEvents(["changeregion", "changeweight"]); Ext.override(a, { getState: function () { var b = a.callParent(); b = a.addPropertyToState(b, "region"); b = a.addPropertyToState(b, "weight"); return b } }) } }, getOwningBorderContainer: function () { var a = this.getOwningBorderLayout(); return a && a.owner }, getOwningBorderLayout: function () { var a = this.ownerLayout; return (a && a.isBorderLayout) ? a : null }, setRegion: function (k) { var j = this, c, d = j.region; if (k !== d) { c = j.getOwningBorderLayout(); if (c) { var g = c.regionFlags[k], l = j.placeholder, a = j.splitter, b = c.owner, n = c.regionMeta, e = j.collapsed || j.floated, m, i, h; if (j.fireEventArgs("beforechangeregion", [j, k]) === false) { return d } Ext.suspendLayouts(); j.region = k; Ext.apply(j, g); if (j.updateCollapseTool) { j.updateCollapseTool() } if (a) { Ext.apply(a, g); a.updateOrientation(); i = b.items; h = i.indexOf(j); if (h >= 0) { m = n[k].splitterDelta; if (i.getAt(h + m) !== a) { i.remove(a); h = i.indexOf(j); if (m > 0) { ++h } i.insert(h, a) } } } if (l) { if (e) { j.expand(false) } b.remove(l); j.placeholder = null; if (e) { j.collapse(null, false) } } b.updateLayout(); Ext.resumeLayouts(true); j.fireEventArgs("changeregion", [j, d]) } else { j.region = k } } return d }, setWeight: function (d) { var c = this, b = c.getOwningBorderContainer(), e = c.placeholder, a = c.weight; if (d !== a) { if (c.fireEventArgs("beforechangeweight", [c, d]) !== false) { c.weight = d; if (e) { e.weight = d } if (b) { b.updateLayout() } c.fireEventArgs("changeweight", [c, a]) } } return a } }, function (a) { var b = a.prototype; b.setBorderRegion = b.setRegion; b.setRegionWeight = b.setWeight }); Ext.define("Ext.overrides.app.domain.Component", { override: "Ext.app.domain.Component" }, function (a) { a.monitor(Ext.Component) }); (Ext.cmd.derive("Ext.app.EventBus", Ext.Base, { singleton: true, constructor: function () { var b = this, a = Ext.app.EventDomain.instances; b.callParent(); b.domains = a; b.bus = a.component.bus }, control: function (b, a) { return this.domains.component.listen(b, a) }, listen: function (d, b) { var a = this.domains, c; for (c in d) { if (d.hasOwnProperty(c)) { a[c].listen(d[c], b) } } }, unlisten: function (c) { var a = Ext.app.EventDomain.instances, b; for (b in a) { a[b].unlisten(c) } } }, 1, 0, 0, 0, 0, 0, [Ext.app, "EventBus"], 0)); (Ext.cmd.derive("Ext.app.domain.Global", Ext.app.EventDomain, { singleton: true, type: "global", constructor: function () { var a = this; a.callParent(); a.monitor(Ext.GlobalEvents) }, listen: function (b, a) { this.callParent([{ global: b }, a]) }, match: Ext.returnTrue }, 1, 0, 0, 0, 0, 0, [Ext.app.domain, "Global"], 0)); (Ext.cmd.derive("Ext.app.BaseController", Ext.Base, { isController: true, config: { id: undefined, control: null, listen: null, routes: null, before: null }, constructor: function (a) { var b = this; Ext.apply(b, a); delete b.control; delete b.listen; b.eventbus = Ext.app.EventBus; b.mixins.observable.constructor.call(b, a) }, updateId: function (a) { this.id = a }, applyListen: function (a) { if (Ext.isObject(a)) { a = Ext.clone(a) } return a }, applyControl: function (a) { if (Ext.isObject(a)) { a = Ext.clone(a) } return a }, updateControl: function (a) { this.getId(); if (a) { this.control(a) } }, updateListen: function (a) { this.getId(); if (a) { this.listen(a) } }, updateRoutes: function (b) { if (b) { var e = this, g = e.getBefore() || {}, a = Ext.app.route.Router, d, c, h; for (d in b) { c = b[d]; if (Ext.isString(c)) { c = { action: c } } h = c.action; if (!c.before) { c.before = g[h] } a.connect(d, c, e) } } }, isActive: function () { return true }, control: function (b, c, a) { var d = this, e = a, g; if (Ext.isString(b)) { g = {}; g[b] = c } else { g = b; e = c } d.eventbus.control(g, e || d) }, listen: function (b, a) { this.eventbus.listen(b, a || this) }, destroy: function () { var b = this, a = b.eventbus; Ext.app.route.Router.disconnectAll(b); if (a) { a.unlisten(b); b.eventbus = null } b.callParent() }, redirectTo: function (c, d) { if (c.isModel) { c = c.toUrl() } var a = Ext.util.History.getToken() === c, b = false; if (!a) { b = true; Ext.util.History.add(c) } else { if (d) { b = true; Ext.app.route.Router.onStateChange(c) } } return b } }, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.app, "BaseController"], 0)); (Ext.cmd.derive("Ext.app.Util", Ext.Base, {}, 0, 0, 0, 0, 0, 0, [Ext.app, "Util"], function () { Ext.apply(Ext.app, { namespaces: { Ext: {} }, addNamespaces: function (c) { var d = Ext.app.namespaces, b, a; if (!Ext.isArray(c)) { c = [c] } for (b = 0, a = c.length; b < a; b++) { d[c[b]] = true } }, clearNamespaces: function () { Ext.app.namespaces = {} }, getNamespace: function (b) { var d = Ext.apply({}, Ext.ClassManager.paths, Ext.app.namespaces), a = "", c; for (c in d) { if (d.hasOwnProperty(c) && c.length > a.length && (c + "." === b.substring(0, c.length + 1))) { a = c } } return a === "" ? undefined : a }, setupPaths: function (a, b, e) { var d = Ext.manifest, c; if (a && b !== null) { d = d && d.paths; if (!d || b !== undefined) { Ext.Loader.setPath(a, (b === undefined) ? "app" : b) } } if (e) { for (c in e) { if (e.hasOwnProperty(c)) { Ext.Loader.setPath(c, e[c]) } } } } }); Ext.getNamespace = Ext.app.getNamespace })); (Ext.cmd.derive("Ext.util.CollectionKey", Ext.Base, { isCollectionKey: true, observerPriority: -200, config: { collection: null, keyFn: null, property: null, rootProperty: null, unique: true }, generation: 0, map: null, mapRebuilds: 0, constructor: function (a) { this.initConfig(a) }, get: function (a) { var b = this.map || this.getMap(); return b[a] || null }, clear: function () { this.map = null }, getRootProperty: function () { var b = this, a = (arguments.callee.$previous || Ext.Base.prototype.getRootProperty).call(this); return a !== null ? a : b.getCollection().getRootProperty() }, indexOf: function (k, e) { var a = this.map || this.getMap(), l = a[k], g = this.getCollection(), b = g.length, d, h, j, c; if (!l) { return -1 } if (e === undefined) { e = -1 } if (l instanceof Array) { j = l; h = b; for (c = j.length; c-- > 0;) { d = g.indexOf(j[c]); if (d < h && d > e) { h = d } } if (h === b) { return -1 } } else { h = g.indexOf(l) } return (h > e) ? h : -1 }, updateKey: function (c, e) { var b = this, d = b.map, g, a; if (d) { g = d[e]; if (g instanceof Array) { a = Ext.Array.indexOf(g, c); if (a >= 0) { if (g.length > 2) { g.splice(a, 1) } else { d[e] = g[1 - a] } } } else { if (g) { delete d[e] } } b.add([c]) } }, onCollectionAdd: function (b, a) { if (this.map) { this.add(a.items) } }, onCollectionItemChange: function (b, a) { this.map = null }, onCollectionRefresh: function () { this.map = null }, onCollectionRemove: function (e, d) { var h = this, a = h.map, g = d.items, b = g.length, c, k, j; if (a) { if (h.getUnique() && b < e.length / 2) { for (c = 0; c < b; ++c) { j = h.getKey(k = g[c]); delete a[j] } } else { h.map = null } } }, add: function (g) { var h = this, a = h.map, b, e, k, j, c, d; c = g.length; d = h.getUnique(); for (e = 0; e < c; ++e) { j = h.getKey(k = g[e]); if (d || !(j in a)) { a[j] = k } else { if (!((b = a[j]) instanceof Array)) { a[j] = b = [b] } b.push(k) } } }, applyKeyFn: function (a) { if (Ext.isString(a)) { this.getKey = function (b) { return b[a]() } } else { this.getKey = a } }, updateProperty: function (b) { var a = this.getRootProperty(); this.getKey = function (c) { return (a ? c[a] : c)[b] } }, getMap: function () { var a = this, b = a.map; if (!b) { a.map = b = {}; a.keysByItemKey = {}; ++a.mapRebuilds; a.add(a.getCollection().items) } return b }, updateCollection: function (a) { a.addObserver(this) }, clone: function () { return new Ext.util.CollectionKey(this.getCurrentConfig()) } }, 1, 0, 0, 0, 0, [[Ext.mixin.Identifiable.prototype.mixinId || Ext.mixin.Identifiable.$className, Ext.mixin.Identifiable]], [Ext.util, "CollectionKey"], 0)); (Ext.cmd.derive("Ext.util.Grouper", Ext.util.Sorter, { isGrouper: true, config: { groupFn: null, sortProperty: null }, constructor: function (a) { Ext.util.Sorter.prototype.constructor.apply(this, arguments) }, getGroupString: function (a) { var b = this._groupFn(a); return (b != null) ? String(b) : "" }, sortFn: function (d, c) { var g = this, b = g._groupFn(d), e = g._groupFn(c), j = g._sortProperty, i = g._root, h = g._sorterFn, a = g._transform; if (b === e) { return 0 } if (j || h) { if (h) { return h.call(this, d, c) } if (i) { d = d[i]; c = c[i] } b = d[j]; e = c[j]; if (a) { b = a(b); e = a(e) } } return (b > e) ? 1 : (b < e ? -1 : 0) }, standardGroupFn: function (b) { var a = this._root; return (a ? b[a] : b)[this._property] }, updateSorterFn: function () { }, updateProperty: function () { if (!this.getGroupFn()) { this.setGroupFn(this.standardGroupFn) } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "Grouper"], 0)); (Ext.cmd.derive("Ext.util.Collection", Ext.Base, { isCollection: true, config: { autoFilter: true, autoSort: true, autoGroup: true, decoder: null, extraKeys: null, filters: null, grouper: null, groups: null, rootProperty: null, sorters: null, multiSortLimit: 3, defaultSortDirection: "ASC", source: null, trackGroups: true }, generation: 0, indices: null, indexRebuilds: 0, updating: 0, grouped: false, sorted: false, filtered: false, $endUpdatePriority: 1001, manageSorters: true, constructor: function (a) { var b = this; b.items = []; b.map = {}; b.length = 0; if (a && a.keyFn) { b.getKey = a.keyFn } b.mixins.observable.constructor.call(b, a) }, destroy: function () { var c = this, b = c._filters, d = c._sorters, a = c._groups; if (b) { b.destroy(); c._filters = null } if (d) { c.grouped = c.sorted = false; c.setSorters(null); if (c.manageSorters) { d.destroy() } } if (a) { a.destroy(); c._groups = null } c.setSource(null); c.observers = c.items = c.map = null; c.callParent() }, add: function (d) { var c = this, a = c.decodeItems(arguments, 0), b = a; if (a.length) { c.splice(c.length, 0, a); b = (a.length === 1) ? a[0] : a } return b }, replaceAll: function () { var c = this, b, a; a = c.decodeItems(arguments, 0); b = a; if (a.length) { c.splice(0, c.length, a); b = (a.length === 1) ? a[0] : a } else { c.removeAll() } return b }, aggregate: function (h, b, e, a, d) { var g = this, c = Ext.Array.slice(arguments); c.unshift(g.items); return g.aggregateItems.apply(g, c) }, aggregateByGroup: function (d, b, c) { var a = this.getGroups(); return this.aggregateGroups(a, d, b, c) }, aggregateItems: function (l, r, d, a, e, s) { var m = this, k = Ext.Number.clipIndices(l.length, [a, e]), b = (a !== 0 && e !== l.length), h, g, c, n, p, q, o; a = k[0]; e = k[1]; if (!Ext.isFunction(d)) { d = m._aggregators[d]; return d.call(m, l, a, e, r, m.getRootProperty()) } n = m.getRootProperty(); q = new Array(c); o = b ? new Array(c) : l; for (h = a, g = 0; h < e; ++h, g++) { if (b) { o[g] = p = l[h] } q[g] = (n ? p[n] : p)[r] } return d.call(s || m, l, q, 0) }, aggregateGroups: function (a, k, c, l) { var h = a.items, g = h.length, b = !Ext.isFunction(c), d = {}, e, j, m; for (e = 0; e < g; ++e) { j = h[e]; if (!b) { m = this.aggregateItems(j.items, k, c, null, null, l) } else { m = j[c](k) } d[j.getGroupKey()] = m } return d }, beginUpdate: function () { if (!this.updating++) { this.notify("beginupdate") } }, clear: function () { var c = this, d = c.generation, a = d ? c.items : [], b, e; if (d) { c.items = []; c.length = 0; c.map = {}; c.indices = {}; c.generation++; b = c.getExtraKeys(); if (b) { for (e in b) { b[e].clear() } } } return a }, clone: function () { var a = this, b = new a.self(a.initialConfig); b.add(a.items); return b }, collect: function (l, g, j) { var e = this.items, b = e.length, a = {}, d = [], c, h, k; for (c = 0; c < b; ++c) { k = e[c]; k = (g ? k[g] : k)[l]; h = String(k); if ((j || !Ext.isEmpty(k)) && !a[h]) { a[h] = 1; d.push(k) } } return d }, contains: function (c) { var a = false, b; if (c != null) { b = this.getKey(c); a = this.map[b] === c } return a }, containsKey: function (a) { return a in this.map }, createFiltered: function (o, n, e, k, d) { var j = this, g = new j.self(j.initialConfig), m = j.getRootProperty(), h = j.items, b, c, a, l, p; if (Ext.isFunction(o)) { l = o; p = n } else { if (Ext.isString(o)) { a = [new Ext.util.Filter({ property: o, value: n, root: m, anyMatch: e, caseSensitive: k, exactMatch: d })] } else { if (o instanceof Ext.util.Filter) { a = [o]; o.setRoot(m) } else { if (Ext.isArray(o)) { a = o.slice(0); for (c = 0, b = a.length; c < b; ++c) { a[c].setRoot(m) } } } } l = Ext.util.Filter.createFilterFn(a) } p = p || j; for (c = 0, b = h.length; c < b; c++) { if (l.call(p, h[c])) { g.add(h[c]) } } return g }, filterBy: function (b, a) { return this.createFiltered(b, a) }, each: function (g, e) { var b = this.items, a = b.length, d, c; if (a) { e = e || this; b = b.slice(0); for (d = 0; d < a; d++) { c = g.call(e, b[d], d, a); if (c === false) { break } } } return c }, eachKey: function (g, k) { var e = this, d = e.items, b = d.length, a, j, h, c; if (b) { k = k || e; d = d.slice(0); for (a = 0; a < b; a++) { h = e.getKey(j = d[a]); c = g.call(k, h, j, a, b); if (c === false) { break } } } return c }, endUpdate: function () { if (!--this.updating) { this.notify("endupdate") } }, find: function (h, g, i, d, c, b) { if (Ext.isEmpty(g, false)) { return null } var e = Ext.String.createRegex(g, d, c, b), a = this.getRootProperty(); return this.findBy(function (j) { return j && e.test((a ? j[a] : j)[h]) }, null, i) }, findBy: function (g, k, a) { var e = this, d = e.items, c = d.length, b, j, h; k = k || e; for (b = a || 0; b < c; b++) { h = e.getKey(j = d[b]); if (g.call(k, j, h)) { return d[b] } } return null }, findIndex: function (g, e, h, c, b, a) { var d = this.find(g, e, h, c, b, a); return d ? this.indexOf(d) : -1 }, findIndexBy: function (b, a, d) { var c = this.findBy(b, a, d); return c ? this.indexOf(c) : -1 }, first: function (b) { var a = b ? this.getGroups() : undefined; return a ? this.aggregateGroups(a, null, "first") : this.items[0] }, last: function (b) { var a = b ? this.getGroups() : undefined; return a ? this.aggregateGroups(a, null, "last") : this.items[this.length - 1] }, get: function (a) { return this.map[a] }, getAt: function (a) { return this.items[a] }, getByKey: function (a) { return this.map[a] }, getCount: function () { return this.length }, getKey: function (a) { var b = a.id; return (b === 0 || b) ? b : ((b = a._id) === 0 || b) ? b : a.getId() }, getRange: function (d, a) { var c = this.items, e = c.length, b; if (!e) { b = [] } else { b = Ext.Number.clipIndices(e, [d, a]); b = c.slice(b[0], b[1]) } return b }, getValues: function (k, h, a, b) { var g = this.items, d = Ext.Number.clipIndices(g.length, [a, b]), e = [], c, j; for (c = d[0], b = d[1]; c < b; ++c) { j = g[c]; j = (h ? j[h] : j)[k]; e.push(j) } return e }, indexOf: function (b) { if (!b) { return -1 } var a = this.getKey(b); return this.indexOfKey(a) }, indexOfKey: function (a) { var b = this, c = b.indices; if (a in b.map) { if (!c) { c = b.getIndices() } return c[a] } return -1 }, insert: function (c, e) { var d = this, a = d.decodeItems(arguments, 1), b = a; if (a.length) { d.splice(c, 0, a); b = (a.length === 1) ? a[0] : a } return b }, itemChanged: function (u, i, m, n) { var v = this, c = m === 0 || !!m, j = v.filtered && v.getAutoFilter(), e = false, d = 0, p = v.items, l = v.length - 1, a = v.sorted && l > 0 && v.getAutoSort(), r = v.getSource(), q = 0, k = false, o = false, t, s, g, w, h, b; if (r && !r.updating) { r.itemChanged(u, i, m, n) } else { s = v.getKey(u); if (j) { h = v.indexOfKey(c ? m : s); o = (h < 0); k = v.isItemFiltered(u); e = (o !== k) } if (e) { if (k) { q = [u]; b = -1 } else { w = [u]; b = v.length } } else { if (a && !k) { if (!j) { h = v.indexOfKey(c ? m : s) } g = v.getSortFn(); if (h !== -1) { if (h && g(p[h - 1], p[h]) > 0) { d = -1; b = Ext.Array.binarySearch(p, u, 0, h, g) } else { if (h < l && g(p[h], p[h + 1]) > 0) { d = 1; b = Ext.Array.binarySearch(p, u, h + 1, g) } } if (d) { w = [u] } } } } t = { item: u, key: s, index: b, filterChanged: e, keyChanged: c, indexChanged: !!d, filtered: k, oldIndex: h, newIndex: b, wasFiltered: o, meta: n }; if (c) { t.oldKey = m } if (i) { t.modified = i } v.beginUpdate(); v.notify("beforeitemchange", [t]); if (c) { v.updateKey(u, m) } if (w || q) { v.splice(b, q, w) } if (d > 0) { t.newIndex-- } else { if (d < 0) { t.oldIndex++ } } v.notify(k ? "filtereditemchange" : "itemchange", [t]); v.endUpdate() } }, remove: function (d) { var c = this, a = c.decodeRemoveItems(arguments, 0), b = c.length; c.splice(0, a); return b - c.length }, removeAll: function () { var b = this, a = b.length; if (b.generation && a) { b.splice(0, a) } return b }, removeAt: function (i, h) { var j = this, b = j.length, e = Ext.Number, d = e.clipIndices(b, [i, (h === undefined) ? 1 : h], e.Clip.COUNT), c = d[0], a = d[1] - c, k = (a === 1) && j.getAt(c), g; j.splice(c, a); g = j.length - b; return (k && g) ? k : g }, removeByKey: function (a) { var b = this.getByKey(a); if (!b || !this.remove(b)) { return false } return b }, replace: function (b) { var a = this.indexOf(b); if (a === -1) { this.add(b) } else { this.insert(a, b) } }, splice: function (E, o, C) { var m = this, d = m.sorted && m.getAutoSort(), A = m.map, s = m.items, q = m.length, w = (o instanceof Array) ? m.decodeRemoveItems(o) : null, x = !w, F = Ext.Number, e = F.clipIndices(q, [E, x ? o : 0], F.Clip.COUNT), h = e[0], l = e[1], L = l - h, u = m.decodeItems(arguments, 2), K = u ? u.length : 0, D, y, v, c = h, b = m.indices || ((K || w) ? m.getIndices() : null), r = null, j = L ? [h] : null, g = null, t = m.getSource(), a, H, I, N, B, G, M, p, z, J, P, O; if (t && !t.updating) { if (x) { w = []; for (N = 0; N < L; ++N) { w.push(s[h + N]) } } if (h < q) { N = t.indexOf(s[h]) } else { N = t.length } m.requestedIndex = E; t.splice(N, w, u); delete m.requestedIndex; return m } if (K) { D = u; g = []; y = {}; if (d) { O = m.getSorters(); if (K > 1) { if (!D.$cloned) { u = D = D.slice(0) } m.sortData(D) } } for (N = 0; N < K; ++N) { p = m.getKey(B = u[N]); if ((M = y[p]) !== undefined) { (P || (P = {}))[M] = 1 } else { G = b[p]; if (G < h || l <= G) { (j || (j = [])).push(G) } } y[p] = N; g.push(p) } if (P) { z = g; D = []; g = []; D.$cloned = true; for (N = 0; N < K; ++N) { if (!P[N]) { B = u[N]; D.push(B); g.push(z[N]) } } K = D.length } r = { items: D, keys: g } } for (N = w ? w.length : 0; N-- > 0;) { p = m.getKey(w[N]); if ((G = b[p]) !== undefined) { (j || (j = [])).push(G) } } if (!r && !j) { return m } m.beginUpdate(); if (j) { a = null; I = []; v = {}; if (j.length > 1) { j.sort(Ext.Array.numericSortFn) } for (N = 0, J = j.length; N < J; ++N) { p = m.getKey(B = s[G = j[N]]); if (!(p in A)) { continue } delete A[p]; if (!a || G > (a.at + H.length)) { I.push(a = { at: G, items: (H = []), keys: (z = []), map: v, next: a, replacement: r }); if (r) { r.replaced = a } } H.push(v[p] = B); z.push(p); if (G < c - 1) { --c } if (L > 1 && G === h) { --L; j[N--] = ++h } } if (r) { r.at = c } for (M = I.length; M-- > 0;) { a = I[M]; N = a.at; J = a.items.length; if (N + J < q) { m.indices = b = null } m.length = q -= J; s.splice(N, J); if (b) { z = a.keys; for (N = 0; N < J; ++N) { delete b[z[N]] } } ++m.generation; m.notify("remove", [a]) } } if (r) { if (d && K > 1 && q) { m.spliceMerge(D, g) } else { if (d) { if (K > 1) { c = 0; m.indices = b = null } else { c = O.findInsertionIndex(r.items[0], s, m.getSortFn(), E) } } if (c === q) { l = c; for (N = D.length - 1; N >= 0; --N) { s[l + N] = D[N] } b = m.indices; if (b) { for (N = 0; N < K; ++N) { b[g[N]] = c + N } } } else { m.indices = null; Ext.Array.insert(s, c, D) } for (N = 0; N < K; ++N) { A[g[N]] = D[N] } m.length += K; r.at = c; r.atItem = c === 0 ? null : s[c - 1]; ++m.generation; m.notify("add", [r]) } } m.endUpdate(); return m }, update: function (b, a) { var c = this; c.beginUpdate(); try { return b.call(a || c, c) } catch (d) { throw d } finally { c.endUpdate() } }, updateKey: function (b, e) { var a = this, d = a.map, h = a.indices, c = a.getSource(), g; if (c && !c.updating) { c.updateKey(b, e) } else { if ((g = a.getKey(b)) !== e) { if (d[e] === b && !(g in d)) { delete d[e]; a.updating++; a.generation++; d[g] = b; if (h) { h[g] = h[e]; delete h[e] } a.notify("updatekey", [{ item: b, newKey: g, oldKey: e }]); a.updating-- } } } }, findInsertIndex: function (d) { var e = this.getSource(), g = e.items, b = e.indexOf(d) - 1, c, a; while (b > -1) { c = g[b]; a = this.indexOf(c); if (a > -1) { return a + 1 } --b } return 0 }, onCollectionAdd: function (a, b) { var l = this, o = b.atItem, k = b.items, g = l.requestedIndex, j, h, c, e, m, d; if (!l.sorted) { if (g !== undefined) { h = g } else { if (o) { h = l.indexOf(o); if (h === -1) { h = l.findInsertIndex(k[0]) } else { ++h } } else { h = 0 } } } if (l.getAutoFilter() && l.filtered) { for (e = 0, d = k.length; e < d; ++e) { m = k[e]; if (l.isItemFiltered(m)) { if (!c) { c = k.slice(0, e) } if (!j) { j = [] } j.push(m) } else { if (c) { c.push(m) } } } } l.splice((h < 0) ? l.length : h, 0, c || k); if (j) { l.notify("filteradd", [j]) } }, onCollectionBeforeItemChange: function (b, a) { this.onCollectionUpdateKey = null }, onCollectionBeginUpdate: function () { this.beginUpdate() }, onCollectionEndUpdate: function () { this.endUpdate() }, onCollectionItemChange: function (b, a) { delete this.onCollectionUpdateKey; this.itemChanged(a.item, a.modified, a.oldKey, a.meta) }, onCollectionFilteredItemChange: null, onCollectionRefresh: function (a) { var g = this, b = {}, j = {}, d, k, e, h, c; e = a.items; e = g.filtered && g.getAutoFilter() ? Ext.Array.filter(e, g.getFilterFn()) : e.slice(0); if (g.sorted) { g.sortData(e) } g.items = e; g.length = c = e.length; g.map = b; g.indices = j; for (d = 0; d < c; ++d) { h = g.getKey(k = e[d]); b[h] = k; j[h] = d } g.notify("refresh") }, onCollectionRemove: function (b, a) { this.splice(0, a.items) }, onCollectionUpdateKey: function (b, a) { this.updateKey(a.item, a.oldKey) }, _aggregators: { average: function (c, d, b, e, a) { var g = b - d; return g && this._aggregators.sum.call(this, c, d, b, e, a) / g }, bounds: function (e, a, b, k, g) { for (var j, h, c, d = a; d < b; ++d) { j = e[d]; j = (g ? j[g] : j)[k]; if (!(j < h)) { h = j } if (!(j > c)) { c = j } } return [c, h] }, count: function (a) { return a.length }, extremes: function (g, a, c, m, k) { var h = null, b = null, e, n, j, d, l; for (e = a; e < c; ++e) { n = g[e]; l = (k ? n[k] : n)[m]; if (!(l < j)) { j = l; h = n } if (!(l > d)) { d = l; b = n } } return [b, h] }, max: function (e, g, d, h, c) { var a = this._aggregators.bounds.call(this, e, g, d, h, c); return a[1] }, maxItem: function (e, g, d, h, c) { var a = this._aggregators.extremes.call(this, e, g, d, h, c); return a[1] }, min: function (e, g, d, h, c) { var a = this._aggregators.bounds.call(this, e, g, d, h, c); return a[0] }, minItem: function (e, g, d, h, c) { var a = this._aggregators.extremes.call(this, e, g, d, h, c); return a[0] }, sum: function (c, g, b, j, a) { for (var h, e = 0, d = g; d < b; ++d) { h = c[d]; h = (a ? h[a] : h)[j]; e += h } return e } }, _eventToMethodMap: { add: "onCollectionAdd", beforeitemchange: "onCollectionBeforeItemChange", beginupdate: "onCollectionBeginUpdate", endupdate: "onCollectionEndUpdate", itemchange: "onCollectionItemChange", filtereditemchange: "onCollectionFilteredItemChange", refresh: "onCollectionRefresh", remove: "onCollectionRemove", beforesort: "beforeCollectionSort", sort: "onCollectionSort", filter: "onCollectionFilter", filteradd: "onCollectionFilterAdd", updatekey: "onCollectionUpdateKey" }, addObserver: function (a) { var b = this, c = b.observers; if (!c) { b.observers = c = [] } if (b.notifying) { b.observers = c = c.slice(0) } c.push(a); if (c.length > 1) { Ext.Array.sort(c, b.prioritySortFn) } }, prioritySortFn: function (g, e) { var d = g.observerPriority || 0, c = e.observerPriority || 0; return d - c }, applyExtraKeys: function (e, a) { var g = this, d = a || {}, c, b, h; for (b in e) { h = e[b]; if (!h.isCollectionKey) { c = { collection: g }; if (Ext.isString(h)) { c.property = h } else { c = Ext.apply(c, h) } h = new Ext.util.CollectionKey(c) } else { h.setCollection(g) } d[b] = g[b] = h; h.name = b } return d }, applyGrouper: function (a) { if (a) { a = this.getSorters().decodeSorter(a, "Ext.util.Grouper") } return a }, decodeItems: function (d, c) { var g = this, b = (c === undefined) ? d : d[c], a, h, e; if (!b || !b.$cloned) { a = d.length > c + 1 || !Ext.isIterable(b); if (a) { b = Ext.Array.slice(d, c); if (b.length === 1 && b[0] === undefined) { b.length = 0 } } h = g.getDecoder(); if (h) { if (!a) { b = b.slice(0); a = true } for (e = b.length; e-- > 0;) { if ((b[e] = h.call(g, b[e])) === false) { b.splice(e, 1) } } } if (a) { b.$cloned = true } } return b }, getIndices: function () { var d = this, e = d.indices, a = d.items, g = a.length, c, b; if (!e) { d.indices = e = {}; ++d.indexRebuilds; for (c = 0; c < g; ++c) { b = d.getKey(a[c]); e[b] = c } } return e }, notify: function (d, h) { var i = this, c = i.observers, k = i._eventToMethodMap[d], j = 0, e, b, a, g; h = h || []; if (c && k) { i.notifying = true; for (e = 0, b = c.length; e < b; ++e) { a = (g = c[e])[k]; if (a) { if (!j++) { h.unshift(i) } a.apply(g, h) } } i.notifying = false } if (!i.hasListeners) { return } if (i.hasListeners[d]) { if (!j) { h.unshift(i) } i.fireEventArgs(d, h) } }, getFilterFn: function () { return this.getFilters().getFilterFn() }, getFilters: function (b) { var a = this._filters; if (!a && b !== false) { a = new Ext.util.FilterCollection(); this.setFilters(a) } return a }, isItemFiltered: function (a) { return !this.getFilters().filterFn(a) }, onFilterChange: function (e) { var d = this, g = d.getSource(), c, b, a; if (!g) { c = d.getExtraKeys(); if (c) { b = {}; for (a in c) { b[a] = c[a].clone(d) } } g = new Ext.util.Collection({ keyFn: d.getKey, extraKeys: b, rootProperty: d.getRootProperty() }); if (d.length) { g.add(d.items) } d.setSource(g); d.autoSource = g } else { if (g.length || d.length) { d.onCollectionRefresh(g) } } d.notify("filter") }, applyFilters: function (a, b) { if (!a || a.isFilterCollection) { return a } if (a) { if (!b) { b = this.getFilters() } b.splice(0, b.length, a) } return b }, updateFilters: function (a, b) { var c = this; if (b) { b.un("endupdate", "onEndUpdateFilters", c) } if (a) { a.on({ endupdate: "onEndUpdateFilters", scope: c, priority: c.$endUpdatePriority }); a.$filterable = c } c.onEndUpdateFilters(a) }, onEndUpdateFilters: function (c) { var b = this, d = b.filtered, a = !!c && (c.length > 0); if (d || a) { b.filtered = a; b.onFilterChange(c) } }, getSortFn: function () { return this._sortFn || this.createSortFn() }, getSorters: function (b) { var a = this._sorters; if (!a && b !== false) { a = new Ext.util.SorterCollection(); this.setSorters(a) } return a }, onSortChange: function () { if (this.sorted) { this.sortItems() } }, sort: function (a, c, d) { var b = this.getSorters(); b.addSort.apply(b, arguments); return this }, sortData: function (a) { Ext.Array.sort(a, this.getSortFn()); return a }, sortItems: function (b) { var a = this; if (a.sorted) { b = a.getSortFn() } a.indices = null; a.notify("beforesort", [a.getSorters(false)]); if (a.length) { Ext.Array.sort(a.items, b) } a.notify("sort") }, sortBy: function (a) { return this.sortItems(a) }, findInsertionIndex: function (g, b, e, d) { var h, c, a; b = b || this.items; e = e || this.getSortFn(); a = b.length; if (d < a) { h = d > 0 ? e(b[d - 1], g) : 0; c = d < a - 1 ? e(g, b[d]) : 0; if (h < 1 && c < 1) { return d } } return Ext.Array.binarySearch(b, g, e) }, applySorters: function (a, b) { if (!a || a.isSorterCollection) { return a } if (a) { if (!b) { b = this.getSorters() } b.splice(0, b.length, a) } return b }, createSortFn: function () { var c = this, a = c.getGrouper(), d = c.getSorters(false), b = d ? d.getSortFn() : null; if (!a) { return b } return function (e, h) { var g = a.sort(e, h); if (!g && b) { g = b(e, h) } return g } }, updateGrouper: function (b) { var c = this, a = c.getGroups(), e = c.getSorters(), d; c.onSorterChange(); c.grouped = !!b; if (b) { if (c.getTrackGroups()) { if (!a) { a = new Ext.util.GroupCollection({ itemRoot: c.getRootProperty() }); a.$groupable = c; c.setGroups(a) } a.setGrouper(b); d = true } } else { if (a) { c.removeObserver(a); a.destroy() } c.setGroups(null) } if (!e.updating) { c.onEndUpdateSorters(e) } if (d) { a.onCollectionRefresh(c) } }, updateSorters: function (a, b) { var c = this; if (b && !b.destroyed) { b.un("endupdate", "onEndUpdateSorters", c) } if (a) { a.on({ endupdate: "onEndUpdateSorters", scope: c, priority: c.$endUpdatePriority }); a.$sortable = c } c.onSorterChange(); c.onEndUpdateSorters(a) }, onSorterChange: function () { this._sortFn = null }, onEndUpdateSorters: function (c) { var b = this, d = b.sorted, a = (b.grouped && b.getAutoGroup()) || (c && c.length > 0); if (d || a) { b.sorted = !!a; b.onSortChange(c) } }, removeObserver: function (a) { var b = this.observers; if (b) { Ext.Array.remove(b, a) } }, spliceMerge: function (k, s) { var r = this, q = r.map, g = k.length, c = 0, l = r.items, t = l.length, j = [], h = 0, n = [], d = r.getSortFn(), m, b, o, e, p, a; r.items = n; for (a = 0; a < g; a = b) { e = k[a]; for (; c < t; ++c) { if (d(e, p = l[c]) < 0) { break } n.push(p) } if (c === t) { j[h++] = { at: n.length, itemAt: n[n.length - 1], items: (m = []) }; if (h > 1) { j[h - 2].next = j[h - 1] } for (; a < g; ++a) { m.push(e = k[a]); n.push(e) } break } j[h++] = { at: n.length, itemAt: n[n.length - 1], items: (m = [e]) }; if (h > 1) { j[h - 2].next = j[h - 1] } n.push(e); for (b = a + 1; b < g; ++b) { if (d(e = k[b], p) >= 0) { break } n.push(e); m.push(e) } } for (; c < t; ++c) { n.push(l[c]) } for (o = 0; o < g; ++o) { q[s[o]] = k[o] } r.length = n.length; ++r.generation; r.indices = null; for (o = 0; o < h; ++o) { r.notify("add", [j[o]]) } }, getGroups: function () { return (arguments.callee.$previous || Ext.Base.prototype.getGroups).call(this) || null }, updateAutoGroup: function (b) { var a = this.getGroups(); if (a) { a.setAutoGroup(b) } this.onEndUpdateSorters(this._sorters) }, updateGroups: function (a, b) { if (b) { this.removeObserver(b) } if (a) { this.addObserver(a) } }, updateSource: function (b, a) { var c = this.autoSource; if (a) { if (!a.destroyed) { a.removeObserver(this) } if (a === c) { c.destroy(); this.autoSource = null } } if (b) { b.addObserver(this); if (b.length || this.length) { this.onCollectionRefresh(b) } } } }, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.util, "Collection"], function () { var a = this.prototype; a.removeAtKey = a.removeByKey; a.decodeRemoveItems = a.decodeItems; Ext.Object.each(a._aggregators, function (b) { a[b] = function (e, d, c) { return this.aggregate(e, b, d, c) }; a[b + "ByGroup"] = function (c) { return this.aggregateByGroup(c, b) } }) })); (Ext.cmd.derive("Ext.util.ObjectTemplate", Ext.Base, { isObjectTemplate: true, excludeProperties: {}, valueRe: /^[{][a-z\.]+[}]$/i, statics: { create: function (b, a) { return b.isObjectTemplate ? b : new Ext.util.ObjectTemplate(b, a) } }, constructor: function (b, a) { Ext.apply(this, a); this.template = b }, apply: function (a) { var b = this; delete b.apply; b.apply = b.compile(b.template); return b.apply(a) }, privates: { compile: function (e) { var g = this, b = g.excludeProperties, h, c, a, d; if (Ext.isString(e)) { if (e.indexOf("{") < 0) { d = function () { return e } } else { if (g.valueRe.test(e)) { e = e.substring(1, e.length - 1).split("."); d = function (l) { for (var j = l, k = 0; j && k < e.length; ++k) { j = j[e[k]] } return j } } else { e = new Ext.XTemplate(e); d = function (i) { return e.apply(i) } } } } else { if (!e || Ext.isPrimitive(e) || Ext.isFunction(e)) { d = function () { return e } } else { if (e instanceof Array) { h = []; for (c = 0, a = e.length; c < a; ++c) { h[c] = g.compile(e[c]) } d = function (l) { var j = [], k; for (k = 0; k < a; ++k) { j[k] = h[k](l) } return j } } else { h = {}; for (c in e) { if (!b[c]) { h[c] = g.compile(e[c]) } } d = function (m) { var k = {}, l, j; for (l in e) { j = b[l] ? e[l] : h[l](m); if (j !== undefined) { k[l] = j } } return k } } } } return d } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "ObjectTemplate"], 0)); (Ext.cmd.derive("Ext.data.schema.Role", Ext.Base, { isRole: true, left: true, owner: false, side: "left", isMany: false, defaultReaderType: "json", _internalReadOptions: { recordsOnly: true, asRoot: true }, constructor: function (b, c) { var d = this, a = c.extra; Ext.apply(d, c); if (a) { a = Ext.apply({}, a); delete a.type; Ext.apply(d, a); delete d.extra } d.association = b; if (b.owner === d.side) { b.owner = d; d.owner = true } }, processUpdate: function () { Ext.raise('Only the "many" for an association may be processed. "' + this.role + '" is not valid.') }, processLoad: function (b, c, a, d) { return a }, checkMembership: Ext.emptyFn, adoptAssociated: function (b, c) { var a = this.getAssociatedItem(b); if (a) { c.adopt(a) } }, $roleFilterId: "$associationRoleFilter", createAssociationStore: function (g, l, e, m) { var i = this, d = i.association, h = d.getFieldName(), j = d.isManyToMany, b = i.storeConfig, a = l.getId(), c = { asynchronousLoad: false, model: i.cls, role: i, session: g, associatedEntity: l, disableMetaChangeEvent: true, pageSize: null, remoteFilter: true, trackRemoved: !g }, k; if (j) { c.filters = [{ id: i.$roleFilterId, property: i.inverse.field, value: a, exactMatch: true }] } else { if (h) { c.filters = [{ id: i.$roleFilterId, property: h, value: a, exactMatch: true }]; c.foreignKeyName = h } } if (b) { Ext.apply(c, b) } k = Ext.Factory.store(c); i.onStoreCreate(k, g, a); if (h || (j && g)) { k.on({ scope: i, add: "onAddToMany", remove: "onRemoveFromMany", clear: "onRemoveFromMany" }) } if (e) { k.loadData(e) } k.complete = !!m; return k }, onStoreCreate: Ext.emptyFn, getAssociatedStore: function (q, e, b, s, u) { var w = this, o = w.getStoreName(), g = q[o], a = q.session, l = e && e.reload, p = q.$source, h = false, m = false, k, c, r, t, n, j, d, v; if (!g) { if (a) { if (p) { m = p.phantom } if (!s && p) { d = p[o]; if (d && !d.isLoading()) { s = []; n = d.getData().items; for (r = 0, t = n.length; r < t; ++r) { j = n[r]; s.push(a.getRecord(j.self, j.id)) } h = !!d.complete; k = true } } if (!k) { v = !!s; s = w.findRecords(a, q, s, u); if (!v && (!s || !s.length)) { s = null } h = m || v } } else { h = !!s } g = w.createAssociationStore(a, q, s, h || q.phantom); g.$source = d; if (!s && (w.autoLoad || e)) { l = true } q[o] = g } if (e) { if (l || g.isLoading()) { g.on("load", function (y, x, z, i) { c = [y, i]; b = b || e.scope || q; if (z) { Ext.callback(e.success, b, c) } else { Ext.callback(e.failure, b, c) } c.push(z); Ext.callback(e, b, c); Ext.callback(e.callback, b, c) }, null, { single: true }) } else { c = [g, null]; b = b || e.scope || q; Ext.callback(e.success, b, c); c.push(true); Ext.callback(e, b, c); Ext.callback(e.callback, b, c) } } if (l && !g.isLoading()) { g.load() } return g }, getAssociatedItem: function (b) { var a = this.isMany ? this.getStoreName() : this.getInstanceName(); return b[a] || null }, onDrop: Ext.emptyFn, onIdChanged: Ext.emptyFn, getReaderRoot: function () { var a = this; return a.associationKey || (a.associationKey = a.association.schema.getNamer().readerRoot(a.role)) }, getReader: function () { var c = this, a = c.reader, d = c.cls, e = !c.associationKey, b = this.getReaderRoot(); if (a && !a.isReader) { if (Ext.isString(a)) { a = { type: a } } Ext.applyIf(a, { model: d, rootProperty: b, useSimpleAccessors: e, type: c.defaultReaderType }); a = c.reader = Ext.createByAlias("reader." + a.type, a) } return a }, getInstanceName: function () { var a = this; return a.instanceName || (a.instanceName = a.association.schema.getNamer().instanceName(a.role)) }, getOldInstanceName: function () { return this.oldInstanceName || (this.oldInstanceName = "$old" + this.getInstanceName()) }, getStoreName: function () { var a = this; return a.storeName || (a.storeName = a.association.schema.getNamer().storeName(a.role)) }, constructReader: function (e) { var g = this, a = g.getReader(), h = g.cls, i = !g.associationKey, b = g.getReaderRoot(), c, d; if (!a) { d = h.getProxy(); if (d) { c = d.getReader(); a = new c.self(); a.copyFrom(c); a.setRootProperty(b) } else { a = new e.self({ model: h, useSimpleAccessors: i, rootProperty: b }) } g.reader = a } return a }, read: function (c, g, d, e) { var a = this.constructReader(d), b = a.getRoot(g); if (b) { return a.readRecords(b, e, this._internalReadOptions) } }, getCallbackOptions: function (a, b, c) { if (typeof a === "function") { a = { callback: a, scope: b || c } } else { if (a) { a = Ext.apply({}, a); a.scope = b || a.scope || c } } return a }, doGetFK: function (b, n, l) { var i = this, m = i.cls, e = i.association.getFieldName(), k = i.getInstanceName(), j = b[k], a = n && n.reload, d = j !== undefined && !a, h = b.session, c, g; if (!d) { if (h) { c = b.get(e); if (c || c === 0) { d = h.peekRecord(m, c, true) && !a; j = h.getRecord(m, c, false) } else { d = true; b[k] = j = null } } else { if (e) { c = b.get(e); if (!c && c !== 0) { d = true; b[k] = j = null } else { if (!j) { j = m.createWithId(c) } } } else { d = true; j = null } } } else { if (j) { d = !j.isLoading() } } if (d) { if (n) { g = [j, null]; l = l || n.scope || b; Ext.callback(n.success, l, g); g.push(true); Ext.callback(n, l, g); Ext.callback(n.callback, l, g) } } else { b[k] = j; n = i.getCallbackOptions(n, l, b); j.load(n) } return j }, doSetFK: function (a, j, n, m) { var i = this, g = i.association.getFieldName(), k = i.getInstanceName(), e = a[k], c = i.inverse, d = c.setterName, h = a.session, l, b; if (j && j.isEntity) { if (e !== j) { b = i.getOldInstanceName(); a[b] = e; a[k] = j; if (e && e.isEntity) { e[c.getInstanceName()] = undefined } if (g) { a.set(g, j.getId()) } delete a[b]; a.onAssociatedRecordSet(j, i); if (d) { j[d](a) } } } else { l = (a.changingKey && !c.isMany) || a.set(g, j); if (l && e && e.isEntity && !e.isEqual(e.getId(), j)) { a[k] = undefined; if (!c.isMany) { e[c.getInstanceName()] = undefined } } } if (n) { if (Ext.isFunction(n)) { n = { callback: n, scope: m || a } } return a.save(n) } } }, 1, 0, 0, 0, 0, 0, [Ext.data.schema, "Role"], 0)); (Ext.cmd.derive("Ext.data.schema.Association", Ext.Base, { isOneToOne: false, isManyToOne: false, isManyToMany: false, owner: null, field: null, constructor: function (a) { var c = this, d, b; Ext.apply(c, a); c.left = d = new c.Left(c, c.left); c.right = b = new c.Right(c, c.right); d.inverse = b; b.inverse = d }, hasField: function () { return !!this.field }, getFieldName: function () { var a = this.field; return a ? a.name : "" } }, 1, 0, 0, 0, 0, 0, [Ext.data.schema, "Association"], 0)); (Ext.cmd.derive("Ext.data.schema.OneToOne", Ext.data.schema.Association, { isOneToOne: true, isToOne: true, kind: "one-to-one", Left: Ext.define(null, { extend: "Ext.data.schema.Role", onDrop: function (a, b) { var c = this.getAssociatedItem(a); a[this.getInstanceName()] = null; if (c) { c[this.inverse.getInstanceName()] = null } }, onIdChanged: function (a, c, b) { var e = this.getAssociatedItem(a), d = this.association.getFieldName(); if (!a.session && e && d) { e.set(d, b) } }, createGetter: function () { var a = this; return function () { return a.doGet(this) } }, createSetter: function () { var a = this; return function (b) { return a.doSet(this, b) } }, doGet: function (a) { var b = this.getInstanceName(), c = a[b], d = a.session; if (!c && d) { } return c || null }, doSet: function (a, e) { var b = this.getInstanceName(), d = a[b], c = this.inverse.setterName; if (d !== e) { a[b] = e; if (c) { e[c](a) } a.onAssociatedRecordSet(e, this) } return d }, read: function (a, d, b, e) { var c = this, g = c.callParent([a, d, b, e]), h; if (g) { h = g[0]; if (h) { h[c.inverse.getInstanceName()] = a; a[c.getInstanceName()] = h; delete a.data[c.role] } } } }), Right: Ext.define(null, { extend: "Ext.data.schema.Role", left: false, side: "right", createGetter: function () { var a = this; return function (b, c) { return a.doGetFK(this, b, c) } }, createSetter: function () { var a = this; return function (d, b, c) { return a.doSetFK(this, d, b, c) } }, onDrop: function (g, d) { var b = this, c = b.association.field, a = b.getAssociatedItem(g), e; if (b.inverse.owner) { if (d && c) { e = g.get(c.name); if (e || e === 0) { a = d.getEntry(b.cls, e).record; if (a) { a.drop() } } } else { if (a) { a.drop() } } } if (c) { g.set(c.name, null) } g[b.getInstanceName()] = null; if (a) { a[b.inverse.getInstanceName()] = null } }, onValueChange: function (i, h, g) { var e = this, a = i[e.getOldInstanceName()] || e.getAssociatedItem(i), d = g || g === 0, c = e.getInstanceName(), b = e.cls; i.changingKey = true; e.doSetFK(i, g); if (!d) { i[c] = null } else { if (h && b) { i[c] = h.peekRecord(b, g) || undefined } } if (e.inverse.owner && a) { e.association.schema.queueKeyCheck(a, e) } i.changingKey = false }, checkKeyForDrop: function (a) { var b = this.inverse.getAssociatedItem(a); if (!b) { a.drop() } }, read: function (d, e, p, g) { var j = this, n = j.callParent([d, e, p, g]), k, m, o, i, l, b, c, a, h; if (n) { k = n[0]; m = j.association.field; if (m) { o = m.name } i = d.session; h = d.data; if (k) { if (i) { l = i.getRefs(k, this.inverse, true); a = (l && l[d.id]) || (h[o] === undefined) } else { a = true } if (a) { if (m) { c = h[o]; b = k.id; if (c !== b) { h[o] = b; if (i) { i.updateReference(d, m, b, c) } } } k[j.inverse.getInstanceName()] = d; d[j.getInstanceName()] = k } delete h[j.role] } } } }) }, 0, 0, 0, 0, 0, 0, [Ext.data.schema, "OneToOne"], 0)); (Ext.cmd.derive("Ext.data.schema.ManyToOne", Ext.data.schema.Association, { isManyToOne: true, isToOne: true, kind: "many-to-one", Left: Ext.define(null, { extend: "Ext.data.schema.Role", isMany: true, onDrop: function (h, e) { var g = this, k = g.getAssociatedItem(h), b, d, c, j, a; if (k) { b = k.removeAll(); if (b && g.inverse.owner) { for (c = 0, d = b.length; c < d; ++c) { b[c].drop() } } k.destroy(); h[g.getStoreName()] = null } else { if (e) { b = e.getRefs(h, g); if (b) { for (a in b) { b[a].drop() } } } } }, onIdChanged: function (h, b, c) { var k = this.association.getFieldName(), j = this.getAssociatedItem(h), d, e, g, a; if (j) { a = j.getFilters().get(this.$roleFilterId); if (a) { a.setValue(c) } if (!h.session && k) { d = j.getDataSource().items; for (e = 0, g = d.length; e < g; ++e) { d[e].set(k, c) } } } }, processUpdate: function (g, b) { var h = this, d = h.inverse.cls, e = b.R, a, i, j, c; if (e) { for (a in e) { i = g.peekRecord(d, a); if (i) { c = g.getEntityList(h.cls, e[a]); j = h.getAssociatedItem(i); if (j) { j.loadData(c); j.complete = true } else { i[h.getterName](null, null, c) } } else { g.onInvalidAssociationEntity(d, a) } } } }, findRecords: function (j, k, d, o) { var h = d, l = j.getRefs(k, this, true), m = this.association.field, n, c, b, e, g, a; if (m && (l || o)) { n = m.name; h = []; if (d) { a = {}; for (e = 0, g = d.length; e < g; ++e) { c = d[e]; b = c.id; if (l && l[b]) { h.push(c) } else { if (o && c.data[n] === undefined) { h.push(c); c.data[n] = k.id; j.updateReference(c, m, k.id, undefined) } } a[b] = true } } if (l) { for (b in l) { if (!a || !a[b]) { h.push(l[b]) } } } } return h }, processLoad: function (b, a, e, d) { var c = e; if (d) { c = this.findRecords(d, a, e, true) } this.onLoadMany(a, c, d); return c }, adoptAssociated: function (b, g) { var c = this.getAssociatedItem(b), e, d, a; if (c) { c.setSession(g); e = c.getData().items; for (d = 0, a = e.length; d < a; ++d) { g.adopt(e[d]) } } }, createGetter: function () { var a = this; return function (b, c, d) { return a.getAssociatedStore(this, b, c, d, true) } }, createSetter: null, onAddToMany: function (a, b) { this.syncFK(b, a.getAssociatedEntity(), false) }, onLoadMany: function (l, e, k) { var n = this.inverse.getInstanceName(), b = l.getId(), m = this.association.field, h, j, d, c, g, a; if (m) { for (h = 0, j = e.length; h < j; ++h) { d = e[h]; d[n] = l; if (m) { a = m.name; g = d.data; c = g[a]; if (c !== b) { g[a] = b; if (k) { k.updateReference(d, m, b, c) } } } } } }, onRemoveFromMany: function (a, b) { this.syncFK(b, a.getAssociatedEntity(), true) }, read: function (h, a, l, c) { var g = this, k = g.inverse.getInstanceName(), b = g.callParent([h, a, l, c]), j, e, d; if (b) { j = h[g.getterName](null, null, b); delete h.data[g.role]; b = j.getData().items; for (d = 0, e = b.length; d < e; ++d) { b[d][k] = h } } }, syncFK: function (e, l, m) { var k = this.association.getFieldName(), h = this.inverse, g = h.setterName, n = h.getInstanceName(), j = e.length, b = l.getId(), a, d, c; while (j-- > 0) { d = e[j]; a = !d.isEqual(b, d.get(k)); c = m ? null : l; if (a !== m) { d.changingKey = true; d[g](c); d.changingKey = false } else { d[n] = c } } } }), Right: Ext.define(null, { extend: "Ext.data.schema.Role", left: false, side: "right", onDrop: function (c, b) { var a = this.association.field; if (a) { c.set(a.name, null) } c[this.getInstanceName()] = null }, createGetter: function () { var a = this; return function (b, c) { return a.doGetFK(this, b, c) } }, createSetter: function () { var a = this; return function (b, c, d) { return a.doSetFK(this, b, c, d) } }, checkMembership: function (c, d) { var b = this.association.field, a; if (b) { a = this.getSessionStore(c, d.get(b.name)); if (a && !a.contains(d)) { a.add(d) } } }, onValueChange: function (d, h, b, a) { var j = this, m = j.getInstanceName(), o = j.cls, c, n, l, e, k, g; if (!d.changingKey) { c = b || b === 0; if (!c) { d[m] = null } if (h) { l = j.getSessionStore(h, a); if (l) { l.remove(d) } if (c) { l = j.getSessionStore(h, b); if (l && !l.isLoading()) { l.add(d) } if (o) { g = h.peekRecord(o, b) } d[m] = g || undefined } } else { n = d.joined; if (n) { for (e = n.length - 1; e >= 0; e--) { l = n[e]; if (l.isStore) { k = l.getAssociatedEntity(); if (k && k.self === j.cls && k.getId() === a) { l.remove(d) } } } } } } if (j.owner && b === null) { j.association.schema.queueKeyCheck(d, j) } }, checkKeyForDrop: function (b) { var a = this.association.field; if (b.get(a.name) === null) { b.drop() } }, getSessionStore: function (c, b) { var a = this.cls, d; if (a) { d = c.peekRecord(a, b); if (d) { return this.inverse.getAssociatedItem(d) } } }, read: function (g, c, b, e) { var d = this.callParent([g, c, b, e]), a; if (d) { a = d[0]; if (a) { g[this.getInstanceName()] = a; delete g.data[this.role] } } } }) }, 0, 0, 0, 0, 0, 0, [Ext.data.schema, "ManyToOne"], 0)); (Ext.cmd.derive("Ext.data.schema.ManyToMany", Ext.data.schema.Association, { isManyToMany: true, isToMany: true, kind: "many-to-many", Left: Ext.define(null, { extend: "Ext.data.schema.Role", isMany: true, digitRe: /^\d+$/, findRecords: function (l, m, d) { var n = l.getMatrixSlice(this.inverse, m.id), e = n.members, k = [], o = this.cls, a, h, j, b, g, c; if (d) { a = {}; for (h = 0, j = d.length; h < j; ++h) { c = d[h]; b = c.id; g = e[b]; if (!(g && g[2] === -1)) { k.push(c) } a[b] = true } } for (b in e) { g = e[b]; if (!a || !a[b] && (g && g[2] !== -1)) { c = l.peekRecord(o, b); if (c) { k.push(c) } } } return k }, onIdChanged: function (a, d, c) { var b = this.getAssociatedItem(a); if (b) { b.getFilters().get(this.$roleFilterId).setValue(c) } }, processLoad: function (b, a, e, d) { var c = e; if (d) { c = this.findRecords(d, a, e); this.onAddToMany(b, c, true) } return c }, processUpdate: function (g, b) { var h = this, d = h.inverse.cls, e = b.R, a, i, j, c; if (e) { for (a in e) { i = g.peekRecord(d, a); if (i) { c = g.getEntityList(h.cls, e[a]); j = h.getAssociatedItem(i); if (j) { j.loadData(c); j.complete = true } else { i[h.getterName](null, null, c) } } else { g.onInvalidAssociationEntity(d, a) } } } h.processMatrixBlock(g, b.C, 1); h.processMatrixBlock(g, b.D, -1) }, checkMembership: function (i, j) { var k = i.getMatrix(this.association, true), h, d, e, m, n, a, c, g, b, l; if (!k) { return } h = this.left ? k.right : k.left; d = h.inverse.role.cls; e = this.inverse; n = h.slices; if (n) { m = n[j.id]; if (m) { c = m.members; for (a in c) { g = c[a]; if (g[2] !== -1) { b = i.peekRecord(d, a); if (b) { l = e.getAssociatedItem(b); if (l) { l.matrixUpdate = 1; l.add(j); l.matrixUpdate = 0 } } } } } } }, onStoreCreate: function (b, d, e) { var c = this, a; if (d) { a = d.getMatrixSlice(c.inverse, e); a.attach(b); a.notify = c.onMatrixUpdate; a.scope = c } }, processMatrixBlock: function (e, d, c) { var a = this.inverse, b = this.digitRe, g, h; if (d) { for (h in d) { if (b.test(h)) { h = parseInt(h, 10) } g = e.getMatrixSlice(a, h); g.update(d[h], c) } } }, createGetter: function () { var a = this; return function (b, c, d) { return a.getAssociatedStore(this, b, c, d, false) } }, onAddToMany: function (a, c, b) { if (!a.matrixUpdate) { a.matrixUpdate = 1; a.matrix.update(c, b === true ? 0 : 1); a.matrixUpdate = 0 } }, onRemoveFromMany: function (b, a) { if (!b.matrixUpdate) { b.matrixUpdate = 1; b.matrix.update(a, -1); b.matrixUpdate = 0 } }, read: function (a, d, b, e) { var c = this, g = c.callParent([a, d, b, e]); if (g) { a[c.getterName](null, null, g); delete a.data[c.role] } }, onMatrixUpdate: function (e, h, d) { var a = e.store, b, g, c; if (a && !a.loading && !a.matrixUpdate) { a.matrixUpdate = 1; b = a.indexOfId(h); if (d < 0) { if (b >= 0) { a.remove([b]) } } else { if (b < 0) { c = a.getSession().getEntry(this.type, h); g = c && c.record; if (g) { a.add(g) } } } a.matrixUpdate = 0 } }, adoptAssociated: function (b, g) { var d = this.getAssociatedItem(b), c, e, a; if (d) { d.setSession(g); this.onStoreCreate(d, g, b.getId()); c = d.getData().items; for (e = 0, a = c.length; e < a; ++e) { g.adopt(c[e]) } } } }, function () { var a = this; Ext.ClassManager.onCreated(function () { Ext.data.schema.ManyToMany.prototype.Right = Ext.define(null, { extend: a, left: false, side: "right" }) }, null, "Ext.data.schema.ManyToMany") }) }, 0, 0, 0, 0, 0, 0, [Ext.data.schema, "ManyToMany"], 0)); (Ext.cmd.derive("Ext.util.Inflector", Ext.Base, { singleton: true, plurals: [[(/(quiz)$/i), "$1zes"], [(/^(ox)$/i), "$1en"], [(/([m|l])ouse$/i), "$1ice"], [(/(matr|vert|ind)ix|ex$/i), "$1ices"], [(/(x|ch|ss|sh)$/i), "$1es"], [(/([^aeiouy]|qu)y$/i), "$1ies"], [(/(hive)$/i), "$1s"], [(/(?:([^f])fe|([lr])f)$/i), "$1$2ves"], [(/sis$/i), "ses"], [(/([ti])um$/i), "$1a"], [(/(buffal|tomat|potat)o$/i), "$1oes"], [(/(bu)s$/i), "$1ses"], [(/(alias|status|sex)$/i), "$1es"], [(/(octop|vir)us$/i), "$1i"], [(/(ax|test)is$/i), "$1es"], [(/^(p)erson$/i), "$1eople"], [(/^(m)an$/i), "$1en"], [(/(.*)(child)(ren)?$/i), "$1$2ren"], [(/s$/i), "s"], [(/$/), "s"]], singulars: [[(/(address)$/i), "$1"], [(/(quiz)zes$/i), "$1"], [(/(matr)ices$/i), "$1ix"], [(/(vert|ind)ices$/i), "$1ex"], [(/^(ox)en/i), "$1"], [(/(alias|status)es$/i), "$1"], [(/(octop|vir)i$/i), "$1us"], [(/(cris|ax|test)es$/i), "$1is"], [(/(shoe)s$/i), "$1"], [(/(o)es$/i), "$1"], [(/(bus)es$/i), "$1"], [(/([m|l])ice$/i), "$1ouse"], [(/(x|ch|ss|sh)es$/i), "$1"], [(/(m)ovies$/i), "$1ovie"], [(/(s)eries$/i), "$1eries"], [(/([^aeiouy]|qu)ies$/i), "$1y"], [(/([lr])ves$/i), "$1f"], [(/(tive)s$/i), "$1"], [(/(hive)s$/i), "$1"], [(/([^f])ves$/i), "$1fe"], [(/(^analy)ses$/i), "$1sis"], [(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i), "$1$2sis"], [(/([ti])a$/i), "$1um"], [(/(n)ews$/i), "$1ews"], [(/(p)eople$/i), "$1erson"], [(/s$/i), ""]], uncountable: ["sheep", "fish", "series", "species", "money", "rice", "information", "equipment", "grass", "mud", "offspring", "deer", "means"], singular: function (b, a) { this.singulars.unshift([b, a]) }, plural: function (b, a) { this.plurals.unshift([b, a]) }, clearSingulars: function () { this.singulars = [] }, clearPlurals: function () { this.plurals = [] }, isTransnumeral: function (a) { return Ext.Array.indexOf(this.uncountable, a) != -1 }, pluralize: function (g) { if (this.isTransnumeral(g)) { return g } var e = this.plurals, d = e.length, a, c, b; for (b = 0; b < d; b++) { a = e[b]; c = a[0]; if (c == g || (c.test && c.test(g))) { return g.replace(c, a[1]) } } return g }, singularize: function (g) { if (this.isTransnumeral(g)) { return g } var e = this.singulars, d = e.length, a, c, b; for (b = 0; b < d; b++) { a = e[b]; c = a[0]; if (c == g || (c.test && c.test(g))) { return g.replace(c, a[1]) } } return g }, classify: function (a) { return Ext.String.capitalize(this.singularize(a)) }, ordinalize: function (d) { var b = parseInt(d, 10), c = b % 10, a = b % 100; if (11 <= a && a <= 13) { return d + "th" } else { switch (c) { case 1: return d + "st"; case 2: return d + "nd"; case 3: return d + "rd"; default: return d + "th" } } } }, 0, 0, 0, 0, 0, 0, [Ext.util, "Inflector"], function () { var b = { alumnus: "alumni", cactus: "cacti", focus: "foci", nucleus: "nuclei", radius: "radii", stimulus: "stimuli", ellipsis: "ellipses", paralysis: "paralyses", oasis: "oases", appendix: "appendices", index: "indexes", beau: "beaux", bureau: "bureaux", tableau: "tableaux", woman: "women", child: "children", man: "men", corpus: "corpora", criterion: "criteria", curriculum: "curricula", genus: "genera", memorandum: "memoranda", phenomenon: "phenomena", foot: "feet", goose: "geese", tooth: "teeth", antenna: "antennae", formula: "formulae", nebula: "nebulae", vertebra: "vertebrae", vita: "vitae" }, a; for (a in b) { if (b.hasOwnProperty(a)) { this.plural(a, b[a]); this.singular(b[a], a) } } })); (Ext.cmd.derive("Ext.data.schema.Namer", Ext.Base, { isNamer: true, capitalize: function (a) { return Ext.String.capitalize(a) }, fieldRole: function (b) { var a = b.match(this.endsWithIdRe, ""); if (a) { b = b.substr(0, b.length - (a[1] || a[2]).length) } return this.apply("uncapitalize", b) }, idField: function (a) { return this.apply("uncapitalize,singularize", a) + "Id" }, instanceName: function (a) { return this.apply("underscore", a) }, multiRole: function (a) { return this.apply("undotted,uncapitalize,pluralize", a) }, pluralize: function (a) { return Ext.util.Inflector.pluralize(a) }, readerRoot: function (a) { return this.apply("uncapitalize", a) }, singularize: function (a) { return Ext.util.Inflector.singularize(a) }, storeName: function (a) { return this.apply("underscore", a) }, uncapitalize: function (a) { return Ext.String.uncapitalize(a) }, underscore: function (a) { return "_" + a }, uniRole: function (a) { return this.apply("undotted,uncapitalize,singularize", a) }, undotted: function (b) { if (b.indexOf(".") < 0) { return b } var c = b.split("."), a = c.length; while (a-- > 1) { c[a] = this.apply("capitalize", c[a]) } return c.join("") }, getterName: function (b) { var a = b.role; if (b && b.isMany) { return a } return "get" + this.apply("capitalize", a) }, inverseFieldRole: function (h, i, e, b) { var g = this, a = g.apply(i ? "uniRole" : "multiRole", h), d = g.apply("pluralize", e), c = g.apply("undotted,pluralize", b); if (d.toLowerCase() !== c.toLowerCase()) { a = e + g.apply("capitalize", a) } return a }, manyToMany: function (e, d, a) { var c = this, b = c.apply("undotted,capitalize,singularize", d) + c.apply("undotted,capitalize,pluralize", a); if (e) { b = c.apply("capitalize", e + b) } return b }, manyToOne: function (d, b, a, c) { return this.apply("capitalize,singularize", a) + this.apply("capitalize", b) }, matrixRole: function (c, b) { var a = this.apply(c ? "multiRole,capitalize" : "multiRole", b); return c ? c + a : a }, oneToOne: function (d, b, a, c) { return this.apply("undotted,capitalize,singularize", a) + this.apply("capitalize", b) }, setterName: function (a) { return "set" + this.apply("capitalize", a.role) }, endsWithIdRe: /(?:(_id)|[^A-Z](Id))$/, cache: {}, apply: function (e, c) { var j = this, b = j.cache, k = b[c] || (b[c] = {}), h = k[e], g, d, a; if (!h) { if (e.indexOf(",") < 0) { h = j[e](c) } else { d = (a = e.split(",")).length; h = c; for (g = 0; g < d; ++g) { h = j.apply(a[g], h) } } k[e] = h } return h } }, 0, 0, 0, 0, ["namer.default"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.schema, "Namer"], 0)); (Ext.cmd.derive("Ext.data.schema.Schema", Ext.Base, { aliasPrefix: "schema.", isSchema: true, type: "default", statics: { instances: {}, get: function (d) { var g = this, c = g.instances, h = "default", b = d && Ext.isString(d), a, e; if (d) { if (d.isSchema) { return d } h = b ? d : (d.id || h) } if (!(a = c[h])) { c[h] = a = g.create(d); a.id = h } else { if (d && !b) { e = Ext.merge({}, a.config); Ext.merge(e, d); a.setConfig(e); a.config = e } } return a }, lookupEntity: function (a) { var d = null, g = this.instances, c, b, e; if (a) { if (a.isEntity) { d = a.self } else { if (Ext.isFunction(a)) { d = a } else { if (Ext.isString(a)) { d = Ext.ClassManager.get(a); if (d && (!d.prototype || !d.prototype.isEntity)) { d = null } if (!d) { for (b in g) { e = g[b]; c = e.getEntity(a); if (c) { if (d) { Ext.raise('Ambiguous entity name "' + a + '". Defined by schema "' + d.schema.type + '" and "' + b + '"') } d = c } } } if (!d) { Ext.raise('No such Entity "' + a + '".') } } } } } return d } }, assocCount: 0, entityCount: 0, config: { defaultIdentifier: null, keyCheckDelay: 10, namer: "default", namespace: null, proxy: { type: "ajax", url: "{prefix}/{entityName}" }, urlPrefix: "" }, onClassExtended: function (a, c) { var b = c.alias; if (b && !c.type) { if (!Ext.isString(b)) { b = b[0] } a.prototype.type = b.substring(this.prototype.aliasPrefix.length) } }, constructor: function (a) { this.initConfig(a); this.clear() }, applyDefaultIdentifier: function (a) { return a && Ext.Factory.dataIdentifier(a) }, applyNamer: function (b) { var a = Ext.data.schema.Namer.create(b); a.schema = this; return a }, applyNamespace: function (b) { if (b) { var a = b.length - 1; if (b.charAt(a) !== ".") { b += "." } } return b }, applyProxy: function (a) { return Ext.util.ObjectTemplate.create(a) }, eachAssociation: function (d, c) { var b = this.associations, a; for (a in b) { if (b.hasOwnProperty(a)) { if (d.call(c, a, b[a]) === false) { break } } } }, eachEntity: function (c, b) { var d = this.entities, a; for (a in d) { if (d.hasOwnProperty(a)) { if (c.call(b, a, d[a].cls) === false) { break } } } }, getAssociation: function (a) { var b = this.associations[a]; return b || null }, getEntity: function (a) { var b = this.entityClasses[a] || this.entities[a]; return (b && b.cls) || null }, getEntityName: function (a) { var d = this.getNamespace(), c, b; if (typeof a === "string") { b = a } else { b = a.$className || null } if (b) { if (d) { c = d.length; if (b.substring(0, c) !== d) { return b } } if (c) { b = b.substring(c) } } return b }, hasAssociations: function (a) { a = a.entityName || a; return !!this.associationEntityMap[a] }, hasEntity: function (a) { var b = this.getEntityName(a); return !!(this.entities[b] || this.entityClasses[b]) }, addMatrix: function (n, h, d, c, r) { var s = this, l = s.getNamer(), p = s.associations, a = s.entities, g = c.type, q = r.type, e = c.field || l.apply("idField", g), j = r.field || l.apply("idField", q), b = c.role || l.matrixRole(d, g), m = r.role || l.matrixRole(d, q), o, i, k; i = a[g] || (a[g] = { cls: null, name: g, associations: {} }); k = a[q] || (a[q] = { cls: null, name: q, associations: {} }); ++s.assocCount; p[h] = o = new Ext.data.schema.ManyToMany({ name: h, schema: s, definedBy: n, left: { cls: i.cls, type: g, role: b, field: e, associationKey: c.associationKey }, right: { cls: k.cls, type: q, role: m, field: j, associationKey: r.associationKey } }); i.associations[o.right.role] = o.right; k.associations[o.left.role] = o.left; if (i.cls) { s.associationEntityMap[i.cls.entityName] = true } if (k.cls) { s.associationEntityMap[k.cls.entityName] = true } s.decorateModel(o) }, addReference: function (q, a, p, b, r) { var u = this, n = u.getNamer(), d = u.entities, s = u.associations, m = q.entityName, e = p.association, j = p.child, l = p.parent, o = p.role, t = p.type || l || j, k = p.inverse, i = Ext.isString(k) ? { role: k } : k, h = i && i.role, c, g; if (!o) { if (!a || p.legacy) { o = n.apply("uncapitalize", t) } else { o = n.apply("fieldRole", a.name) } } if (!h) { h = n.inverseFieldRole(m, b, o, t) } if (!e) { if (b) { e = n.oneToOne(q, h, t, o) } else { e = n.manyToOne(q, h, t, o) } } if (r && e in s) { if (r(s[e], e, h, o) !== false) { return } } c = d[t] || (d[t] = { cls: null, name: t, associations: {} }); g = b ? Ext.data.schema.OneToOne : Ext.data.schema.ManyToOne; e = new g({ name: e, owner: j ? "left" : (l ? "right" : null), definedBy: q, schema: u, field: a, nullable: a ? !!a.allowBlank : true, left: { cls: q, type: m, role: h, extra: i }, right: { cls: c.cls, type: t, role: o, extra: p }, meta: p }); q.associations[o] = e.right; c.associations[h] = e.left; if (a) { a.reference = e.right; q.references.push(a) } ++u.assocCount; u.associationEntityMap[m] = true; if (c.cls) { u.associationEntityMap[c.cls.entityName] = true } s[e.name] = e; if (e.right.cls) { u.decorateModel(e) } }, privates: { addEntity: function (d) { var j = this, h = j.entities, l = d.entityName, m = h[l], g = d.fields, c, k, e, b, a; if (!m) { h[l] = m = { name: l, associations: {} } } else { c = m.associations; for (a in c) { c[a].inverse.cls = d; j.associationEntityMap[l] = true; j.decorateModel(c[a].association) } } m.cls = d; d.prototype.associations = d.associations = m.associations; j.entityClasses[d.$className] = m; ++j.entityCount; for (e = 0, b = g.length; e < b; ++e) { k = g[e]; if (k.reference) { j.addReferenceDescr(d, k) } } }, addMatrices: function (g, a) { var e = this, b, d, c; if (Ext.isString(a)) { e.addMatrixDescr(g, null, a) } else { if (a[0]) { for (b = 0, d = a.length; b < d; ++b) { e.addMatrixDescr(g, null, a[b]) } } else { for (c in a) { e.addMatrixDescr(g, c, a[c]) } } } }, addMatrixDescr: function (e, a, g) { var h = this, j = e.entityName, d = h.associations, i = h.getNamer(), c = g.left, l = g.right, k, b; if (Ext.isString(g)) { if (g.charAt(0) === "#") { c = { type: j }; l = { type: g.substring(1) } } else { if (g.charAt(k = g.length - 1) === "#") { c = { type: g.substring(0, k) }; l = { type: j } } else { if (i.apply("multiRole", j) < i.apply("multiRole", g)) { c = { type: j }; l = { type: g } } else { c = { type: g }; l = { type: j } } } } } else { b = g.relation; if (c || (!l && i.apply("multiRole", j) < i.apply("multiRole", g.type))) { if (!c || c === true) { c = { type: j } } else { c = Ext.apply({ type: j }, c) } l = g } else { if (!l || l === true) { l = { type: j } } else { l = Ext.apply({ type: j }, l) } c = g } } if (!a) { a = i.manyToMany(b, c.type, l.type) } if (!(a in d)) { h.addMatrix(e, a, b, c, l) } }, addReferenceDescr: function (b, d) { var a = this, c = d.$reference; if (Ext.isString(c)) { c = { type: c } } else { c = Ext.apply({}, c) } a.addReference(b, d, c, d.unique) }, addBelongsTo: function (a, b) { this.addKeylessSingle(a, b, false) }, addHasOne: function (a, b) { this.addKeylessSingle(a, b, true) }, addKeylessSingle: function (b, e, d) { var a, c; e = Ext.apply({}, this.checkLegacyAssociation(b, e)); e.type = this.getEntityName(e.child || e.parent || e.type); a = e.foreignKey || (e.type.toLowerCase() + "_id"); c = b.getField(a); e.fromSingle = true; if (c) { c.$reference = e; c.unique = true; e.legacy = true } this.addReference(b, c, e, d) }, addHasMany: function (e, k) { var l = this, h = l.entities, b = l.pending, n, a, m, j, i, g, c, d; k = Ext.apply({}, this.checkLegacyAssociation(e, k)); k.type = this.getEntityName(k.child || k.parent || k.type); a = k.type; j = h[a]; n = j && j.cls; if (n) { a = e.entityName; i = k.foreignKey || (a.toLowerCase() + "_id"); delete k.foreignKey; d = Ext.apply({}, k.inverse); delete k.inverse; g = Ext.apply({}, k); delete g.type; k = Ext.apply({ type: a, inverse: g }, d); c = g.child; if (c) { delete g.child; k.parent = a } m = n.getField(i); if (m) { m.$reference = k; k.legacy = true } l.addReference(n, m, k, false) } else { if (!b[a]) { b[a] = [] } b[a].push([e, k]) } }, checkLegacyAssociation: function (b, c) { if (Ext.isString(c)) { c = { type: c } } else { c = Ext.apply({}, c) } if (c.model) { c.type = c.model; delete c.model } var a = c.associatedName || c.name; if (a) { delete c.associatedName; delete c.name; c.role = a } return c }, afterKeylessAssociations: function (b) { var g = this.pending, c = b.entityName, e = g[c], d, a; if (e) { for (d = 0, a = e.length; d < a; ++d) { this.addHasMany.apply(this, e[d]) } delete g[c] } }, clear: function (b) { var a = this, c = a.timer; delete a.setConfig; if (c) { window.clearTimeout(c); a.timer = null } a.associations = {}; a.associationEntityMap = {}; a.entities = {}; a.entityClasses = {}; a.pending = {}; a.assocCount = a.entityCount = 0; if (b) { a.setNamespace(null) } }, constructProxy: function (d) { var b = this, c = Ext.Object.chain(d), a = b.getProxy(); c.schema = b; c.prefix = b.getUrlPrefix(); return a.apply(c) }, applyDecoration: function (h) { var e = this, a = h.inverse.cls, g = e.getNamer(), c, b, d; if (a && !h.decorated) { h.decorated = true; d = a.prototype; if (!(c = h.getterName)) { h.getterName = c = g.getterName(h) } d[c] = h.createGetter(); if (h.createSetter) { if (!(b = h.setterName)) { h.setterName = b = g.setterName(h) } d[b] = h.createSetter() } } }, decorateModel: function (a) { this.applyDecoration(a.left); this.applyDecoration(a.right) }, processKeyChecks: function (d) { var g = this, b = g.keyCheckQueue, h = g.timer, a, c, e; if (h) { window.clearTimeout(h); g.timer = null } if (!b) { return } do { b = g.keyCheckQueue; g.keyCheckQueue = []; for (c = 0, a = b.length; c < a; ++c) { e = b[c]; e.role.checkKeyForDrop(e.record) } } while (d && g.keyCheckQueue.length) }, queueKeyCheck: function (a, e) { var c = this, b = c.keyCheckQueue, d = c.timer; if (!b) { c.keyCheckQueue = b = [] } b.push({ record: a, role: e }); if (!d) { c.timer = d = Ext.Function.defer(c.processKeyChecks, c.getKeyCheckDelay(), c) } }, rankEntities: function () { var e = this, g = e.entities, a = Ext.Object.getKeys(g), d = a.length, c, b; e.nextRank = 1; a.sort(); for (b = 0; b < d; ++b) { c = g[a[b]].cls; if (!c.rank) { e.rankEntity(c) } } }, rankEntity: function (c) { var b = c.associations, e, d, a; for (a in b) { d = b[a]; if (!d.left && d.association.field) { e = d.cls; if (!e.rank) { this.rankEntity(e) } } } c.rank = this.nextRank++ } } }, 1, 0, 0, 0, ["schema.default"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.schema, "Schema"], 0)); (Ext.cmd.derive("Ext.data.AbstractStore", Ext.Base, { factoryConfig: { defaultType: "store", type: "store" }, $configPrefixed: false, $configStrict: false, config: { filters: null, autoDestroy: undefined, storeId: null, statefulFilters: false, sorters: null, remoteSort: { lazy: true, $value: false }, remoteFilter: { lazy: true, $value: false }, groupField: undefined, groupDir: "ASC", grouper: null, pageSize: 25, autoSort: null }, currentPage: 1, loading: false, isStore: true, updating: 0, constructor: function (b) { var c = this, a; c.isInitializing = true; c.mixins.observable.constructor.call(c, b); c.isInitializing = false; a = c.getStoreId(); if (!a && (b && b.id)) { c.setStoreId(a = b.id) } if (a) { Ext.data.StoreManager.register(c) } }, getCount: function () { var a = this.getData(); return a ? a.getCount() : 0 }, rangeCached: function (b, a) { return this.getData().getCount() >= Math.max(b, a) }, find: function (g, e, h, i, a, d) { var c = !i, b = !!(c && d); return this.getData().findIndex(g, e, h, c, b, !a) }, findRecord: function () { var b = this, a = b.find.apply(b, arguments); return a !== -1 ? b.getAt(a) : null }, findExact: function (c, a, b) { return this.getData().findIndexBy(function (d) { return d.isEqual(d.get(c), a) }, this, b) }, findBy: function (b, a, c) { return this.getData().findIndexBy(b, a, c) }, getAt: function (a) { return this.getData().getAt(a) || null }, getRange: function (d, b, c) { var a = this.getData().getRange(d, Ext.isNumber(b) ? b + 1 : b); if (c && c.callback) { c.callback.call(c.scope || this, a, d, b, c) } return a }, getFilters: function (b) { var a = (arguments.callee.$previous || Ext.Base.prototype.getFilters).call(this); if (!a && b !== false) { this.setFilters([]); a = (arguments.callee.$previous || Ext.Base.prototype.getFilters).call(this) } return a }, applyFilters: function (b, a) { var c; if (!a) { a = this.createFiltersCollection(); c = true } a.add(b); if (c) { this.onRemoteFilterSet(a, this.getRemoteFilter()) } return a }, getSorters: function (b) { var a = (arguments.callee.$previous || Ext.Base.prototype.getSorters).call(this); if (!a && b !== false) { this.setSorters([]); a = (arguments.callee.$previous || Ext.Base.prototype.getSorters).call(this) } return a }, applySorters: function (b, a) { var c; if (!a) { a = this.createSortersCollection(); c = true } a.add(b); if (c) { this.onRemoteSortSet(a, this.getRemoteSort()) } return a }, filter: function (b, c, a) { if (Ext.isString(b)) { b = { property: b, value: c } } this.suppressNextFilter = !!a; this.getFilters().add(b); this.suppressNextFilter = false }, removeFilter: function (b, a) { var d = this, c = d.getFilters(); d.suppressNextFilter = !!a; if (b instanceof Ext.util.Filter) { c.remove(b) } else { c.removeByKey(b) } d.suppressNextFilter = false }, updateAutoSort: function (a) { this.getData().setAutoSort(a) }, updateRemoteSort: function (a) { this.onRemoteSortSet(this.getSorters(false), a) }, updateRemoteFilter: function (a) { this.onRemoteFilterSet(this.getFilters(false), a) }, addFilter: function (b, a) { this.suppressNextFilter = !!a; this.getFilters().add(b); this.suppressNextFilter = false }, filterBy: function (b, a) { this.getFilters().add({ filterFn: b, scope: a || this }) }, clearFilter: function (a) { var c = this, b = c.getFilters(false); if (!b || b.getCount() === 0) { return } c.suppressNextFilter = !!a; b.removeAll(); c.suppressNextFilter = false }, isFiltered: function () { return this.getFilters().getCount() > 0 }, isSorted: function () { var a = this.getSorters(false); return !!(a && a.length > 0) || this.isGrouped() }, addFieldTransform: function (e) { if (e.getTransform()) { return } var d = e.getProperty(), c = this.getModel(), a, b; if (c) { a = c.getField(d); b = a ? a.getSortType() : null } if (b && b !== Ext.identityFn) { e.setTransform(b) } }, beginUpdate: function () { if (!this.updating++) { this.fireEvent("beginupdate") } }, endUpdate: function () { if (this.updating && !--this.updating) { this.fireEvent("endupdate"); this.onEndUpdate() } }, getState: function () { var e = this, g = [], d = e.getFilters(), b = e.getGrouper(), h, c, a; e.getSorters().each(function (i) { g[g.length] = i.getState(); c = true }); if (e.statefulFilters && e.saveStatefulFilters) { c = true; h = []; d.each(function (i) { h[h.length] = i.getState() }) } if (b) { c = true } if (c) { a = {}; if (g.length) { a.sorters = g } if (h) { a.filters = h } if (b) { a.grouper = b.getState() } } return a }, applyState: function (e) { var c = this, b = e.sorters, a = e.filters, d = e.grouper; if (b) { c.getSorters().replaceAll(b) } if (a) { c.saveStatefulFilters = true; c.getFilters().replaceAll(a) } if (d) { c.setGrouper(d) } }, hasPendingLoad: Ext.emptyFn, isLoaded: Ext.emptyFn, isLoading: Ext.emptyFn, destroy: function () { var a = this; if (a.hasListeners.beforedestroy) { a.fireEvent("beforedestroy", a) } a.destroying = true; if (a.getStoreId()) { Ext.data.StoreManager.unregister(a) } a.doDestroy(); if (a.hasListeners.destroy) { a.fireEvent("destroy", a) } a.destroying = false; a.callParent() }, doDestroy: Ext.emptyFn, sort: function (c, b, d) { var a = this; if (arguments.length === 0) { if (a.getRemoteSort()) { a.load() } else { a.forceLocalSort() } } else { a.getSorters().addSort(c, b, d) } }, onBeforeCollectionSort: function (a, b) { if (b) { this.fireEvent("beforesort", this, b.getRange()) } }, onSorterEndUpdate: function () { var a = this, b; b = a.getSorters(false); if (a.settingGroups || !b) { return } b = b.getRange(); if (b.length) { if (a.getRemoteSort()) { a.load({ callback: function () { a.fireEvent("sort", a, b) } }) } else { a.fireEvent("datachanged", a); a.fireEvent("refresh", a); a.fireEvent("sort", a, b) } } else { a.fireEvent("sort", a, b) } }, onFilterEndUpdate: function () { var c = this, b = c.suppressNextFilter, a = c.getFilters(false); if (!a) { return } if (c.getRemoteFilter()) { c.currentPage = 1; if (!b) { c.load() } } else { if (!b) { c.fireEvent("datachanged", c); c.fireEvent("refresh", c) } } if (c.trackStateChanges) { c.saveStatefulFilters = true } c.fireEvent("filterchange", c, c.getFilters().getRange()) }, updateGroupField: function (a) { if (a) { this.setGrouper({ property: a, direction: this.getGroupDir() }) } else { this.setGrouper(null) } }, getGrouper: function () { return this.getData().getGrouper() }, group: function (a, d) { var b = this, c = b.getSorters(false), e = a || (c && c.length); if (a && typeof a === "string") { a = { property: a, direction: d || b.getGroupDir() } } b.settingGroups = true; b.getData().setGrouper(a); delete b.settingGroups; if (e) { if (b.getRemoteSort()) { b.load({ scope: b, callback: b.fireGroupChange }) } else { b.fireEvent("datachanged", b); b.fireEvent("refresh", b); b.fireGroupChange() } } else { b.fireGroupChange() } }, fireGroupChange: function () { if (!this.destroyed) { this.fireEvent("groupchange", this, this.getGrouper()) } }, clearGrouping: function () { this.group(null) }, getGroupField: function () { var a = this.getGrouper(), b = ""; if (a) { b = a.getProperty() } return b }, isGrouped: function () { return !!this.getGrouper() }, applyGrouper: function (a) { this.group(a); return this.getData().getGrouper() }, getGroups: function () { return this.getData().getGroups() }, onEndUpdate: Ext.emptyFn, privates: { loadsSynchronously: Ext.privateFn, onRemoteFilterSet: function (a, b) { if (a) { a[b ? "on" : "un"]("endupdate", this.onFilterEndUpdate, this) } }, onRemoteSortSet: function (b, c) { var a = this; if (b) { b[c ? "on" : "un"]("endupdate", a.onSorterEndUpdate, a); a.getData()[c ? "un" : "on"]("beforesort", a.onBeforeCollectionSort, a) } } }, deprecated: { 5: { methods: { destroyStore: function () { this.destroy() } } } } }, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable], [Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data, "AbstractStore"], 0)); (Ext.cmd.derive("Ext.data.Error", Ext.Base, { isError: true, $configPrefixed: false, config: { field: null, message: "" }, constructor: function (a) { this.initConfig(a); this.msg = this.message } }, 1, 0, 0, 0, 0, 0, [Ext.data, "Error"], 0)); (Ext.cmd.derive("Ext.data.ErrorCollection", Ext.util.MixedCollection, { alternateClassName: "Ext.data.Errors", init: function (g) { var k = this, h = g.fields, d = g.data, m, l, n, e, j, c, b, a; for (e = 0, j = h.length; e < j; ++e) { l = h[e]; a = l.name; b = d[a]; if (l.validate && !l.validate.$nullFn) { m = k.length; c = l.validate(b, null, k, g); if (m === k.length && c !== true) { k.add(a, c) } } } return k }, add: function (b, d) { var c = this, a = Ext.data.field.Field.defaultInvalidMessage, g = b, e; if (Ext.isString(b)) { g = new Ext.data.Error({ field: b, message: d || a }) } else { if (!(g.isError)) { g = new Ext.data.Error({ field: g.field || g.name, message: g.error || g.message || g.msg || a }) } b = g.field } e = c.get(b); if (e) { if (Ext.isArray(e)) { e.push(g); return e } c.removeAtKey(b); g = [e, g]; g.field = b; g = [g] } return Ext.util.MixedCollection.prototype.add.call(this, g) }, getKey: function (a) { return a.field }, isValid: function () { return this.length === 0 }, getByField: function (b) { var a = this.get(b); if (a && !Ext.isArray(a)) { a = [a] } return a || [] } }, 0, 0, 0, 0, 0, 0, [Ext.data, "ErrorCollection", Ext.data, "Errors"], 0)); (Ext.cmd.derive("Ext.data.operation.Operation", Ext.Base, { alternateClassName: "Ext.data.Operation", isOperation: true, config: { synchronous: false, url: "", params: undefined, callback: undefined, scope: undefined, resultSet: null, response: null, request: null, records: null, id: undefined, proxy: null, batch: null, recordCreator: null, internalCallback: null, internalScope: null }, order: 0, foreignKeyDirection: 1, started: false, running: false, complete: false, success: undefined, exception: false, error: undefined, idPrefix: "ext-operation-", constructor: function (a) { var b = a && a.scope; this.initConfig(a); if (a) { a.scope = b } if (b) { this.setScope(b); this.initialConfig.scope = b } this._internalId = Ext.id(this, this.idPrefix) }, getAction: function () { return this.action }, execute: function () { var b = this, a; delete b.error; delete b.success; b.complete = b.exception = false; b.setStarted(); b.request = a = b.doExecute(); if (a) { a.setOperation(b) } return a }, doExecute: Ext.emptyFn, abort: function () { var b = this, a = b.request; if (b.running && a) { b.getProxy().abort(a); b.request = null } }, process: function (b, d, a, e) { var c = this; e = e !== false; c.setResponse(a); c.setResultSet(b); if (b.getSuccess()) { c.doProcess(b, d, a); c.setSuccessful(e) } else { if (e) { c.setException(b.getMessage()) } } }, _commitSetOptions: { convert: true, commit: true }, doProcess: function (n, g, e) { var l = this, d = l._commitSetOptions, a = l.getRecords(), c = a.length, o = a[0].clientIdProperty, p = n.getRecords(), k = p ? p.length : 0, m, j, b, h; if (k && o) { m = Ext.Array.toValueMap(a, "id"); for (h = 0; h < k; ++h) { j = p[h]; b = m[j[o]]; if (b) { delete m[b.id]; delete j[o]; b.set(j, d) } } for (h in m) { m[h].commit() } } else { for (h = 0; h < c; ++h) { b = a[h]; if (k === 0 || !(j = p[h])) { b.commit() } else { b.set(j, d) } } } }, setStarted: function () { this.started = this.running = true }, setCompleted: function () { var b = this, a = b.getProxy(); b.complete = true; b.running = false; b.triggerCallbacks(); if (a) { a.completeOperation(b) } }, setSuccessful: function (a) { this.success = true; if (a) { this.setCompleted() } }, setException: function (a) { var b = this; b.exception = true; b.success = b.running = false; b.error = a; b.setCompleted() }, triggerCallbacks: function () { var a = this, b = a.getInternalCallback(); if (b) { b.call(a.getInternalScope() || a, a); a.setInternalCallback(null); a.setInternalScope(null) } if (b = a.getCallback()) { b.call(a.getScope() || a, a.getRecords(), a, a.wasSuccessful()); a.setCallback(null); a.setScope(null) } }, hasException: function () { return this.exception }, getError: function () { return this.error }, getRecords: function () { var a; return this._records || ((a = this.getResultSet()) ? a.getRecords() : null) }, isStarted: function () { return this.started }, isRunning: function () { return this.running }, isComplete: function () { return this.complete }, wasSuccessful: function () { return this.isComplete() && this.success === true }, allowWrite: function () { return true } }, 1, 0, 0, 0, 0, 0, [Ext.data.operation, "Operation", Ext.data, "Operation"], 0)); (Ext.cmd.derive("Ext.data.operation.Create", Ext.data.operation.Operation, { action: "create", isCreateOperation: true, order: 10, config: { recordCreator: Ext.identityFn }, doExecute: function () { return this.getProxy().create(this) } }, 0, 0, 0, 0, ["data.operation.create"], 0, [Ext.data.operation, "Create"], 0)); (Ext.cmd.derive("Ext.data.operation.Destroy", Ext.data.operation.Operation, { action: "destroy", isDestroyOperation: true, order: 30, foreignKeyDirection: -1, doProcess: function () { var c = this.getRecords(), a = c.length, b; for (b = 0; b < a; ++b) { c[b].setErased() } }, doExecute: function () { return this.getProxy().erase(this) }, getRecordData: function (a, c) { var e = {}, d = a.idField, b = this.getNameProperty() || "name"; e[d[b]] = a.id; return e } }, 0, 0, 0, 0, ["data.operation.destroy"], 0, [Ext.data.operation, "Destroy"], 0)); (Ext.cmd.derive("Ext.data.operation.Read", Ext.data.operation.Operation, { action: "read", isReadOperation: true, config: { filters: undefined, sorters: undefined, grouper: undefined, start: undefined, limit: undefined, page: undefined, addRecords: false }, doExecute: function () { return this.getProxy().read(this) }, doProcess: Ext.emptyFn, allowWrite: function () { return false } }, 0, 0, 0, 0, ["data.operation.read"], 0, [Ext.data.operation, "Read"], 0)); (Ext.cmd.derive("Ext.data.operation.Update", Ext.data.operation.Operation, { action: "update", isUpdateOperation: true, order: 20, config: { recordCreator: Ext.identityFn }, doExecute: function () { return this.getProxy().update(this) } }, 0, 0, 0, 0, ["data.operation.update"], 0, [Ext.data.operation, "Update"], 0)); (Ext.cmd.derive("Ext.data.SortTypes", Ext.Base, { singleton: true, none: Ext.identityFn, stripCommasRe: /,/g, stripTagsRE: /<\/?[^>]+>/gi, asText: function (a) { return (a != null) ? String(a).replace(this.stripTagsRe, "") : "\x00" }, asUCText: function (a) { return (a != null) ? String(a).toUpperCase().replace(this.stripTagsRe, "") : "\x00" }, asUCString: function (a) { return (a != null) ? String(a).toUpperCase() : "\x00" }, asDate: function (a) { if (!a) { return 0 } if (Ext.isDate(a)) { return a.getTime() } return Date.parse(String(a)) }, asFloat: function (a) { var b = parseFloat(String(a).replace(this.stripCommasRe, "")); return isNaN(b) ? 0 : b }, asInt: function (a) { var b = parseInt(String(a).replace(this.stripCommasRe, ""), 10); return isNaN(b) ? 0 : b } }, 0, 0, 0, 0, 0, 0, [Ext.data, "SortTypes"], 0)); (Ext.cmd.derive("Ext.data.validator.Validator", Ext.Base, { isValidator: true, type: "base", statics: { all: {}, register: function (b, a) { var c = this.all; c[b.toUpperCase()] = c[b.toLowerCase()] = c[b] = a.prototype } }, onClassExtended: function (a, b) { if (b.type) { Ext.data.validator.Validator.register(b.type, a) } }, constructor: function (a) { if (typeof a === "function") { this.fnOnly = true; this.validate = a } else { this.initConfig(a) } }, validate: function () { return true }, clone: function () { var a = this; if (a.fnOnly) { return new Ext.data.validator.Validator(a.validate) } return new a.self(a.getCurrentConfig()) } }, 1, 0, 0, 0, ["data.validator.base"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.validator, "Validator"], function () { this.register(this.prototype.type, this) })); (Ext.cmd.derive("Ext.data.field.Field", Ext.Base, { alternateClassName: "Ext.data.Field", aliasPrefix: "data.field.", type: "auto", factoryConfig: { defaultProperty: "name" }, isDataField: true, isField: true, allowBlank: true, allowNull: false, critical: false, defaultInvalidMessage: "This field is invalid", defaultValue: undefined, definedBy: null, depends: null, dependents: null, mapping: null, name: null, ordinal: undefined, persist: null, reference: null, unique: false, rank: null, stripRe: /[\$,%]/g, calculated: false, evil: false, identifier: false, onClassExtended: function (c, e) { var g = e.sortType, d = c.prototype, a = d.validators, b = e.validators; if (g && Ext.isString(g)) { d.sortType = Ext.data.SortTypes[g] } if (b) { if (!Ext.isArray(b)) { b = [b] } delete e.validators; if (a) { b = a.concat(b) } d.validators = b } }, argumentNamesRe: /^function\s*\(\s*([^,\)\s]+)/, calculateRe: /[^\.a-z0-9_]([a-z_][a-z_0-9]*)\.([a-z_][a-z_0-9]*)/gi, constructor: function (d) { var l = this, n = l.calculateRe, h, o, m, i, c, a, j, b, k, e, g; if (d) { if (Ext.isString(d)) { l.name = d } else { g = d.validators; if (g) { delete d.validators; l.instanceValidators = g } Ext.apply(l, d) } } if (!l.allowNull) { l.allowNull = !!l.reference } h = l.calculate; c = l.depends; if (h) { l.convert = l.doCalculate; if (!c) { if (!(c = h.$depends)) { a = {}; k = h.toString(); h.$depends = c = []; j = l.argumentNamesRe.exec(k); b = j ? j[1] : "data"; while ((j = n.exec(k))) { if (b === j[1] && !a[e = j[2]]) { a[e] = 1; c.push(e) } } } l.depends = c } } m = l.defaultValue; if (l.convert) { l.calculated = o = l.convert.length > 1; l.evil = o && !c } if (l.persist === null) { l.persist = !h } i = l.sortType; if (!l.sortType) { l.sortType = Ext.data.SortTypes.none } else { if (Ext.isString(i)) { l.sortType = Ext.data.SortTypes[i] } } if (c && typeof c === "string") { l.depends = [c] } l.cloneDefaultValue = m !== undefined && (Ext.isDate(m) || Ext.isArray(m) || Ext.isObject(m)) }, setModelValidators: function (a) { this._validators = null; this.modelValidators = a }, compileValidators: function () { var a = this; a._validators = []; a.constructValidators(a.validators); a.constructValidators(a.modelValidators); a.constructValidators(a.instanceValidators) }, constructValidators: function (a) { if (a) { if (!(a instanceof Array)) { a = [a] } var e = a.length, c = this._validators, b, d; for (b = 0; b < e; ++b) { d = a[b]; if (d.fn) { d = d.fn } c.push(Ext.Factory.dataValidator(d)) } } }, collate: function (c, b) { var d = this, a = c, e = b; if (d.sortType) { a = d.sortType(a); e = d.sortType(e) } return (a === e) ? 0 : ((a < e) ? -1 : 1) }, compare: function (b, a) { return (b === a) ? 0 : ((b < a) ? -1 : 1) }, isEqual: function (b, a) { return this.compare(b, a) === 0 }, convert: null, serialize: null, validate: function (l, e, k, g) { var j = this, h = "", m, a, c, b, d; if (!j._validators) { j.compileValidators() } c = j._validators; for (d = 0, b = c.length; d < b; ++d) { a = c[d]; m = a.validate(l, g); if (m !== true) { m = m || j.defaultInvalidMessage; if (k) { k.add(j.name, m); h = h || m } else { if (e) { if (h) { h += e } h += m } else { h = m; break } } } } return h || true }, doCalculate: function (a, b) { return b ? this.calculate(b.data) : a }, getName: function () { return this.name }, getAllowBlank: function () { return this.allowBlank }, getAllowNull: function () { return this.allowNull }, getConvert: function () { return this.convert }, getDefaultValue: function () { return this.defaultValue }, getDepends: function () { return this.depends }, getMapping: function () { return this.mapping }, hasMapping: function () { var a = this.mapping; return !!(a || a === 0) }, getPersist: function () { return this.persist }, getSortType: function () { return this.sortType }, getType: function () { return "auto" }, deprecated: { 5.1: { methods: { getSortDir: function () { return this.sortDir } } } } }, 1, 0, 0, 0, ["data.field.auto"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.field, "Field", Ext.data, "Field"], 0)); (Ext.cmd.derive("Ext.data.field.Boolean", Ext.data.field.Field, { isBooleanField: true, trueRe: /^\s*(?:true|yes|on|1)\s*$/i, convert: function (a) { if (typeof a === "boolean") { return a } if (this.allowNull && (a === undefined || a === null || a === "")) { return null } return this.trueRe.test(String(a)) }, getType: function () { return "bool" } }, 0, 0, 0, 0, ["data.field.bool", "data.field.boolean"], 0, [Ext.data.field, "Boolean"], 0)); (Ext.cmd.derive("Ext.data.field.Date", Ext.data.field.Field, { sortType: "asDate", isDateField: true, dateFormat: null, dateReadFormat: null, dateWriteFormat: null, compare: function (b, e) { var d = b instanceof Date, c = e instanceof Date, a; if (c && d) { a = b.getTime() - e.getTime(); if (a === 0) { a = 0 } else { a = a < 0 ? -1 : 1 } } else { if (d === c) { a = 0 } else { a = d ? 1 : -1 } } return a }, convert: function (c) { if (!c) { return null } if (c instanceof Date) { return c } var a = this.dateReadFormat || this.dateFormat, b; if (a) { return Ext.Date.parse(c, a, this.useStrict) } b = Date.parse(c); return b ? new Date(b) : null }, serialize: function (b) { var a = null, c; if (Ext.isDate(b)) { c = this.getDateWriteFormat(); a = c ? Ext.Date.format(b, c) : b } return a }, getDateFormat: function () { return this.dateFormat }, getDateReadFormat: function () { return this.dateReadFormat }, getDateWriteFormat: function () { var a = this; if (a.hasOwnProperty("dateWriteFormat")) { return a.dateWriteFormat } if (a.hasOwnProperty("dateFormat")) { return a.dateFormat } return a.dateWriteFormat || a.dateFormat || "timestamp" }, getType: function () { return "date" } }, 0, 0, 0, 0, ["data.field.date"], 0, [Ext.data.field, "Date"], 0)); (Ext.cmd.derive("Ext.data.field.Integer", Ext.data.field.Field, { isNumeric: true, isIntegerField: true, numericType: "int", convert: function (b) { if (typeof b === "number") { return this.getNumber(b) } var d = b === undefined || b === null || b === "", a = this.allowNull, c; if (d) { c = a ? null : 0 } else { c = this.parse(b); if (a && isNaN(c)) { c = null } } return c }, getNumber: function (a) { return parseInt(a, 10) }, getType: function () { return this.numericType }, parse: function (a) { return parseInt(String(a).replace(this.stripRe, ""), 10) }, sortType: function (a) { if (a == null) { a = Infinity } return a } }, 0, 0, 0, 0, ["data.field.int", "data.field.integer"], 0, [Ext.data.field, "Integer"], 0)); (Ext.cmd.derive("Ext.data.field.Number", Ext.data.field.Integer, { isIntegerField: false, isNumberField: true, numericType: "float", getNumber: Ext.identityFn, parse: function (a) { return parseFloat(String(a).replace(this.stripRe, "")) } }, 0, 0, 0, 0, ["data.field.float", "data.field.number"], 0, [Ext.data.field, "Number"], 0)); (Ext.cmd.derive("Ext.data.field.String", Ext.data.field.Field, { sortType: "asUCString", isStringField: true, convert: function (b) { var a = this.allowNull ? null : ""; return (b === undefined || b === null) ? a : String(b) }, getType: function () { return "string" } }, 0, 0, 0, 0, ["data.field.string"], 0, [Ext.data.field, "String"], 0)); (Ext.cmd.derive("Ext.data.identifier.Generator", Ext.Base, { "abstract": true, factoryConfig: { defaultType: "sequential" }, isGenerator: true, config: { id: null }, constructor: function (a) { var b = this, c; b.initConfig(a); c = b.getId(); if (c) { Ext.data.identifier.Generator.all[c] = b } }, privates: { clone: function (b) { var a = this.getInitialConfig(); a = b ? Ext.apply({}, b, a) : a; return new this.self(a) }, statics: { all: {} } } }, 1, 0, 0, 0, ["data.identifier.default"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.identifier, "Generator"], function () { var c = this, a = Ext.Factory, b = a.dataIdentifier; a.dataIdentifier = function (d) { var g = Ext.isString(d) ? d : (d && d.id), e = g && c.all[g]; return e || b(d) } })); (Ext.cmd.derive("Ext.data.identifier.Sequential", Ext.data.identifier.Generator, { config: { increment: 1, prefix: null, seed: 1 }, generate: function () { var b = this, a = b._seed, c = b._prefix; b._seed += b._increment; return (c !== null) ? c + a : a } }, 0, 0, 0, 0, ["data.identifier.sequential"], 0, [Ext.data.identifier, "Sequential"], 0)); (Ext.cmd.derive("Ext.data.Model", Ext.Base, { alternateClassName: "Ext.data.Record", isEntity: true, isModel: true, validIdRe: null, erasing: false, observableType: "record", crudState: "R", crudStateWas: null, constructor: function (e, m) { var n = this, q = n.self, l = q.identifier, c = Ext.data.Model, o = c.identifier, p = n.idField.name, k, a, b, j, h, d, g; n.data = n.data = e || (e = {}); n.session = m || null; n.internalId = j = o.generate(); if ((k = e) instanceof Array) { n.data = e = {}; g = n.getFields(); h = Math.min(g.length, k.length); for (d = 0; d < h; ++d) { e[g[d].name] = k[d] } } if (!(b = q.initializeFn)) { q.initializeFn = b = c.makeInitializeFn(q) } if (!b.$nullFn) { q.initializeFn(n) } if (!(n.id = a = e[p]) && a !== 0) { if (m) { l = m.getIdentifier(q); a = l.generate() } else { if (o === l) { a = j } else { a = l.generate() } } e[p] = n.id = a; n.phantom = true; n.crudState = "C" } if (m) { m.add(n) } if (n.init && Ext.isFunction(n.init)) { n.init() } }, editing: false, dirty: false, session: null, dropped: false, erased: false, clientIdProperty: null, evented: false, phantom: false, idProperty: "id", manyToMany: null, identifier: null, previousValues: undefined, proxy: undefined, schema: "default", versionProperty: null, generation: 1, validationSeparator: null, convertOnSet: true, beginEdit: function () { var c = this, b = c.modified, a = c.previousValues; if (!c.editing) { c.editing = true; c.editMemento = { dirty: c.dirty, data: Ext.apply({}, c.data), generation: c.generation, modified: b && Ext.apply({}, b), previousValues: a && Ext.apply({}, a) } } }, cancelEdit: function () { var b = this, a = b.editMemento; if (a) { b.editing = false; Ext.apply(b, a); b.editMemento = null } }, endEdit: function (b, d) { var c = this, a = c.editMemento; if (a) { c.editing = false; c.editMemento = null; c.previousValues = a.previousValues; if (!b) { if (!d) { d = c.getModifiedFieldNames(a.data) } if (c.dirty || (d && d.length)) { c.callJoined("afterEdit", [d]) } } } }, getField: function (a) { return this.self.getField(a) }, getFields: function () { return this.self.getFields() }, getFieldsMap: function () { return this.fieldsMap }, getIdProperty: function () { return this.idProperty }, getId: function () { return this.id }, getObservableId: function () { return this.internalId }, setId: function (b, a) { this.set(this.idProperty, b, a) }, getPrevious: function (b) { var a = this.previousValues; return a && a[b] }, isModified: function (b) { var a = this.modified; return !!(a && a.hasOwnProperty(b)) }, getModified: function (b) { var a; if (this.isModified(b)) { a = this.modified[b] } return a }, get: function (a) { return this.data[a] }, _singleProp: {}, _rejectOptions: { convert: false, silent: true }, set: function (u, H, w) { var n = this, c = n.self, L = n.data, q = n.modified, y = n.previousValues, A = n.session, z = Ext.isString(u), r = (z ? w : H), C = r ? r.convert !== false : n.convertOnSet, D = n.fieldsMap, e = r && r.silent, m = r && r.commit, E = !(r && r.refs === false) && A, s = !(r && r.dirty === false && !m), p = null, j = 0, d = n.associations, h, g, b, o, l, x, v, k, J, K, G, B, I, a, F, M, t; if (z) { M = n._singleProp; M[u] = H } else { M = u } if (!(I = c.rankedFields)) { I = c.rankFields() } G = I.length; do { for (l in M) { F = M[l]; h = L[l]; v = n; g = D[l]; if (g) { if (C && g.convert) { F = g.convert(F, n) } v = g; a = g.reference } else { a = null } if (v.isEqual(h, F)) { continue } L[l] = F; (p || (p = [])).push(l); (y || (n.previousValues = y = {}))[l] = h; if (a && a.cls) { if (E) { A.updateReference(n, g, F, h) } a.onValueChange(n, A, F, h) } K = (J = g && g.dependents) && J.length; while (K-- > 0) { (k = J[K]).dirty = true; j = j ? Math.min(j, k.rank) : k.rank } if (!g || g.persist) { if (q && q.hasOwnProperty(l)) { if (!s || v.isEqual(q[l], F)) { delete q[l]; n.dirty = -1 } } else { if (s) { if (!q) { n.modified = q = {} } n.dirty = true; q[l] = h } } } if (l === n.idField.name) { b = true; x = h; B = F } } if (!j) { break } g = I[j - 1]; g.dirty = false; if (z) { delete M[u] } else { M = n._singleProp; z = true } u = g.name; M[u] = L[u]; C = true; for (; j < G; ++j) { if (I[j].dirty) { break } } if (j < G) { ++j } else { j = 0 } } while (1); if (n.dirty < 0) { n.dirty = false; for (o in q) { if (q.hasOwnProperty(o)) { n.dirty = true; break } } } if (z) { delete M[u] } ++n.generation; if (b) { n.id = B; n.onIdChanged(B, x); n.callJoined("onIdChanged", [x, B]); if (d) { for (t in d) { d[t].onIdChanged(n, x, B) } } } if (m) { n.commit(e, p) } else { if (!e && !n.editing && p) { n.callJoined("afterEdit", [p]) } } return p }, reject: function (a) { var c = this, b = c.modified; if (b) { c.set(b, c._rejectOptions) } c.dropped = false; c.clearState(); if (!a) { c.callJoined("afterReject") } }, commit: function (b, d) { var c = this, g = c.versionProperty, e = c.data, a; c.clearState(); if (g && !c.phantom && !isNaN(e[g])) { ++e[g] } c.phantom = false; if (c.dropped) { c.erased = a = true } if (!b) { if (a) { c.callJoined("afterErase") } else { c.callJoined("afterCommit", [d]) } } }, clearState: function () { var a = this; a.dirty = a.editing = false; a.editMemento = a.modified = null }, drop: function (b) { var d = this, c = d.associations, e = d.session, a; if (d.erased || d.dropped) { return } d.dropped = true; if (c && b !== false) { for (a in c) { c[a].onDrop(d, e) } } d.callJoined("afterDrop"); if (d.phantom) { d.setErased() } }, join: function (b) { var a = this, c = a.joined; if (!c) { c = a.joined = [b] } else { if (!c.length) { c[0] = b } else { Ext.Array.include(c, b) } } if (b.isStore && !a.store) { a.store = b } }, unjoin: function (e) { var d = this, g = d.joined, a = g && g.length, b = d.store, c; if (e === d.session) { d.session = null } else { if (a === 1 && g[0] === e) { g.length = 0 } else { if (a) { Ext.Array.remove(g, e) } } if (b === e) { b = null; if (g) { for (c = 0, a = g.length; c < a; ++c) { e = g[c]; if (e.isStore) { b = e; break } } } d.store = b } } }, clone: function (d) { var c = this, b = c.modified, a = c.copy(c.id, d); if (b) { a.modified = Ext.apply({}, b) } a.dirty = c.dirty; a.dropped = c.dropped; a.phantom = c.phantom; return a }, copy: function (c, g) { var d = this, e = Ext.apply({}, d.data), b = d.idProperty, a = d.self; if (c || c === 0) { e[b] = c } else { if (c === null) { delete e[b] } } return new a(e, g) }, getProxy: function () { return this.self.getProxy() }, getValidation: function (b) { var c = this, a = c.validation; if (!a) { c.validation = a = new Ext.data.Validation(); a.attach(c) } if (b === true || (b !== false && a.syncGeneration !== c.generation)) { a.refresh(b) } return a }, validate: function () { return new Ext.data.ErrorCollection().init(this) }, isValid: function () { return this.getValidation().isValid() }, toUrl: function () { var b = this.$className.split("."), a = b[b.length - 1].toLowerCase(); return a + "/" + this.getId() }, erase: function (a) { var b = this; b.erasing = true; b.drop(); b.erasing = false; return b.save(a) }, setErased: function () { this.erased = true; this.callJoined("afterErase") }, getChanges: function () { return this.getData(this._getChangesOptions) }, getCriticalFields: function () { var a = this.self, b = a.criticalFields; if (!b) { a.rankFields(); b = a.criticalFields } return b }, getAssociatedData: function (r, q) { var m = this, c = m.associations, o, h, p, l, d, b, k, g, e, a, j, n; r = r || {}; m.$gathering = 1; if (q) { q = Ext.Object.chain(q) } for (e in c) { g = c[e]; p = g.getAssociatedItem(m); if (!p || p.$gathering) { continue } if (p.isStore) { p.$gathering = 1; l = p.getData().items; b = l.length; d = []; for (h = 0; h < b; ++h) { k = l[h]; o = !k.$gathering; k.$gathering = 1; if (q) { n = q.associated; if (n === undefined) { q.associated = o; j = true } else { if (!o) { q.associated = false; j = true } } a = q } else { a = o ? m._getAssociatedOptions : m._getNotAssociatedOptions } d.push(k.getData(a)); if (j) { q.associated = n; j = false } delete k.$gathering } delete p.$gathering } else { a = q || m._getAssociatedOptions; if (q && q.associated === undefined) { a.associated = true } d = p.getData(a) } r[e] = d } delete m.$gathering; return r }, getData: function (s) { var k = this, j = {}, a = (s === true) ? k._getAssociatedOptions : (s || j), e = k.data, l = a.associated, p = a.changes, o = p && a.critical, i = p ? k.modified : e, h = k.fieldsMap, g = a.persist, r = a.serialize, c, m, d, b, q; if (i) { for (b in i) { q = e[b]; m = h[b]; if (m) { if (g && !m.persist) { continue } if (r && m.serialize) { q = m.serialize(q, k) } } j[b] = q } } if (o) { c = k.self.criticalFields || k.getCriticalFields(); for (d = c.length; d-- > 0;) { b = (m = c[d]).name; if (!(b in j)) { q = e[b]; if (r && m.serialize) { q = m.serialize(q, k) } j[b] = q } } } if (l) { k.getAssociatedData(j, a) } return j }, getTransientFields: function () { var a = this.self, b = a.transientFields; if (!b) { a.rankFields(); b = a.transientFields } return b }, isLoading: function () { return !!this.loadOperation }, abort: function () { var a = this.loadOperation; if (a) { a.abort() } }, load: function (b) { b = Ext.apply({}, b); var g = this, e = b.scope || g, c = g.getProxy(), i = b.callback, a = g.loadOperation, h = g.getId(), d; if (a) { d = a.extraCalls; if (!d) { d = a.extraCalls = [] } d.push(b); return a } b.id = h; b.recordCreator = function (l, j, k) { var m = g.session; if (k) { k.recordCreator = m ? m.recordCreator : null } g.set(l, g._commitOptions); return g }; b.internalCallback = function (l) { var p = l.wasSuccessful() && l.getRecords().length > 0, q = g.loadOperation, n = q.extraCalls, k = [g, l], o = [g, l, p], m, j; g.loadOperation = null; if (p) { Ext.callback(b.success, e, k) } else { Ext.callback(b.failure, e, k) } Ext.callback(i, e, o); if (n) { for (m = 0, j = n.length; m < j; ++m) { b = n[m]; if (p) { Ext.callback(b.success, e, k) } else { Ext.callback(b.failure, e, k) } Ext.callback(b.callback, e, o) } } g.callJoined("afterLoad") }; delete b.callback; g.loadOperation = a = c.createOperation("read", b); a.execute(); return a }, save: function (j) { j = Ext.apply({}, j); var g = this, d = g.phantom, a = g.dropped, c = a ? "destroy" : (d ? "create" : "update"), i = j.scope || g, h = j.callback, e = g.getProxy(), b; j.records = [g]; j.internalCallback = function (k) { var l = [g, k], m = k.wasSuccessful(); if (m) { Ext.callback(j.success, i, l) } else { Ext.callback(j.failure, i, l) } l.push(m); Ext.callback(h, i, l) }; delete j.callback; b = e.createOperation(c, j); if (a && d) { b.setResultSet(Ext.data.reader.Reader.prototype.nullResultSet); g.setErased(); b.setSuccessful(true) } else { b.execute() } return b }, inheritableStatics: { addFields: function (a) { this.replaceFields(a) }, replaceFields: function (n, k) { var o = this, e = o.prototype, j = Ext.data.field.Field, g = o.fields, m = o.fieldsMap, c = o.fieldOrdinals, p, d, b, h, a, l; if (k === true) { g.length = 0; o.fieldsMap = m = {}; o.fieldOrdinals = c = {} } else { if (k) { for (d = k.length; d-- > 0;) { a = k[d]; if (a in c) { delete c[a]; delete m[a] } } for (d = 0, h = g.length; d < h; ++d) { a = (p = g[d]).name; if (a in c) { c[a] = d } else { g.splice(d, 1); --d; --h } } } } for (d = 0, h = n ? n.length : 0; d < h; d++) { a = (p = n[d]).name; if (!(a in c)) { c[a] = l = g.length; g.push(p = j.create(p)); m[a] = p; p.ordinal = l; p.definedBy = p.owner = this } } o.idField = e.idField = b = m[e.idProperty]; b.allowNull = b.critical = b.identifier = true; b.defaultValue = null; o.initializeFn = o.rankedFields = o.transientFields = o.criticalFields = null }, removeFields: function (a) { this.replaceFields(null, a) }, getIdFromData: function (c) { var b = this, a = b.idField, d = a.calculated ? (new b(c)).id : c[a.name]; return d }, createWithId: function (g, b, c) { var e = b, a = this; if (g || g === 0) { e = {}; if (b) { Ext.apply(e, b) } e[a.idField.name] = g } return new a(e, c) }, getFields: function () { return this.fields }, getFieldsMap: function () { return this.fieldsMap }, getField: function (a) { return this.fieldsMap[a] || null }, getProxy: function () { var b = this, a = b.proxy, d = b.defaultProxy, c; if (!a) { a = b.proxyConfig; if (!a && d) { a = d } if (!a || !a.isProxy) { if (typeof a === "string") { a = { type: a } } c = b.schema.constructProxy(b); a = a ? Ext.merge(c, a) : c } a = b.setProxy(a) } return a }, setProxy: function (b) { var c = this, a; if (b) { if (!b.isProxy) { b = Ext.Factory.proxy(b) } else { a = b.getModel(); if (a && a !== c) { b = b.clone() } } b.setModel(c) } return (c.prototype.proxy = c.proxy = b) }, load: function (e, a, c) { var b = {}, d; b[this.prototype.idProperty] = e; d = new this(b, c); d.load(a); return d } }, deprecated: { 5: { methods: { hasId: null, markDirty: null, setDirty: null, eachStore: function (g, d) { var e = this, b = e.stores, a = b.length, c; for (c = 0; c < a; ++c) { g.call(d, b[c]) } }, join: function (c) { var b = this, a = b.stores, d = b.joined; if (!d) { d = b.joined = [c] } else { d.push(c) } if (c.isStore) { b.store = b.store || c; if (!a) { a = b.stores = [] } a.push(c) } }, unjoin: function (c) { var b = this, a = b.stores, d = b.joined; if (d.length === 1) { d.length = 0 } else { Ext.Array.remove(d, c) } if (c.isStore) { Ext.Array.remove(a, c); b.store = a[0] || null } } }, properties: { persistenceProperty: null }, inheritableStatics: { methods: { setFields: null } } } }, privates: { _commitOptions: { commit: true }, _getChangesOptions: { changes: true }, _getAssociatedOptions: { associated: true }, _getNotAssociatedOptions: { associated: false }, copyFrom: function (j) { var h = this, e = h.fields, m = e.length, b = [], k, c = 0, g, d, n = h.idProperty, a, l; if (j) { g = h.data; d = j.data; for (; c < m; c++) { k = e[c]; a = k.name; if (a !== n) { l = d[a]; if (l !== undefined && !h.isEqual(g[a], l)) { g[a] = l; b.push(a) } } } if (h.phantom && !j.phantom) { h.beginEdit(); h.setId(j.getId()); h.endEdit(true); h.commit(true) } } return b }, callJoined: function (e, d) { var h = this, k = h.joined, g = h.session, a = h.dropped ? "D" : (h.phantom ? "C" : (h.dirty ? "U" : "R")), b, c, j, l; h.crudState = a; if (k || g) { if (d) { d.unshift(h) } else { d = [h] } if (k) { for (b = 0, c = k.length; b < c; ++b) { l = k[b]; if (l && (j = l[e])) { j.apply(l, d) } } } j = g && g[e]; if (j) { j.apply(g, d) } } h.crudStateWas = a }, onAssociatedRecordSet: function (a, b) { this.callJoined("afterAssociatedRecordSet", [a, b]) }, onIdChanged: Ext.privateFn, setSession: function (a) { this.session = a; if (a) { a.add(this) } }, getModifiedFieldNames: function (a) { var d = this, e = d.data, b = [], g = a || d.editMemento.data, c; for (c in e) { if (e.hasOwnProperty(c)) { if (!d.isEqual(e[c], g[c], c)) { b.push(c) } } } return b }, isEqual: function (a, d, c) { var b; if (c) { b = c.isField ? c : this.fieldsMap[c]; if (b) { return b.isEqual(a, d) } } if (a instanceof Date && d instanceof Date) { return a.getTime() === d.getTime() } return a === d }, statics: { EDIT: "edit", REJECT: "reject", COMMIT: "commit", defaultProxy: "memory", rankFields: function () { var k = this, j = k.prototype, d = k.fields, b = d.length, g = [], a = [], e = [], l, h, c; k.rankedFields = j.rankedFields = g; k.criticalFields = j.criticalFields = a; k.transientFields = j.transientFields = e; for (c = 0; c < b; ++c) { h = d[c]; if (h.critical) { a.push(h) } if (!h.persist) { e.push(h) } if (h.evil) { (l || (l = [])).push(h) } else { if (!h.depends) { g.push(h); h.rank = g.length } } } for (c = 0; c < b; ++c) { if (!(h = d[c]).rank && !h.evil) { k.topoAdd(h) } } if (l) { for (c = 0, b = l.length; c < b; ++c) { g.push(h = l[c]); h.rank = g.length } } return g }, topoAdd: function (h) { var b = this, g = h.depends, a = g ? g.length : 0, d = b.rankedFields, c, e; for (c = 0; c < a; ++c) { e = b.fieldsMap[g[c]]; (e.dependents || (e.dependents = [])).push(h); if (!e.rank) { b.topoAdd(e) } } d.push(h); h.rank = d.length }, initFields: function (w, b, p) { var k = Ext.data.field.Field, d = w.fields, q = [], l = {}, g = {}, a = [], v = p.fields, m = w.versionProperty || p.versionProperty, n = b.idProperty, h, c, t, e, x, s, j, u, r, o; b.fields = p.fields = q; b.fieldOrdinals = p.fieldOrdinals = l; b.fieldsMap = p.fieldsMap = g; b.references = p.references = a; if (v) { for (t = 0, e = v.length; t < e; ++t) { q[t] = c = Ext.Object.chain(v[t]); c.dependents = null; c.owner = b; l[x = c.name] = t; g[x] = c; c.rank = null; if (c.generated) { u = c; r = c.name } } } if (d) { delete w.fields; for (t = 0, e = d.length; t < e; ++t) { c = d[t]; j = c.reference; if (j && typeof j !== "string") { j = Ext.merge({}, j) } c.$reference = j; c = k.create(d[t]); x = c.name; s = l[x]; if (s === undefined) { l[x] = s = q.length } g[x] = c; q[s] = c; c.definedBy = c.owner = b; c.ordinal = s; if (x === n) { o = c } } } h = g[n]; if (!h) { if (u && u.generated) { s = u.ordinal } else { s = q.length } delete g[r]; delete l[r]; h = new k(n); q[s] = h; l[n] = s; g[n] = h; h.definedBy = b; h.ordinal = s; h.generated = true } else { if (o && u && u.generated) { Ext.Array.remove(q, u); delete g[r]; delete l[r]; g[n] = o; for (t = 0, e = q.length; t < e; ++t) { c = q[t]; q.ordinal = t; l[c.name] = t } } } h.allowNull = h.critical = h.identifier = true; h.defaultValue = null; b.idField = p.idField = h; if (m) { c = g[m]; if (!c) { s = q.length; c = new k({ name: m, type: "int" }); q[s] = c; l[m] = s; g[m] = c; c.definedBy = b; c.ordinal = s; c.generated = true } c.defaultValue = 1; c.critical = true } }, initValidators: function (h, p, k) { var n = k.validators, e, m, c, l, g, d, j, b, a, o; if (n) { e = {}; for (m in n) { e[m] = Ext.Array.clone(n[m]) } } l = h.validators || h.validations; if (l) { delete h.validators; e = e || {}; if (Ext.isArray(l)) { c = {}; for (g = 0, d = l.length; g < d; ++g) { o = l[g]; b = o.field; if (!c[b]) { c[b] = [] } o = o.fn || o; c[b].push(o) } l = c } for (b in l) { j = l[b]; if (!Ext.isArray(j)) { j = [j] } a = e[b]; if (e[b]) { Ext.Array.push(a, j) } else { e[b] = j } } } if (e) { for (b in e) { m = p.getField(b); if (m) { m.setModelValidators(e[b]) } } } p.validators = k.validators = e }, initAssociations: function (d, h, m) { var c = h.associations, e = h.belongsTo, k = h.hasMany, n = h.hasOne, l = h.manyToMany, g, b, j, a; delete h.associations; delete h.belongsTo; delete h.hasMany; delete h.hasOne; delete h.manyToMany; if (l) { d.addMatrices(m, l) } if (c) { c = Ext.isArray(c) ? c : [c]; for (g = 0, b = c.length; g < b; ++g) { j = c[g]; a = Ext.apply({}, j); delete a.type; switch (j.type) { case "belongsTo": d.addBelongsTo(m, a); break; case "hasMany": d.addHasMany(m, a); break; case "hasOne": d.addHasOne(m, a); break } } } if (e) { e = Ext.isArray(e) ? e : [e]; for (g = 0, b = e.length; g < b; ++g) { d.addBelongsTo(m, e[g]) } } if (k) { k = Ext.isArray(k) ? k : [k]; for (g = 0, b = k.length; g < b; ++g) { d.addHasMany(m, k[g]) } } if (n) { n = Ext.isArray(n) ? n : [n]; for (g = 0, b = n.length; g < b; ++g) { d.addHasOne(m, n[g]) } } d.afterKeylessAssociations(m) }, initIdentifier: function (g, a, e) { var b = g.identifier || g.idgen, d = e.identifier || a.schema._defaultIdentifier, c; if (b) { delete g.identifier; delete g.idgen; b = Ext.Factory.dataIdentifier(b) } else { if (d) { if (d.clone && !d.getId()) { b = d.clone() } else { if (d.isGenerator) { b = d } else { b = Ext.Factory.dataIdentifier(d) } } } } a.identifier = e.identifier = b; if (!b) { c = a.entityName; if (!c) { c = Ext.id(null, "extModel") } a.identifier = Ext.Factory.dataIdentifier({ type: "sequential", prefix: c + "-" }) } }, findValidator: function (c, d, b) { var g = b.type || b, j = c[d], a, e, h; if (j) { for (e = 0, a = j.length; e < a; ++e) { h = j[e]; if (h.type === g) { return h } } } return null }, makeInitializeFn: function (q) { var a = ["var "], h = ["\nreturn function (e) {\n    var data = e.data, v;\n"], n = 0, k, j, l, p, d, m, g, e, o, c, b; if (!(g = q.rankedFields)) { g = q.rankFields() } for (c = 0, b = g.length; c < b; ++c) { m = g[c]; e = "f" + c; l = m.convert; if (c) { a.push(",  \n    ") } a.push(e, " = $fields[" + c + "]"); if ((o = (m.defaultValue !== undefined)) || l) { p = 'data["' + m.name + '"]'; ++n; k = j = ""; if (m.cloneDefaultValue) { k = "Ext.clone("; j = ")" } h.push("\n"); if (l && o) { h.push("    v = ", p, ";\n    if (v !== undefined) {\n        v = ", e, ".convert(v, e);\n    }\n    if (v === undefined) {\n        v = ", k, e, ".defaultValue", j, ";\n    }\n    ", p, " = v;") } else { if (l) { h.push("    v = ", e, ".convert(", p, ",e);\n    if (v !== undefined) {\n        ", p, " = v;\n    }\n") } else { if (o) { h.push("    if (", p, " === undefined) {\n        ", p, " = ", k, e, ".defaultValue", j, ";\n    }\n") } } } } } if (!n) { return Ext.emptyFn } a.push(";\n"); a.push.apply(a, h); a.push("}"); a = a.join(""); d = new Function("$fields", "Ext", a); return d(g, Ext) } } } }, 1, 0, 0, 0, 0, 0, [Ext.data, "Model", Ext.data, "Record"], function () { var d = this, c = d.prototype, b = Ext.data.schema.Schema, a; d.proxyConfig = c.proxy; delete c.proxy; d.fields = []; d.fieldsMap = c.fieldsMap = {}; d.schema = c.schema = b.get(c.schema); c.idField = new Ext.data.field.Field(c.idProperty); d.identifier = new Ext.data.identifier.Sequential(); d.onExtended(function (e, k) { var j = e.prototype, m = k.schema, l = j.superclass.self, i, h, g; e.idProperty = k.idProperty || j.idProperty; if (m) { delete k.schema; i = b.get(m) } else { if (!(i = j.schema)) { i = a || (a = b.get("default")) } } e.rankFields = d.rankFields; e.topoAdd = d.topoAdd; j.schema = e.schema = i; if (!(h = k.entityName)) { j.entityName = h = i.getEntityName(e) } e.entityName = h; e.fieldExtractors = {}; d.initIdentifier(k, e, j); d.initFields(k, e, j); d.initValidators(k, e, j); e.fields.items = e.fields; if (h) { i.addEntity(e); d.initAssociations(i, k, e) } g = k.proxy; if (g) { delete k.proxy } else { if (l !== d) { g = l.proxyConfig || l.proxy } } e.proxyConfig = g }) })); (Ext.cmd.derive("Ext.data.ResultSet", Ext.Base, { isResultSet: true, $configPrefixed: false, config: { loaded: true, count: null, total: null, success: false, records: null, message: null, metadata: null }, constructor: function (a) { this.initConfig(a) }, getCount: function () { var b = (arguments.callee.$previous || Ext.Base.prototype.getCount).call(this), a; if (!b) { a = this.getRecords(); if (a) { b = a.length } } return b } }, 1, 0, 0, 0, 0, 0, [Ext.data, "ResultSet"], 0)); (Ext.cmd.derive("Ext.data.reader.Reader", Ext.Base, { alternateClassName: ["Ext.data.Reader", "Ext.data.DataReader"], factoryConfig: { defaultType: null }, config: { totalProperty: "total", successProperty: "success", rootProperty: "", messageProperty: "", typeProperty: "", implicitIncludes: true, readRecordsOnFailure: true, model: null, proxy: null, transform: null, keepRawData: null }, isReader: true, constructor: function (a) { if (a && a.hasOwnProperty("root")) { a = Ext.apply({}, a); a.rootProperty = a.root; delete a.root } var b = this; b.duringInit = 1; b.mixins.observable.constructor.call(b, a); --b.duringInit; b.buildExtractors() }, applyModel: function (a) { return Ext.data.schema.Schema.lookupEntity(a) }, applyTransform: function (a) { if (a) { if (Ext.isFunction(a)) { a = { fn: a } } else { if (a.charAt) { a = { fn: this[a] } } } return a.fn.bind(a.scope || this) } return a }, forceBuildExtractors: function () { if (!this.duringInit) { this.buildExtractors(true) } }, updateTotalProperty: function () { this.forceBuildExtractors() }, updateMessageProperty: function () { this.forceBuildExtractors() }, updateSuccessProperty: function () { this.forceBuildExtractors() }, read: function (b, e) { var d, a, c; if (b) { c = b.responseText; if (c) { a = this.getResponseData(b); if (a && a.__$isError) { return new Ext.data.ResultSet({ total: 0, count: 0, records: [], success: false, message: a.msg }) } else { d = this.readRecords(a, e) } } else { if (c !== "") { d = this.readRecords(b, e) } } } return d || this.nullResultSet }, getNullResultSet: function () { return this.nullResultSet }, createReadError: function (a) { return { __$isError: true, msg: a } }, readRecords: function (e, c, h) { var i = this, g = h && h.recordsOnly, m = h && h.asRoot, n, d, b, k, j, l, p, a, o; o = i.getMeta ? i.getMeta(e) : e.metaData; if (o) { i.onMetaChange(o) } a = i.getTransform(); if (a) { e = a(e) } i.buildExtractors(); if (i.getKeepRawData()) { i.rawData = e } if (i.hasListeners.rawdata) { i.fireEventArgs("rawdata", [e]) } e = i.getData(e); n = true; d = 0; b = []; if (i.getSuccessProperty()) { l = i.getSuccess(e); if (l === false || l === "false") { n = false } } if (i.getMessageProperty()) { p = i.getMessage(e) } if (n || i.getReadRecordsOnFailure()) { k = (m || Ext.isArray(e)) ? e : i.getRoot(e); if (k) { j = k.length } if (i.getTotalProperty()) { l = parseInt(i.getTotal(e), 10); if (!isNaN(l)) { j = l } } if (k) { b = i.extractData(k, c); d = b.length } } return g ? b : new Ext.data.ResultSet({ total: j || d, metadata: o, count: d, records: b, success: n, message: p }) }, extractData: function (p, g) { var n = this, h = g && g.model ? Ext.data.schema.Schema.lookupEntity(g.model) : n.getModel(), d = h.schema, q = d.hasAssociations(h) && n.getImplicitIncludes(), o = n.getFieldExtractorInfo(h.fieldExtractors), a = p.length, c = new Array(a), l = n.getTypeProperty(), m, b, e, k, j; if (!a && Ext.isObject(p)) { p = [p]; a = 1 } for (j = 0; j < a; j++) { k = p[j]; if (!k.isModel) { b = k; if (l && (e = n.getChildType(d, b, l))) { m = e.getProxy().getReader(); k = m.extractRecord(b, g, e, d.hasAssociations(e) && m.getImplicitIncludes(), m.getFieldExtractorInfo(e.fieldExtractors)) } else { k = n.extractRecord(b, g, h, q, o) } if (k.isModel && k.isNode) { k.raw = b } } if (k.onLoad) { k.onLoad() } c[j] = k } return c }, getChildType: function (b, c, d) { var a; switch (typeof d) { case "string": return b.getEntity(c[d]); case "object": a = d.namespace; return b.getEntity((a ? a + "." : "") + c[d.name]); case "function": return b.getEntity(d(c)) } }, extractRecordData: function (c, d) { var b = d && d.model ? Ext.data.schema.Schema.lookupEntity(d.model) : this.getModel(), a = this.getFieldExtractorInfo(b.fieldExtractors); return this.extractRecord(c, d, b, false, a) }, extractRecord: function (a, b, c, j, h) { var g = this, e = (b && b.recordCreator) || g.defaultRecordCreator, i, d; i = g.extractModelData(a, h); d = e.call(g, i, c || g.getModel(), b); if (j && d.isModel) { g.readAssociated(d, a, b) } return d }, getFieldExtractorInfo: function (c) { if (!c) { return } var a = this.$className, b = c[a]; if (b === undefined) { c[a] = b = this.buildFieldExtractors() } return b }, buildFieldExtractors: function () { var h = this.getFields(), j = h.length, e = [], l = [], d = null, b = 0, k, a, g, c; for (g = 0; g < j; ++g) { k = h[g]; c = this.createFieldAccessor(k); if (c) { a = k.name; e.push("val = extractors[" + b + "](raw); if (val !== undefined) { data['" + a + "'] = val; }"); l.push(c); ++b } } if (e.length) { d = { extractors: l, fn: new Function("raw", "data", "extractors", "var val;" + e.join("")) } } return d }, defaultRecordCreator: function (b, c) { var a = new c(b); a.phantom = false; return a }, getModelData: function (a) { return {} }, extractModelData: function (b, a) { var d = this.getModelData(b), c; if (a) { c = a.fn; c(b, d, a.extractors) } return d }, readAssociated: function (a, e, d) { var c = a.associations, b, g; for (b in c) { if (c.hasOwnProperty(b)) { g = c[b]; if (g.cls) { g.read(a, e, this, d) } } } }, getFields: function () { return this.getModel().fields }, getData: Ext.identityFn, getRoot: Ext.identityFn, getResponseData: function (a) { }, onMetaChange: function (h) { var g = this, b = h.fields, c, e, a, d; g.metaData = h; if (h.root) { g.setRootProperty(h.root) } if (h.totalProperty) { g.setTotalProperty(h.totalProperty) } if (h.successProperty) { g.setSuccessProperty(h.successProperty) } if (h.messageProperty) { g.setMessageProperty(h.messageProperty) } a = h.clientIdProperty; if (b) { e = Ext.define(null, { extend: "Ext.data.Model", fields: b, clientIdProperty: a }); g.setModel(e); d = g.getProxy(); if (d) { d.setModel(e) } } else { if (a) { c = g.getModel(); if (c) { c.self.prototype.clientIdProperty = a } } } }, buildExtractors: function (d) { var b = this, c, a, e; if (d || !b.hasExtractors) { c = b.getTotalProperty(); a = b.getSuccessProperty(); e = b.getMessageProperty(); if (c) { b.getTotal = b.getAccessor(c) } if (a) { b.getSuccess = b.getAccessor(a) } if (e) { b.getMessage = b.getAccessor(e) } b.hasExtractors = true; return true } }, getAccessor: function (e) { var d = this, a = d.extractorCache, b, c; if (typeof e === "string") { c = d.getAccessorKey(e); b = a.get(c); if (!b) { b = d.createAccessor(e); a.add(c, b) } } else { b = d.createAccessor(e) } return b }, getAccessorKey: function (a) { return this.$className + a }, createAccessor: Ext.emptyFn, createFieldAccessor: Ext.emptyFn, destroy: function () { var a = this; a.model = a.getTotal = a.getSuccess = a.getMessage = a.rawData = null; a.onMetaChange = null; a.transform = null; a.callParent() }, privates: { copyFrom: function (a) { var b = this; a.buildExtractors(); b.getTotal = a.getTotal; b.getSuccess = a.getSuccess; b.getMessage = a.getMessage; ++b.duringInit; b.setConfig(a.getConfig()); --b.duringInit; b.hasExtractors = true } } }, 1, 0, 0, 0, ["reader.base"], [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable], [Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.reader, "Reader", Ext.data, "Reader", Ext.data, "DataReader"], function (b) { var a = b.prototype; Ext.apply(a, { nullResultSet: new Ext.data.ResultSet({ total: 0, count: 0, records: [], success: true, message: "" }) }); a.extractorCache = new Ext.util.LruCache() })); (Ext.cmd.derive("Ext.data.writer.Writer", Ext.Base, { factoryConfig: { defaultType: null }, alternateClassName: ["Ext.data.DataWriter", "Ext.data.Writer"], config: { clientIdProperty: null, allDataOptions: { persist: true }, partialDataOptions: { changes: true, critical: true }, writeAllFields: false, dateFormat: null, nameProperty: "name", writeRecordId: true, transform: null }, isWriter: true, constructor: function (a) { this.initConfig(a) }, applyTransform: function (a) { if (a) { if (Ext.isFunction(a)) { a = { fn: a } } return a.fn.bind(a.scope || this) } return a }, write: function (e) { var c = e.getOperation(), b = c.getRecords() || [], a = b.length, g = [], d; for (d = 0; d < a; d++) { g.push(this.getRecordData(b[d], c)) } return this.writeRecords(e, g) }, writeRecords: Ext.emptyFn, getRecordData: function (j, h) { var m = this, e = m.getNameProperty(), a = e !== "name", c = j.self.idField, q = c[e] || c.name, p = j.id, d = m.getWriteAllFields(), l, b, g, r, o, k, i, n; if (c.serialize) { p = c.serialize(p) } if (!d && h && h.isDestroyOperation) { l = {}; l[q] = p } else { b = m.getDateFormat(); g = j.phantom; r = (g || d) ? m.getAllDataOptions() : m.getPartialDataOptions(); o = g && m.getClientIdProperty(); k = j.getFieldsMap(); r.serialize = false; i = j.getData(r); l = a ? {} : i; if (o) { l[o] = p; delete i[q] } else { if (!m.getWriteRecordId()) { delete i[q] } } for (q in i) { p = i[q]; if (!(n = k[q])) { if (a) { l[q] = p } } else { if (n.isDateField && b && Ext.isDate(p)) { p = Ext.Date.format(p, b) } else { if (n.serialize) { p = n.serialize(p, j) } } if (a) { q = n[e] || q } l[q] = p } } } return l } }, 1, 0, 0, 0, ["writer.base"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.data.writer, "Writer", Ext.data, "DataWriter", Ext.data, "Writer"], 0)); (Ext.cmd.derive("Ext.data.proxy.Proxy", Ext.Base, { $configPrefixed: false, alternateClassName: ["Ext.data.DataProxy", "Ext.data.Proxy"], config: { batchOrder: "create,update,destroy", batchActions: true, model: undefined, reader: { type: "json" }, writer: { type: "json" } }, isProxy: true, isSynchronous: false, constructor: function (a) { this.mixins.observable.constructor.call(this, a); this.pendingOperations = {} }, applyModel: function (a) { return Ext.data.schema.Schema.lookupEntity(a) }, updateModel: function (b) { if (b) { var a = this.getReader(); if (a && !a.getModel()) { a.setModel(b) } } }, applyReader: function (a) { if (this.isSynchronous) { a = a || {}; a.keepRawData = true } return Ext.Factory.reader(a) }, updateReader: function (a) { if (a) { var c = this, b = c.getModel(); if (!b) { b = a.getModel(); if (b) { c.setModel(b) } } else { a.setModel(b) } } }, applyWriter: function (b) { var a = this.getReader(); b = Ext.Factory.writer(b); if (b.getRecord && !b.getRecord() && a && a.getRecord) { a = a.getRecord(); if (a) { b.setRecord(a) } } return b }, abort: Ext.emptyFn, onMetaChange: function (a) { this.fireEvent("metachange", this, a) }, create: Ext.emptyFn, read: Ext.emptyFn, update: Ext.emptyFn, erase: Ext.emptyFn, batch: function (o, l) { var k = this, j = k.getBatchActions(), h, c, g, d, e, m, b, n, i; if (o.operations === undefined) { o = { operations: o, listeners: l } } if (o.batch) { if (Ext.isDefined(o.batch.runOperation)) { h = Ext.applyIf(o.batch, { proxy: k, listeners: {} }) } } else { o.batch = { proxy: k, listeners: o.listeners || {} } } if (!h) { h = new Ext.data.Batch(o.batch) } h.on("complete", Ext.bind(k.onBatchComplete, k, [o], 0)); g = k.getBatchOrder().split(","); d = g.length; for (m = 0; m < d; m++) { e = g[m]; c = o.operations[e]; if (c) { if (j) { h.add(k.createOperation(e, { records: c, params: o.params })) } else { n = c.length; for (b = 0; b < n; b++) { i = c[b]; h.add(k.createOperation(e, { records: [i], params: o.params })) } } } } h.start(); return h }, onBatchComplete: function (a, b) { var c = a.scope || this; if (b.hasException()) { if (Ext.isFunction(a.failure)) { Ext.callback(a.failure, c, [b, a]) } } else { if (Ext.isFunction(a.success)) { Ext.callback(a.success, c, [b, a]) } } if (Ext.isFunction(a.callback)) { Ext.callback(a.callback, c, [b, a]) } }, createOperation: function (c, b) { var a = Ext.createByAlias("data.operation." + c, b); a.setProxy(this); this.pendingOperations[a._internalId] = a; return a }, completeOperation: function (a) { delete this.pendingOperations[a._internalId] }, clone: function () { return new this.self(this.getInitialConfig()) }, destroy: function () { var b = this.pendingOperations, a, c; for (a in b) { c = b[a]; if (c && c.isRunning()) { c.abort() } } this.pendingOperations = null; this.callParent() } }, 1, 0, 0, 0, ["proxy.proxy"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable], [Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.data.proxy, "Proxy", Ext.data, "DataProxy", Ext.data, "Proxy"], 0)); (Ext.cmd.derive("Ext.data.proxy.Client", Ext.data.proxy.Proxy, { alternateClassName: "Ext.data.ClientProxy", isSynchronous: true, clear: function () { } }, 0, 0, 0, 0, 0, 0, [Ext.data.proxy, "Client", Ext.data, "ClientProxy"], 0)); (Ext.cmd.derive("Ext.data.proxy.Memory", Ext.data.proxy.Client, { alternateClassName: "Ext.data.MemoryProxy", isMemoryProxy: true, config: { enablePaging: false, data: { $value: null, merge: function (d, a, c, b) { if (Ext.isArray(d)) { return Ext.Array.clone(d) } else { return Ext.clone(d) } } } }, finishOperation: function (b) { var c = 0, d = b.getRecords(), a = d.length; for (c; c < a; c++) { d[c].dropped = !!b.isDestroyOperation; d[c].commit() } b.setSuccessful(true) }, create: function (a) { this.finishOperation(a) }, update: function (a) { this.finishOperation(a) }, erase: function (a) { this.finishOperation(a) }, read: function (g) { var i = this, j = i.getReader().read(i.getData()), d = j.getRecords(), h = g.getSorters(), a = g.getGrouper(), c = g.getFilters(), b = g.getStart(), e = g.getLimit(), k; if (g.process(j, null, null, false) !== false) { if (c && c.length) { j.setRecords(d = Ext.Array.filter(d, Ext.util.Filter.createFilterFn(c))); j.setTotal(d.length) } if (a) { h = h ? h.concat(a) : h } if (h && h.length) { j.setRecords(d = Ext.Array.sort(d, Ext.util.Sortable.createComparator(h))) } if (i.getEnablePaging() && b !== undefined && e !== undefined) { if (b >= j.getTotal()) { j.setConfig({ success: false, records: [], total: 0 }) } else { j.setRecords(Ext.Array.slice(d, b, b + e)) } } g.setCompleted(); if (k = j.getMetadata()) { i.onMetaChange(k) } } }, clear: Ext.emptyFn }, 0, 0, 0, 0, ["proxy.memory"], 0, [Ext.data.proxy, "Memory", Ext.data, "MemoryProxy"], 0)); (Ext.cmd.derive("Ext.data.ProxyStore", Ext.data.AbstractStore, { config: { model: undefined, fields: null, proxy: undefined, autoLoad: undefined, autoSync: false, batchUpdateMode: "operation", sortOnLoad: true, trackRemoved: true, asynchronousLoad: undefined }, onClassExtended: function (b, d, a) { var c = d.model, e; if (typeof c === "string") { e = a.onBeforeCreated; a.onBeforeCreated = function () { var h = this, g = arguments; Ext.require(c, function () { e.apply(h, g) }) } } }, implicitModel: "Ext.data.Model", autoSyncSuspended: 0, constructor: function (a) { var b = this; b.removed = []; Ext.data.AbstractStore.prototype.constructor.apply(this, arguments); if (b.getAsynchronousLoad() === false) { b.flushLoad() } }, applyAsynchronousLoad: function (a) { if (a == null) { a = !this.loadsSynchronously() } return a }, updateAutoLoad: function (a) { this.getData(); if (a) { this.load(Ext.isObject(a) ? a : undefined) } }, getTotalCount: function () { return this.totalCount || 0 }, applyFields: function (a) { if (a) { this.createImplicitModel(a) } }, applyModel: function (a) { if (a) { a = Ext.data.schema.Schema.lookupEntity(a) } else { if (!this.destroying) { this.getFields(); a = this.getModel() || this.createImplicitModel() } } return a }, applyProxy: function (b) { var a = this.getModel(); if (b !== null) { if (b) { if (b.isProxy) { b.setModel(a) } else { if (Ext.isString(b)) { b = { type: b, model: a } } else { if (!b.model) { b = Ext.apply({ model: a }, b) } } b = Ext.createByAlias("proxy." + b.type, b); b.autoCreated = true } } else { if (a) { b = a.getProxy(); this.useModelProxy = true } } if (!b) { b = Ext.createByAlias("proxy.memory"); b.autoCreated = true } } return b }, applyState: function (b) { var a = this; Ext.data.AbstractStore.prototype.applyState.call(this, b); if (a.getAutoLoad() || a.isLoaded()) { a.load() } }, updateProxy: function (b, a) { this.proxyListeners = Ext.destroy(this.proxyListeners) }, updateTrackRemoved: function (a) { this.cleanRemoved(); this.removed = a ? [] : null }, onMetaChange: function (a, b) { this.fireEvent("metachange", this, b) }, create: function (e, c) { var d = this, g = d.getModel(), a = new g(e), b; c = Ext.apply({}, c); if (!c.records) { c.records = [a] } c.internalScope = d; c.internalCallback = d.onProxyWrite; b = d.createOperation("create", c); return b.execute() }, read: function () { return this.load.apply(this, arguments) }, update: function (b) { var c = this, a; b = Ext.apply({}, b); if (!b.records) { b.records = c.getUpdatedRecords() } b.internalScope = c; b.internalCallback = c.onProxyWrite; a = c.createOperation("update", b); return a.execute() }, onProxyWrite: function (b) { var c = this, d = b.wasSuccessful(), a = b.getRecords(); switch (b.getAction()) { case "create": c.onCreateRecords(a, b, d); break; case "update": c.onUpdateRecords(a, b, d); break; case "destroy": c.onDestroyRecords(a, b, d); break }if (d) { c.fireEvent("write", c, b); c.fireEvent("datachanged", c) } }, onCreateRecords: Ext.emptyFn, onUpdateRecords: Ext.emptyFn, onDestroyRecords: function (b, a, c) { if (c) { this.cleanRemoved() } }, erase: function (b) { var c = this, a; b = Ext.apply({}, b); if (!b.records) { b.records = c.getRemovedRecords() } b.internalScope = c; b.internalCallback = c.onProxyWrite; a = c.createOperation("destroy", b); return a.execute() }, onBatchOperationComplete: function (b, a) { return this.onProxyWrite(a) }, onBatchComplete: function (c, a) { var g = this, b = c.operations, e = b.length, d; if (g.batchUpdateMode !== "operation") { g.suspendEvents(); for (d = 0; d < e; d++) { g.onProxyWrite(b[d]) } g.resumeEvents() } g.isSyncing = false; g.fireEvent("datachanged", g) }, onBatchException: function (b, a) { }, filterNew: function (a) { return a.phantom === true && a.isValid() }, getNewRecords: function () { return [] }, getUpdatedRecords: function () { return [] }, getModifiedRecords: function () { return [].concat(this.getNewRecords(), this.getUpdatedRecords()) }, filterUpdated: function (a) { return a.dirty === true && a.phantom !== true && a.isValid() }, getRemovedRecords: function () { var a = this.getRawRemovedRecords(); return a ? Ext.Array.clone(a) : [] }, sync: function (c) { var e = this, b = {}, g = e.getNewRecords(), d = e.getUpdatedRecords(), a = e.getRemovedRecords(), h = false; e.needsSync = false; if (g.length > 0) { b.create = g; h = true } if (d.length > 0) { b.update = d; h = true } if (a.length > 0) { b.destroy = a; h = true } if (h && e.fireEvent("beforesync", b) !== false) { e.isSyncing = true; c = c || {}; e.proxy.batch(Ext.apply(c, { operations: b, listeners: e.getBatchListeners() })) } return e }, getBatchListeners: function () { var b = this, a = { scope: b, exception: b.onBatchException, complete: b.onBatchComplete }; if (b.batchUpdateMode === "operation") { a.operationcomplete = b.onBatchOperationComplete } return a }, save: function () { return this.sync.apply(this, arguments) }, load: function (a) { var b = this; if (typeof a === "function") { a = { callback: a } } else { a = a ? Ext.Object.chain(a) : {} } b.pendingLoadOptions = a; if (b.getAsynchronousLoad()) { if (!b.loadTimer) { b.loadTimer = Ext.asap(b.flushLoad, b) } } else { b.flushLoad() } return b }, flushLoad: function () { var c = this, b = c.pendingLoadOptions, a; c.clearLoadTask(); if (!b) { return } c.setLoadOptions(b); if (c.getRemoteSort() && b.sorters) { c.fireEvent("beforesort", c, b.sorters) } a = Ext.apply({ internalScope: c, internalCallback: c.onProxyLoad, scope: c }, b); c.lastOptions = a; a = c.createOperation("read", a); if (c.fireEvent("beforeload", c, a) !== false) { c.onBeforeLoad(a); c.loading = true; a.execute() } }, reload: function (a) { return this.load(Ext.apply({}, a, this.lastOptions)) }, onEndUpdate: function () { var a = this; if (a.needsSync && a.autoSync && !a.autoSyncSuspended) { a.sync() } }, afterReject: function (a) { var b = this; if (b.contains(a)) { b.onUpdate(a, Ext.data.Model.REJECT, null); b.fireEvent("update", b, a, Ext.data.Model.REJECT, null) } }, afterCommit: function (a, c) { var b = this; if (!c) { c = null } if (b.contains(a)) { b.onUpdate(a, Ext.data.Model.COMMIT, c); b.fireEvent("update", b, a, Ext.data.Model.COMMIT, c) } }, afterErase: function (a) { this.onErase(a) }, onErase: Ext.emptyFn, onUpdate: Ext.emptyFn, doDestroy: function () { var b = this, a = b.getProxy(); b.clearLoadTask(); b.getData().destroy(); b.data = null; b.setProxy(null); if (a.autoCreated) { a.destroy() } b.setModel(null); Ext.data.AbstractStore.prototype.doDestroy.call(this) }, hasPendingLoad: function () { return !!this.pendingLoadOptions || this.isLoading() }, isLoading: function () { return !!this.loading }, isLoaded: function () { return this.loadCount > 0 }, suspendAutoSync: function () { ++this.autoSyncSuspended }, resumeAutoSync: function (b) { var a = this; if (a.autoSyncSuspended && !--a.autoSyncSuspended) { if (b) { a.sync() } } }, removeAll: Ext.emptyFn, clearData: Ext.emptyFn, privates: { getRawRemovedRecords: function () { return this.removed }, onExtraParamsChanged: function () { }, clearLoadTask: function () { if (this.loadTimer) { Ext.asapCancel(this.loadTimer) } this.pendingLoadOptions = this.loadTimer = null }, cleanRemoved: function () { var c = this.getRawRemovedRecords(), a, b; if (c) { for (b = 0, a = c.length; b < a; ++b) { c[b].unjoin(this) } c.length = 0 } }, createOperation: function (d, a) { var e = this, b = e.getProxy(), c; if (!e.proxyListeners) { c = { scope: e, destroyable: true, beginprocessresponse: e.beginUpdate, endprocessresponse: e.endUpdate }; if (!e.disableMetaChangeEvent) { c.metachange = e.onMetaChange } e.proxyListeners = b.on(c) } return b.createOperation(d, a) }, createImplicitModel: function (a) { var e = this, b = { extend: e.implicitModel, statics: { defaultProxy: "memory" } }, d, c; if (a) { b.fields = a } c = Ext.define(null, b); e.setModel(c); d = e.getProxy(); if (d) { c.setProxy(d) } else { e.setProxy(c.getProxy()) } }, loadsSynchronously: function () { return this.getProxy().isSynchronous }, onBeforeLoad: Ext.privateFn, removeFromRemoved: function (a) { var b = this.getRawRemovedRecords(); if (b) { Ext.Array.remove(b, a); a.unjoin(this) } }, setLoadOptions: function (a) { var c = this, b, d; if (c.getRemoteFilter()) { b = c.getFilters(false); if (b && b.getCount()) { a.filters = b.getRange() } } if (c.getRemoteSort()) { d = c.getSorters(false); if (d && d.getCount()) { a.sorters = d.getRange() } } } } }, 1, 0, 0, 0, 0, 0, [Ext.data, "ProxyStore"], 0)); (Ext.cmd.derive("Ext.data.LocalStore", Ext.Mixin, { mixinConfig: { id: "localstore" }, config: { extraKeys: null }, applyExtraKeys: function (a) { var c, b = this.getData(); b.setExtraKeys(a); a = b.getExtraKeys(); for (c in a) { this[c] = a[c] } }, add: function (a) { return this.insert(this.getCount(), arguments.length === 1 ? a : arguments) }, constructDataCollection: function () { var a = new Ext.util.Collection({ rootProperty: "data" }); a.addObserver(this); return a }, createModel: function (a) { var b = this.getSession(), c; if (!a.isModel) { c = this.getModel(); a = new c(a, b) } return a }, createFiltersCollection: function () { return this.getData().getFilters() }, createSortersCollection: function () { var a = this.getData().getSorters(); a.setSorterConfigure(this.addFieldTransform, this); return a }, onCollectionBeginUpdate: function () { this.beginUpdate() }, onCollectionEndUpdate: function () { this.endUpdate() }, onCollectionSort: function () { this.onSorterEndUpdate() }, onCollectionFilter: function () { this.onFilterEndUpdate() }, notifySorterChange: function () { this.getData().onSorterChange() }, forceLocalSort: function () { this.getData().onSortChange() }, contains: function (a) { return this.indexOf(a) > -1 }, each: function (e, d, h) { var g = this.getData(), a, b, c; if (typeof h === "object") { h = h.filtered } if (h === true && g.filtered) { g = g.getSource() } g = g.items.slice(0); a = g.length; for (c = 0; c < a; ++c) { b = g[c]; if (e.call(d || b, b, c, a) === false) { break } } }, collect: function (b, a, e) { var c = this, d = c.getData(); if (typeof a === "object") { e = a.filtered; a = a.allowNull } if (e === true && d.filtered) { d = d.getSource() } return d.collect(b, "data", a) }, getById: function (b) { var a = this.getData(); if (a.filtered) { a = a.getSource() } return a.get(b) || null }, getByInternalId: function (a) { var c = this.getData(), b; if (c.filtered) { if (!c.$hasExtraKeys) { b = this.makeInternalKeyCfg(); c.setExtraKeys(b); c.$hasExtraKeys = true } c = c.getSource() } if (!c.$hasExtraKeys) { c.setExtraKeys(b || this.makeInternalKeyCfg()); c.$hasExtraKeys = true } return c.byInternalId.get(a) || null }, getDataSource: function () { var a = this.getData(); return a.getSource() || a }, indexOf: function (a) { return this.getData().indexOf(a) }, indexOfId: function (a) { return this.indexOf(this.getById(a)) }, insert: function (c, b) { var e = this, a, d; if (b) { if (!Ext.isIterable(b)) { b = [b] } else { b = Ext.Array.clone(b) } a = b.length } if (!a) { return [] } for (d = 0; d < a; ++d) { b[d] = e.createModel(b[d]) } e.getData().insert(c, b); return b }, queryBy: function (b, a) { var c = this.getData(); return (c.getSource() || c).createFiltered(b, a) }, query: function (e, d, g, a, b) { var c = this.getData(); return (c.getSource() || c).createFiltered(e, d, g, a, b) }, first: function (a) { return this.getData().first(a) || null }, last: function (a) { return this.getData().last(a) || null }, sum: function (c, a) { var b = this.getData(); return (a && this.isGrouped()) ? b.sumByGroup(c) : b.sum(c) }, count: function (a) { var b = this.getData(); return (a && this.isGrouped()) ? b.countByGroup() : b.count() }, min: function (c, a) { var b = this.getData(); return (a && this.isGrouped()) ? b.minByGroup(c) : b.min(c) }, max: function (c, a) { var b = this.getData(); return (a && this.isGrouped()) ? b.maxByGroup(c) : b.max(c) }, average: function (c, a) { var b = this.getData(); return (a && this.isGrouped()) ? b.averageByGroup(c) : b.average(c) }, aggregate: function (h, l, e, j) { var g = this, a, d, b, k, c; if (e && g.isGrouped()) { a = g.getGroups().items; d = a.length; b = {}; for (c = 0; c < d; ++c) { k = a[c]; b[k.getGroupKey()] = g.getAggregate(h, l || g, k.items, j) } return b } else { return g.getAggregate(h, l, g.getData().items, j) } }, getAggregate: function (g, e, c, h) { var b = [], a = c.length, d; for (d = 0; d < a; ++d) { b[d] = c[d].get(h) } return g.call(e || this, c, b) }, addObserver: function (a) { var b = this.observers; if (!b) { this.observers = b = new Ext.util.Collection() } b.add(a) }, removeObserver: function (a) { var b = this.observers; if (b) { b.remove(a) } }, callObservers: function (h, d) { var j = this.observers, a, c, e, b, g; if (j) { c = j.items; if (d) { d.unshift(this) } else { d = [this] } for (e = 0, a = c.length; e < a; ++e) { g = c[e]; b = "onSource" + h; if (g[b]) { g[b].apply(g, d) } } } }, queryRecordsBy: function (e, d) { var h = this.getData(), g = [], a, c, b; h = (h.getSource() || h).items; d = d || this; for (c = 0, a = h.length; c < a; ++c) { b = h[c]; if (e.call(d, b) === true) { g.push(b) } } return g }, queryRecords: function (h, g) { var e = this.getData(), d = [], a, c, b; e = (e.getSource() || e).items; for (c = 0, a = e.length; c < a; ++c) { b = e[c]; if (b.get(h) === g) { d.push(b) } } return d }, privates: { isLast: function (a) { return a === this.last() }, makeInternalKeyCfg: function () { return { byInternalId: { property: "internalId", rootProperty: "" } } } } }, 0, 0, 0, 0, 0, 0, [Ext.data, "LocalStore"], 0)); (Ext.cmd.derive("Ext.data.proxy.Server", Ext.data.proxy.Proxy, { alternateClassName: "Ext.data.ServerProxy", isRemote: true, config: { url: "", pageParam: "page", startParam: "start", limitParam: "limit", groupParam: "group", groupDirectionParam: "groupDir", sortParam: "sort", filterParam: "filter", directionParam: "dir", idParam: "id", simpleSortMode: false, simpleGroupMode: false, noCache: true, cacheString: "_dc", timeout: 30000, api: { create: undefined, read: undefined, update: undefined, destroy: undefined }, extraParams: {} }, create: function () { return this.doRequest.apply(this, arguments) }, read: function () { return this.doRequest.apply(this, arguments) }, update: function () { return this.doRequest.apply(this, arguments) }, erase: function () { return this.doRequest.apply(this, arguments) }, setExtraParam: function (a, b) { var c = this.getExtraParams(); c[a] = b; this.fireEvent("extraparamschanged", c) }, updateExtraParams: function (b, a) { this.fireEvent("extraparamschanged", b) }, buildRequest: function (a) { var g = this, b = Ext.apply({}, a.getParams()), h = Ext.applyIf(b, g.getExtraParams() || {}), e, d, c; Ext.applyIf(h, g.getParams(a)); d = a.getId(); c = g.getIdParam(); if (d !== undefined && h[c] === undefined) { h[c] = d } e = new Ext.data.Request({ params: h, action: a.getAction(), records: a.getRecords(), url: a.getUrl(), operation: a, proxy: g }); e.setUrl(g.buildUrl(e)); a.setRequest(e); return e }, processResponse: function (i, b, d, c) { var g = this, a, e, h, j; if (g.destroying || g.destroyed) { return } g.fireEvent("beginprocessresponse", g, c, b); if (i === true) { e = g.getReader(); if (c.status === 204) { h = e.getNullResultSet() } else { h = e.read(g.extractResponseData(c), { recordCreator: b.getRecordCreator() }) } b.process(h, d, c); a = !b.wasSuccessful() } else { g.setException(b, c); a = true } if (a) { g.fireEvent("exception", g, c, b) } else { j = h.getMetadata(); if (j) { g.onMetaChange(j) } } g.afterRequest(d, i); g.fireEvent("endprocessresponse", g, c, b) }, setException: function (b, a) { b.setException({ status: a.status, statusText: a.statusText, response: a }) }, extractResponseData: Ext.identityFn, applyEncoding: function (a) { return Ext.encode(a) }, encodeSorters: function (e, c) { var a = [], d = e.length, b; for (b = 0; b < d; b++) { a[b] = e[b].serialize() } return this.applyEncoding(c ? a[0] : a) }, encodeFilters: function (e) { var a = [], d = e.length, b, c; for (b = 0; b < d; b++) { c = e[b]; c.getFilterFn(); if (c.generatedFilterFn) { a.push(c.serialize()) } } return this.applyEncoding(a) }, getParams: function (p) { if (!p.isReadOperation) { return {} } var v = this, u = {}, s = p.getGrouper(), a = p.getSorters(), n = p.getFilters(), i = p.getPage(), h = p.getStart(), t = p.getLimit(), l = v.getSimpleSortMode(), d = v.getSimpleGroupMode(), r = v.getPageParam(), e = v.getStartParam(), b = v.getLimitParam(), c = v.getGroupParam(), m = v.getGroupDirectionParam(), g = v.getSortParam(), q = v.getFilterParam(), o = v.getDirectionParam(), k, j; if (r && i) { u[r] = i } if (e && (h || h === 0)) { u[e] = h } if (b && t) { u[b] = t } k = c && s; if (k) { if (d) { u[c] = s.getProperty(); u[m] = s.getDirection() } else { u[c] = v.encodeSorters([s], true) } } if (g && a && a.length > 0) { if (l) { j = 0; if (a.length > 1 && k) { j = 1 } u[g] = a[j].getProperty(); u[o] = a[j].getDirection() } else { u[g] = v.encodeSorters(a) } } if (q && n && n.length > 0) { u[q] = v.encodeFilters(n) } return u }, buildUrl: function (c) { var b = this, a = b.getUrl(c); if (b.getNoCache()) { a = Ext.urlAppend(a, Ext.String.format("{0}={1}", b.getCacheString(), Ext.Date.now())) } return a }, getUrl: function (b) { var a; if (b) { a = b.getUrl() || this.getApi()[b.getAction()] } return a ? a : (arguments.callee.$previous || Ext.data.proxy.Proxy.prototype.getUrl).call(this) }, doRequest: function (a) { }, afterRequest: Ext.emptyFn, destroy: function () { var a = this; a.destroying = true; a.reader = a.writer = Ext.destroy(a.reader, a.writer); Ext.data.proxy.Proxy.prototype.destroy.call(this); a.destroying = false; a.destroyed = true } }, 0, 0, 0, 0, ["proxy.server"], 0, [Ext.data.proxy, "Server", Ext.data, "ServerProxy"], 0)); (Ext.cmd.derive("Ext.data.proxy.Ajax", Ext.data.proxy.Server, { alternateClassName: ["Ext.data.HttpProxy", "Ext.data.AjaxProxy"], isAjaxProxy: true, defaultActionMethods: { create: "POST", read: "GET", update: "POST", destroy: "POST" }, config: { binary: false, headers: undefined, paramsAsJson: false, withCredentials: false, useDefaultXhrHeader: true, username: null, password: null, actionMethods: { create: "POST", read: "GET", update: "POST", destroy: "POST" } }, doRequest: function (a) { var d = this, e = d.getWriter(), c = d.buildRequest(a), h = d.getMethod(c), b, g; if (e && a.allowWrite()) { c = e.write(c) } c.setConfig({ binary: d.getBinary(), headers: d.getHeaders(), timeout: d.getTimeout(), scope: d, callback: d.createRequestCallback(c, a), method: h, useDefaultXhrHeader: d.getUseDefaultXhrHeader(), disableCaching: false }); if (h.toUpperCase() !== "GET" && d.getParamsAsJson()) { g = c.getParams(); if (g) { b = c.getJsonData(); if (b) { b = Ext.Object.merge({}, b, g) } else { b = g } c.setJsonData(b); c.setParams(undefined) } } if (d.getWithCredentials()) { c.setWithCredentials(true); c.setUsername(d.getUsername()); c.setPassword(d.getPassword()) } return d.sendRequest(c) }, sendRequest: function (a) { a.setRawRequest(Ext.Ajax.request(a.getCurrentConfig())); this.lastRequest = a; return a }, abort: function (a) { a = a || this.lastRequest; if (a) { Ext.Ajax.abort(a.getRawRequest()) } }, getMethod: function (a) { var c = this.getActionMethods(), b = a.getAction(), d; if (c) { d = c[b] } return d || this.defaultActionMethods[b] }, createRequestCallback: function (c, a) { var b = this; return function (e, g, d) { if (c === b.lastRequest) { b.lastRequest = null } b.processResponse(g, a, c, d) } }, destroy: function () { this.lastRequest = null; Ext.data.proxy.Server.prototype.destroy.call(this) } }, 0, 0, 0, 0, ["proxy.ajax"], 0, [Ext.data.proxy, "Ajax", Ext.data, "HttpProxy", Ext.data, "AjaxProxy"], 0)); (Ext.cmd.derive("Ext.data.reader.Json", Ext.data.reader.Reader, { alternateClassName: "Ext.data.JsonReader", config: { record: null, metaProperty: "metaData", useSimpleAccessors: false, preserveRawData: false }, updateRootProperty: function () { this.forceBuildExtractors() }, updateMetaProperty: function () { this.forceBuildExtractors() }, getResponseData: function (a) { var b; try { return Ext.decode(a.responseText) } catch (c) { b = this.createReadError(c.message); Ext.Logger.warn("Unable to parse the JSON returned by the server"); this.fireEvent("exception", this, a, b); return b } }, buildExtractors: function () { var c = this, a, b; if (Ext.data.reader.Reader.prototype.buildExtractors.apply(this, arguments)) { a = c.getMetaProperty(); b = c.getRootProperty(); if (b) { c.getRoot = c.getAccessor(b) } else { c.getRoot = Ext.identityFn } if (a) { c.getMeta = c.getAccessor(a) } } }, extractData: function (a, e) { var g = this.getRecord(), d = [], c, b; if (g) { c = a.length; if (!c && Ext.isObject(a)) { c = 1; a = [a] } for (b = 0; b < c; b++) { d[b] = a[b][g] } } else { d = a } return Ext.data.reader.Reader.prototype.extractData.call(this, d, e) }, getModelData: function (a) { return this.getPreserveRawData() ? Ext.apply({}, a) : a }, createAccessor: (function () { var a = /[\[\.]/; return function (r) { var n = this, b = n.getUseSimpleAccessors(), e, u, k, g, d, q, t, p, o, l, m, h, s, j; if (!(r || r === 0)) { return } if (typeof r === "function") { return r } if (!b) { e = String(r).search(a) } if (b === true || e < 0) { u = function (c) { return c[r] } } else { k = "raw"; g = []; d = ""; q = 0; j = r.length; for (h = 0; h <= j; ++h) { m = r[h]; t = m === "."; p = m === "["; o = m === "]"; l = t || p || o || !m; if (!l || q > 1 || (q && !o)) { d += m } else { if (l) { s = false; if (p) { ++q } else { if (o) { --q; s = true } } if (d) { if (s) { d = "[" + d + "]" } else { d = "." + d } k += d; g.push("" + k); d = "" } } } } u = g.join(" && "); u = Ext.functionFactory("raw", "return " + u) } return u } }()), createFieldAccessor: function (e) { var b = this, a = e.mapping, c = a || a === 0, d = c ? a : e.name; if (c) { if (typeof d === "function") { return function (g) { return e.mapping(g, b) } } else { return b.createAccessor(d) } } }, getAccessorKey: function (b) { var a = this.getUseSimpleAccessors() ? "simple" : ""; return this.$className + a + b }, privates: { copyFrom: function (a) { Ext.data.reader.Reader.prototype.copyFrom.call(this, a); this.getRoot = a.getRoot } } }, 0, 0, 0, 0, ["reader.json"], 0, [Ext.data.reader, "Json", Ext.data, "JsonReader"], 0)); (Ext.cmd.derive("Ext.data.writer.Json", Ext.data.writer.Writer, { alternateClassName: "Ext.data.JsonWriter", config: { rootProperty: undefined, encode: false, allowSingle: true, expandData: false }, getExpandedData: function (d) { var b = d.length, e = 0, k, a, g, c, h, l = function (i, j) { var m = {}; m[i] = j; return m }; for (; e < b; e++) { k = d[e]; for (a in k) { if (k.hasOwnProperty(a)) { g = a.split("."); c = g.length - 1; if (c > 0) { h = k[a]; for (; c > 0; c--) { h = l(g[c], h) } k[g[0]] = k[g[0]] || {}; Ext.Object.merge(k[g[0]], h); delete k[a] } } } } return d }, writeRecords: function (e, g) { var d = this, a = d.getRootProperty(), c, h, b; if (d.getExpandData()) { g = d.getExpandedData(g) } if (d.getAllowSingle() && g.length === 1) { g = g[0]; h = true } b = this.getTransform(); if (b) { g = b(g, e) } if (d.getEncode()) { if (a) { e.setParam(a, Ext.encode(g)) } else { } } else { if (h || (g && g.length)) { c = e.getJsonData() || {}; if (a) { c[a] = g } else { c = g } e.setJsonData(c) } } return e } }, 0, 0, 0, 0, ["writer.json"], 0, [Ext.data.writer, "Json", Ext.data, "JsonWriter"], 0)); (Ext.cmd.derive("Ext.util.Group", Ext.util.Collection, { config: { groupKey: null }, $endUpdatePriority: 2001, manageSorters: false }, 0, 0, 0, 0, 0, 0, [Ext.util, "Group"], 0)); (Ext.cmd.derive("Ext.util.SorterCollection", Ext.util.Collection, { isSorterCollection: true, $sortable: null, sortFn: null, config: { sorterOptionsFn: null, sorterOptionsScope: null }, constructor: function (a) { var b = this; b.sortFn = Ext.util.Sorter.createComparator(b); Ext.util.Collection.prototype.constructor.call(this, a); b.setDecoder(b.decodeSorter) }, addSort: function (j, i, c) { var h = this, d, e, b, l, a, k, g; if (!j) { h.beginUpdate(); h.endUpdate() } else { l = h.getOptions(); if (j instanceof Array) { g = j; c = i; i = null } else { if (Ext.isString(j)) { if (!(k = h.get(j))) { g = [{ property: j, direction: i || l.getDefaultSortDirection() }] } else { g = [k] } } else { if (Ext.isFunction(j)) { g = [{ sorterFn: j, direction: i || l.getDefaultSortDirection() }] } else { g = [j]; c = i; i = null } } } c = h._sortModes[c || "replace"]; a = h.getAt(0); d = h.length; e = c.append ? d : 0; h.beginUpdate(); h.splice(e, c.replace ? d : 0, g); if (c.multi) { d = h.length; b = l.getMultiSortLimit(); if (d > b) { h.removeAt(b, d) } } if (k && i) { k.setDirection(i) } else { if (e === 0 && a && a === h.getAt(0)) { a.toggle() } } h.endUpdate() } }, clear: function () { this.beginUpdate(); Ext.util.Collection.prototype.clear.call(this); this.endUpdate(this.items) }, getSortFn: function () { return this.sortFn }, getByProperty: function (e) { var b = this.items, a = b.length, c, d; for (c = 0; c < a; ++c) { d = b[c]; if (d.getProperty() === e) { return d } } return null }, _sortModes: { append: { append: 1 }, multi: { multi: 1 }, prepend: { prepend: 1 }, replace: { replace: 1 } }, decodeSorter: function (i, a) { var g = this, j = g.getOptions(), h = j.getRootProperty(), b = g.getSorterOptionsFn(), c, e, d; if (i.isSorter) { if (!i.getRoot()) { i.setRoot(h) } } else { e = { direction: j.getDefaultSortDirection(), root: h }; d = typeof i; if (d === "string") { c = g.get(i); if (c) { return c } e.property = i } else { if (d === "function") { e.sorterFn = i } else { e = Ext.apply(e, i); if (e.fn) { e.sorterFn = e.fn; delete e.fn } } } i = Ext.create(a || "Ext.util.Sorter", e) } if (b) { b.call(g.getSorterOptionsScope() || g, i) } return i }, setSorterConfigure: function (b, a) { this.setSorterOptionsFn(b); this.setSorterOptionsScope(a) }, decodeRemoveItems: function (h, d) { var k = this, e = (d === undefined) ? h : h[d]; if (!e || !e.$cloned) { if (h.length > d + 1 || !Ext.isIterable(e)) { e = Ext.Array.slice(h, d) } var l = k.items, g = e.length, c = [], b, m, a, o, j; for (b = 0; b < g; b++) { o = e[b]; if (o && o.isSorter) { c.push(o) } else { j = typeof o; if (j === "string") { o = k.get(o); if (o) { c.push(o) } } else { if (j === "function") { for (a = l.length; a-- > 0;) { m = l[a]; if (m.getSorterFn() === o) { c.push(m) } } } } } } e = c; e.$cloned = true } return e }, getOptions: function () { return this.$sortable || this } }, 1, 0, 0, 0, 0, 0, [Ext.util, "SorterCollection"], 0)); (Ext.cmd.derive("Ext.util.FilterCollection", Ext.util.Collection, { isFilterCollection: true, $filterable: null, filterFn: null, constructor: function (a) { var b = this; b.filterFn = Ext.util.Filter.createFilterFn(b); Ext.util.Collection.prototype.constructor.call(this, a); b.setDecoder(b.decodeFilter) }, filterData: function (a) { return this.filtered ? Ext.Array.filter(a, this.filterFn) : a }, getFilterFn: function () { return this.filterFn }, isItemFiltered: function (a) { return !this.filterFn(a) }, decodeFilter: function (c) { var b = this.getOptions(), a = b.getRootProperty(), d; if (c.isFilter) { if (!c.getRoot()) { c.setRoot(a) } } else { d = { root: a }; if (Ext.isFunction(c)) { d.filterFn = c } else { d = Ext.apply(d, c); if (d.fn) { d.filterFn = d.fn; delete d.fn } if (Ext.util.Filter.isInvalid(d)) { return false } } c = new Ext.util.Filter(d) } return c }, decodeRemoveItems: function (p, k) { var r = this, l = (k === undefined) ? p : p[k]; if (!l.$cloned) { if (p.length > k + 1 || !Ext.isIterable(l)) { l = Ext.Array.slice(p, k) } var e = r.items, o = l.length, h = [], b, g, c, m, a, s, j, d, q; for (g = 0; g < o; g++) { b = l[g]; if (b && b.isFilter) { h.push(b) } else { q = typeof b; c = q === "function"; m = b.property !== undefined && b.value !== undefined; a = q === "string"; for (d = e.length; d-- > 0;) { s = e[d]; j = false; if (a) { j = s.getProperty() === b } else { if (c) { j = s.getFilterFn() === b } else { if (m) { j = s.getProperty() === b.property && s.getValue() === b.value } } } if (j) { h.push(s) } } } } l = h; l.$cloned = true } return l }, getOptions: function () { return this.$filterable || this } }, 1, 0, 0, 0, 0, 0, [Ext.util, "FilterCollection"], 0)); (Ext.cmd.derive("Ext.util.GroupCollection", Ext.util.Collection, { isGroupCollection: true, config: { grouper: null, itemRoot: null }, observerPriority: -100, constructor: function (a) { Ext.util.Collection.prototype.constructor.call(this, a); this.on("remove", "onGroupRemove", this) }, onCollectionAdd: function (b, a) { this.addItemsToGroups(b, a.items, a.at) }, onCollectionBeforeItemChange: function (b, a) { this.changeDetails = a }, onCollectionBeginUpdate: function () { this.beginUpdate() }, onCollectionEndUpdate: function () { this.endUpdate() }, onCollectionItemChange: function (c, a) { var b = a.item; if (!a.indexChanged) { this.syncItemGrouping(c, b, c.getKey(b), a.oldKey, a.oldIndex) } this.changeDetails = null }, onCollectionRefresh: function (a) { this.removeAll(); this.addItemsToGroups(a, a.items) }, onCollectionRemove: function (a, b) { var h = this, l = h.changeDetails, g, j, k, e, c, d, m; if (l) { m = l.item; k = h.findGroupForItem(m); g = []; if (k) { g.push({ group: k, items: [m] }) } } else { g = h.groupItems(a, b.items, false) } for (e = 0, c = g.length; e < c; ++e) { k = (j = g[e]).group; if (k) { k.remove(j.items); if (!k.length) { (d || (d = [])).push(k) } } } if (d) { h.remove(d) } }, onCollectionSort: function (e) { var d = this, h = e.getSorters(false), a, c, b, g; if (h) { a = d.items; c = d.length; for (b = 0; b < c; ++b) { g = a[b]; if (g.getSorters() !== h) { g.setSorters(h) } } } }, onCollectionUpdateKey: function (d, b) { var a = b.index, c = b.item; if (!b.indexChanged) { a = d.indexOf(c); this.syncItemGrouping(d, c, b.newKey, b.oldKey, a) } }, addItemsToGroups: function (c, b, a) { this.groupItems(c, b, true, a) }, groupItems: function (k, h, n, g) { var s = this, l = {}, e = [], j = k.getGrouper(), a = s.itemGroupKeys, c, b, d, p, m, r, q, o, t; for (m = 0, o = h.length; m < o; ++m) { p = j.getGroupString(r = h[m]); q = k.getKey(r); if (n) { (a || (s.itemGroupKeys = a = {}))[q] = p } else { if (a) { delete a[q] } } if (!(b = l[p])) { if (!(d = s.getByKey(p)) && n) { (t || (t = [])).push(d = s.createGroup(k, p)) } e.push(l[p] = b = { group: d, items: [] }) } b.items.push(r) } if (n && s.length > 1 && g) { c = k.indexOf(e[0].group.getAt(0)); g = Math.max(g - c, 0) } for (m = 0, o = e.length; m < o; ++m) { b = e[m]; b.group.insert(g != null ? g : d.items.length, b.items) } if (t) { s.add(t) } return e }, syncItemGrouping: function (a, q, g, j, b) { var n = this, k = n.itemGroupKeys || (n.itemGroupKeys = {}), c = a.getGrouper(), r = c.getGroupString(q), h = 0, m = -1, o = g, l, p, e, i, d; if (j || j === 0) { i = k[j]; delete k[j]; o = j } else { i = k[g] } k[g] = r; if (!(p = n.get(r))) { p = n.createGroup(a, r); l = [p] } if (p.get(o) !== q) { if (p.getCount() > 0 && a.getSorters().getCount() === 0) { d = a.indexOf(p.items[0]); if (b < d) { m = 0 } else { m = b - d } } if (m === -1) { p.add(q) } else { p.insert(m, q) } } else { p.itemChanged(q, null, j) } if (r !== i && (i === 0 || i)) { e = n.get(i); if (e) { e.remove(q); if (!e.length) { h = [e] } } } if (l) { n.splice(0, h, l) } else { if (h) { n.splice(0, h) } } }, createGroup: function (b, a) { var c = new Ext.util.Group({ groupKey: a, rootProperty: this.getItemRoot(), sorters: b.getSorters() }); return c }, getKey: function (a) { return a.getGroupKey() }, createSortFn: function () { var c = this, a = c.getGrouper(), b = c.getSorters().getSortFn(); if (!a) { return b } return function (d, e) { return a.sort(d.items[0], e.items[0]) || b(d, e) } }, updateGrouper: function (a) { var b = this; b.grouped = !!(a && b.$groupable.getAutoGroup()); b.onSorterChange(); b.onEndUpdateSorters(b.getSorters()) }, destroy: function () { this.$groupable = null; this.destroyGroups(this.items); Ext.util.Collection.prototype.destroy.call(this) }, privates: { destroyGroups: function (b) { var a = b.length, c; for (c = 0; c < a; ++c) { b[c].destroy() } }, findGroupForItem: function (d) { var b = this.items, a = b.length, c, e; for (c = 0; c < a; ++c) { e = b[c]; if (e.contains(d)) { return e } } }, onGroupRemove: function (b, a) { this.destroyGroups(a.items) } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "GroupCollection"], 0)); (Ext.cmd.derive("Ext.data.Store", Ext.data.ProxyStore, { config: { data: 0, clearRemovedOnLoad: true, clearOnPageLoad: true, associatedEntity: null, role: null, session: null }, addRecordsOptions: { addRecords: true }, loadCount: 0, complete: false, moveMapCount: 0, constructor: function (a) { var b = this, c; if (a) { if (a.buffered) { return new Ext.data.BufferedStore(a) } } Ext.data.ProxyStore.prototype.constructor.call(this, a); c = b.inlineData; if (c) { delete b.inlineData; b.loadInlineData(c) } }, applyData: function (c, a) { var b = this; b.getFields(); b.getModel(); if (c && c.isCollection) { a = c } else { if (!a) { a = b.constructDataCollection() } if (c) { if (b.isInitializing) { b.inlineData = c } else { b.loadData(c) } } } return a }, loadInlineData: function (c) { var b = this, a = b.getProxy(); if (a && a.isMemoryProxy) { a.setData(c); b.suspendEvents(); b.read(); b.resumeEvents() } else { b.removeAll(true); b.suspendEvents(); b.loadData(c); b.resumeEvents() } }, onCollectionAdd: function (b, a) { this.onCollectionAddItems(b, a.items, a) }, onCollectionFilterAdd: function (b, a) { this.onCollectionAddItems(b, a) }, onCollectionAddItems: function (g, b, a) { var l = this, j = b.length, n = a ? !a.next : false, h = l.removed, e = l.ignoreCollectionAdd, k = l.getSession(), p = a && a.replaced, c, m, d, o; for (c = 0; c < j; ++c) { d = b[c]; if (k) { k.adopt(d) } if (!e) { d.join(l); if (h && h.length) { Ext.Array.remove(h, d) } m = m || d.phantom || d.dirty } } if (e) { return } if (p) { o = []; do { Ext.Array.push(o, p.items); p = p.next } while (p); l.setMoving(o, true) } if (a) { if (a.replaced) { if (n) { l.fireEvent("refresh", l) } } else { l.fireEvent("add", l, b, a.at); if (n) { l.fireEvent("datachanged", l) } } } if (o) { l.setMoving(o, false) } l.needsSync = l.needsSync || m }, onCollectionBeforeItemChange: function (e, d) { var a = d.item, c = d.modified || null, b = d.meta; this.fireEvent("beforeupdate", this, a, b, c, d) }, onCollectionFilteredItemChange: function () { this.onCollectionItemChange.apply(this, arguments) }, onCollectionItemChange: function (g, e) { var d = this, a = e.item, c = e.modified || null, b = e.meta; if (d.fireChangeEvent(a)) { d.onUpdate(a, b, c, e); d.fireEvent("update", d, a, b, c, e) } }, afterChange: function (a, c, b) { this.getData().itemChanged(a, c || null, undefined, b) }, afterCommit: function (a, b) { this.afterChange(a, b, Ext.data.Model.COMMIT) }, afterEdit: function (a, b) { this.needsSync = this.needsSync || a.dirty; this.afterChange(a, b, Ext.data.Model.EDIT) }, afterReject: function (a) { this.afterChange(a, null, Ext.data.Model.REJECT) }, afterDrop: function (a) { this.getData().remove(a) }, afterErase: function (a) { this.removeFromRemoved(a) }, addSorted: function (a) { var c = this, e = c.getRemoteSort(), d = c.getData(), b; if (e) { d.setSorters(c.getSorters()) } b = d.findInsertionIndex(a); if (e) { d.setSorters(null) } return c.insert(b, a) }, remove: function (b, k, h) { var j = this, c = j.getDataSource(), g, d, a, e; if (b) { if (b.isModel) { if (c.indexOf(b) > -1) { a = [b]; g = 1 } else { g = 0 } } else { a = []; for (d = 0, g = b.length; d < g; ++d) { e = b[d]; if (e && e.isEntity) { if (!c.contains(e)) { continue } } else { if (!(e = c.getAt(e))) { continue } } a.push(e) } g = a.length } } if (!g) { return [] } j.removeIsMove = k === true; j.removeIsSilent = h; c.remove(a); j.removeIsSilent = false; return a }, onCollectionRemove: function (h, a) { var n = this, j = n.removed, c = a.items, l = c.length, k = a.at, b = a.replacement, p = n.removeIsMove || (b && Ext.Array.equals(c, b.items)), m = n.removeIsSilent, o = !a.next, e = n.getDataSource(), d, g; if (n.ignoreCollectionRemove) { return } if (b) { n.setMoving(b.items, true) } for (d = 0; d < l; ++d) { g = c[d]; if (!e.contains(g)) { if (j && !p && !g.phantom && !g.erasing) { g.removedFrom = k + d; j.push(g); n.needsSync = true } else { g.unjoin(n) } } } if (!m) { if (!b || !b.items.length) { n.fireEvent("remove", n, c, k, p); if (o) { n.fireEvent("datachanged", n) } } } if (b) { n.setMoving(b.items, false) } }, onFilterEndUpdate: function () { var a = this; if (a.destroying || a.destroyed) { return } Ext.data.ProxyStore.prototype.onFilterEndUpdate.apply(this, arguments); a.callObservers("Filter") }, removeAt: function (a, b) { var c = this.getData(); a = Math.max(a, 0); if (a < c.length) { if (arguments.length === 1) { b = 1 } else { if (!b) { return } } c.removeAt(a, b) } }, removeAll: function (b) { var c = this, d = c.getData(), e = c.hasListeners.clear, a = d.getRange(); if (d.length) { c.removeIsSilent = true; c.callObservers("BeforeRemoveAll"); d.removeAll(); c.removeIsSilent = false; if (!b) { c.fireEvent("clear", c, a); c.fireEvent("datachanged", c) } c.callObservers("AfterRemoveAll", [!!b]) } return a }, setRecords: function (a) { var b = this.getCount(); ++this.loadCount; if (b) { this.getData().splice(0, b, a) } else { this.add(a) } }, splice: function (a, c, b) { return this.getData().splice(a, c, b) }, onProxyLoad: function (b) { var d = this, c = b.getResultSet(), a = b.getRecords(), e = b.wasSuccessful(); if (d.destroyed) { return } if (c) { d.totalCount = c.getTotal() } if (e) { a = d.processAssociation(a); d.loadRecords(a, b.getAddRecords() ? { addRecords: true } : undefined) } else { d.loading = false } if (d.hasListeners.load) { d.fireEvent("load", d, a, e, b) } d.callObservers("AfterLoad", [a, e, b]) }, filterDataSource: function (e) { var g = this.getDataSource(), b = g.items, a = b.length, c = [], d; for (d = 0; d < a; d++) { if (e.call(g, b[d])) { c.push(b[d]) } } return c }, getNewRecords: function () { return this.filterDataSource(this.filterNew) }, getRejectRecords: function () { return this.filterDataSource(this.filterRejects) }, getUpdatedRecords: function () { return this.filterDataSource(this.filterUpdated) }, loadData: function (g, a) { var e = this, d = g.length, c = [], b; for (b = 0; b < d; b++) { c.push(e.createModel(g[b])) } c = e.processAssociation(c); e.loadRecords(c, a ? e.addRecordsOptions : undefined) }, loadRawData: function (e, b) { var d = this, g = d.getSession(), a = d.getProxy().getReader().read(e, g ? { recordCreator: g.recordCreator } : undefined), c = a.getRecords(), h = a.getSuccess(); if (h) { d.totalCount = a.getTotal(); d.loadRecords(c, b ? d.addRecordsOptions : undefined) } return h }, loadRecords: function (a, c) { var h = this, g = a.length, j = h.getData(), e, d, b; if (c) { e = c.addRecords } if (!h.getRemoteSort() && !h.getSortOnLoad()) { b = true; j.setAutoSort(false) } if (!e) { h.clearData(true) } h.loading = false; h.ignoreCollectionAdd = true; h.callObservers("BeforePopulate"); j.add(a); h.ignoreCollectionAdd = false; if (b) { j.setAutoSort(true) } for (d = 0; d < g; d++) { a[d].join(h) } ++h.loadCount; h.complete = true; if (h.hasListeners.datachanged) { h.fireEvent("datachanged", h) } if (h.hasListeners.refresh) { h.fireEvent("refresh", h) } h.callObservers("AfterPopulate") }, loadPage: function (d, a) { var c = this, b = c.getPageSize(); c.currentPage = d; a = Ext.apply({ page: d, start: (d - 1) * b, limit: b, addRecords: !c.getClearOnPageLoad() }, a); c.read(a) }, nextPage: function (a) { this.loadPage(this.currentPage + 1, a) }, previousPage: function (a) { this.loadPage(this.currentPage - 1, a) }, clearData: function (c) { var k = this, h = k.removed, d = k.getDataSource(), j = k.getClearRemovedOnLoad(), l = h && c && !j, a, e, b, g; if (d) { a = d.items; for (b = 0, g = a.length; b < g; ++b) { e = a[b]; if (l && Ext.Array.contains(h, e)) { continue } e.unjoin(k) } k.ignoreCollectionRemove = true; k.callObservers("BeforeClear"); d.removeAll(); k.ignoreCollectionRemove = false; k.callObservers("AfterClear") } if (h && (!c || j)) { h.length = 0 } }, onIdChanged: function (c, b, a) { this.getData().updateKey(c, b); this.fireEvent("idchanged", this, c, b, a) }, commitChanges: function () { var c = this, d = c.getModifiedRecords(), a = d.length, b = 0; Ext.suspendLayouts(); c.beginUpdate(); for (; b < a; b++) { d[b].commit() } c.cleanRemoved(); c.endUpdate(); Ext.resumeLayouts(true) }, filterNewOnly: function (a) { return a.phantom === true }, filterRejects: function (a) { return a.phantom || a.dirty }, rejectChanges: function () { var j = this, k = j.getRejectRecords(), g = k.length, d, b, a, h, c, e; Ext.suspendLayouts(); j.beginUpdate(); for (d = 0; d < g; d++) { b = k[d]; if (b.phantom) { a = a || []; a.push(b) } else { b.reject() } } if (a) { j.remove(a); for (d = 0, g = a.length; d < g; ++d) { a[d].reject() } } k = j.getRawRemovedRecords(); if (k) { g = k.length; h = !j.getRemoteSort() && j.isSorted(); if (h) { c = j.getData(); e = c.getAutoSort(); c.setAutoSort(false) } for (d = g - 1; d >= 0; d--) { b = k[d]; b.reject(); if (!h) { j.insert(b.removedFrom || 0, b) } } if (h) { c.setAutoSort(e); j.add(k) } k.length = 0 } j.endUpdate(); Ext.resumeLayouts(true) }, doDestroy: function () { var b = this, a = b.loadTask, d = b.getData(), c = d.getSource(); b.clearData(); b.setSession(null); b.observers = null; if (a) { a.cancel(); b.loadTask = null } if (c) { c.destroy() } Ext.data.ProxyStore.prototype.doDestroy.call(this) }, privates: { fetch: function (b) { b = Ext.apply({}, b); this.setLoadOptions(b); var a = this.createOperation("read", b); a.execute() }, fireChangeEvent: function (a) { return this.getDataSource().contains(a) }, onBeforeLoad: function (a) { this.callObservers("BeforeLoad", [a]) }, onRemoteFilterSet: function (a, b) { if (a) { this.getData().setFilters(b ? null : a) } Ext.data.ProxyStore.prototype.onRemoteFilterSet.call(this, a, b) }, onRemoteSortSet: function (b, c) { var a = this.getData(); if (b) { a.setSorters(c ? null : b) } a.setAutoGroup(!c); Ext.data.ProxyStore.prototype.onRemoteSortSet.call(this, b, c) }, isMoving: function (c, e) { var g = this.moveMap, b = 0, a, d; if (g) { if (c) { if (Ext.isArray(c)) { for (d = 0, a = c.length; d < a; ++d) { b += g[c[d].id] ? 1 : 0 } } else { if (g[c.id]) { ++b } } } else { b = e ? g : this.moveMapCount } } return b }, setLoadOptions: function (c) { var d = this, a = d.getPageSize(), e, b; if (d.getRemoteSort() && !c.grouper) { b = d.getGrouper(); if (b) { c.grouper = b } } if (a || "start" in c || "limit" in c || "page" in c) { c.page = c.page != null ? c.page : d.currentPage; c.start = (c.start !== undefined) ? c.start : (c.page - 1) * a; c.limit = c.limit != null ? c.limit : a; d.currentPage = c.page } c.addRecords = c.addRecords || false; if (!c.recordCreator) { e = d.getSession(); if (e) { c.recordCreator = e.recordCreator } } Ext.data.ProxyStore.prototype.setLoadOptions.call(this, c) }, setMoving: function (b, g) { var d = this, e = d.moveMap || (d.moveMap = {}), a = b.length, c, h; for (c = 0; c < a; ++c) { h = b[c].id; if (g) { if (e[h]) { ++e[h] } else { e[h] = 1; ++d.moveMapCount } } else { if (--e[h] === 0) { delete e[h]; --d.moveMapCount } } } if (d.moveMapCount === 0) { d.moveMap = null } }, processAssociation: function (a) { var c = this, b = c.getAssociatedEntity(); if (b) { a = c.getRole().processLoad(c, b, a, c.getSession()) } return a } } }, 1, 0, 0, 0, ["store.store"], [[Ext.data.LocalStore.prototype.mixinId || Ext.data.LocalStore.$className, Ext.data.LocalStore]], [Ext.data, "Store"], 0)); (Ext.cmd.derive("Ext.data.reader.Array", Ext.data.reader.Json, { alternateClassName: "Ext.data.ArrayReader", config: { totalProperty: undefined, successProperty: undefined }, createFieldAccessor: function (d) { var b = d.mapping, c = d.hasMapping() ? b : d.ordinal, a; d.mapping = c; a = Ext.data.reader.Json.prototype.createFieldAccessor.apply(this, arguments); d.mapping = b; return a }, getModelData: function (a) { return {} } }, 0, 0, 0, 0, ["reader.array"], 0, [Ext.data.reader, "Array", Ext.data, "ArrayReader"], 0)); (Ext.cmd.derive("Ext.data.ArrayStore", Ext.data.Store, { alternateClassName: ["Ext.data.SimpleStore"], config: { proxy: { type: "memory", reader: "array" } }, loadData: function (e, a) { if (this.expandData) { var d = [], b = 0, c = e.length; for (; b < c; b++) { d[d.length] = [e[b]] } e = d } Ext.data.Store.prototype.loadData.call(this, e, a) } }, 0, 0, 0, 0, ["store.array"], 0, [Ext.data, "ArrayStore", Ext.data, "SimpleStore"], 0)); (Ext.cmd.derive("Ext.data.StoreManager", Ext.util.MixedCollection, { alternateClassName: ["Ext.StoreMgr", "Ext.data.StoreMgr", "Ext.StoreManager"], singleton: true, register: function () { for (var a = 0, b; (b = arguments[a]); a++) { this.add(b) } }, unregister: function () { for (var a = 0, b; (b = arguments[a]); a++) { this.remove(this.lookup(b)) } }, lookup: function (c, h) { if (Ext.isArray(c)) { var b = ["field1"], e = !Ext.isArray(c[0]), g = c, d, a; if (e) { g = []; for (d = 0, a = c.length; d < a; ++d) { g.push([c[d]]) } } else { for (d = 2, a = c[0].length; d <= a; ++d) { b.push("field" + d) } } return new Ext.data.ArrayStore({ data: g, fields: b, autoDestroy: true, autoCreated: true, expanded: e }) } if (Ext.isString(c)) { return this.get(c) } else { return Ext.Factory.store(c, h) } }, getKey: function (a) { return a.storeId }, addEmptyStore: function () { var a = Ext.regStore("ext-empty-store", { proxy: "memory", useModelWarning: false }); a.isEmptyStore = true; this.add(a) }, clear: function () { this.callParent(); this.addEmptyStore() } }, 0, 0, 0, 0, 0, 0, [Ext.data, "StoreManager", Ext, "StoreMgr", Ext.data, "StoreMgr", Ext, "StoreManager"], function () { Ext.regStore = function (c, b) { var a; if (Ext.isObject(c)) { b = c } else { if (Ext.data.StoreManager.containsKey(c)) { return Ext.data.StoreManager.lookup(c) } b.storeId = c } if (b instanceof Ext.data.Store) { a = b } else { a = new Ext.data.Store(b) } Ext.data.StoreManager.register(a); return a }; Ext.getStore = function (a) { return Ext.data.StoreManager.lookup(a) }; Ext.data.StoreManager.addEmptyStore() })); (Ext.cmd.derive("Ext.app.domain.Store", Ext.app.EventDomain, { singleton: true, type: "store", prefix: "store.", idMatchRe: /^\#/, constructor: function () { var a = this; a.callParent(); a.monitor(Ext.data.AbstractStore) }, match: function (d, b) { var a = false, c = d.alias; if (b === "*") { a = true } else { if (this.idMatchRe.test(b)) { a = d.getStoreId() === b.substring(1) } else { if (c) { a = Ext.Array.indexOf(c, this.prefix + b) > -1 } } } return a } }, 1, 0, 0, 0, 0, 0, [Ext.app.domain, "Store"], 0)); (Ext.cmd.derive("Ext.app.route.Queue", Ext.Base, { queue: null, token: null, constructor: function (a) { Ext.apply(this, a); this.queue = new Ext.util.MixedCollection() }, queueAction: function (a, b) { this.queue.add({ route: a, args: b }) }, clearQueue: function () { this.queue.removeAll() }, runQueue: function () { var a = this.queue, c = a.removeAt(0), b; if (c) { b = c && c.route; b.execute(this.token, c.args, this.onActionExecute, this) } }, onActionExecute: function (a) { if (a) { this.clearQueue() } else { this.runQueue() } } }, 1, 0, 0, 0, 0, 0, [Ext.app.route, "Queue"], 0)); (Ext.cmd.derive("Ext.app.route.Route", Ext.Base, { action: null, conditions: null, controller: null, allowInactive: false, url: null, before: null, caseInsensitive: false, matcherRegex: null, paramMatchingRegex: null, paramsInMatchString: null, constructor: function (b) { var c = this, a; Ext.apply(c, b, { conditions: {} }); a = c.url; c.paramMatchingRegex = new RegExp(/:([0-9A-Za-z\_]*)/g); c.paramsInMatchString = a.match(c.paramMatchingRegex) || []; c.matcherRegex = c.createMatcherRegex(a) }, recognize: function (c) { var d = this, a = d.controller, e, b; if ((d.allowInactive || a.isActive()) && d.recognizes(c)) { e = d.matchesFor(c); b = c.match(d.matcherRegex); b.shift(); return Ext.applyIf(e, { controller: a, action: d.action, historyUrl: c, args: b }) } return false }, recognizes: function (a) { return this.matcherRegex.test(a) }, execute: function (c, h, i, d) { var b = h.args || [], g = this.before, a = this.controller, e = this.createCallback(h, i, d); if (g) { b.push(e); if (Ext.isString(g)) { g = this.before = a[g] } if (g) { g.apply(a, b) } } else { e.resume() } }, matchesFor: function (c) { var g = {}, e = this.paramsInMatchString, b = c.match(this.matcherRegex), d = 0, a = e.length; b.shift(); for (; d < a; d++) { g[e[d].replace(":", "")] = b[d] } return g }, createMatcherRegex: function (a) { var c = this.paramsInMatchString, j = this.conditions, d = 0, g = c.length, k = Ext.util.Format.format, l = this.caseInsensitive ? "i" : "", b, h, e; for (; d < g; d++) { b = c[d]; h = j[b]; e = k("{0}", h || "([%a-zA-Z0-9\\-\\_\\s,]+)"); a = a.replace(new RegExp(b), e) } return new RegExp("^" + a + "$", l) }, createCallback: function (a, d, b) { var c = this; b = b || c; return { resume: function () { var e = c.controller, h = c.action, g; if (Ext.isString(h)) { h = e[h] } a = a && a.args ? a.args : []; g = a.pop(); if (g && !Ext.isObject(g)) { a.push(g) } if (h) { c.action = h; h.apply(e, a) } if (d) { d.call(b) } }, stop: function (e) { if (d) { d.call(b, e) } } } } }, 1, 0, 0, 0, 0, 0, [Ext.app.route, "Route"], 0)); (Ext.cmd.derive("Ext.util.History", Ext.Base, { singleton: true, alternateClassName: "Ext.History", useTopWindow: false, constructor: function () { var a = this; a.hiddenField = null; a.ready = false; a.currentToken = null; a.mixins.observable.constructor.call(a) }, getHash: function () { return this.win.location.hash.substr(1) }, setHash: function (b) { try { this.win.location.hash = b; this.currentToken = b } catch (a) { } }, handleStateChange: function (a) { this.currentToken = a; this.fireEvent("change", a) }, startUp: function () { var a = this; a.currentToken = a.getHash(); if (Ext.supports.Hashchange) { Ext.get(a.win).on("hashchange", a.onHashChange, a) } else { Ext.TaskManager.start({ fireIdleEvent: false, run: a.onHashChange, interval: 50, scope: a }) } a.ready = true; a.fireEvent("ready", a) }, onHashChange: function () { var b = this, a = b.getHash(); if (a !== b.hash) { b.hash = a; b.handleStateChange(a) } }, init: function (c, a) { var b = this; if (b.ready) { Ext.callback(c, a, [b]); return } if (!Ext.isReady) { Ext.onInternalReady(function () { b.init(c, a) }); return } b.win = b.useTopWindow ? window.top : window; b.hash = b.getHash(); if (c) { b.on("ready", c, a, { single: true }) } b.startUp() }, add: function (a, b) { var c = this, d = false; if (b === false || c.getToken() !== a) { c.setHash(a); d = true } return d }, back: function () { var a = this.useTopWindow ? window.top : window; a.history.go(-1) }, forward: function () { var a = this.useTopWindow ? window.top : window; a.history.go(1) }, getToken: function () { return this.ready ? this.currentToken : this.getHash() } }, 1, 0, 0, 0, 0, [["observable", Ext.util.Observable]], [Ext.util, "History", Ext, "History"], 0)); (Ext.cmd.derive("Ext.app.route.Router", Ext.Base, { singleton: true, multipleToken: "|", queueRoutes: true, constructor: function () { var a = Ext.util.History; if (!a.ready) { a.init() } a.on("change", this.onStateChange, this); this.clear() }, onStateChange: function (d) { var l = this, c = l.application, n = l.routes, h = n.length, p = l.queueRoutes, k = d.split(l.multipleToken), o = 0, b = k.length, e, g, m, j, a; for (; o < b; o++) { d = k[o]; a = false; if (p) { g = new Ext.app.route.Queue({ token: d }) } for (e = 0; e < h; e++) { m = n[e]; j = m.recognize(d); if (j) { a = true; if (p) { g.queueAction(m, j) } else { m.execute(d, j) } } } if (p) { g.runQueue() } if (!a && c) { c.fireEvent("unmatchedroute", d) } } }, connect: function (c, d, a) { var b = { url: c, action: d, controller: a }; if (Ext.isObject(d)) { Ext.merge(b, d) } this.routes.push(new Ext.app.route.Route(b)) }, disconnectAll: function (c) { var b = this.routes, a = b.length, e = [], g, d; for (g = 0; g < a; ++g) { d = b[g]; if (d.controller !== c) { e.push(d) } } this.routes = e }, recognize: function (e) { var b = this.routes || [], g = 0, a = b.length, c, d; for (; g < a; g++) { c = b[g]; d = c.recognize(e); if (d) { return { route: c, args: d } } } return false }, draw: function (a) { a.call(this, this) }, clear: function () { this.routes = [] } }, 1, 0, 0, 0, 0, 0, [Ext.app.route, "Router"], 0)); (Ext.cmd.derive("Ext.app.Controller", Ext.app.BaseController, { statics: { strings: { model: { getter: "getModel", upper: "Model" }, view: { getter: "getView", upper: "View" }, controller: { getter: "getController", upper: "Controller" }, store: { getter: "getStore", upper: "Store" }, profile: { getter: "getProfile", upper: "Profiles" } }, controllerRegex: /^(.*)\.controller\./, profileRegex: /^(.*)\.profile\./, createGetter: function (a, b) { return function () { return this[a](b) } }, getGetterName: function (c, a) { var d = "get", e = c.split("."), g = e.length, b; for (b = 0; b < g; b++) { d += Ext.String.capitalize(e[b]) } d += a; return d }, resolveNamespace: function (a, g) { var h = Ext.app.Controller, e = a.prototype.isProfile ? h.profileRegex : h.controllerRegex, d, c, b; d = Ext.getClassName(a); c = g.$namespace || g.namespace || Ext.app.getNamespace(d) || ((b = e.exec(d)) && b[1]); return c }, processDependencies: function (r, s, d, e, k, b) { if (!k || !k.length) { return } var l = this, q = l.strings[e], c, p, n, a, g, h, m, i; if (!Ext.isArray(k)) { k = [k] } for (g = 0, h = k.length; g < h; g++) { a = k[g]; c = l.getFullName(a, e, d, b); k[g] = p = c.absoluteName; n = c.shortName; s.push(p); m = l.getGetterName(n, q.upper); if (!r[m]) { r[m] = i = l.createGetter(q.getter, a) } if (i && e !== "controller") { i["Ext.app.getter"] = true } } }, getFullName: function (c, g, e, d) { var a = c, b, h; if ((b = c.indexOf("@")) > 0) { a = c.substring(0, b); h = c.substring(b + 1) + "." + a } else { if (c.indexOf(".") > 0 && (Ext.ClassManager.isCreated(c) || this.hasRegisteredPrefix(c))) { h = c; a = c.replace(e + "." + g + ".", "") } else { if (e) { h = e + "." + g + "." + (d ? d + "." + c : c); a = c } else { h = c } } } return { absoluteName: h, shortName: a } }, hasRegisteredPrefix: function (a) { var c = Ext.ClassManager, b = c.getPrefix(a); return b && b !== a } }, models: null, views: null, stores: null, controllers: null, config: { application: null, refs: null, active: true, moduleClassName: null }, onClassExtended: function (b, c, a) { var d = a.onBeforeCreated; a.onBeforeCreated = function (e, j) { var k = Ext.app.Controller, h = [], g, i; i = e.prototype; g = k.resolveNamespace(e, j); if (g) { i.$namespace = g } k.processDependencies(i, h, g, "model", j.models); k.processDependencies(i, h, g, "view", j.views); k.processDependencies(i, h, g, "store", j.stores); k.processDependencies(i, h, g, "controller", j.controllers); Ext.require(h, Ext.Function.pass(d, arguments, this)) } }, constructor: function (a) { this.initAutoGetters(); Ext.app.BaseController.prototype.constructor.call(this, a) }, normalizeRefs: function (b) { var c = this, a = []; if (b) { if (Ext.isObject(b)) { Ext.Object.each(b, function (d, e) { if (Ext.isString(e)) { e = { selector: e } } e.ref = d; a.push(e) }) } else { if (Ext.isArray(b)) { a = Ext.Array.merge(a, b) } } } b = c.refs; if (b) { c.refs = null; b = c.normalizeRefs(b); if (b) { a = Ext.Array.merge(a, b) } } return a }, getRefMap: function () { var g = this, c = g._refMap, a, e, d, b; if (!c) { a = g.getRefs(); c = g._refMap = {}; if (a) { for (b = 0, d = a.length; b < d; b++) { e = a[b]; c[e.ref] = e.selector } } } return c }, applyId: function (a) { return a || Ext.app.Controller.getFullName(this.$className, "controller", this.$namespace).shortName }, applyRefs: function (a) { return this.normalizeRefs(Ext.clone(a)) }, updateRefs: function (a) { if (a) { this.ref(a) } }, initAutoGetters: function () { var b = this.self.prototype, c, a; for (c in b) { a = b[c]; if (a && a["Ext.app.getter"]) { a.call(this) } } }, doInit: function (b) { var a = this; if (!a._initialized) { a.init(b); a._initialized = true } }, finishInit: function (g) { var d = this, e = d.controllers, b, c, a; if (d._initialized && e && e.length) { for (c = 0, a = e.length; c < a; c++) { b = d.getController(e[c]); b.finishInit(g) } } }, init: Ext.emptyFn, onLaunch: Ext.emptyFn, activate: function () { this.setActive(true) }, deactivate: function () { this.setActive(false) }, isActive: function () { return this.getActive() }, ref: function (a) { var g = this, b = 0, e = a.length, h, d, c; a = Ext.Array.from(a); g.references = g.references || []; for (; b < e; b++) { h = a[b]; d = h.ref; c = "get" + Ext.String.capitalize(d); if (!g[c]) { g[c] = Ext.Function.pass(g.getRef, [d, h], g) } g.references.push(d.toLowerCase()) } }, addRef: function (a) { this.ref(a) }, getRef: function (d, g, a) { var c = this, e = c.refCache || (c.refCache = {}), b = e[d]; g = g || {}; a = a || {}; Ext.apply(g, a); if (g.forceCreate) { return Ext.ComponentManager.create(g, "component") } if (!b) { if (g.selector) { e[d] = b = Ext.ComponentQuery.query(g.selector)[0] } if (!b && g.autoCreate) { e[d] = b = Ext.ComponentManager.create(g, "component") } if (b) { b.on("destroy", function () { e[d] = null }) } } return b }, hasRef: function (b) { var a = this.references; return a && Ext.Array.indexOf(a, b.toLowerCase()) !== -1 }, getController: function (b) { var a = this.getApplication(); if (b === this.getId()) { return this } return a && a.getController(b) }, getStore: function (c) { var a, b; a = (c.indexOf("@") === -1) ? c : c.split("@")[0]; b = Ext.StoreManager.get(a); if (!b) { c = Ext.app.Controller.getFullName(c, "store", this.$namespace); if (c) { b = Ext.create(c.absoluteName, { id: a }) } } return b }, getModel: function (c) { var b = Ext.app.Controller.getFullName(c, "model", this.$namespace), a = Ext.ClassManager.get(b.absoluteName); if (!a) { a = Ext.data.schema.Schema.lookupEntity(c) } return a }, getProfile: function (a) { a = Ext.app.Controller.getFullName(a, "profile", this.$namespace); return a }, getView: function (a) { var b = Ext.app.Controller.getFullName(a, "view", this.$namespace); return b && Ext.ClassManager.get(b.absoluteName) }, destroy: function (a, b) { var d = this, g = d.application, e, c; if (!b && g) { g.unregister(d) } d.application = null; if (a) { e = d.refCache; for (c in e) { if (e.hasOwnProperty(c)) { Ext.destroy(e[c]) } } } Ext.app.BaseController.prototype.destroy.call(this) } }, 1, 0, 0, 0, 0, 0, [Ext.app, "Controller"], 0)); (Ext.cmd.derive("Ext.app.Application", Ext.app.Controller, { isApplication: true, scope: undefined, namespaces: [], paths: null, config: { name: "", appProperty: "app", profiles: [], currentProfile: null, mainView: { $value: null, lazy: true }, defaultToken: null, glyphFontFamily: null, quickTips: true }, onClassExtended: function (i, c, h) { var b = Ext.app.Controller, d = i.prototype, k = [], e, j, a, g; a = c.name || i.superclass.name; if (a) { c.$namespace = a; Ext.app.addNamespaces(a) } if (c.namespaces) { Ext.app.addNamespaces(c.namespaces) } if (c["paths processed"]) { delete c["paths processed"] } else { Ext.app.setupPaths(a, ("appFolder" in c) ? c.appFolder : i.superclass.appFolder, c.paths) } b.processDependencies(d, k, a, "profile", c.profiles); d.getDependencies(i, c, k); if (k.length) { e = h.onBeforeCreated; h.onBeforeCreated = function (l, n) { var m = Ext.Array.clone(arguments); Ext.require(k, function () { return e.apply(this, m) }) } } }, getDependencies: Ext.emptyFn, constructor: function (a) { var b = this; Ext.app.route.Router.application = b; Ext.app.Controller.prototype.constructor.call(this, a); b.doInit(b); b.initNamespace(); Ext.on("appupdate", b.onAppUpdate, b, { single: true }); this.onProfilesReady() }, applyId: function (a) { return a || this.$className }, onAppUpdate: Ext.emptyFn, onProfilesReady: function () { var e = this, b = e.getProfiles(), d = b.length, g, c, a; for (c = 0; c < d; c++) { a = Ext.create(b[c], { application: e }); if (a.isActive() && !g) { g = a; e.setCurrentProfile(g) } } if (g) { g.init() } e.initControllers(); e.onBeforeLaunch(); e.finishInitControllers() }, initNamespace: function () { var c = this, a = c.getAppProperty(), b; b = Ext.namespace(c.getName()); if (b) { b.getApplication = function () { return c }; if (a) { if (!b[a]) { b[a] = c } } } }, initControllers: function () { var d = this, e = Ext.Array.from(d.controllers), b = d.getCurrentProfile(), a, c; d.controllers = new Ext.util.MixedCollection(); for (a = 0, c = e.length; a < c; a++) { d.getController(e[a]) } if (b) { e = b.getControllers(); for (a = 0, c = e.length; a < c; a++) { d.getController(e[a]) } } }, finishInitControllers: function () { var c = this, d, b, a; d = c.controllers.getRange(); for (b = 0, a = d.length; b < a; b++) { d[b].finishInit(c) } }, launch: Ext.emptyFn, onBeforeLaunch: function () { var j = this, e = Ext.util.History, a = j.getDefaultToken(), h = j.getCurrentProfile(), b, i, k, g, d; j.initMainView(); if (h) { h.launch() } j.launch.call(j.scope || j); j.launched = true; j.fireEvent("launch", j); b = j.controllers.items; k = b.length; for (i = 0; i < k; i++) { g = b[i]; g.onLaunch(j) } if (!e.ready) { e.init() } d = e.getToken(); if (d || d === a) { Ext.app.route.Router.onStateChange(d) } else { if (a) { e.add(a) } } if (Ext.Microloader && Ext.Microloader.appUpdate && Ext.Microloader.appUpdate.updated) { Ext.Microloader.fireAppUpdate() } Ext.defer(Ext.ClassManager.clearNamespaceCache, 2000, Ext.ClassManager) }, getModuleClassName: function (a, b) { return Ext.app.Controller.getFullName(a, b, this.getName()).absoluteName }, initMainView: function () { var c = this, b = c.getCurrentProfile(), a; if (b) { a = b.getMainView() } if (a) { c.setMainView(a) } else { c.getMainView() } }, applyMainView: function (b) { var a = this.getView(b); return a.create({ $initParent: this.viewport }) }, createController: function (a) { return this.getController(a) }, destroyController: function (a) { if (typeof a === "string") { a = this.getController(a, true) } Ext.destroy(a) }, getController: function (b, a) { var l = this, d = l.controllers, j, g, h, e, k, m; g = d.get(b); if (!g) { m = d.items; for (e = 0, h = m.length; e < h; ++e) { k = m[e]; j = k.getModuleClassName(); if (j && j === b) { g = k; break } } } if (!g && !a) { j = l.getModuleClassName(b, "controller"); g = Ext.create(j, { application: l, moduleClassName: j }); d.add(g); if (l._initialized) { g.doInit(l) } } return g }, unregister: function (a) { this.controllers.remove(a) }, getApplication: function () { return this }, destroy: function (a) { var c = this, e = c.controllers, b = Ext.namespace(c.getName()), d = c.getAppProperty(); Ext.un("appupdate", c.onAppUpdate, c); Ext.destroy(c.viewport); if (e) { e.each(function (g) { g.destroy(a, true) }) } c.controllers = null; Ext.app.Controller.prototype.destroy.call(this, a, true); if (b && b[d] === c) { delete b[d] } if (Ext.app.route.Router.application === c) { Ext.app.route.Router.application = null } if (Ext.app.Application.instance === c) { Ext.app.Application.instance = null } }, updateGlyphFontFamily: function (a) { Ext.setGlyphFontFamily(a) }, applyProfiles: function (a) { var b = this; return Ext.Array.map(a, function (c) { return b.getModuleClassName(c, "profile") }) } }, 1, 0, 0, 0, 0, 0, [Ext.app, "Application"], 0)); Ext.application = function (a) { var b = function (c) { Ext.onReady(function () { var d = Ext.viewport; d = d && d.Viewport; if (d && d.setup) { d.setup(c.prototype.config.viewport) } Ext.app.Application.instance = new c() }) }; if (typeof a === "string") { Ext.require(a, function () { b(Ext.ClassManager.get(a)) }) } else { a = Ext.apply({ extend: "Ext.app.Application" }, a); Ext.app.setupPaths(a.name, a.appFolder, a.paths); a["paths processed"] = true; Ext.define(a.name + ".$application", a, function () { b(this) }) } }; Ext.define("Ext.overrides.app.Application", { override: "Ext.app.Application", autoCreateViewport: false, config: { enableQuickTips: null }, quickTips: true, updateEnableQuickTips: function (a) { this.setQuickTips(a) }, applyMainView: function (e) { var b, d, c, a; if (typeof e === "string") { b = this.getView(e) } else { b = Ext.ClassManager.getByConfig(e) } d = b.prototype; if (!d.isViewport) { a = d.plugins; a = ["viewport"].concat(a ? Ext.Array.from(a, true) : []); c = { plugins: a } } return b.create(c) }, getDependencies: function (a, g, d) { var h = Ext.app.Controller, e = a.prototype, c = g.$namespace, b = g.autoCreateViewport; if (b) { if (b === true) { b = "Viewport" } else { d.push("Ext.plugin.Viewport") } h.processDependencies(e, d, c, "view", b) } }, onBeforeLaunch: function () { var b = this, a = b.autoCreateViewport; if (b.getQuickTips()) { b.initQuickTips() } if (a) { b.initViewport() } arguments.callee.$previous.apply(this, arguments) }, getViewportName: function () { var a = null, b = this.autoCreateViewport; if (b) { a = (b === true) ? "Viewport" : b } return a }, initViewport: function () { this.setMainView(this.getViewportName()) }, initQuickTips: function () { Ext.tip.QuickTipManager.init() } }); (Ext.cmd.derive("Ext.app.Profile", Ext.Base, { isProfile: true, config: { mainView: { $value: null, lazy: true }, application: null, controllers: [], models: [], views: [], stores: [] }, constructor: function (a) { this.initConfig(a); this.mixins.observable.constructor.apply(this, arguments) }, isActive: function () { return false }, init: function () { var a = this.getViews(), b; if (a && !(a instanceof Array)) { for (b in a) { Ext.ClassManager.setXType(a[b], b) } } }, launch: Ext.emptyFn, onClassExtended: function (b, c, a) { var d = a.onBeforeCreated; a.onBeforeCreated = function (m, i) { var h = Ext.app.Controller, k = m.$className, n = [], j = m.prototype, l = i.views, e, g; e = i.name; if (e) { delete i.name } else { e = k.split("."); e = e[e.length - 1] } m._name = e; m._namespace = e = (i.namespace || e).toLowerCase(); delete i.namespace; g = h.resolveNamespace(m, i); h.processDependencies(j, n, g, "model", i.models, e); h.processDependencies(j, n, g, "store", i.stores, e); h.processDependencies(j, n, g, "controller", i.controllers, e); if (l) { if (l instanceof Array) { h.processDependencies(j, n, g, "view", l, e) } else { Ext.app.Profile.processViews(k, l, n) } } Ext.require(n, Ext.Function.pass(d, arguments, this)) } }, getName: function () { return this.self._name }, getNamespace: function () { return this.self._namespace }, privates: { statics: { processViews: function (g, c, e) { var a, b, d, h; for (h in c) { b = c[h]; if (typeof b !== "string") { d = b.xclass; a = Ext.apply({ extend: d }, b); delete a.xclass; Ext.define(c[h] = g + "$" + h, a); b = d } e.push(b) } } } } }, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.app, "Profile"], 0)); (Ext.cmd.derive("Ext.app.domain.View", Ext.app.EventDomain, { isInstance: true, constructor: function (a) { Ext.app.EventDomain.prototype.constructor.call(this, a); this.controller = a; this.monitoredClasses = [Ext.Widget] }, match: function (d, a, b) { var c = false; if (a === "#") { c = b === d.getController() } else { c = d.is(a) } return c }, destroy: function () { this.controller = null; Ext.app.EventDomain.prototype.destroy.call(this) } }, 1, 0, 0, 0, 0, 0, [Ext.app.domain, "View"], 0)); Ext.define("Ext.overrides.app.domain.View", { override: "Ext.app.domain.View", constructor: function (a) { (arguments.callee.$previous || Ext.app.EventDomain.prototype.constructor).call(this, a); this.monitoredClasses.push(Ext.Component) } }); (Ext.cmd.derive("Ext.app.ViewController", Ext.app.BaseController, { isViewController: true, factoryConfig: { type: "controller" }, config: { closeViewAction: "destroy" }, view: null, constructor: function () { this.compDomain = new Ext.app.domain.View(this); Ext.app.BaseController.prototype.constructor.apply(this, arguments) }, beforeInit: Ext.emptyFn, init: Ext.emptyFn, initViewModel: Ext.emptyFn, destroy: function () { var a = this, b = a.compDomain; if (b) { b.unlisten(a); b.destroy() } a.compDomain = a.view = null; Ext.app.BaseController.prototype.destroy.call(this) }, closeView: function () { var a = this.getView(), b; if (a) { b = this.getCloseViewAction(); a[b]() } }, control: function (a, b) { var c = a; if (Ext.isString(a)) { c = {}; c[a] = b } this.compDomain.listen(c, this) }, listen: function (c, a) { var b = c.component; if (b) { c = Ext.apply({}, c); delete c.component; this.control(b) } this.callParent([c, a]) }, applyId: function (a) { if (!a) { a = Ext.id(null, "controller-") } return a }, getReferences: function () { var a = this.view; return a && a.getReferences() }, getView: function () { return this.view }, lookup: function (b) { var a = this.view; return a && a.lookup(b) }, lookupReference: function (a) { return this.lookup(a) }, getSession: function () { var a = this.view; return a && a.lookupSession() }, getViewModel: function () { var a = this.view; return a && a.lookupViewModel() }, getStore: function (b) { var a = this.getViewModel(); return a ? a.getStore(b) : null }, fireViewEvent: function (d, b) { var c = this.view, a = false, e = arguments; if (c) { if (c !== b) { e = Ext.Array.slice(e); e.splice(1, 0, c) } a = c.fireEvent.apply(c, e) } return a }, privates: { view: null, attachReference: function (b) { var a = this.view; if (a) { a.attachReference(b) } }, clearReference: function (b) { var a = this.view; if (a) { a.clearReference(b) } }, clearReferences: function () { var a = this.view; if (a) { a.clearReferences() } }, setView: function (a) { this.view = a; if (!this.beforeInit.$nullFn) { this.beforeInit(a) } } } }, 1, 0, 0, 0, ["controller.controller"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.app, "ViewController"], 0)); (Ext.cmd.derive("Ext.util.Bag", Ext.Base, { isBag: true, constructor: function () { this.items = []; this.map = {} }, generation: 0, length: 0, beginUpdate: Ext.emptyFn, endUpdate: Ext.emptyFn, add: function (o) { var l = this, k = l.items, a = l.map, d = 1, e, h, m, c, g, j, b; if (Ext.isArray(o)) { e = j = []; d = o.length } for (h = 0; h < d; h++) { c = l.getKey(g = e ? o[h] : o); m = a[c]; if (m === undefined) { k.push(g); a[c] = l.length++; if (e) { e.push(g) } else { j = g } } else { b = k[m]; if (e) { e.push(b) } else { j = b } k[m] = g } } ++l.generation; return j }, clear: function () { var c = this, b = c.generation || c.length, a = b ? c.items : []; if (b) { c.items = []; c.length = 0; c.map = {}; ++c.generation } return a }, clone: function () { var c = this, b = new c.self(), a = c.length; if (a) { Ext.apply(b.map, c.map); b.items = c.items.slice(); b.length = c.length } return b }, contains: function (c) { var a = false, d = this.map, b; if (c != null) { b = this.getKey(c); if (b in d) { a = this.items[d[b]] === c } } return a }, containsKey: function (a) { return a in this.map }, destroy: function () { this.items = this.map = null; this.callParent() }, each: function (g, e) { var b = this.items, a = b.length, d, c; if (a) { e = e || this; b = b.slice(0); for (d = 0; d < a; d++) { c = g.call(e, b[d], d, a); if (c === false) { break } } } return c }, getAt: function (b) { var a = null; if (b < this.length) { a = this.items[b] } return a }, get: function (a) { return this.getByKey(a) }, getByKey: function (b) { var c = this.map, a = (b in c) ? this.items[c[b]] : null; return a }, indexOfKey: function (b) { var c = this.map, a = (b in c) ? c[b] : -1; return a }, last: function () { return this.items[this.length - 1] }, updateKey: function (b, d) { var a = this, c = a.map, e; if (!b || !d) { return } if ((e = a.getKey(b)) !== d) { if (a.getAt(c[d]) === b && !(e in c)) { a.generation++; c[e] = c[d]; delete c[d] } } }, getCount: function () { return this.length }, getKey: function (a) { return a.id || a.getId() }, getRange: function (d, a) { var c = this.items, e = c.length, b; if (!e) { b = [] } else { b = Ext.Number.clipIndices(e, [d, a]); b = c.slice(b[0], b[1]) } return b }, remove: function (p) { var l = this, a = l.map, k = l.items, j = null, d = 1, h, e, g, m, c, o, b; if (Ext.isArray(p)) { d = p.length; e = j = [] } if (l.length) { for (g = 0; g < d; g++) { m = a[c = l.getKey(e ? p[g] : p)]; if (m !== undefined) { delete a[c]; b = k[m]; if (e) { e.push(b) } else { j = b } o = k.pop(); if (m < --l.length) { k[m] = o; a[l.getKey(o)] = m } h = true } } if (h) { ++l.generation } } return j }, removeByKey: function (a) { var b = this.getByKey(a); if (b) { this.remove(b) } return b || null }, replace: function (a) { this.add(a); return a }, sort: function (b) { var d = this, a = d.items, e = a.length, c; if (e) { Ext.Array.sort(a, b); d.map = {}; while (e-- > 0) { c = a[e]; d.map[d.getKey(c)] = e } ++d.generation } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "Bag"], 0)); (Ext.cmd.derive("Ext.util.Scheduler", Ext.Base, { busyCounter: 0, lastBusyCounter: 0, destroyed: false, firing: null, notifyIndex: -1, nextId: 0, orderedItems: null, passes: 0, scheduledCount: 0, validIdRe: null, config: { cycleLimit: 5, preSort: null, tickDelay: 5 }, suspendOnNotify: true, constructor: function (a) { this.mixins.observable.constructor.call(this, a); this.items = new Ext.util.Bag() }, destroy: function () { var a = this, b = a.timer; if (b) { window.clearTimeout(b); a.timer = null } a.items.destroy(); a.items = a.orderedItems = null; a.callParent() }, add: function (c) { var b = this, a = b.items; if (a === b.firing) { b.items = a = a.clone() } c.id = c.id || ++b.nextId; c.scheduler = b; a.add(c); if (!b.sortMap) { b.orderedItems = null } }, remove: function (c) { var b = this, a = b.items; if (b.destroyed) { return } if (a === b.firing) { b.items = a = a.clone() } if (c.scheduled) { b.unscheduleItem(c); c.scheduled = false } a.remove(c); b.orderedItems = null }, sort: function () { var d = this, a = d.items, e = {}, g = d.getPreSort(), b, c; d.orderedItems = []; d.sortMap = e; if (g) { a.sort(g) } a = a.items; for (b = 0; b < a.length; ++b) { c = a[b]; if (!e[c.id]) { d.sortItem(c) } } d.sortMap = null }, sortItem: function (c) { var b = this, d = b.sortMap, a = b.orderedItems, e; if (!c.scheduler) { b.add(c) } e = c.id; if (!(e in d)) { d[e] = 0; if (!c.sort.$nullFn) { c.sort() } d[e] = 1; c.order = b.orderedItems.length; a.push(c) } return b }, sortItems: function (a) { var b = this, c = b.sortItem; if (a) { if (a instanceof Array) { Ext.each(a, c, b) } else { Ext.Object.eachValue(a, c, b) } } return b }, applyPreSort: function (h) { if (typeof h === "function") { return h } var g = h.split(","), e = [], d = g.length, j, a, b; for (a = 0; a < d; ++a) { e[a] = 1; b = g[a]; if ((j = b.charAt(0)) === "-") { e[a] = -1 } else { if (j !== "+") { j = 0 } } if (j) { g[a] = b.substring(1) } } return function (c, p) { var k = 0, l, o, n, m; for (l = 0; !k && l < d; ++l) { o = g[l]; n = c[o]; m = p[o]; k = e[l] * ((n < m) ? -1 : ((m < n) ? 1 : 0)) } return k } }, notify: function () { var k = this, b = k.timer, d = k.getCycleLimit(), c = Ext.GlobalEvents, h = k.suspendOnNotify, m, e, l, j, g, a; if (b) { window.clearTimeout(b); k.timer = null } if (!k.firing && k.scheduledCount) { if (h) { Ext.suspendLayouts() } while (k.scheduledCount) { if (d) { --d } else { k.firing = null; break } if (!a) { a = true; if (c.hasListeners.beforebindnotify) { c.fireEvent("beforebindnotify", k) } } ++k.passes; if (!(g = k.orderedItems)) { k.sort(); g = k.orderedItems } j = g.length; if (j) { k.firing = k.items; for (e = 0; e < j; ++e) { l = g[e]; if (l.scheduled) { l.scheduled = false; --k.scheduledCount; k.notifyIndex = e; l.react(); if (!k.scheduledCount) { break } } } } } k.firing = null; k.notifyIndex = -1; if (h) { Ext.resumeLayouts(true) } } if ((m = k.busyCounter) !== k.lastBusyCounter) { if (!(k.lastBusyCounter = m)) { k.fireEvent("idle", k) } } }, onTick: function () { this.timer = null; this.notify() }, scheduleItem: function (b) { var a = this; ++a.scheduledCount; if (!a.timer && !a.firing) { a.scheduleTick() } }, scheduleTick: function () { var a = this; if (!a.destroyed && !a.timer) { a.timer = Ext.Function.defer(a.onTick, a.getTickDelay(), a) } }, unscheduleItem: function (a) { if (this.scheduledCount) { --this.scheduledCount } }, adjustBusy: function (a) { var b = this, c = b.busyCounter + a; b.busyCounter = c; if (c) { if (!b.lastBusyCounter) { b.lastBusyCounter = c; b.fireEvent("busy", b) } } else { if (b.lastBusyCounter && !b.timer) { b.scheduleTick() } } }, isBusy: function () { return !this.isIdle() }, isIdle: function () { return !(this.busyCounter + this.lastBusyCounter) } }, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.util, "Scheduler"], 0)); (Ext.cmd.derive("Ext.data.Batch", Ext.Base, { config: { pauseOnException: false }, current: -1, total: 0, running: false, complete: false, exception: false, constructor: function (a) { var b = this; b.mixins.observable.constructor.call(b, a); b.operations = []; b.exceptions = [] }, add: function (b) { var d = this, c, a; if (Ext.isArray(b)) { for (c = 0, a = b.length; c < a; ++c) { d.add(b[c]) } } else { d.total++; b.setBatch(d); d.operations.push(b) } return d }, sort: function () { this.operations.sort(this.sortFn) }, sortFn: function (c, a) { var b = c.order - a.order; if (b) { return b } var g = c.entityType, d = a.entityType, e; if (!g || !d) { return 0 } if (!(e = g.rank)) { g.schema.rankEntities(); e = g.rank } return (e - d.rank) * c.foreignKeyDirection }, start: function (a) { var b = this; if (!b.operations.length || b.running) { return b } b.exceptions.length = 0; b.exception = false; b.running = true; return b.runOperation(Ext.isDefined(a) ? a : b.current + 1) }, retry: function () { return this.start(this.current) }, runNextOperation: function () { var a = this; if (a.running) { a.runOperation(a.current + 1) } return a }, pause: function () { this.running = false; return this }, getOperations: function () { return this.operations }, getExceptions: function () { return this.exceptions }, getCurrent: function () { var a = null, b = this.current; if (!(b === -1 || this.complete)) { a = this.operations[b] } return a }, getTotal: function () { return this.total }, isRunning: function () { return this.running }, isComplete: function () { return this.complete }, hasException: function () { return this.exception }, runOperation: function (c) { var d = this, b = d.operations, a = b[c]; if (a === undefined) { d.running = false; d.complete = true; d.fireEvent("complete", d, b[b.length - 1]) } else { d.current = c; a.setInternalCallback(d.onOperationComplete); a.setInternalScope(d); a.execute() } return d }, onOperationComplete: function (a) { var c = this, b = a.hasException(); if (b) { c.exception = true; c.exceptions.push(a); c.fireEvent("exception", c, a) } if (b && c.getPauseOnException()) { c.pause() } else { c.fireEvent("operationcomplete", c, a); c.runNextOperation() } } }, 1, 0, 0, 0, 0, [["observable", Ext.mixin.Observable]], [Ext.data, "Batch"], 0)); (Ext.cmd.derive("Ext.data.matrix.Slice", Ext.Base, { constructor: function (a, b) { this.id = b; this.side = a; this.members = {} }, attach: function (a) { var b = this; b.store = a; a.matrix = b; a.on("load", b.onStoreLoad, b, { single: true }) }, commit: function () { var a = this.members, b; for (b in a) { a[b][2] = 0 } }, onStoreLoad: function (a) { this.update(a.getData().items, 0) }, update: function (n, g) { var t = this, j = Ext.data.matrix.Slice, c = t.side, k = c.index, e = n.length, m = t.id, s = t.members, b = c.inverse, r = b.slices, h, p, o, q, a, l, d; for (o = 0; o < e; ++o) { p = d = null; q = n[o]; a = q.isEntity ? (d = q).id : q; h = s[a]; if (g < 0 && h && h[2] === 1) { delete s[a]; l = r[a]; if (l) { delete l.members[m] } p = 1 } else { if (!h) { h = [a, a, g]; h[k] = m; s[a] = h; l = r[a]; if (!l) { r[a] = l = new j(b, a) } l.members[m] = h; p = 1 } else { if (g !== h[2] && g !== 0) { h[2] = g; l = r[a]; p = 1 } } } if (p) { if (t.notify) { t.notify.call(t.scope, t, a, g) } if (l && l.notify) { l.notify.call(l.scope, l, m, g) } } } }, updateId: function (b) { var j = this, a = j.id, i = j.side, m = i.slices, l = m[a], c = l.members, g = i.index, d = i.inverse.slices, h, e, k; j.id = b; m[b] = l; delete m[a]; for (e in c) { h = c[e]; h[g] = b; k = d[e].members; k[b] = k[a]; delete k[a] } }, destroy: function () { var b = this, a = b.store; if (a) { a.matrix = null; a.un("load", b.onStoreLoad, b) } b.notify = b.scope = b.store = b.side = b.members = null; b.callParent() } }, 1, 0, 0, 0, 0, 0, [Ext.data.matrix, "Slice"], 0)); (Ext.cmd.derive("Ext.data.matrix.Side", Ext.Base, { constructor: function (a, b, d) { var c = this; c.matrix = a; c.index = b; c.role = d; c.slices = {} }, commit: function () { var a = this.slices, b; for (b in a) { a[b].commit() } }, get: function (b, a) { var c = this, e = c.slices, d = e[b] || (e[b] = new Ext.data.matrix.Slice(c, b)); return (a || a === 0) ? d.members[a] : d }, update: function (b, a, c) { var d = this.get(b); return d.update(a, c) }, updateId: function (c, a) { var b = this.get(c); if (b) { b.updateId(a) } }, destroy: function () { var a = this, b = a.slices, c; for (c in b) { b[c].destroy() } a.inverse = a.matrix = a.role = a.slices = null; a.callParent() } }, 1, 0, 0, 0, 0, 0, [Ext.data.matrix, "Side"], 0)); (Ext.cmd.derive("Ext.data.matrix.Matrix", Ext.Base, { constructor: function (h, c) { var e = this, b = c.isManyToMany ? c : h.getSchema().getAssociation(c), a = Ext.data.matrix.Side, g = new a(e, 0, b.left), d = new a(e, 1, b.right); e.association = b; e.session = h; e.left = g; e.right = d; g.inverse = d; d.inverse = g }, commit: function () { this.left.commit(); this.right.commit() }, update: function (b, a, c) { return this.left.update(b, a, c) }, updateId: function (a, h, c) { var b = a.self, g = this.left, d = this.right, e; if (b === g.role.cls) { e = g } if (b === d.role.cls) { e = d } if (e) { e.updateId(h, c) } }, destroy: function () { var a = this; a.left.destroy(); a.right.destroy(); a.association = a.session = a.left = a.right = null; a.callParent() } }, 1, 0, 0, 0, 0, 0, [Ext.data.matrix, "Matrix"], 0)); (Ext.cmd.derive("Ext.data.session.ChangesVisitor", Ext.Base, { constructor: function (c) { var a = this, b; a.session = c; b = c.getCrudProperties(); a.result = null; a.writerOptions = {}; a.createKey = b.create; a.readKey = b.read; a.updateKey = b.update; a.dropKey = b.drop }, onDirtyRecord: function (g) { var j = this, m = j.crud, e = g.phantom, c = g.dropped, h = !e && !c, k = g.$className, b = (e || c) ? "allDataOptions" : "partialDataOptions", i = j.writerOptions, a = g.entityName, o, d, l, n; if (e && c) { return false } m = e ? j.createKey : (c ? j.dropKey : j.updateKey); i = i[k] || (i[k] = {}); if (c) { if (!(o = i.drop)) { i.drop = o = { all: g.getProxy().getWriter().getWriteAllFields() } } if (!o.all) { l = g.id } } if (!l) { if (!(o = i[b])) { o = g.getProxy().getWriter().getConfig(b); i[b] = o = Ext.Object.chain(o); j.setupOptions(o) } l = g.getData(o) } n = j.result || (j.result = {}); d = n[a] || (n[a] = {}); d = d[m] || (d[m] = []); d.push(l) }, setupOptions: function (a) { a.serialize = true }, onMatrixChange: function (d, j, i, a) { var h = this, b = d.left.type, g = d.right.role, e = a < 0 ? h.dropKey : h.createKey, c, k; k = h.result || (h.result = {}); c = k[b] || (k[b] = {}); c = c[g] || (c[g] = {}); c = c[e] || (c[e] = {}); c = c[j] || (c[j] = []); c.push(i) } }, 1, 0, 0, 0, 0, 0, [Ext.data.session, "ChangesVisitor"], 0)); (Ext.cmd.derive("Ext.data.session.ChildChangesVisitor", Ext.data.session.ChangesVisitor, { constructor: function () { this.seen = {}; Ext.data.session.ChangesVisitor.prototype.constructor.apply(this, arguments) }, setupOptions: function (a) { Ext.data.session.ChangesVisitor.prototype.setupOptions.call(this, a); a.serialize = false }, onDirtyRecord: function (a) { if (Ext.data.session.ChangesVisitor.prototype.onDirtyRecord.apply(this, arguments) !== false) { if (!a.$source && (a.dropped || !a.phantom)) { this.readEntity(a) } } }, readEntity: function (g) { var h = this, e = h.readKey, b = g.entityName, c = g.id, a = h.seen, i = b + c, j, d; if (a[i]) { return } a[i] = true; j = h.result || (h.result = {}); d = j[b] || (j[b] = {}); d = d[e] || (d[e] = []); d.push(Ext.apply({}, g.modified, g.data)) } }, 1, 0, 0, 0, 0, 0, [Ext.data.session, "ChildChangesVisitor"], 0)); (Ext.cmd.derive("Ext.data.session.BatchVisitor", Ext.Base, { map: null, constructor: function (a) { this.batch = a }, getBatch: function (g) { var h = this.map, d = this.batch, i, b, c, a, e; if (h) { if (!d) { d = new Ext.data.Batch() } for (c in h) { i = h[c]; b = i.entity; e = b.getProxy(); delete i.entity; for (a in i) { a = e.createOperation(a, { records: i[a] }); a.entityType = b; d.add(a) } } } if (d && g !== false) { d.sort() } return d }, onDirtyRecord: function (a) { var d = this, b = a.phantom ? "create" : (a.dropped ? "destroy" : "update"), c = a.$className, e = (d.map || (d.map = {})), g = (e[c] || (e[c] = { entity: a.self })); g = g[b] || (g[b] = []); g.push(a) } }, 1, 0, 0, 0, 0, 0, [Ext.data.session, "BatchVisitor"], 0)); (Ext.cmd.derive("Ext.mixin.Dirty", Ext.Base, { mixinId: "dirty", config: { dirty: null }, dirty: false, _dirtyRecordCount: 0, ignoreDirty: false, recordStateIsDirtyState: true, isDirty: function () { return this.getDirty() }, applyDirty: function (a) { return this.ignoreDirty ? false : a }, updateDirty: function (b, a) { var c = this; c.dirty = b; if (!c.ignoreDirty && c.fireEvent) { c.fireEvent("dirtychange", c, b) } }, clearRecordStates: function () { var b = this, a = b._crudCounters; if (a) { a.C = a.U = a.D = 0 } b._dirtyRecordCount = 0; if (b.recordStateIsDirtyState) { b.setDirty(false) } }, trackRecordState: function (a, b) { var e = this, d = e._crudCounters || (e._crudCounters = { C: 0, R: 0, U: 0, D: 0 }), i = e._dirtyRecordCount, h, c, g; if (!b && (g = a.crudStateWas) !== null) { --d[g] } ++d[a.crudState]; e._dirtyRecordCount = c = d.C + d.U + d.D; h = !c !== !i; if (h && e.recordStateIsDirtyState) { e.setDirty(c > 0) } return h }, untrackRecordState: function (a) { var d = this, c = d._crudCounters, g = d._dirtyRecordCount, e, b; if (c) { --c[a.crudState]; d._dirtyRecordCount = b = c.C + c.U + c.D; e = !b !== !g; if (e && d.recordStateIsDirtyState) { d.setDirty(b > 0) } } return e } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "Dirty"], 0)); (Ext.cmd.derive("Ext.data.Session", Ext.Base, { isSession: true, config: { schema: "default", parent: null, autoDestroy: true, crudProperties: { create: "C", read: "R", update: "U", drop: "D" } }, crudOperations: [{ type: "R", entityMethod: "readEntities" }, { type: "C", entityMethod: "createEntities" }, { type: "U", entityMethod: "updateEntities" }, { type: "D", entityMethod: "dropEntities" }], crudKeys: { C: 1, R: 1, U: 1, D: 1 }, statics: { nextId: 1 }, constructor: function (a) { var b = this; b.data = {}; b.matrices = {}; b.id = Ext.data.Session.nextId++; b.identifierCache = {}; b.recordCreator = b.recordCreator.bind(b); b.mixins.observable.constructor.call(b, a) }, destroy: function () { var d = this, b = d.matrices, e = d.data, c, g, a, h; for (h in b) { b[h].destroy() } for (c in e) { g = e[c]; for (h in g) { a = g[h].record; if (a) { a.$source = null; a.unjoin(d) } } } d.identifierCache = d.recordCreator = d.matrices = d.data = null; d.setSchema(null); d.callParent() }, adopt: function (b) { var d = this, c = b.associations, a; if (b.session !== d) { b.session = d; d.add(b); if (c) { for (a in c) { c[a].adoptAssociated(b, d) } } } }, commit: function () { var d = this, e = d.data, b = d.matrices, c, g, h, a; for (c in e) { g = e[c]; for (h in g) { a = g[h].record; if (a) { a.commit() } } } for (h in b) { b[h].commit() } d.clearRecordStates() }, createRecord: function (b, c) { var d = b.$isClass ? b : this.getSchema().getEntity(b), a = this.getParent(), e; if (c && a) { e = d.getIdFromData(c); if (a.peekRecord(d, e)) { Ext.raise("A parent session already contains an entry for " + d.entityName + ": " + e) } } return new d(c, this) }, getChanges: function () { var a = new Ext.data.session.ChangesVisitor(this); this.visitData(a); return a.result }, getChangesForParent: function () { var a = new Ext.data.session.ChildChangesVisitor(this); this.visitData(a); return a.result }, getRecord: function (i, a, c) { var h = this, b = i.isModel, g, d, j, e; if (b) { b = i; a = i.id; i = i.self } g = h.peekRecord(i, a); if (!g) { d = i.$isClass ? i : h.getSchema().getEntity(i); j = h.getParent(); if (j) { e = j.peekRecord(d, a) } if (e) { if (e.isLoading()) { b = false } else { g = e.copy(undefined, h); g.$source = e } } if (!g) { if (b) { g = b; h.adopt(g) } else { g = d.createWithId(a, null, h); if (c !== false) { g.load(Ext.isObject(c) ? c : undefined) } } } } return g }, getSaveBatch: function (a) { var b = new Ext.data.session.BatchVisitor(); this.visitData(b); return b.getBatch(a) }, onInvalidAssociationEntity: function (a, b) { Ext.raise("Unable to read association entity: " + this.getModelIdentifier(a, b)) }, onInvalidEntityCreate: function (a, b) { Ext.raise("Cannot create, record already not exists: " + this.getModelIdentifier(a, b)) }, onInvalidEntityDrop: function (a, b) { Ext.raise("Cannot drop, record does not exist: " + this.getModelIdentifier(a, b)) }, onInvalidEntityRead: function (a, b) { Ext.raise("Cannot read, record already not exists: " + this.getModelIdentifier(a, b)) }, onInvalidEntityUpdate: function (a, c, b) { if (b) { Ext.raise("Cannot update, record dropped: " + this.getModelIdentifier(a, c)) } else { Ext.raise("Cannot update, record does not exist: " + this.getModelIdentifier(a, c)) } }, peekRecord: function (e, i, a) { var h = e.$isClass ? e : this.getSchema().getEntity(e), c = h.entityName, g = this.data[c], b, d; g = g && g[i]; b = g && g.record; if (!b && a) { d = this.getParent(); b = d && d.peekRecord(e, i, a) } return b || null }, save: function () { var b = this, a = b.getParent(), c; if (a) { c = new Ext.data.session.ChildChangesVisitor(b); b.visitData(c); a.update(c.result); b.commit() } }, spawn: function () { return new this.self({ schema: this.getSchema(), parent: this }) }, update: function (k) { var m = this, e = m.getSchema(), a = m.crudOperations, l = a.length, n = m.crudKeys, o, g, q, j, d, r, c, p, h, b; m.getSchema().processKeyChecks(true); for (o in k) { g = e.getEntity(o); q = k[o]; for (j = 0; j < l; ++j) { d = a[j]; r = q[d.type]; if (r) { m[d.entityMethod](g, r) } } } for (o in k) { g = e.getEntity(o); c = g.associations; q = k[o]; for (p in q) { if (n[p]) { continue } h = c[p]; b = q[h.role]; h.processUpdate(m, b) } } }, privates: { add: function (b) { var e = this, g = b.id, d = e.getEntry(b.self, g), c, a; d.record = b; e.trackRecordState(b, true); e.registerReferences(b); c = b.associations; for (a in c) { c[a].checkMembership(e, b) } }, afterCommit: function (a) { this.trackRecordState(a) }, afterDrop: function (a) { this.trackRecordState(a) }, afterEdit: function (a) { this.trackRecordState(a) }, afterErase: function (a) { this.evict(a) }, applySchema: function (a) { return Ext.data.schema.Schema.get(a) }, createEntities: function (d, b) { var a = b.length, c, e, g, h; for (c = 0; c < a; ++c) { e = b[c]; h = d.getIdFromData(e); g = this.peekRecord(d, h); if (!g) { g = this.createRecord(d, e) } else { this.onInvalidEntityCreate(d, h) } g.phantom = true } }, dropEntities: function (e, d) { var b = d.length, c, g, h, a; if (b) { a = Ext.isObject(d[0]) } for (c = 0; c < b; ++c) { h = d[c]; if (a) { h = e.getIdFromData(h) } g = this.peekRecord(e, h); if (g) { g.drop() } else { this.onInvalidEntityDrop(e, h) } } }, evict: function (a) { var c = this, b = a.entityName, d = c.data[b], e = a.id; if (d && d[e]) { c.untrackRecordState(a); a.unjoin(c); delete d[e] } }, getEntityList: function (d, c) { var a = c.length, b, h, g, e; for (b = 0; b < a; ++b) { h = c[b]; g = this.peekRecord(d, h); if (g) { c[b] = g } else { e = true; c[b] = null; this.onInvalidAssociationEntity(d, h) } } if (e) { c = Ext.Array.clean(c) } return c }, getEntry: function (b, g) { if (b.isModel) { g = b.getId(); b = b.self } var d = b.$isClass ? b : this.getSchema().getEntity(b), a = d.entityName, e = this.data, c; c = e[a] || (e[a] = {}); c = c[g] || (c[g] = {}); return c }, getRefs: function (d, c, i) { var g = this.getEntry(d), e = g && g.refs && g.refs[c.role], h = i && this.getParent(), j, a, b; if (h) { j = h.getRefs(d, c); if (j) { for (a in j) { b = j[a]; if ((!e || !e[a])) { this.getRecord(b.self, b.id) } } e = g && g.refs && g.refs[c.role] } } return e || null }, getIdentifier: function (g) { var e = this.getParent(), a, c, d, b; if (e) { b = e.getIdentifier(g) } else { a = this.identifierCache; c = g.identifier; d = c.getId() || g.entityName; b = a[d]; if (!b) { if (c.clone) { b = c.clone({ id: null }) } else { b = c } a[d] = b } } return b }, getMatrix: function (a, e) { var d = a.isManyToMany ? a.name : a, c = this.matrices, b; b = c[d]; if (!b && !e) { b = c[d] = new Ext.data.matrix.Matrix(this, a) } return b || null }, getMatrixSlice: function (d, c) { var a = this.getMatrix(d.association), b = a[d.side]; return b.get(c) }, getModelIdentifier: function (a, b) { return b + "@" + a.entityName }, onIdChanged: function (g, m, i) { var r = this, b = r.matrices, j = g.entityName, n = g.id, u = r.data[j], c = u[m], q = g.associations, d = c.refs, a = r._setNoRefs, h, e, p, k, t, l, o, s; delete u[m]; u[i] = c; for (s in b) { b[s].updateId(g, m, i) } if (d) { for (l in d) { o = d[l]; t = q[l]; h = t.association; if (!h.isManyToMany) { e = h.field.name; for (k in o) { o[k].set(e, n, a) } } } } r.registerReferences(g, m) }, processManyBlock: function (d, e, h, b) { var i = this, a, g, c, j; if (h) { for (a in h) { g = i.peekRecord(d, a); if (g) { c = i.getEntityList(e.cls, h[a]); j = e.getAssociatedItem(g); i[b](e, j, g, c) } else { i.onInvalidAssociationEntity(d, a) } } } }, processManyCreate: function (d, c, a, b) { if (c) { c.add(b) } else { a[d.getterName](null, null, b) } }, processManyDrop: function (d, c, a, b) { if (c) { c.remove(b) } }, processManyRead: function (d, c, a, b) { if (c) { c.setRecords(b) } else { a[d.getterName](null, null, b) } }, readEntities: function (d, b) { var a = b.length, c, e, g, h; for (c = 0; c < a; ++c) { e = b[c]; h = d.getIdFromData(e); g = this.peekRecord(d, h); if (!g) { g = this.createRecord(d, e) } else { this.onInvalidEntityRead(d, h) } g.phantom = false } }, recordCreator: function (c, d) { var b = this, e = d.getIdFromData(c), a = b.peekRecord(d, e, true); if (!a) { a = new d(c, b) } else { a = b.getRecord(d, e) } return a }, registerReferences: function (j, c) { var m = j.entityName, b = j.id, a = j.data, h = c || c === 0, n, g, p, k, d, o, l, e; k = (o = j.references).length; for (g = 0; g < k; ++g) { d = o[g]; p = a[d.name]; if (p || p === 0) { d = d.reference; m = d.type; e = d.inverse.role; n = this.getEntry(d.cls, p); l = n.refs || (n.refs = {}); l = l[e] || (l[e] = {}); l[b] = j; if (h) { delete l[c] } } } }, updateEntities: function (e, b) { var a = b.length, d, g, h, j, c; if (Ext.isArray(b)) { for (d = 0; d < a; ++d) { g = b[d]; j = e.getIdFromData(g); h = this.peekRecord(e, j); if (h) { h.set(g) } else { this.onInvalidEntityUpdate(e, j) } } } else { for (j in b) { g = b[j]; h = this.peekRecord(e, j); if (h && !h.dropped) { c = h.set(g) } else { this.onInvalidEntityUpdate(e, j, !!h) } } } }, updateReference: function (g, i, c, a) { var d = i.reference, j = d.type, e = d.inverse.role, b = g.id, k, h; if (a || a === 0) { h = this.getEntry(j, a).refs[e]; delete h[b] } if (c || c === 0) { k = this.getEntry(j, c); h = k.refs || (k.refs = {}); h = h[e] || (h[e] = {}); h[b] = g } }, visitData: function (h) { var j = this, e = j.data, n = j.matrices, m, i, c, p, k, d, b, g, l, o, a; j.getSchema().processKeyChecks(true); for (b in e) { m = e[b]; for (c in m) { g = m[c].record; if (g) { if (g.phantom || g.dirty || g.dropped) { if (h.onDirtyRecord) { h.onDirtyRecord(g) } } else { if (h.onCleanRecord) { h.onCleanRecord(g) } } } } } if (h.onMatrixChange) { for (b in n) { k = n[b].left; o = k.slices; i = k.role.association; for (c in o) { l = o[c]; d = l.members; for (p in d) { a = (g = d[p])[2]; if (a) { h.onMatrixChange(i, g[0], g[1], a) } } } } } return h }, _setNoRefs: { refs: false } } }, 1, 0, 0, 0, 0, [[Ext.mixin.Dirty.prototype.mixinId || Ext.mixin.Dirty.$className, Ext.mixin.Dirty], [Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.data, "Session"], 0)); (Ext.cmd.derive("Ext.util.Schedulable", Ext.Base, { "abstract": true, isSchedulable: true, scheduled: false, constructor: function () { this.getScheduler().add(this) }, destroy: function () { var b = this, a = b.getScheduler(); if (a) { a.remove(b) } b.scheduler = null; b.schedule = b.react = Ext.emptyFn; b.callParent() }, getFullName: function () { return this.name || this.id }, privates: { getScheduler: function () { return this.scheduler }, schedule: function () { var b = this, a; if (!b.scheduled) { a = b.getScheduler(); if (a) { b.scheduled = true; if (b.onSchedule) { b.onSchedule() } a.scheduleItem(b) } } }, unschedule: function () { var b = this, a; if (b.scheduled) { a = b.getScheduler(); if (a) { a.unscheduleItem(b) } b.scheduled = false } }, sort: function () { } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "Schedulable"], 0)); (Ext.cmd.derive("Ext.app.bind.BaseBinding", Ext.util.Schedulable, { calls: 0, kind: 20, defaultOptions: {}, lastValue: undefined, constructor: function (a, e, c, b) { var d = this; d.options = b; d.owner = a; d.scope = c; d.callback = e; d.lateBound = Ext.isString(e); if (b && b.deep) { d.deep = true } Ext.util.Schedulable.prototype.constructor.call(this) }, destroy: function () { var b = this, a = b.owner; if (a) { a.onBindDestroy(b) } Ext.util.Schedulable.prototype.destroy.call(this); b.scope = b.callback = b.owner = null }, isReadOnly: function () { return true }, privates: { getScheduler: function () { var a = this.owner; return a && a.getScheduler() }, getSession: function () { var a = this.owner; return a.isSession ? a : a.getSession() }, notify: function (d) { var c = this, a = c.options || c.defaultOptions, b = c.lastValue; if (!c.calls || c.deep || c.valueChanged(d, b)) { ++c.calls; c.lastValue = d; if (c.lateBound) { c.scope[c.callback](d, b, c) } else { c.callback.call(c.scope, d, b, c) } if (a.single) { c.destroy() } } }, valueChanged: function (c, b) { var a = true; if (b !== c) { if (c && b && c instanceof Date && b instanceof Date) { a = c.getTime() !== b.getTime() } } else { a = Ext.isArray(c) } return a } } }, 1, 0, 0, 0, 0, 0, [Ext.app.bind, "BaseBinding"], 0)); (Ext.cmd.derive("Ext.app.bind.Binding", Ext.app.bind.BaseBinding, { constructor: function (d, e, b, a) { var c = this; Ext.app.bind.BaseBinding.prototype.constructor.call(this, d.owner, e, b, a); c.stub = d; c.depth = d.depth; if (!d.isLoading() && !d.scheduled) { c.schedule() } }, destroy: function (c) { var a = this, b = a.stub; if (b && !c) { b.unbind(a); a.stub = null } Ext.app.bind.BaseBinding.prototype.destroy.call(this) }, bindValidation: function (c, a) { var b = this.stub; return b && b.bindValidation(c, a) }, bindValidationField: function (c, a) { var b = this.stub; return b && b.bindValidationField(c, a) }, getFullName: function () { return this.fullName || (this.fullName = "@(" + this.stub.getFullName() + ")") }, getValue: function () { var a = this, b = a.stub; return b && b.getValue() }, isLoading: function () { var a = this.stub; return a && a.isLoading() }, isReadOnly: function () { var c = this.stub, b = this.options, a = true; if (!(b && b.twoWay === false)) { if (c) { a = c.isReadOnly() } } return a }, refresh: function () { }, setValue: function (a) { this.stub.set(a) }, privates: { getDataObject: function () { var a = this.stub; return a && a.getDataObject() }, getRawValue: function () { var a = this, b = a.stub; return b && b.getRawValue() }, isDescendantOf: function (a) { var b = this.stub; return b ? (a === b) || b.isDescendantOf(a) : false }, react: function () { this.notify(this.getValue()) }, schedule: function () { if (!this.stub.scheduled) { Ext.app.bind.BaseBinding.prototype.schedule.call(this) } }, sort: function () { var a = this.stub; a.scheduler.sortItem(a) } } }, 1, 0, 0, 0, 0, 0, [Ext.app.bind, "Binding"], 0)); (Ext.cmd.derive("Ext.app.bind.AbstractStub", Ext.util.Schedulable, { children: null, depth: 0, generation: 1, kind: 10, parent: null, constructor: function (a, b) { var c = this; c.owner = a; c.name = b; Ext.util.Schedulable.prototype.constructor.call(this) }, destroy: function () { var e = this, d = e.children, g = e.bindings, a, c, b; if (g) { for (c = 0, a = g.length; c < a; ++c) { g[c].destroy(true) } } for (b in d) { d[b].destroy() } if (e.scheduled) { e.unschedule() } Ext.util.Schedulable.prototype.destroy.call(this) }, add: function (b) { var a = this; (a.children || (a.children = {}))[b.name] = b; b.depth = a.depth + 1; b.parent = a }, getChild: function (b) { var a = Ext.isString(b) ? b.split(".") : b; if (a && a.length) { return this.descend(a, 0) } return this }, getFullName: function () { var d = this, a = d.fullName, c = d.parent, b; if (!a) { a = d.name || d.id; if (c && (b = c.getFullName())) { a = ((b.charAt(b.length - 1) !== ":") ? b + "." : b) + a } d.fullName = a } return a }, getSession: function () { var a = this.owner; return a.isSession ? a : a.getSession() }, bind: function (g, b, a) { var c = this, d = new Ext.app.bind.Binding(c, g, b, a), e = (c.bindings || (c.bindings = [])); d.depth = c.depth; e.push(d); return d }, getValue: function () { return this.isLoading() ? null : this.getRawValue() }, graft: function (c) { var d = this, e = d.bindings, a = d.name, b; d.parent = d.bindings = null; d.destroy(); c.depth = d.depth; c.bindings = e; c.generation = d.generation + 1; c.name = a; c.id = d.id; c.path = d.path; if (e) { for (b = e.length; b-- > 0;) { e[b].stub = c } } return c }, isDescendantOf: function (b) { for (var a = this; a = a.parent;) { if (a === b) { return true } } return false }, onSchedule: function () { for (var b, a, d, e, c = this.parent; c; c = c.parent) { e = c.bindings; if (e) { for (b = 0, a = e.length; b < a; ++b) { d = e[b]; if (d.deep && !d.scheduled) { d.schedule() } } } } }, react: function () { var d = this.bindings, c, b, a; if (d) { for (b = 0, a = d.length; b < a; ++b) { c = d[b]; if (!c.scheduled) { c.schedule() } } } }, unbind: function (a) { var b = this.bindings; if (b && b.length) { Ext.Array.remove(b, a) } }, privates: { collect: function () { var c = this.children, g = this.bindings, a = 0, d = 0, e, b; if (c) { for (b in c) { e = c[b]; d = e.collect(); if (d === 0) { e.destroy(); delete c[b] } a += d } } if (g) { a += g.length } return a }, getScheduler: function () { var a = this.owner; return a && a.getScheduler() }, sort: function () { var a = this.parent; if (a) { this.scheduler.sortItem(a) } } } }, 1, 0, 0, 0, 0, 0, [Ext.app.bind, "AbstractStub"], 0)); (Ext.cmd.derive("Ext.app.bind.Stub", Ext.app.bind.AbstractStub, { isStub: true, dirty: true, formula: null, validationKey: "validation", constructor: function (a, b, c) { var d = this, e = b; Ext.app.bind.AbstractStub.prototype.constructor.call(this, a, b); d.boundValue = null; if (c) { c.add(d); if (!c.isRootStub) { e = c.path + "." + b } d.checkHadValue() } d.path = e }, destroy: function () { var b = this, c = b.formula, a = b.storeBinding; if (c) { c.destroy() } if (a) { a.destroy() } b.detachBound(); Ext.app.bind.AbstractStub.prototype.destroy.call(this) }, bindValidation: function (c, b) { var a = this.parent; return a && a.descend([this.validationKey, this.name]).bind(c, b) }, bindValidationField: function (g, d) { var c = this.parent, b = this.name, e = typeof g === "string", a; if (c) { a = c.bind(function (h) { var i = null; if (h && h.isModel) { i = h.getField(b) } if (e) { d[g](i, h, this) } else { g.call(d, i, h, this) } }) } return a || null }, descend: function (g, c) { var e = this, d = e.children || (e.children = {}), h = c || 0, b = g[h++], a; if (!(a = d[b])) { a = new Ext.app.bind.Stub(e.owner, b, e) } if (h < g.length) { a = a.descend(g, h) } return a }, getChildValue: function (a) { var d = this, c = d.name, b; if (!a && !Ext.isString(a)) { b = d.hadValue ? null : undefined } else { b = d.inspectValue(a); if (!b) { if (a.isEntity) { b = a.data[c] } else { b = a[c] } } } return b }, getDataObject: function () { var e = this, a = e.parent.getDataObject(), c = e.name, b = a ? a[c] : null, d; if (!b && a && a.isEntity) { d = a.associations; if (d && c in d) { b = a[d[c].getterName]() } } if (!b || !(b.$className || Ext.isObject(b))) { a[c] = b = {}; e.hadValue = true; e.invalidate(true, true) } return b }, getRawValue: function () { return this.getChildValue(this.getParentValue()) }, graft: function (e) { var g = this, d = g.parent, c = g.children, a = g.name, b; e.parent = d; e.children = c; if (d) { d.children[a] = e } if (c) { for (b in c) { c[b].parent = e } } g.children = null; e.checkHadValue(); return Ext.app.bind.AbstractStub.prototype.graft.call(this, e) }, isLoading: function () { var d = this, c = d.parent, h = false, b, g, e, a; if (c && !(h = c.isLoading())) { g = d.getParentValue(); e = d.inspectValue(g); if (e) { h = e.isLoading() } else { if (g && g.isModel) { b = g.associations; if (!(b && d.name in b)) { h = false; a = true } } if (!a) { h = !d.hadValue && d.getRawValue() === undefined } } } return h }, invalidate: function (b, a) { var e = this, d = e.children, c; e.checkHadValue(); e.dirty = true; if (!a && !e.isLoading()) { if (!e.scheduled) { e.schedule() } } if (b && d) { for (c in d) { d[c].invalidate(b, a) } } }, isReadOnly: function () { var a = this.formula; return !!(a && !a.set) }, set: function (j) { var i = this, k = i.parent, a = i.name, g = i.formula, h, c, b, d, e; if (g && !g.settingValue && g.set) { g.setValue(j); return } else { if (i.isLinkStub) { d = i.getLinkFormulaStub(); g = d ? d.formula : null; if (g) { g.setValue(j); return } } } h = k.getDataObject(); if (h.isEntity) { c = h.associations; if (c && (a in c)) { b = c[a]; e = b.setterName; if (e) { h[e](j) } i.invalidate(true) } else { h.set(a, j) } } else { if ((j && j.constructor === Object) || j !== h[a]) { if (!i.setByLink(j)) { if (j === undefined) { delete h[a] } else { h[a] = j } i.inspectValue(h); i.invalidate(true) } } } }, onStoreLoad: function () { this.invalidate(true) }, afterLoad: function (a) { this.invalidate(true) }, afterCommit: function (a) { this.afterEdit(a, null) }, afterEdit: function (b, h) { var g = this.children, a = h && h.length, e = b.associations, d, c, j; if (g) { if (a) { for (c = 0; c < a; ++c) { j = g[h[c]]; if (j) { j.invalidate() } } } else { for (d in g) { if (!(e && d in e)) { g[d].invalidate() } } } } this.invalidate() }, afterReject: function (a) { this.afterEdit(a, null) }, afterAssociatedRecordSet: function (a, d, e) { var c = this.children, b = e.role; if (c && b in c) { c[b].invalidate(true) } }, setByLink: function (d) { var c = this, h = 0, a, b, g, e; for (e = c; e; e = e.parent) { if (e.isLinkStub) { b = e; if (h) { for (g = [], a = 0, e = c; e !== b; e = e.parent) { ++a; g[h - a] = e.name } } break } ++h } if (!b || !(e = b.getTargetStub())) { return false } if (g) { e = e.descend(g) } e.set(d); return true }, setFormula: function (c) { var a = this, b = a.formula; if (b) { b.destroy() } a.formula = new Ext.app.bind.Formula(a, c) }, react: function () { var c = this, b = this.boundValue, a = c.children, d; if (b) { if (b.isValidation) { b.refresh(); d = b.generation; if (c.lastValidationGeneration === d) { return } c.lastValidationGeneration = d } else { if (b.isModel) { if (a && a[c.validationKey]) { b.isValid() } } else { if (b.isStore) { if (b.isLoading() && !b.loadCount) { return } } } } } Ext.app.bind.AbstractStub.prototype.react.call(this) }, privates: { checkHadValue: function () { if (!this.hadValue) { this.hadValue = this.getRawValue() !== undefined } }, collect: function () { var c = this, a = Ext.app.bind.AbstractStub.prototype.collect.call(this), b = c.storeBinding ? 1 : 0, d = c.formula ? 1 : 0; return a + b + d }, getLinkFormulaStub: function () { var a = this; while (a.isLinkStub) { a = a.binding.stub } return a.formula ? a : null }, getParentValue: function () { var a = this; if (a.dirty) { a.parentValue = a.parent.getValue(); a.dirty = false } return a.parentValue }, setStore: function (a) { this.storeBinding = a }, inspectValue: function (h) { var i = this, a = i.name, e = i.boundValue, b = null, c, j, d, g; if (h && h.isEntity) { c = h.associations; if (c && (a in c)) { b = h[c[a].getterName](); if (b && b.isStore) { b.$associatedStore = true } } else { if (a === i.validationKey) { b = h.getValidation(); i.lastValidationGeneration = null } } } else { if (h) { j = h[a]; if (j && (j.isModel || j.isStore)) { b = j } } } d = e !== b; if (d) { if (e) { i.detachBound() } if (b) { if (b.isModel) { b.join(i) } else { g = b.associatedEntity; if (g && b.autoLoad !== false && !b.complete && !b.hasPendingLoad()) { b.load() } b.on({ scope: i, load: { fn: "onStoreLoad", single: true }, destroy: "onDestroyBound" }) } } i.boundValue = b } return b }, detachBound: function () { var a = this, b = a.boundValue; if (b) { if (b.isModel) { b.unjoin(a) } else { b.un({ scope: a, load: "onStoreLoad", destroy: "onDestroyBound" }) } } }, onDestroyBound: function () { if (!this.owner.destroying) { this.set(null) } }, sort: function () { var c = this, d = c.formula, a = c.scheduler, b = c.storeBinding; Ext.app.bind.AbstractStub.prototype.sort.call(this); if (b) { a.sortItem(b) } if (d) { a.sortItem(d) } } } }, 1, 0, 0, 0, 0, 0, [Ext.app.bind, "Stub"], 0)); (Ext.cmd.derive("Ext.app.bind.LinkStub", Ext.app.bind.Stub, { isLinkStub: true, binding: null, destroy: function () { var b = this, c = b.binding, a = b.owner; if (c) { b.binding = null; c.destroy(); if (a) { delete a.linkData[b.name] } } b.target = null; Ext.app.bind.Stub.prototype.destroy.call(this) }, getFullName: function () { var a = this; return a.fullName || (a.fullName = "(" + Ext.app.bind.Stub.prototype.getFullName.call(this) + " -> " + a.binding.getFullName() + ")") }, getDataObject: function () { var a = this.binding; return a && a.getDataObject() }, getRawValue: function () { var a = this.binding; return a && a.getRawValue() }, getValue: function () { var a = this.binding; return a && a.getValue() }, getTargetStub: function () { var a = this.binding; return a && a.stub }, isLoading: function () { var a = this.binding; return a ? a.isLoading() : false }, link: function (d, b) { var a = this, c = a.binding; if (c) { c.destroy() } b = a.target = b || a.owner; a.linkDescriptor = d; a.binding = b.bind(d, a.onChange, a); a.binding.deep = true }, onChange: function () { this.invalidate(true) }, react: function () { var b = this, a = b.owner.linkData; a[b.name] = b.getValue(); Ext.app.bind.Stub.prototype.react.call(this) }, privates: { collect: function () { var b = this, a = Ext.app.bind.Stub.prototype.collect.call(this), c = b.binding ? 1 : 0; return a + c }, sort: function () { var a = this.binding; if (a) { this.scheduler.sortItem(a) } } } }, 0, 0, 0, 0, 0, 0, [Ext.app.bind, "LinkStub"], 0)); (Ext.cmd.derive("Ext.app.bind.RootStub", Ext.app.bind.AbstractStub, { isRootStub: true, depth: 0, createRootChild: function (a, e) { var j = this, b = j.owner, g = b.getData(), c = j.children, i = c && c[a], h = i ? null : j, k, d; if (e || g.hasOwnProperty(a) || !(k = b.getParent())) { d = new Ext.app.bind.Stub(b, a, h) } else { d = new Ext.app.bind.LinkStub(b, a, i ? null : h); d.link("{" + a + "}", k) } if (i) { i.graft(d) } return d }, createStubChild: function (a) { return this.createRootChild(a, true) }, descend: function (g, c) { var e = this, d = e.children, h = c || 0, b = g[h++], a = (d && d[b]) || e.createRootChild(b); if (h < g.length) { a = a.descend(g, h) } return a }, getFullName: function () { return this.fullName || (this.fullName = this.owner.id + ":") }, getDataObject: function () { return this.owner.data }, getRawValue: function () { return this.owner.data }, getValue: function () { return this.owner.data }, isDescendantOf: function () { return false }, isLoading: function () { return false }, set: function (h) { var g = this, b = g.children || (g.children = {}), a = g.owner, d = a.data, k = a.getParent(), e, c, j, i; for (i in h) { if ((j = h[i]) !== undefined) { if (!(c = b[i])) { c = new Ext.app.bind.Stub(a, i, g) } else { if (c.isLinkStub) { if (!c.getLinkFormulaStub()) { e = c; c = new Ext.app.bind.Stub(a, i); e.graft(c) } } } c.set(j) } else { if (d.hasOwnProperty(i)) { delete d[i]; c = b[i]; if (c) { if (!c.isLinkStub && k) { c = g.createRootChild(i) } c.invalidate(true) } } } } }, schedule: Ext.emptyFn, unschedule: Ext.emptyFn }, 0, 0, 0, 0, 0, 0, [Ext.app.bind, "RootStub"], 0)); (Ext.cmd.derive("Ext.app.bind.Multi", Ext.app.bind.BaseBinding, { isMultiBinding: true, missing: 1, deep: true, constructor: function (e, a, h, c, b) { var d = this, g = b && b.trackStatics; Ext.app.bind.BaseBinding.prototype.constructor.call(this, a, h, c, b); d.bindings = []; d.literal = e.$literal; if (e.constructor === Object) { if (g) { d.staticKeys = [] } d.addObject(e, d.lastValue = {}, d.staticKeys) } else { d.addArray(e, d.lastValue = []) } if (!--d.missing && !d.scheduled) { d.schedule() } }, destroy: function () { var a = this; a.bindings = Ext.destroy(a.bindings); Ext.app.bind.BaseBinding.prototype.destroy.call(this) }, add: function (b, g, j) { var i = this, d = i.owner, c = i.bindings, a = i.literal ? (b.reference ? "bindEntity" : "bindExpression") : "bind", h, e; ++i.missing; h = d[a](b, function (k) { g[j] = k; if (h.calls === 1) { --i.missing } if (!i.missing && !i.scheduled) { i.schedule() } }, i, null); e = h.depth; if (!c.length || e < i.depth) { i.depth = e } c.push(h); return !this.isBindingStatic(h) }, addArray: function (c, k) { var g = this, j = c.length, d = false, h, a, e; for (e = 0; e < j; ++e) { a = c[e]; if (a && (a.reference || Ext.isString(a))) { h = g.add(a, k, e) } else { if (Ext.isArray(a)) { h = g.addArray(a, k[e] = []) } else { if (a && a.constructor === Object) { h = g.addObject(a, k[e] = {}) } else { k[e] = a; h = false } } } d = d || h } return d }, addObject: function (c, g, i) { var h = this, e = false, j, a, d; for (d in c) { a = c[d]; if (a && (a.reference || Ext.isString(a))) { j = h.add(a, g, d) } else { if (Ext.isArray(a)) { j = h.addArray(a, g[d] = []) } else { if (a && a.constructor === Object) { j = h.addObject(a, g[d] = {}) } else { g[d] = a; j = false } } } if (i && !j) { i.push(d) } e = e || j } return e }, getFullName: function () { var c = this, d = c.fullName, e = c.bindings, b = e.length, a; if (!d) { d = "@["; for (a = 0; a < b; ++a) { if (a) { d += "," } d += e[a].getFullName() } d += "]"; c.fullName = d } return d }, getRawValue: function () { return this.lastValue }, isDescendantOf: function () { return false }, isLoading: function () { for (var b = this.bindings, a = b.length; a-- > 0;) { if (b[a].isLoading()) { return true } } return false }, isBindingStatic: function (a) { return a.isTemplateBinding && a.isStatic }, isStatic: function () { var d = this.bindings, a = d.length, b, c; for (b = 0; b < a; ++b) { c = d[b]; if (!this.isBindingStatic(c)) { return false } } return true }, pruneStaticKeys: function () { var d = Ext.apply({}, this.lastValue), c = this.staticKeys, a = c.length, b; for (b = 0; b < a; ++b) { delete d[c[b]] } return d }, react: function () { this.notify(this.lastValue) }, refresh: function () { }, privates: { sort: function () { this.scheduler.sortItems(this.bindings) } } }, 1, 0, 0, 0, 0, 0, [Ext.app.bind, "Multi"], 0)); (Ext.cmd.derive("Ext.app.bind.Formula", Ext.util.Schedulable, { statics: { getFormulaParser: function (b) { var a = this.formulaCache, d, c; if (!a) { a = this.formulaCache = new Ext.util.LruCache({ maxSize: 20 }) } d = a.get(b); if (!d) { c = "[^\\.a-z0-9_]" + b + "\\(\\s*(['\"])(.*?)\\1\\s*\\)"; d = new RegExp(c, "gi"); a.add(b, d) } return d } }, isFormula: true, calculation: null, explicit: false, set: null, single: false, argumentNamesRe: /^function\s*\(\s*([^,\)\s]+)/, constructor: function (h, i) { var g = this, b = h.owner, d, e, a, c; g.owner = b; g.stub = h; Ext.util.Schedulable.prototype.constructor.call(this); if (i instanceof Function) { g.get = a = i } else { g.get = a = i.get; g.set = i.set; e = i.bind; if (i.single) { g.single = i.single } if (e) { d = e.bindTo; if (d) { c = Ext.apply({}, e); delete c.bindTo; e = d } } } if (e) { g.explicit = true } else { e = a.$expressions || g.parseFormula(a) } g.binding = b.bind(e, g.onChange, g, c) }, destroy: function () { var a = this, c = a.binding, b = a.stub; if (c) { c.destroy(); a.binding = null } if (b) { b.formula = null } Ext.util.Schedulable.prototype.destroy.call(this); a.getterFn = a.owner = null }, getFullName: function () { return this.fullName || (this.fullName = this.stub.getFullName() + "=" + Ext.util.Schedulable.prototype.getFullName.call(this) + ")") }, getRawValue: function () { return this.calculation }, onChange: function () { if (!this.scheduled) { this.schedule() } }, parseFormula: function (h) { var g = h.toString(), d = { $literal: true }, c, b, a, e; c = this.argumentNamesRe.exec(g); b = c ? c[1] : "get"; a = Ext.app.bind.Formula.getFormulaParser(b); while ((c = a.exec(g))) { e = c[2]; d[e] = e } d.$literal = true; h.$expressions = d; return d }, react: function () { var c = this, b = c.owner, d = c.binding.lastValue, e = c.getterFn, a; if (c.explicit) { a = d } else { a = b.getFormulaFn(d) } c.settingValue = true; c.stub.set(c.calculation = c.get.call(b, a)); c.settingValue = false; if (c.single) { c.destroy() } }, setValue: function (a) { this.set.call(this.stub.owner, a) }, privates: { getScheduler: function () { var a = this.owner; return a && a.getScheduler() }, sort: function () { var a = this, b = a.binding; if (!b.destroyed) { a.scheduler.sortItem(b) } } } }, 1, 0, 0, 0, 0, 0, [Ext.app.bind, "Formula"], 0)); (Ext.cmd.derive("Ext.util.Fly", Ext.Base, { inheritableStatics: { flyPoolSize: 2, fly: function () { var c = this, b = c.flyweights || (c.flyweights = []), a = b.length ? b.pop() : new c(); a.reset.apply(a, arguments); return a } }, release: function () { var c = this, b = c.self, a = b.flyweights || (b.flyweights = []); c.reset(); if (a.length < b.flyPoolSize) { a.push(c) } }, reset: Ext.emptyFn }, 0, 0, 0, 0, 0, 0, [Ext.util, "Fly"], 0)); (Ext.cmd.derive("Ext.parse.Tokenizer", Ext.util.Fly, function (j) { var i = (j.flyweights = []), d = { literal: true, "boolean": true }, g = { error: true }, a = { ident: true }, b = { literal: true }, e = { literal: true, nil: true }, c = { literal: true, number: true }, h = { literal: true, string: true }; return { isTokenizer: true, statics: { BOOLEAN: d, ERROR: g, IDENT: a, LITERAL: b, NULL: e, NUMBER: c, STRING: h }, config: { keywords: { "null": { type: "literal", is: e, value: null }, "false": { type: "literal", is: d, value: false }, "true": { type: "literal", is: d, value: true } }, operators: { "+": "plus", "-": "minus", "*": "multiply", "/": "divide", "!": "bang", ",": "comma", ":": "colon", "[": "arrayOpen", "]": "arrayClose", "{": "curlyOpen", "}": "curlyClose", "(": "parenOpen", ")": "parenClose" } }, error: null, index: -1, constructor: function (k) { this.operators = {}; this.initConfig(k) }, next: function () { var k = this.peek(); this.head = undefined; return k }, peek: function () { var m = this, k = m.error, l = m.head; if (k) { return k } if (l === undefined) { m.head = l = m.advance() } return l }, release: function () { this.reset(); if (i.length < j.flyPoolSize) { i.push(this) } }, reset: function (m, n, k) { var l = this; l.error = null; l.head = undefined; l.index = -1; l.text = m || null; l.pos = n || 0; l.end = (m && k == null) ? m.length : k; return l }, privates: { digitRe: /[0-9]/, identFirstRe: /[a-z_$]/i, identRe: /[0-9a-z_$]/i, spaceRe: /[ \t]/, end: 0, head: undefined, pos: 0, text: null, applyOperators: function (m) { var o = this.operators, n, s, l, p, r, k, q; for (q in m) { n = o; k = m[q]; r = q.length; for (p = 0; p < r; ++p) { s = q.charAt(p); n = n[s] || (n[s] = {}) } if (k) { n.token = l = { type: "operator", value: q, is: { operator: true } }; l.is[k] = true } else { n.token = null } } }, advance: function () { var m = this, k = m.spaceRe, n = m.text, l = m.end, o; while (m.pos < l) { o = n.charAt(m.pos); if (k.test(o)) { ++m.pos; continue } m.index = m.pos; return m.parse(o) } return null }, parse: function (p) { var n = this, l = n.digitRe, o = n.text, m = n.end, k; if (p === "." && n.pos + 1 < m) { if (l.test(o.charAt(n.pos + 1))) { k = n.parseNumber() } } if (!k && n.operators[p]) { k = n.parseOperator(p) } if (!k) { if (p === '"' || p === "'") { k = n.parseString() } else { if (l.test(p)) { k = n.parseNumber() } else { if (n.identFirstRe.test(p)) { k = n.parseIdent() } else { k = n.syntaxError("Unexpected character") } } } } return k }, parseIdent: function () { var s = this, o = s.identRe, p = s.getKeywords(), q = !s.operators["."], u = s.text, k = s.pos, n = k, l = s.end, m = 0, r, t; while (n < l) { r = u.charAt(n); if (q && r === ".") { if (m === ".") { return s.syntaxError(n, "Unexpected dot operator") } ++n } else { if (o.test(r)) { ++n } else { break } } m = r } if (m === ".") { return s.syntaxError(n - 1, "Unexpected dot operator") } t = u.substring(k, s.pos = n); return (p && p[t]) || { type: "ident", is: a, value: t } }, parseNumber: function () { var r = this, o = r.digitRe, s = r.text, k = r.pos, l = r.end, q, p, n, m; while (r.pos < l) { q = s.charAt(r.pos); if (q === "-" || q === "+") { if (r.pos !== k) { return r.syntaxError(k, "Invalid number") } ++r.pos } else { if (q === ".") { if (p) { break } p = true; ++r.pos } else { if (q === "e" || q === "E") { if (n) { break } p = n = true; q = s.charAt(++r.pos); if (q === "-" || q === "+") { ++r.pos } } else { if (o.test(q)) { ++r.pos } else { break } } } } } m = { type: "literal", is: c, value: +s.substring(k, r.pos) }; if (!isFinite(m.value)) { m = r.syntaxError(k, "Invalid number") } return m }, parseOperator: function (q) { var r = this, m = r.operators, s = r.text, k = r.end, n = r.pos, p, o, l; while (m[q]) { m = m[q]; l = m.token; ++n; if (l) { p = l; o = n } if (n < k) { q = s.charAt(n) } else { break } } if (p) { r.pos = o } return p }, parseString: function () { var q = this, s = q.text, r = q.pos, l = r, m = q.end, p = "", o, n, k; k = s.charAt(r++); while (r < m) { o = s.charAt(r++); if (o === k) { n = true; break } if (o === "\\" && r < m) { o = s.charAt(r++) } p += o } q.pos = r; if (!n) { return q.syntaxError(l, "Unterminated string") } return { type: "literal", is: h, value: p } }, syntaxError: function (k, m) { if (typeof k === "string") { m = k; k = this.pos } var n = (k == null) ? "" : (" (at index " + k + ")"), l = new Error(m + n); l.type = "error"; l.is = g; if (n) { l.at = k } return this.error = l } } } }, 1, 0, 0, 0, 0, 0, [Ext.parse, "Tokenizer"], 0)); (Ext.cmd.derive("Ext.parse.Symbol", Ext.Base, { priority: 0, constructor: function (d, a) { var b = this, c = b.defaultProperty; if (a && typeof a === "object") { Ext.apply(b, a) } else { if (a !== undefined && c) { b[c] = a } } b.id = d }, led: function () { this.parser.syntaxError(this.at, "Missing operator") }, nud: function () { this.parser.syntaxError(this.at, "Undefined") }, update: function (b) { if (b && typeof b === "object") { var d = this, c = b.priority, e = b.led, a = b.nud; if (d.priority <= c) { d.priority = c } if (e) { d.led = e } if (a) { d.nud = a } } } }, 1, 0, 0, 0, 0, 0, [Ext.parse, "Symbol"], 0)); (Ext.cmd.derive("Ext.parse.symbol.Constant", Ext.parse.Symbol, { arity: "literal", isLiteral: true, defaultProperty: "value", constructor: function (b, a) { Ext.parse.Symbol.prototype.constructor.call(this, b, a); this._value = this.value }, nud: function () { var a = this; a.value = a._value; a.arity = "literal"; a.isLiteral = true; return a } }, 1, 0, 0, 0, 0, 0, [Ext.parse.symbol, "Constant"], 0)); (Ext.cmd.derive("Ext.parse.symbol.Infix", Ext.parse.Symbol, { arity: "binary", isBinary: true, defaultProperty: "priority", led: function (b) { var a = this; a.lhs = b; a.rhs = a.parser.parseExpression(a.priority); a.arity = "binary"; a.isBinary = true; return a } }, 0, 0, 0, 0, 0, 0, [Ext.parse.symbol, "Infix"], 0)); (Ext.cmd.derive("Ext.parse.symbol.InfixRight", Ext.parse.symbol.Infix, { led: function (b) { var a = this; a.lhs = b; a.rhs = a.parser.parseExpression(a.priority - 1); a.arity = "binary"; a.isBinary = true; return a } }, 0, 0, 0, 0, 0, 0, [Ext.parse.symbol, "InfixRight"], 0)); (Ext.cmd.derive("Ext.parse.symbol.Paren", Ext.parse.Symbol, { arity: "binary", isBinary: true, priority: 80, led: function (d) { var c = this, a = [], g = c.parser, e = d.id, b = d.arity; if (e !== "." && e !== "[") { if ((b !== "unary" || e !== "function") && b !== "ident" && e !== "(" && e !== "&&" && e !== "||" && e !== "?") { g.syntaxError(d.at, "Expected a variable name.") } } c.arity = "invoke"; c.isInvoke = true; c.operand = d; c.args = a; while (g.token.id !== ")") { if (a.length) { g.advance(",") } a.push(g.parseExpression()) } g.advance(")"); return c }, nud: function () { var b = this.parser, a = b.parseExpression(); b.advance(")"); return a } }, 0, 0, 0, 0, 0, 0, [Ext.parse.symbol, "Paren"], 0)); (Ext.cmd.derive("Ext.parse.symbol.Prefix", Ext.parse.Symbol, { arity: "unary", isUnary: true, priority: 70, nud: function () { var a = this; a.operand = a.parser.parseExpression(a.priority); a.arity = "unary"; a.isUnary = true; return a } }, 0, 0, 0, 0, 0, 0, [Ext.parse.symbol, "Prefix"], 0)); (Ext.cmd.derive("Ext.parse.Parser", Ext.util.Fly, function () { var a = function () { return this }; return { isParser: true, config: { constants: { "null": null, "false": false, "true": true }, infix: { "+": 50, "-": 50, "*": 60, "/": 60 }, infixRight: { "&&": 30, "||": 30 }, prefix: { "!": 0, "-": 0, "+": 0 }, symbols: { ":": 0, ",": 0, ")": 0, "[": 0, "]": 0, "{": 0, "}": 0, "(end)": 0, "(ident)": { arity: "ident", isIdent: true, nud: a }, "(literal)": { arity: "literal", isLiteral: true, nud: a }, "(": { xclass: "Ext.parse.symbol.Paren" } }, tokenizer: { keywords: null } }, token: null, constructor: function (b) { this.symbols = {}; this.initConfig(b) }, advance: function (g) { var i = this, k = i.tokenizer, d = k.peek(), b = i.symbols, h = k.index, e, c, j; if (i.error) { throw i.error } if (g) { i.expect(g) } if (!d) { return i.token = b["(end)"] } k.next(); e = d.is; j = d.value; if (e.ident) { c = b[j] || b["(ident)"] } else { if (e.operator) { if (!(c = b[j])) { i.syntaxError(d.at, 'Unknown operator "' + j + '"') } } else { if (e.literal) { c = b["(literal)"] } else { i.syntaxError(d.at, "Unexpected token") } } } i.token = c = Ext.Object.chain(c); c.at = h; c.value = j; if (!c.arity) { c.arity = d.type } return c }, expect: function (c) { var b = this.token; if (c !== b.id) { this.syntaxError(b.at, 'Expected "' + c + '"') } return this }, parseExpression: function (b) { var d = this, c = d.token, e; b = b || 0; d.advance(); e = c.nud(); while (b < (c = d.token).priority) { d.advance(); e = c.led(e) } return e }, reset: function (d, e, b) { var c = this; c.error = c.token = null; c.tokenizer.reset(d, e, b); c.advance(); return c }, syntaxError: function (b, d) { if (typeof b === "string") { d = b; b = this.pos } var e = (b == null) ? "" : (" (at index " + b + ")"), c = new Error(d + e); c.type = "error"; if (e) { c.at = b } throw this.error = c }, privates: { error: null, addSymbol: function (b, e, l, h) { var c = this.symbols, g = c[b], k, d, j; if (g) { if (typeof e === "object") { k = e } else { if (h && l) { h = Ext.Array.from(h); d = h.length; k = {}; for (j = 0; j < d; j++) { k[h[j]] = l.prototype[h[j]] } } else { return g } } g.update(k) } else { if (e && e.xclass) { l = Ext.ClassManager.get(e.xclass) } else { l = l || Ext.parse.Symbol } c[b] = g = new l(b, e); g.parser = this } return g }, addSymbols: function (b, c, e) { for (var d in b) { this.addSymbol(d, b[d], c, e) } }, applyConstants: function (b) { this.addSymbols(b, Ext.parse.symbol.Constant, "nud") }, applyInfix: function (b) { this.addSymbols(b, Ext.parse.symbol.Infix, "led") }, applyInfixRight: function (b) { this.addSymbols(b, Ext.parse.symbol.InfixRight, "led") }, applyPrefix: function (b) { this.addSymbols(b, Ext.parse.symbol.Prefix, "nud") }, applySymbols: function (b) { this.addSymbols(b) }, applyTokenizer: function (c) { var b = c; if (c && !c.isTokenizer) { b = new Ext.parse.Tokenizer(c) } this.tokenizer = b } } } }, 1, 0, 0, 0, 0, 0, [Ext.parse, "Parser"], 0)); (Ext.cmd.derive("Ext.app.bind.Parser", Ext.parse.Parser, { infix: { ":": { priority: 70, led: function (b) { var a = this; a.arity = "formatter"; a.operand = b; a.fmt = a.parser.parseFmt(); return a } }, "?": { priority: 20, led: function (d) { var b = this, e = b.parser, c = e.symbols[":"], a; b.condition = d; a = c.priority; c.priority = 0; b.tv = e.parseExpression(0); b.parser.advance(":"); c.priority = a; b.fv = e.parseExpression(0); b.arity = "ternary"; return b } }, "===": 40, "!==": 40, "==": 40, "!=": 40, "<": 40, "<=": 40, ">": 40, ">=": 40 }, symbols: { "(": { nud: function () { var d = this.parser, c = d.symbols[":"], b, a; a = c.priority; c.priority = 70; b = d.parseExpression(); d.advance(")"); c.priority = a; return b } } }, prefix: { "@": 0 }, tokenizer: { operators: { "@": "at", "?": "qmark", "===": "feq", "!==": "fneq", "==": "eq", "!=": "neq", "<": "lt", "<=": "lte", ">": "gt", ">=": "gte", "&&": "and", "||": "or" } }, compileExpression: function (e, d) { var c = this, a, b; c.tokens = e; c.tokensMap = d; b = c.parseSlot(c.parseExpression(), a); c.tokens = c.tokensMap = null; return b }, compileFormat: function () { var a; a = this.parseSlot({ arity: "formatter", fmt: this.parseFmt(), operand: { arity: "ident", value: "dummy" } }); this.expect("(end)"); return a }, privates: { useEval: Ext.isGecko, escapeRe: /("|'|\\)/g, parseFmt: function () { var c = this, a = [], b = c.symbols[":"].priority, d; do { if (a.length) { c.advance() } d = c.parseExpression(b); if (d.isIdent || d.isInvoke) { a.push(d) } else { c.syntaxError(d.at, "Expected formatter name") } } while (c.token.id === ":"); return a }, parseSlot: function (l, a) { var j = this, d = [], g = [], h = j.tokens || [], k, b, e, c, m; j.definitions = d; j.body = g; g.push("return " + j.compile(l) + ";"); c = h.length; b = "var fm = Ext.util.Format,\nme,"; m = "var a = Ext.Array.from(values);\nme = scope;\n"; if (h.length) { for (e = 0; e < c; e++) { b += "v" + e + ((e == c - 1) ? ";" : ","); m += "v" + e + " = a[" + e + "]; " } } else { b += "v0;"; m += "v0 = a[0];" } d = Ext.Array.insert(d, 0, [b]); g = Ext.Array.insert(g, 0, [m]); g = g.join("\n"); d.push((j.useEval ? "$=" : "return") + " function (values, scope) {", g, "}"); b = d.join("\n"); k = j.useEval ? j.evalFn(b) : (new Function("Ext", b))(Ext); j.definitions = j.body = null; return k }, compile: function (c) { var b = this, a; switch (c.arity) { case "ident": return b.addToken(c.value); case "literal": a = c.value; return (typeof a === "string") ? '"' + String(a).replace(b.escapeRe, "\\$1") + '"' : a; case "unary": return b.compileUnary(c); case "binary": return b.compileBinary(c); case "ternary": return b.compileTernary(c); case "formatter": return b.compileFormatter(c) }return this.syntaxError(c.at, "Compile error! Unknown symbol") }, compileUnary: function (b) { var a = b.value, c = b.operand; if (a === "!" || a === "-" || a === "+") { return a + "(" + this.compile(c) + ")" } else { if (a === "@") { if (!c.isIdent) { return this.syntaxError(b.at, "Compile error! Unexpected symbol") } return c.value } } return "" }, compileBinary: function (a) { return "(" + this.compile(a.lhs) + " " + a.value + " " + this.compile(a.rhs) + ")" }, compileTernary: function (a) { return "(" + this.compile(a.condition) + " ? " + this.compile(a.tv) + " : " + this.compile(a.fv) + ")" }, compileFormatter: function (g) { var e = this, b = g.fmt, d = b.length, a = ["var ret;"], c; if (b.length) { a.push("ret = " + e.compileFormatFn(b[0], e.compile(g.operand)) + ";"); for (c = 1; c < d; c++) { a.push("ret = " + e.compileFormatFn(b[c], "ret") + ";") } } a.push("return ret;"); return e.addFn(a.join("\n")) }, compileFormatFn: function (h, g) { var a, b = [], e = "", d, c; if (h.isIdent) { a = h.value } else { if (h.isInvoke) { a = h.operand.value; b = h.args } } if (a.substring(0, 5) === "this.") { a = "me." + a.substring(5) } else { if (!(a in Ext.util.Format)) { return this.syntaxError(h.at, 'Compile error! Invalid format specified "' + a + '"') } a = "fm." + a } e += g; d = b.length; for (c = 0; c < d; c++) { e += ", " + this.compile(b[c]) } return a + "(" + e + ")" }, addFn: function (b) { var a = this.definitions, c = "f" + a.length; a.push("function " + c + "() {", b, "}"); return c + "()" }, evalFn: function ($) { eval($); return $ }, addToken: function (a) { var b = this.tokensMap, c = this.tokens, d = 0; if (b && c) { if (a in b) { d = b[a] } else { b[a] = d = c.length; c.push(a) } } return "v" + d } } }, 0, 0, 0, 0, 0, 0, [Ext.app.bind, "Parser"], 0)); (Ext.cmd.derive("Ext.app.bind.Template", Ext.Base, { buffer: null, slots: null, tokens: null, constructor: function (d) { var c = this, b = c._initters, a; c.text = d; for (a in b) { c[a] = b[a] } }, _initters: { apply: function (a, b) { return this.parse().apply(a, b) }, getTokens: function () { return this.parse().getTokens() } }, apply: function (b, e) { var h = this, d = h.slots, a = h.buffer, g = d.length, c, j; for (c = 0; c < g; ++c) { j = d[c]; if (j) { a[c] = j(b, e) } } if (j && h.single) { return a[0] } return a.join("") }, getTokens: function () { return this.tokens }, isStatic: function () { var b = this.getTokens(), a = this.slots; return (b.length === 0 && a.length === 0) }, privates: { parse: function () { var g = this, k = g.text, a = Ext.app.bind.Parser.fly(), c = (g.buffer = []), e = (g.slots = []), j = 0, b = k.length, h = 0, d; for (d in g._initters) { delete g[d] } g.tokens = []; g.tokensMap = {}; for (d = 0; d < b;) { j = d; if ((d = k.indexOf("{", j)) < 0) { c[h++] = k.substring(j); break } if (j < d) { c[h++] = k.substring(j, d) } a.reset(k, d + 1); e[h++] = a.compileExpression(g.tokens, g.tokensMap); d = a.token.at + 1; a.expect("}") } a.release(); g.single = c.length === 0 && e.length === 1; return g } } }, 1, 0, 0, 0, 0, 0, [Ext.app.bind, "Template"], 0)); (Ext.cmd.derive("Ext.app.bind.TemplateBinding", Ext.app.bind.BaseBinding, { isTemplateBinding: true, lastValue: undefined, value: undefined, constructor: function (e, a, i, d, c) { var g = this, b = new Ext.app.bind.Template(e), h = b.getTokens(); Ext.app.bind.BaseBinding.prototype.constructor.call(this, a, i, d, c); g.tpl = b; g.tokens = h; h.$literal = true; if (!b.isStatic()) { g.multiBinding = new Ext.app.bind.Multi(h, a, g.onBindData, g) } else { g.isStatic = true; g.onData(b.text) } }, destroy: function () { var a = this; Ext.destroy(a.multiBinding); a.tpl = a.multiBinding = null; Ext.app.bind.BaseBinding.prototype.destroy.call(this) }, getFullName: function () { var a = this.multiBinding; return this.fullName || (this.fullName = "$" + (a ? a.getFullName() : Ext.app.bind.BaseBinding.prototype.getFullName.call(this))) }, getRawValue: function () { return this.value }, getTemplateScope: function () { return null }, isDescendantOf: function () { return false }, isLoading: function () { var a = this.multiBinding; return a ? a.isLoading() : false }, onBindData: function (a) { this.onData(this.tpl.apply(a, this.getTemplateScope())) }, onData: function (c) { var b = this, a = b.value; if (a !== (b.value = c)) { b.lastValue = a; b.schedule() } }, react: function () { this.notify(this.value) }, refresh: function () { var a = this.multiBinding; if (a) { a.refresh() } }, privates: { sort: function () { var a = this.multiBinding; if (a) { this.scheduler.sortItem(a) } } } }, 1, 0, 0, 0, 0, 0, [Ext.app.bind, "TemplateBinding"], 0)); (Ext.cmd.derive("Ext.data.ChainedStore", Ext.data.AbstractStore, { config: { source: null, remoteFilter: false, remoteSort: false }, remove: function () { var a = this.getSource(); return a.remove.apply(a, arguments) }, removeAll: function () { var a = this.getSource(); return a.removeAll() }, getData: function () { var a = this, b = a.data; if (!b) { a.data = b = a.constructDataCollection() } return b }, getTotalCount: function () { return this.getCount() }, getSession: function () { return this.getSource().getSession() }, applySource: function (a) { if (a) { a = Ext.data.StoreManager.lookup(a) } return a }, updateSource: function (d, b) { var a = this, c; if (b && !b.destroyed) { b.removeObserver(a) } if (d) { c = a.getData(); c.setSource(d.getData()); if (!a.isInitializing) { a.fireEvent("refresh", a); a.fireEvent("datachanged", a) } d.addObserver(a) } }, getModel: function () { return this.getSource().getModel() }, getProxy: function () { return null }, onCollectionAdd: function (d, c) { var b = this, a = c.items, e = !c.next; if (b.ignoreCollectionAdd) { return } b.fireEvent("add", b, a, c.at); if (e) { b.fireEvent("datachanged", b) } }, onCollectionItemChange: function (g, e) { var d = this, a = e.item, c = e.modified || null, b = e.meta; d.onUpdate(a, b, c, e); d.fireEvent("update", d, a, b, c, e) }, onCollectionUpdateKey: function (b, a) { this.fireEvent("idchanged", this, a.item, a.oldKey, a.newKey) }, onUpdate: Ext.emptyFn, onCollectionRemove: function (d, c) { var b = this, a = c.items, e = !c.next; if (b.ignoreCollectionRemove) { return } b.fireEvent("remove", b, a, c.at, false); if (e) { b.fireEvent("datachanged", b) } }, onSourceBeforeLoad: function (b, a) { this.fireEvent("beforeload", this, a) }, onSourceAfterLoad: function (c, b, d, a) { this.fireEvent("load", this, b, d, a) }, onFilterEndUpdate: function () { Ext.data.AbstractStore.prototype.onFilterEndUpdate.apply(this, arguments); this.callObservers("Filter") }, onSourceBeforePopulate: function () { this.ignoreCollectionAdd = true; this.callObservers("BeforePopulate") }, onSourceAfterPopulate: function () { var a = this; a.ignoreCollectionAdd = false; a.fireEvent("datachanged", a); a.fireEvent("refresh", a); this.callObservers("AfterPopulate") }, onSourceBeforeClear: function () { this.ignoreCollectionRemove = true; this.callObservers("BeforeClear") }, onSourceAfterClear: function () { this.ignoreCollectionRemove = false; this.callObservers("AfterClear") }, onSourceBeforeRemoveAll: function () { this.ignoreCollectionRemove = true; this.callObservers("BeforeRemoveAll") }, onSourceAfterRemoveAll: function (c, a) { var b = this; b.ignoreCollectionRemove = false; if (!a) { b.fireEvent("clear", b); b.fireEvent("datachanged", b) } this.callObservers("AfterRemoveAll", [a]) }, onSourceFilter: function () { var a = this; a.fireEvent("refresh", a); a.fireEvent("datachanged", a) }, hasPendingLoad: function () { return this.getSource().hasPendingLoad() }, isLoaded: function () { return this.getSource().isLoaded() }, isLoading: function () { return this.getSource().isLoading() }, doDestroy: function () { var a = this; a.observers = null; a.setSource(null); a.getData().destroy(true); a.data = null; Ext.data.AbstractStore.prototype.doDestroy.call(this) }, privates: { isMoving: function () { var a = this.getSource(); return a.isMoving ? a.isMoving.apply(a, arguments) : false }, loadsSynchronously: function () { return this.getSource().loadsSynchronously() } } }, 0, 0, 0, 0, ["store.chained"], [[Ext.data.LocalStore.prototype.mixinId || Ext.data.LocalStore.$className, Ext.data.LocalStore]], [Ext.data, "ChainedStore"], 0)); (Ext.cmd.derive("Ext.app.ViewModel", Ext.Base, { isViewModel: true, factoryConfig: { name: "viewModel" }, collectTimeout: 100, expressionRe: /^(?:\{(?:(\d+)|([a-z_][\w\-\.]*))\})$/i, $configStrict: false, config: { data: true, formulas: { $value: null, merge: function (d, a, c, b) { return this.mergeNew(d, a, c, b) } }, links: null, parent: null, root: true, scheduler: null, schema: "default", session: null, stores: null, view: null }, constructor: function (a) { this.bindings = {}; this.initConfig(a) }, destroy: function () { var g = this, d = g._scheduler, k = g.storeInfo, i = g.getParent(), c = g.collectTask, b = g.children, a = g.bindings, j, h, e; g.destroying = true; if (c) { c.cancel(); g.collectTask = null } if (b) { for (j in b) { b[j].destroy() } } if (k) { for (j in k) { h = k[j]; e = h.autoDestroy; if (e || (!h.$wasInstance && e !== false)) { h.destroy() } Ext.destroy(h.$binding) } } if (i) { i.unregisterChild(g) } g.getRoot().destroy(); for (j in a) { a[j].destroy() } if (d && d.$owner === g) { d.$owner = null; d.destroy() } g.children = g.storeInfo = g._session = g._view = g._scheduler = g.bindings = g._root = g._parent = g.formulaFn = g.$formulaData = null; g.destroying = false; g.callParent() }, bind: function (e, h, c, b) { var d = this, a = true, g; c = c || d; if (!b && e.bindTo !== undefined && !Ext.isString(e)) { b = e; e = b.bindTo } if (!Ext.isString(e)) { g = new Ext.app.bind.Multi(e, d, h, c, b) } else { if (d.expressionRe.test(e)) { e = e.substring(1, e.length - 1); g = d.bindExpression(e, h, c, b); a = false } else { g = new Ext.app.bind.TemplateBinding(e, d, h, c, b) } } if (a) { d.bindings[g.id] = g } return g }, getSession: function () { var b = this, c = b._session, a; if (!c && (a = b.getParent())) { b.setSession(c = a.getSession()) } return c || null }, getStore: function (b) { var c = this.storeInfo, a; if (c) { a = c[b] } return a || null }, linkTo: function (j, d) { var i = this, c, g, a, b, h, e; if (d.isModel) { d = { type: d.entityName, id: d.id } } b = d.type || d.reference; g = d.create; if (b) { a = d.id; if (g) { a = undefined } e = i.getRecord(b, a); if (Ext.isObject(g)) { e.set(g); e.commit(); e.phantom = true } c = i.getRoot().createStubChild(j); c.set(e) } else { c = i.getStub(j); if (!c.isLinkStub) { h = new Ext.app.bind.LinkStub(i, c.name); c.graft(h); c = h } c.link(d) } }, notify: function () { var a = this.getScheduler(); if (!a.firing) { a.notify() } }, get: function (a) { return this.getStub(a).getValue() }, set: function (e, b) { var a = this, d, c; a.getData(); if (b === undefined && e && e.constructor === Object) { c = a.getRoot(); b = e } else { if (e && e.indexOf(".") < 0) { d = {}; d[e] = b; b = d; c = a.getRoot() } else { c = a.getStub(e) } } c.set(b) }, privates: { registerChild: function (b) { var a = this.children; if (!a) { this.children = a = {} } a[b.getId()] = b }, unregisterChild: function (b) { var a = this.children; if (!this.destroying && a) { delete a[b.getId()] } }, getRecord: function (b, g) { var d = this.getSession(), e = b, c = g !== undefined, a; if (d) { if (c) { a = d.getRecord(b, g) } else { a = d.createRecord(b) } } else { if (!e.$isClass) { e = this.getSchema().getEntity(e) } if (c) { a = e.createWithId(g); a.load() } else { a = new e() } } return a }, bindExpression: function (d, e, b, a) { var c = this.getStub(d); return c.bind(e, b, a) }, applyScheduler: function (a) { if (a && !a.isInstance) { a = new Ext.util.Scheduler(a); a.$owner = this } return a }, getScheduler: function () { var c = this, a = c._scheduler, b; if (!a) { if (!(b = c.getParent())) { a = new Ext.util.Scheduler({ preSort: "kind,-depth" }); a.$owner = c } else { a = b.getScheduler() } c.setScheduler(a) } return a }, getStub: function (b) { var a = this.getRoot(); return b ? a.getChild(b) : a }, collect: function () { var c = this, b = c.getParent(), a = c.collectTask; if (b) { b.collect(); return } if (!a) { a = c.collectTask = new Ext.util.DelayedTask(c.doCollect, c) } if (c.collectTimeout === 0) { c.doCollect() } else { a.delay(c.collectTimeout) } }, doCollect: function () { var b = this.children, a; if (b) { for (a in b) { b[a].doCollect() } } this.getRoot().collect() }, onBindDestroy: function (d, a) { var c = this, b; if (c.destroying) { return } if (!a) { delete c.bindings[d.id] } b = c.getParent(); if (b) { b.onBindDestroy(d, true) } else { c.collect() } }, applyData: function (c, e) { var d = this, a, b; d.getSession(); if (!e) { b = d.getParent(); d.linkData = a = b ? Ext.Object.chain(b.getData()) : {}; d.data = d._data = Ext.Object.chain(a) } if (c && c.constructor === Object) { d.getRoot().set(c) } }, applyParent: function (a) { if (a) { a.registerChild(this) } return a }, applyStores: function (c) { var g = this, b = g.getRoot(), d, a, i, h, e; g.storeInfo = {}; g.listenerScopeFn = function () { return g.getView().getInheritedConfig("defaultListenerScope") }; for (d in c) { a = c[d]; if (a.isStore) { a.$wasInstance = true; g.setupStore(a, d); continue } else { if (Ext.isString(a)) { a = { source: a } } else { a = Ext.apply({}, a) } } e = a.listeners; delete a.listeners; i = g.bind(a, g.onStoreBind, g, { trackStatics: true }); if (i.isStatic()) { i.destroy(); g.createStore(d, a, e) } else { i.$storeKey = d; i.$listeners = e; h = b.createStubChild(d); h.setStore(i) } } }, onStoreBind: function (a, c, h) { var g = this.storeInfo, e = h.$storeKey, b = g[e], d; if (!b) { this.createStore(e, a, h.$listeners, h) } else { a = Ext.merge({}, h.pruneStaticKeys()); d = a.proxy; delete a.type; delete a.model; delete a.fields; delete a.proxy; delete a.listeners; if (d) { delete d.reader; delete d.writer; b.getProxy().setConfig(d) } b.setConfig(a) } }, createStore: function (c, a, d, g) { var e = this.getSession(), b; a = Ext.apply({}, a); if (a.session) { a.session = e } if (a.source) { a.type = a.type || "chained" } a.listeners = d; a.resolveListenerScope = this.listenerScopeFn; b = Ext.Factory.store(a); b.$binding = g; this.setupStore(b, c) }, setupStore: function (a, b) { a.resolveListenerScope = this.listenerScopeFn; this.storeInfo[b] = a; this.set(b, a) }, applyFormulas: function (c) { var d = this, a = d.getRoot(), b, e; d.getData(); for (b in c) { a.createStubChild(b); e = d.getStub(b); e.setFormula(c[b]) } return c }, applyLinks: function (a) { for (var b in a) { this.linkTo(b, a[b]) } }, applySchema: function (a) { return Ext.data.schema.Schema.get(a) }, applyRoot: function () { var a = new Ext.app.bind.RootStub(this), b = this.getParent(); if (b) { a.depth = b.getRoot().depth - 1000 } return a }, getFormulaFn: function (c) { var b = this, a = b.formulaFn; if (!a) { a = b.formulaFn = function (d) { return b.$formulaData[d] } } b.$formulaData = c; return a } } }, 1, 0, 0, 0, ["viewmodel.default"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable], [Ext.mixin.Identifiable.prototype.mixinId || Ext.mixin.Identifiable.$className, Ext.mixin.Identifiable]], [Ext.app, "ViewModel"], 0)); (Ext.cmd.derive("Ext.app.domain.Controller", Ext.app.EventDomain, { singleton: true, type: "controller", prefix: "controller.", idMatchRe: /^\#/, constructor: function () { var a = this; a.callParent(); a.monitor(Ext.app.BaseController) }, match: function (d, b) { var a = false, c = d.alias; if (b === "*") { a = true } else { if (b === "#") { a = !!d.isApplication } else { if (this.idMatchRe.test(b)) { a = d.getId() === b.substring(1) } else { if (c) { a = Ext.Array.indexOf(c, this.prefix + b) > -1 } } } } return a } }, 1, 0, 0, 0, 0, 0, [Ext.app.domain, "Controller"], 0)); (Ext.cmd.derive("Ext.direct.Manager", Ext.Base, { singleton: true, exceptions: { TRANSPORT: "xhr", PARSE: "parse", DATA: "data", LOGIN: "login", SERVER: "exception" }, providerClasses: {}, remotingMethods: {}, config: { varName: "Ext.REMOTING_API" }, apiNotFoundError: "Ext Direct API was not found at {0}", constructor: function () { var a = this; a.mixins.observable.constructor.call(a); a.transactions = new Ext.util.MixedCollection(); a.providers = new Ext.util.MixedCollection() }, addProvider: function (g) { var d = this, b = arguments, e = d.relayers || (d.relayers = {}), c, a; if (b.length > 1) { for (c = 0, a = b.length; c < a; ++c) { d.addProvider(b[c]) } return } if (!g.isProvider) { g = Ext.create("direct." + g.type + "provider", g) } d.providers.add(g); g.on("data", d.onProviderData, d); if (g.relayedEvents) { e[g.id] = d.relayEvents(g, g.relayedEvents) } if (!g.isConnected()) { g.connect() } return g }, loadProvider: function (b, l, m) { var h = this, c = h.providerClasses, j, a, d, k, e, g; if (Ext.isArray(b)) { for (e = 0, g = b.length; e < g; e++) { h.loadProvider(b[e], l, m) } return } j = b.type; a = b.url; if (c[j] && c[j].checkConfig(b)) { k = h.addProvider(b); h.fireEventArgs("providerload", [a, k]); Ext.callback(l, m, [a, k]); return } d = b.varName || h.getVarName(); delete b.varName; delete b.url; Ext.Loader.loadScript({ url: a, scope: h, onLoad: function () { this.onApiLoadSuccess({ url: a, varName: d, config: b, callback: l, scope: m }) }, onError: function () { this.onApiLoadFailure({ url: a, callback: l, scope: m }) } }) }, getProvider: function (a) { return a.isProvider ? a : this.providers.get(a) }, removeProvider: function (d) { var b = this, a = b.providers, c = b.relayers, e; d = d.isProvider ? d : a.get(d); if (d) { d.un("data", b.onProviderData, b); e = d.id; if (c[e]) { c[e].destroy(); delete c[e] } a.remove(d); return d } return null }, addTransaction: function (a) { this.transactions.add(a); return a }, removeTransaction: function (b) { var a = this; b = a.getTransaction(b); a.transactions.remove(b); return b }, getTransaction: function (a) { return typeof a === "object" ? a : this.transactions.get(a) }, onProviderData: function (e, d) { var c = this, b, a; if (Ext.isArray(d)) { for (b = 0, a = d.length; b < a; ++b) { c.onProviderData(e, d[b]) } return } if (d.name && d.name !== "event" && d.name !== "exception") { c.fireEvent(d.name, d) } else { if (d.status === false) { c.fireEvent("exception", d) } } c.fireEvent("event", d, e) }, parseMethod: function (d) { var g = Ext.global, c = 0, b, e, a; if (Ext.isFunction(d)) { b = d } else { if (Ext.isString(d)) { b = this.remotingMethods[d]; if (!b) { e = d.split("."); a = e.length; while (g && c < a) { g = g[e[c]]; ++c } b = Ext.isFunction(g) ? g : null } } } return b || null }, resolveApi: function (c, a) { var e, d, h, g, b; e = c && c.prefix; if (e && e.substr(e.length - 1) !== ".") { e += "." } for (d in c) { h = c[d]; if (d !== "prefix" && typeof h !== "function") { g = (e || "") + h; b = this.parseMethod(g); if (typeof b === "function") { c[d] = b } } } return c }, privates: { addProviderClass: function (b, a) { this.providerClasses[b] = a }, onApiLoadSuccess: function (options) { var me = this, url = options.url, varName = options.varName, api, provider, error; try { api = Ext.apply(options.config, eval(varName)); provider = me.addProvider(api) } catch (e) { error = e + "" } if (error) { me.fireEventArgs("providerloaderror", [url, error]); Ext.callback(options.callback, options.scope, [url, error]) } else { me.fireEventArgs("providerload", [url, provider]); Ext.callback(options.callback, options.scope, [url, provider]) } }, onApiLoadFailure: function (c) { var b = c.url, a; a = Ext.String.format(this.apiNotFoundError, b); this.fireEventArgs("providerloaderror", [b, a]); Ext.callback(c.callback, c.scope, [b, a]) }, registerMethod: function (a, b) { this.remotingMethods[a] = b }, clearAllMethods: function () { this.remotingMethods = {} } } }, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.direct, "Manager"], function () { Ext.Direct = Ext.direct.Manager })); (Ext.cmd.derive("Ext.direct.Provider", Ext.Base, { isProvider: true, $configPrefixed: false, $configStrict: false, config: { headers: undefined }, subscribers: 0, constructor: function (a) { var b = this; b.mixins.observable.constructor.call(b, a); b.requests = {}; Ext.applyIf(b, { id: Ext.id(null, "provider-") }) }, destroy: function () { var a = this; a.disconnect(true); a.callParent() }, isConnected: function () { return this.subscribers > 0 }, connect: function () { var a = this; if (a.subscribers === 0) { a.doConnect(); a.fireEventArgs("connect", [a]) } a.subscribers++ }, doConnect: Ext.emptyFn, disconnect: function (b) { var a = this; if (a.subscribers > 0 || b) { if (b) { a.subscribers = 0 } else { a.subscribers-- } if (a.subscribers === 0) { a.doDisconnect(); a.fireEventArgs("disconnect", [a]) } } }, doDisconnect: function () { var c = this.requests, a, b; for (b in c) { a = c[b]; a.abort() } this.requests = {} }, sendAjaxRequest: function (b) { var a = Ext.Ajax.request(b); if (a && a.id) { this.requests[a.id] = a } return a }, onData: function (b, c, a) { if (a && a.request) { delete this.requests[a.request.id] } }, inheritableStatics: { checkConfig: Ext.returnFalse }, onClassExtended: function (b, c, a) { if (c.type) { Ext.direct.Manager.addProviderClass(c.type, b) } } }, 1, 0, 0, 0, ["direct.provider"], [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.direct, "Provider"], 0)); (Ext.cmd.derive("Ext.app.domain.Direct", Ext.app.EventDomain, { singleton: true, type: "direct", idProperty: "id", constructor: function () { var a = this; a.callParent(); a.monitor(Ext.direct.Provider) } }, 1, 0, 0, 0, 0, 0, [Ext.app.domain, "Direct"], 0)); (Ext.cmd.derive("Ext.data.PageMap", Ext.util.LruCache, { config: { store: null, pageSize: 0, rootProperty: "" }, clear: function (a) { var b = this; b.pageMapGeneration = (b.pageMapGeneration || 0) + 1; b.indexMap = {}; Ext.util.LruCache.prototype.clear.call(this, a) }, forEach: function (l, n) { var h = this, d = Ext.Object.getKeys(h.map), a = d.length, k = h.getPageSize(), c, b, m, g, e; for (c = 0; c < a; c++) { d[c] = +d[c] } Ext.Array.sort(d, Ext.Array.numericSortFn); n = n || h; for (c = 0; c < a; c++) { m = d[c]; g = h.getPage(m); e = g.length; for (b = 0; b < e; b++) { if (l.call(n, g[b], (m - 1) * k + b) === false) { return } } } }, findBy: function (c, b) { var d = this, a = null; b = b || d; d.forEach(function (g, e) { if (c.call(b, g, e)) { a = g; return false } }); return a }, findIndexBy: function (c, b) { var d = this, a = -1; b = b || d; d.forEach(function (g, e) { if (c.call(b, g)) { a = e; return false } }); return a }, find: function (h, g, i, d, c, b) { if (Ext.isEmpty(g, false)) { return null } var e = Ext.String.createRegex(g, d, c, b), a = this.getRootProperty(); return this.findBy(function (j) { return j && e.test((a ? j[a] : j)[h]) }, null, i) }, findIndex: function (h, g, i, d, c, b) { if (Ext.isEmpty(g, false)) { return null } var e = Ext.String.createRegex(g, d, c, b), a = this.getRootProperty(); return this.findIndexBy(function (j) { return j && e.test((a ? j[a] : j)[h]) }, null, i) }, getPageFromRecordIndex: function (a) { return Math.floor(a / this.getPageSize()) + 1 }, addAll: function (a) { this.addPage(1, a) }, addPage: function (m, a) { var k = this, l = k.getPageSize(), c = m + Math.floor((a.length - 1) / l), j = (m - 1) * l, g = k.indexMap, e, b, d, h; for (h = 0; m <= c; m++ , h += l) { e = Ext.Array.slice(a, h, h + l); for (b = 0, d = e.length; b < d; b++) { g[e[b].internalId] = j++ } k.add(m, e); k.fireEvent("pageadd", k, m, e) } }, getCount: function () { var a = Ext.util.LruCache.prototype.getCount.call(this); if (a) { a = (a - 1) * this.getPageSize() + this.last.value.length } return a }, getByInternalId: function (a) { var b = this.indexMap[a]; if (b != null) { return this.getAt(b) } }, indexOf: function (b) { var a = -1; if (b) { a = this.indexMap[b.internalId]; if (a == null) { a = -1 } } return a }, insert: function () { }, remove: function () { }, removeAt: function () { }, removeAtKey: function (g) { var e = this, c = e.getPage(g), b, d, a; if (c) { if (e.fireEvent("beforepageremove", e, g, c) !== false) { b = c.length; for (d = 0; d < b; d++) { delete e.indexMap[c[d].internalId] } a = Ext.util.LruCache.prototype.removeAtKey.apply(this, arguments); e.fireEvent("pageremove", e, g, c); c.length = 0 } } return a }, getPage: function (a) { return this.get(a) }, hasRange: function (e, b) { var c = this, a = c.getPageFromRecordIndex(e), d = c.getPageFromRecordIndex(b); for (; a <= d; a++) { if (!c.hasPage(a)) { return false } } return (d - 1) * c._pageSize + c.getPage(d).length > b }, hasPage: function (a) { return !!this.get(a) }, peekPage: function (a) { return this.map[a] }, getAt: function (a) { return this.getRange(a, a + 1)[0] }, getRange: function (a, b) { b--; if (!this.hasRange(a, b)) { Ext.raise("PageMap asked for range which it does not have") } var h = this, d = Ext.Array, i = h.getPageSize(), l = h.getPageFromRecordIndex(a), e = h.getPageFromRecordIndex(b), c = (l - 1) * i, n = (e * i) - 1, j = l, o = [], m, g, k; for (; j <= e; j++) { if (j === l) { m = a - c; k = m > 0 } else { m = 0; k = false } if (j === e) { g = i - (n - b); k = k || g < i } if (k) { d.push(o, d.slice(h.getPage(j), m, g)) } else { d.push(o, h.getPage(j)) } } return o } }, 0, 0, 0, 0, 0, 0, [Ext.data, "PageMap"], 0)); (Ext.cmd.derive("Ext.data.BufferedStore", Ext.data.ProxyStore, { isBufferedStore: true, buffered: true, config: { data: 0, pageSize: 25, remoteSort: true, remoteFilter: true, sortOnLoad: false, purgePageCount: 5, trailingBufferZone: 25, leadingBufferZone: 200, defaultViewSize: 100, viewSize: 0, trackRemoved: false }, applyData: function (b) { var a = this.data || (this.data = this.createDataCollection()); return a }, applyProxy: function (a) { a = Ext.data.ProxyStore.prototype.applyProxy.call(this, a); if (a && a.setEnablePaging) { a.setEnablePaging(true) } return a }, applyAutoSort: function () { }, createFiltersCollection: function () { return new Ext.util.FilterCollection() }, createSortersCollection: function () { return new Ext.util.SorterCollection() }, updateGroupField: function (a) { this.group(a) }, getGrouper: function () { return this.grouper }, isGrouped: function () { return !!this.grouper }, createDataCollection: function () { var b = this, a = new Ext.data.PageMap({ store: b, rootProperty: "data", pageSize: b.getPageSize(), maxSize: b.getPurgePageCount(), listeners: { clear: b.onPageMapClear, scope: b } }); b.relayEvents(a, ["beforepageremove", "pageadd", "pageremove"]); b.pageRequests = {}; return a }, removeAll: function (a) { var b = this, c = b.getData(); if (c) { if (a) { b.suspendEvent("clear") } c.clear(); if (a) { b.resumeEvent("clear") } } }, flushLoad: function () { var b = this, a = b.pendingLoadOptions; b.clearLoadTask(); if (!a) { return } b.getData().clear(); a.page = 1; a.start = 0; a.limit = b.getViewSize() || b.getDefaultViewSize(); a.loadCallback = a.callback; a.callback = null; return b.loadToPrefetch(a) }, reload: function (n) { var h = this, e = h.getData(), k = Number.MAX_VALUE, j, b, g, m, d, a, l, c; if (!n) { n = {} } if (h.loading || h.fireEvent("beforeload", h, n) === false) { return } a = function () { var o = h.totalCount, i = b - j; if (b >= o) { b = o - 1; j = Math.max(b - i, 0) } if (h.rangeCached(j, b, false)) { h.loadCount = (h.loadCount || 0) + 1; h.loading = false; e.un("pageadd", a); c = e.getRange(j, b); h.fireEvent("load", h, c, true); h.fireEvent("refresh", h) } }; l = Math.ceil((h.getLeadingBufferZone() + h.getTrailingBufferZone()) / 2); if (h.lastRequestStart && h.preserveScrollOnReload) { j = h.lastRequestStart; b = h.lastRequestEnd; k = h.getTotalCount() } else { j = n.start || 0; b = j + (n.count || h.getPageSize()) - 1 } e.clear(true); delete h.totalCount; j = Math.max(j - l, 0); b = Math.min(b + l, k); j = j === 0 ? 0 : j - 1; b = b === k ? b : b + 1; g = h.getPageFromRecordIndex(j); m = h.getPageFromRecordIndex(b); h.loading = true; n.waitForReload = a; e.on("pageadd", a); for (d = g; d <= m; d++) { h.prefetchPage(d, n) } }, filter: function () { Ext.data.ProxyStore.prototype.filter.apply(this, arguments) }, filterBy: function (b, a) { }, loadData: function (b, a) { }, loadPage: function (c, a) { var b = this; a = a || {}; a.page = b.currentPage = c; a.start = (c - 1) * b.getPageSize(); a.limit = b.getViewSize() || b.getDefaultViewSize(); a.loadCallback = a.callback; a.callback = null; return b.loadToPrefetch(a) }, clearData: function (c) { var a = this, b = a.getData(); if (b) { b.clear() } }, getCount: function () { return this.totalCount || 0 }, getRange: function (d, h, m) { var l = this, e = l.totalCount - 1, g = l.lastRequestStart, n = [], i = l.getData(), c, k, b, a, j; m = Ext.apply({ prefetchStart: d, prefetchEnd: h }, m); h = (h >= l.totalCount) ? e : h; if (m.forRender !== false) { k = d === 0 ? 0 : d - 1; b = h === e ? h : h + 1 } else { k = d; b = h } l.lastRequestStart = d; l.lastRequestEnd = h; if (l.rangeCached(d, h, m.forRender)) { l.onRangeAvailable(m); n = i.getRange(d, h + 1) } else { l.fireEvent("cachemiss", l, d, h); a = l.getPageFromRecordIndex(k); j = l.getPageFromRecordIndex(b); c = function (o, q, p) { if (q >= a && q <= j && l.rangeCached(d, h)) { l.fireEvent("cachefilled", l, d, h); i.un("pageadd", c); l.onRangeAvailable(m) } }; i.on("pageadd", c); l.prefetchRange(d, h) } l.primeCache(d, h, d < g ? -1 : 1); return n }, getById: function (b) { var a = this.data.findBy(function (c) { return c.getId() === b }); return a }, getAt: function (a) { var b = this.getData(); if (b.hasRange(a, a)) { return b.getAt(a) } }, getByInternalId: function (a) { return this.data.getByInternalId(a) }, contains: function (a) { return this.indexOf(a) > -1 }, indexOf: function (a) { return this.getData().indexOf(a) }, indexOfId: function (a) { return this.indexOf(this.getById(a)) }, group: function (b, d) { var c = this, a; if (b && typeof b === "string") { a = c.grouper; if (a && d !== undefined) { a.setDirection(d) } else { c.grouper = new Ext.util.Grouper({ property: b, direction: d || "ASC", root: "data" }) } } else { c.grouper = b ? c.getSorters().decodeSorter(b, "Ext.util.Grouper") : null } c.getData().clear(); c.loadPage(1, { callback: function () { c.fireEvent("groupchange", c, c.getGrouper()) } }) }, getPageFromRecordIndex: function (a) { return Math.floor(a / this.getPageSize()) + 1 }, calculatePageCacheSize: function (a) { var c = this, b = c.getPurgePageCount(); return b ? Math.max(c.getData().getMaxSize() || 0, Math.ceil((a + c.getTrailingBufferZone() + c.getLeadingBufferZone()) / c.getPageSize()) * 2 + b) : 0 }, loadToPrefetch: function (s) { var m = this, c = s, h, b, o, n = s.start, a = s.start + s.limit - 1, r = (m.getViewSize() || s.limit), j = Math.min(a, s.start + r - 1), k = m.getPageFromRecordIndex(Math.max(n - m.getTrailingBufferZone(), 0)), q = m.getPageFromRecordIndex(a + m.getLeadingBufferZone()), g = m.getData(), l = function () { b = b || []; if (s.loadCallback) { s.loadCallback.call(s.scope || m, b, e, true) } if (s.callback) { s.callback.call(s.scope || m, b, n || 0, a || 0, s) } }, p = function () { m.loadCount = (m.loadCount || 0) + 1; m.fireEvent("datachanged", m); m.fireEvent("refresh", m); m.fireEvent("load", m, b, true) }, d = function () { if (m.rangeCached(n, j)) { m.loading = false; b = g.getRange(n, j + 1); g.un("pageadd", d); if (m.hasListeners.guaranteedrange) { m.guaranteeRange(n, j, s.callback, s.scope) } l(); p() } }, e; g.setMaxSize(m.calculatePageCacheSize(r)); if (m.fireEvent("beforeload", m, s) !== false) { delete m.totalCount; m.loading = true; if (s.callback) { c = Ext.apply({}, s); delete c.callback } m.on("prefetch", function (t, i, v, u) { e = u; if (v) { if ((o = m.getTotalCount())) { g.on("pageadd", d); j = Math.min(j, o - 1); q = m.getPageFromRecordIndex(Math.min(j + m.getLeadingBufferZone(), o - 1)); for (h = k + 1; h <= q; ++h) { m.prefetchPage(h, c) } } else { l(); p() } } else { m.loading = false; l(); m.fireEvent("load", m, i, false) } }, null, { single: true }); m.prefetchPage(k, c) } }, prefetch: function (d) { var e = this, b = e.getPageSize(), g = e.getData(), c, a; if (b) { if (e.lastPageSize && b != e.lastPageSize) { Ext.raise("pageSize cannot be dynamically altered") } if (!g.getPageSize()) { g.setPageSize(b) } } else { e.pageSize = g.setPageSize(b = d.limit) } e.lastPageSize = b; if (!d.page) { d.page = e.getPageFromRecordIndex(d.start); d.start = (d.page - 1) * b; d.limit = Math.ceil(d.limit / b) * b } a = e.pageRequests[d.page]; if (!a || a.getOperation().pageMapGeneration !== g.pageMapGeneration) { d = Ext.apply({ action: "read", filters: e.getFilters().items, sorters: e.getSorters().items, grouper: e.getGrouper(), internalCallback: e.onProxyPrefetch, internalScope: e }, d); c = e.createOperation("read", d); c.pageMapGeneration = g.pageMapGeneration; if (e.fireEvent("beforeprefetch", e, c) !== false) { e.pageRequests[d.page] = c.execute(); if (e.getProxy().isSynchronous) { delete e.pageRequests[d.page] } } } return e }, onPageMapClear: function () { var c = this, b = c.wasLoading, a = c.pageRequests, e = c.getData(), d; e.clearListeners(); e.on("clear", c.onPageMapClear, c); c.relayEvents(e, ["beforepageremove", "pageadd", "pageremove"]); c.loading = true; c.totalCount = 0; for (d in a) { if (a.hasOwnProperty(d)) { a[d].getOperation().abort() } } c.fireEvent("clear", c); c.loading = b }, prefetchPage: function (e, b) { var d = this, a = d.getPageSize(), g = (e - 1) * a, c = d.totalCount; if (c !== undefined && d.data.getCount() === c) { return } d.prefetch(Ext.applyIf({ page: e, start: g, limit: a }, b)) }, onProxyPrefetch: function (d) { if (this.destroying || this.destroyed) { return } var i = this, j = d.getResultSet(), c = d.getRecords(), g = d.wasSuccessful(), h = d.getPage(), b = d.waitForReload, l = i.totalCount, a = i.pageRequests, k, e; if (d.pageMapGeneration === i.getData().pageMapGeneration) { if (j) { i.totalCount = j.getTotal(); if (i.totalCount !== l) { i.fireEvent("totalcountchange", i.totalCount) } } if (h !== undefined) { delete i.pageRequests[h] } i.loading = false; i.fireEvent("prefetch", i, c, g, d); if (g) { if (i.totalCount === 0) { if (b) { for (k in a) { e = a[k].getOperation(); if (e.waitForReload === b) { delete e.waitForReload } } i.getData().un("pageadd", b); i.fireEvent("load", i, [], true); i.fireEvent("refresh", i) } } else { i.cachePage(c, d.getPage()) } } Ext.callback(d.getCallback(), d.getScope() || i, [c, d, g]) } }, cachePage: function (b, e) { var d = this, a = b.length, c; if (!Ext.isDefined(d.totalCount)) { d.totalCount = b.length; d.fireEvent("totalcountchange", d.totalCount) } for (c = 0; c < a; c++) { b[c].join(d) } d.getData().addPage(e, b) }, rangeCached: function (e, a, d) { var c = e, b = a; if (d !== false) { c = e === 0 ? 0 : e - 1, b = a === this.totalCount - 1 ? a : a + 1 } return this.getData().hasRange(c, b) }, pageCached: function (a) { return this.getData().hasPage(a) }, pagePending: function (a) { return !!this.pageRequests[a] }, rangeSatisfied: function (b, a) { return this.rangeCached(b, a) }, onRangeAvailable: function (d) { var e = this, b = e.getTotalCount(), g = d.prefetchStart, a = (d.prefetchEnd > b - 1) ? b - 1 : d.prefetchEnd, c; a = Math.max(0, a); c = e.getData().getRange(g, a + 1); if (d.fireEvent !== false) { e.fireEvent("guaranteedrange", c, g, a, d) } if (d.callback) { d.callback.call(d.scope || e, c, g, a, d) } }, guaranteeRange: function (e, a, d, c, b) { b = Ext.apply({ callback: d, scope: c }, b); this.getRange(e, a + 1, b) }, prefetchRange: function (h, b) { var d = this, c, a, g, e = d.getData(); if (!d.rangeCached(h, b)) { c = d.getPageFromRecordIndex(h); a = d.getPageFromRecordIndex(b); e.setMaxSize(d.calculatePageCacheSize(b - h + 1)); for (g = c; g <= a; g++) { if (!d.pageCached(g)) { d.prefetchPage(g) } } } }, primeCache: function (i, c, h) { var g = this, e = g.getLeadingBufferZone(), d = g.getTrailingBufferZone(), b = g.getPageSize(), a = g.totalCount; if (h === -1) { i = Math.max(i - e, 0); c = Math.min(c + d, a - 1) } else { if (h === 1) { i = Math.max(Math.min(i - d, a - b), 0); c = Math.min(c + e, a - 1) } else { i = Math.min(Math.max(Math.floor(i - ((e + d) / 2)), 0), a - g.pageSize); c = Math.min(Math.max(Math.ceil(c + ((e + d) / 2)), 0), a - 1) } } g.prefetchRange(i, c) }, sort: function (b, a, c) { if (arguments.length === 0) { this.clearAndLoad() } else { this.getSorters().addSort(b, a, c) } }, onSorterEndUpdate: function () { var a = this, b = a.getSorters().getRange(); if (b.length) { a.fireEvent("beforesort", a, b); a.clearAndLoad({ callback: function () { a.fireEvent("sort", a, b) } }) } else { a.fireEvent("sort", a, b) } }, clearAndLoad: function (a) { var b = this; b.clearing = true; b.getData().clear(); b.clearing = false; b.loadPage(1, a) }, privates: { isLast: function (a) { return this.indexOf(a) === this.getTotalCount() - 1 }, isMoving: function () { return false } } }, 0, 0, 0, 0, ["store.buffered"], 0, [Ext.data, "BufferedStore"], 0)); (Ext.cmd.derive("Ext.data.proxy.Direct", Ext.data.proxy.Server, { alternateClassName: "Ext.data.DirectProxy", config: { paramOrder: undefined, paramsAsHash: true, directFn: undefined, api: undefined, metadata: undefined }, paramOrderRe: /[\s,|]/, constructor: function (a) { Ext.data.proxy.Server.prototype.constructor.call(this, a); this.canceledOperations = {} }, applyParamOrder: function (a) { if (Ext.isString(a)) { a = a.split(this.paramOrderRe) } return a }, updateApi: function () { this.methodsResolved = false }, updateDirectFn: function () { this.methodsResolved = false }, resolveMethods: function () { var c = this, b = c.getDirectFn(), a = c.getApi(), d; if (b) { c.setDirectFn(d = Ext.direct.Manager.parseMethod(b)); if (!Ext.isFunction(d)) { Ext.raise("Cannot resolve directFn " + b) } } if (a) { a = Ext.direct.Manager.resolveApi(a, c); c.setApi(a) } c.methodsResolved = true }, doRequest: function (d) { var i = this, a, e, c, b, h, g, j, k; if (!i.methodsResolved) { i.resolveMethods() } e = i.buildRequest(d); c = e.getAction(); g = i.getApi(); if (g) { j = g[c] } j = j || i.getDirectFn(); a = i.getWriter(); if (a && d.allowWrite()) { e = a.write(e) } if (c === "read") { b = e.getParams() } else { b = e.getJsonData() } h = j.directCfg.method.getArgs({ params: b, allowSingle: a.getAllowSingle(), paramOrder: i.getParamOrder(), paramsAsHash: i.getParamsAsHash(), paramsAsArray: true, metadata: i.getMetadata(), callback: i.createRequestCallback(e, d), scope: i }); e.setConfig({ args: h, directFn: j }); j.apply(window, h); return e }, abort: function (a) { var b; if (a && a.isDataRequest) { a = a.getOperation() } if (a && a.isOperation) { b = a.id } if (b != null) { this.canceledOperations[b] = true } }, applyEncoding: Ext.identityFn, createRequestCallback: function (c, a) { var b = this; return function (e, d) { if (!b.canceledOperations[a.id]) { b.processResponse(d.status, a, c, d) } delete b.canceledOperations[a.id] } }, extractResponseData: function (a) { return Ext.isDefined(a.result) ? a.result : a.data }, setException: function (b, a) { b.setException(a.message) }, buildUrl: function () { return "" } }, 1, 0, 0, 0, ["proxy.direct"], 0, [Ext.data.proxy, "Direct", Ext.data, "DirectProxy"], 0)); (Ext.cmd.derive("Ext.data.DirectStore", Ext.data.Store, { constructor: function (a) { a = Ext.apply({}, a); if (!a.proxy) { var b = { type: "direct", reader: { type: "json" } }; Ext.copyTo(b, a, "paramOrder,paramsAsHash,directFn,api,simpleSortMode,extraParams"); Ext.copyTo(b.reader, a, "totalProperty,root,rootProperty,idProperty"); a.proxy = b } Ext.data.Store.prototype.constructor.call(this, a) } }, 1, 0, 0, 0, ["store.direct"], 0, [Ext.data, "DirectStore"], 0)); (Ext.cmd.derive("Ext.data.JsonP", Ext.Base, { singleton: true, requestCount: 0, requests: {}, timeout: 30000, disableCaching: true, disableCachingParam: "_dc", callbackKey: "callback", request: function (n) { n = Ext.apply({}, n); var j = this, d = Ext.isDefined(n.disableCaching) ? n.disableCaching : j.disableCaching, h = n.disableCachingParam || j.disableCachingParam, c = ++j.requestCount, l = n.callbackName || "callback" + c, i = n.callbackKey || j.callbackKey, m = Ext.isDefined(n.timeout) ? n.timeout : j.timeout, e = Ext.apply({}, n.params), b = n.url, a = Ext.name, g, k; if (d && !e[h]) { e[h] = Ext.Date.now() } n.params = e; e[i] = a + ".data.JsonP." + l; k = j.createScript(b, e, n); j.requests[c] = g = { url: b, params: e, script: k, id: c, scope: n.scope, success: n.success, failure: n.failure, callback: n.callback, callbackKey: i, callbackName: l }; if (m > 0) { g.timeout = Ext.defer(j.handleTimeout, m, j, [g]) } j.setupErrorHandling(g); j[l] = Ext.bind(j.handleResponse, j, [g], true); j.loadScript(g); return g }, abort: function (c) { var b = this, d = b.requests, a; if (c) { if (!c.id) { c = d[c] } b.handleAbort(c) } else { for (a in d) { if (d.hasOwnProperty(a)) { b.abort(d[a]) } } } }, setupErrorHandling: function (a) { a.script.onerror = Ext.bind(this.handleError, this, [a]) }, handleAbort: function (a) { a.errorType = "abort"; this.handleResponse(null, a) }, handleError: function (a) { a.errorType = "error"; this.handleResponse(null, a) }, cleanupErrorHandling: function (a) { a.script.onerror = null }, handleTimeout: function (a) { a.errorType = "timeout"; this.handleResponse(null, a) }, handleResponse: function (b, c) { var d = true, a = Ext.GlobalEvents; if (c.timeout) { clearTimeout(c.timeout) } delete this[c.callbackName]; delete this.requests[c.id]; this.cleanupErrorHandling(c); Ext.fly(c.script).destroy(); if (c.errorType) { d = false; Ext.callback(c.failure, c.scope, [c.errorType]) } else { Ext.callback(c.success, c.scope, [b]) } Ext.callback(c.callback, c.scope, [d, b, c.errorType]); if (a.hasListeners.idle) { a.fireEvent("idle") } }, createScript: function (c, d, b) { var a = document.createElement("script"); a.setAttribute("src", Ext.urlAppend(c, Ext.Object.toQueryString(d))); a.setAttribute("async", true); a.setAttribute("type", "text/javascript"); return a }, loadScript: function (a) { Ext.getHead().appendChild(a.script) } }, 0, 0, 0, 0, 0, 0, [Ext.data, "JsonP"], 0)); (Ext.cmd.derive("Ext.data.proxy.JsonP", Ext.data.proxy.Server, { alternateClassName: "Ext.data.ScriptTagProxy", config: { callbackKey: "callback", recordParam: "records", autoAppendParams: true }, doRequest: function (a) { var c = this, b = c.buildRequest(a), d = b.getParams(); b.setConfig({ callbackKey: c.callbackKey, timeout: c.timeout, scope: c, disableCaching: false, callback: c.createRequestCallback(b, a) }); if (c.getAutoAppendParams()) { b.setParams({}) } b.setRawRequest(Ext.data.JsonP.request(b.getCurrentConfig())); b.setParams(d); c.lastRequest = b; return b }, createRequestCallback: function (c, a) { var b = this; return function (g, d, e) { if (c === b.lastRequest) { b.lastRequest = null } b.processResponse(g, a, c, d) } }, setException: function (b, a) { b.setException(b.getRequest().getRawRequest().errorType) }, buildUrl: function (h) { var k = this, a = Ext.data.proxy.Server.prototype.buildUrl.apply(this, arguments), d = h.getRecords(), e = k.getWriter(), g, c, b, j, l; if (e && h.getOperation().allowWrite()) { h = e.write(h) } g = h.getParams(); c = g.filters; delete g.filters; if (c && c.length) { for (j = 0; j < c.length; j++) { b = c[j]; l = b.getValue(); if (l) { g[b.getProperty()] = l } } } if (Ext.isArray(d) && d.length > 0 && (!e || !e.getEncode())) { g[k.getRecordParam()] = k.encodeRecords(d) } if (k.getAutoAppendParams()) { a = Ext.urlAppend(a, Ext.Object.toQueryString(g)) } return a }, abort: function (a) { a = a || this.lastRequest; if (a) { Ext.data.JsonP.abort(a.getRawRequest()) } }, encodeRecords: function (b) { var d = [], c = 0, a = b.length; for (; c < a; c++) { d.push(Ext.encode(b[c].getData())) } return d } }, 0, 0, 0, 0, ["proxy.jsonp", "proxy.scripttag"], 0, [Ext.data.proxy, "JsonP", Ext.data, "ScriptTagProxy"], 0)); (Ext.cmd.derive("Ext.data.JsonPStore", Ext.data.Store, { constructor: function (a) { a = Ext.apply({ proxy: { type: "jsonp", reader: "json" } }, a); Ext.data.Store.prototype.constructor.call(this, a) } }, 1, 0, 0, 0, ["store.jsonp"], 0, [Ext.data, "JsonPStore"], 0)); (Ext.cmd.derive("Ext.data.JsonStore", Ext.data.Store, { constructor: function (a) { a = Ext.apply({ proxy: { type: "ajax", reader: "json", writer: "json" } }, a); Ext.data.Store.prototype.constructor.call(this, a) } }, 1, 0, 0, 0, ["store.json"], 0, [Ext.data, "JsonStore"], 0)); (Ext.cmd.derive("Ext.data.ModelManager", Ext.Base, { alternateClassName: "Ext.ModelMgr", singleton: true, deprecated: { 5: { methods: { clear: null, create: function (c, b, d) { var a = b; if (!a.isEntity) { a = this.getModel(b || c.name) } return a.createWithId(d, c) }, each: function (b, a) { Ext.data.Model.schema.eachEntity(b, a) }, get: function (a) { return this.getModel(a) }, getCount: function () { return Ext.data.Model.schema.entityCount }, getModel: function (a) { return Ext.data.schema.Schema.lookupEntity(a) }, isRegistered: function (a) { return !!this.getModel(a) } } } } }, 0, 0, 0, 0, 0, 0, [Ext.data, "ModelManager", Ext, "ModelMgr"], 0)); (Ext.cmd.derive("Ext.data.NodeInterface", Ext.Base, { statics: { decorate: function (b) { var d = Ext.data.schema.Schema.lookupEntity(b), g = d.prototype, a, c, e; if (!d.prototype.isObservable) { d.mixin(Ext.mixin.Observable.prototype.mixinId, Ext.mixin.Observable) } if (g.isNode) { return } a = g.idProperty; c = d.getField(a); e = c.type; d.override(this.getPrototypeBody()); d.addFields([{ name: "parentId", type: e, defaultValue: null, allowNull: c.allowNull }, { name: "index", type: "int", defaultValue: -1, persist: false, convert: null }, { name: "depth", type: "int", defaultValue: 0, persist: false, convert: null }, { name: "expanded", type: "bool", defaultValue: false, persist: false, convert: null }, { name: "expandable", type: "bool", defaultValue: true, persist: false, convert: null }, { name: "checked", type: "auto", defaultValue: null, persist: false, convert: null }, { name: "leaf", type: "bool", defaultValue: false }, { name: "cls", type: "string", defaultValue: "", persist: false, convert: null }, { name: "iconCls", type: "string", defaultValue: "", persist: false, convert: null }, { name: "icon", type: "string", defaultValue: "", persist: false, convert: null }, { name: "glyph", type: "string", defaultValue: "", persist: false, convert: null }, { name: "root", type: "boolean", defaultValue: false, persist: false, convert: null }, { name: "isLast", type: "boolean", defaultValue: false, persist: false, convert: null }, { name: "isFirst", type: "boolean", defaultValue: false, persist: false, convert: null }, { name: "allowDrop", type: "boolean", defaultValue: true, persist: false, convert: null }, { name: "allowDrag", type: "boolean", defaultValue: true, persist: false, convert: null }, { name: "loaded", type: "boolean", defaultValue: false, persist: false, convert: null }, { name: "loading", type: "boolean", defaultValue: false, persist: false, convert: null }, { name: "href", type: "string", defaultValue: "", persist: false, convert: null }, { name: "hrefTarget", type: "string", defaultValue: "", persist: false, convert: null }, { name: "qtip", type: "string", defaultValue: "", persist: false, convert: null }, { name: "qtitle", type: "string", defaultValue: "", persist: false, convert: null }, { name: "qshowDelay", type: "int", defaultValue: 0, persist: false, convert: null }, { name: "children", type: "auto", defaultValue: null, persist: false, convert: null }, { name: "visible", type: "boolean", defaultValue: true, persist: false }, { name: "text", type: "string", persist: false }]) }, getPrototypeBody: function () { var a = { idchanged: true, append: true, remove: true, move: true, insert: true, beforeappend: true, beforeremove: true, beforemove: true, beforeinsert: true, expand: true, collapse: true, beforeexpand: true, beforecollapse: true, sort: true }, b = { silent: true }; return { isNode: true, firstChild: null, lastChild: null, parentNode: null, previousSibling: null, nextSibling: null, constructor: function () { var c = this; c.mixins.observable.constructor.call(c); c.callParent(arguments); c.childNodes = []; return c }, createNode: function (c) { var j = this, h = j.childType, m, k, e, l, i, g, d = j.self; if (!c.isModel) { if (h) { d = j.schema.getEntity(h) } else { m = j.getTreeStore(); k = m && m.getProxy().getReader(); e = j.getProxy(); l = e ? e.getReader() : null; i = !k || (l && l.initialConfig.typeProperty) ? l : k; if (i) { g = i.getTypeProperty(); if (g) { d = i.getChildType(j.schema, c, g) } } } c = new d(c) } if (!c.childNodes) { c.firstChild = c.lastChild = c.parentNode = c.previousSibling = c.nextSibling = null; c.childNodes = [] } return c }, isLeaf: function () { return this.get("leaf") === true }, setFirstChild: function (c) { this.firstChild = c }, setLastChild: function (c) { this.lastChild = c }, updateInfo: function (j, d) { var k = this, e = k.phantom, m; j = { silent: true, commit: j }; if (d.depth !== k.data.depth) { var l = { depth: k.data.depth + 1 }, c = k.childNodes, g = c.length, h; for (h = 0; h < g; h++) { c[h].set(l) } } m = k.set(d, j); k.phantom = e; return m }, isLast: function () { return this.get("isLast") }, isFirst: function () { return this.get("isFirst") }, hasChildNodes: function () { return !this.isLeaf() && this.childNodes.length > 0 }, isExpandable: function () { var c = this; if (c.get("expandable")) { return !(c.isLeaf() || (c.isLoaded() && !c.phantom && !c.hasChildNodes())) } return false }, triggerUIUpdate: function () { this.callJoined("afterEdit", []) }, appendChild: function (h, s, k) { var p = this, l, o, n, r, c, u = { isLast: true, parentId: p.getId(), depth: (p.data.depth || 0) + 1 }, t, g = p.getTreeStore(), e = g && g.triStateCheckbox ? 1 : false, d = g && g.bulkUpdate, m, j, q; Ext.suspendLayouts(); if (Ext.isArray(h)) { o = h.length; t = new Array(o); p.callTreeStore("beginFill"); for (l = 0; l < o; l++) { t[l] = p.appendChild(h[l], s, k) } p.callTreeStore("endFill", [t]) } else { h = p.createNode(h); if (s !== true && p.fireBubbledEvent("beforeappend", [p, h]) === false) { Ext.resumeLayouts(true); return false } n = p.childNodes.length; r = h.parentNode; if (r) { if (s !== true && h.fireBubbledEvent("beforemove", [h, r, p, n]) === false) { Ext.resumeLayouts(true); return false } if (r.removeChild(h, false, s, r.getTreeStore() === g) === false) { Ext.resumeLayouts(true); return false } } g && g.beginUpdate(); n = p.childNodes.length; if (n === 0) { p.setFirstChild(h) } p.childNodes[n] = h; h.parentNode = p; h.nextSibling = null; p.setLastChild(h); c = p.childNodes[n - 1]; if (c) { h.previousSibling = c; c.nextSibling = h; c.updateInfo(k, { isLast: false }); if (!d) { c.triggerUIUpdate() } } else { h.previousSibling = null } u.isFirst = n === 0; u.index = n; q = h.updateInfo(k, u); if (p.isLeaf()) { p.set("leaf", false) } if (!p.isLoaded()) { if (d) { p.data.loaded = true } else { p.set("loaded", true) } } else { if (p.childNodes.length === 1 && !d) { p.triggerUIUpdate() } } if (n && p.childNodes[n - 1].isExpanded() && !d) { p.childNodes[n - 1].cascade(p.triggerUIUpdate) } if (g) { g.registerNode(p, !d); if (d) { g.registerNode(h) } } if (s !== true) { p.fireBubbledEvent("append", [p, h, n]); if (r) { h.fireBubbledEvent("move", [h, r, p, n]) } } p.callTreeStore("onNodeAppend", [h, n]); if (q) { h.callJoined("afterEdit", [q]) } t = h; if (g) { g.endUpdate() } } Ext.resumeLayouts(true); return t }, getOwnerTree: function () { var c = this.getTreeStore(); if (c) { return c.ownerTree } }, getTreeStore: function () { var c = this; while (c && !c.treeStore) { c = c.parentNode } return c && c.treeStore }, removeChild: function (j, g, q, p) { var o = this, n = o.indexOf(j), l, k, d, h = o.getTreeStore(), e = h && h.bulkUpdate, m, c = []; if (n === -1 || (q !== true && o.fireBubbledEvent("beforeremove", [o, j, !!p]) === false)) { return false } Ext.suspendLayouts(); h && h.beginUpdate(); Ext.Array.erase(o.childNodes, n, 1); if (o.firstChild === j) { o.setFirstChild(j.nextSibling) } if (o.lastChild === j) { o.setLastChild(j.previousSibling) } d = j.previousSibling; if (d) { j.previousSibling.nextSibling = j.nextSibling } if (j.nextSibling) { j.nextSibling.previousSibling = j.previousSibling; if (n === 0) { j.nextSibling.updateInfo(false, { isFirst: true }) } for (l = n, k = o.childNodes.length; l < k; l++) { o.childNodes[l].updateInfo(false, { index: l }) } } else { if (d) { d.updateInfo(false, { isLast: true }); if (!e) { if (d.isExpanded()) { d.cascade(o.triggerUIUpdate) } else { d.triggerUIUpdate() } } } } if (!o.childNodes.length && !e) { o.triggerUIUpdate() } Ext.resumeLayouts(true); if (q !== true) { m = { parentNode: j.parentNode, previousSibling: j.previousSibling, nextSibling: j.nextSibling }; o.callTreeStore("beforeNodeRemove", [[j], !!p, c]); j.previousSibling = j.nextSibling = j.parentNode = null; o.fireBubbledEvent("remove", [o, j, !!p, m]); o.callTreeStore("onNodeRemove", [[j], !!p, c]) } if (g) { j.erase(true) } else { j.clear() } if (!p) { j.set({ parentId: null, lastParentId: o.getId() }, b) } if (h) { h.endUpdate() } return j }, copy: function (h, l, e) { var k = this, d, g = [h], c = k.childNodes ? k.childNodes.length : 0, j; if (l && l.isSession) { g.push(l) } else { if (arguments.length < 3) { e = l } } d = k.callParent(g); if (e) { for (j = 0; j < c; j++) { d.appendChild(k.childNodes[j].copy(undefined, true)) } } return d }, clear: function (d, c) { var e = this, g; e.parentNode = e.previousSibling = e.nextSibling = null; if (d) { e.firstChild = e.lastChild = e.childNodes = null } if (c) { e.firstChild = e.lastChild = null; e.childNodes.length = 0; if (e.data) { e.data.children = null } } }, drop: function () { var h = this, k = h.childNodes, d = h.parentNode, c, e, g, j = h.getTreeStore(); h.callParent(); if (d) { d.removeChild(h) } else { if (h.get("root")) { j.setRoot(null) } } j && j.beginUpdate(); for (e = 0, c = k ? k.length : 0; e < c; e++) { g = k[e]; g.clear(); g.drop() } j && j.endUpdate() }, erase: function (d) { var h = this, j = h.childNodes, c = j && j.length, e, g; h.remove(); h.clear(true); h.callParent([d]); for (e = 0; e < c; e++) { g = j[e]; g.parentNode = null; g.erase(d) } }, insertBefore: function (h, m, s) { var n = this, l = n.indexOf(m), p = h.parentNode, r = l, j, c, k, g = n.getTreeStore(), d = g && g.bulkUpdate, o, q, e; if (!m) { return n.appendChild(h) } if (h === m) { return false } h = n.createNode(h); if (s !== true && n.fireBubbledEvent("beforeinsert", [n, h, m]) === false) { return false } if (p === n && n.indexOf(h) < l) { r-- } if (p) { if (s !== true && h.fireBubbledEvent("beforemove", [h, p, n, l, m]) === false) { return false } if (p.removeChild(h, false, s, p.getTreeStore() === g) === false) { return false } } g && g.beginUpdate(); if (r === 0) { n.setFirstChild(h) } Ext.Array.splice(n.childNodes, r, 0, h); h.parentNode = n; h.nextSibling = m; m.previousSibling = h; c = n.childNodes[r - 1]; if (c) { h.previousSibling = c; c.nextSibling = h } else { h.previousSibling = null } o = h.updateInfo(false, { parentId: n.getId(), index: r, isFirst: r === 0, isLast: false, depth: (n.data.depth || 0) + 1 }); for (k = r + 1, j = n.childNodes.length; k < j; k++) { q = n.childNodes[k]; e = q.updateInfo(false, { index: k }); if (e) { q.callJoined("afterEdit", [e]) } } if (!n.isLoaded()) { if (d) { n.data.loaded = true } else { n.set("loaded", true) } } else { if (n.childNodes.length === 1 && !d) { n.triggerUIUpdate() } } if (g) { g.registerNode(n, !d) } if (s !== true) { n.fireBubbledEvent("insert", [n, h, m]); if (p) { h.fireBubbledEvent("move", [h, p, n, r, m]) } } n.callTreeStore("onNodeInsert", [h, r]); if (o) { h.callJoined("afterEdit", [o]) } if (g) { g.endUpdate() } return h }, insertChild: function (c, e) { var d = this.childNodes[c]; if (d) { return this.insertBefore(e, d) } else { return this.appendChild(e) } }, isLastVisible: function () { var e = this, c = e.data.isLast, d = e.nextSibling; if (!c && e.getTreeStore().isFiltered()) { while (d) { if (d.data.visible) { return false } d = d.nextSibling } return true } return c }, remove: function (d, e) { var g = this, c = g.parentNode; if (c) { c.removeChild(g, d, e) } else { if (d) { g.erase(true) } } return g }, removeAll: function (d, n, h) { var l = this, m = l.childNodes, k = m.length, g, e, j, c = []; if (!k) { return } if (!h) { e = l.getTreeStore(); if (e) { e.beginUpdate(); e.suspendEvent("remove"); l.callTreeStore("beforeNodeRemove", [m, false, c]) } } for (j = 0; j < k; ++j) { g = m[j]; g.previousSibling = g.nextSibling = g.parentNode = null; l.fireBubbledEvent("remove", [l, g, false]); if (d) { g.erase(true) } else { g.removeAll(false, n, true) } } if (!h && e) { e.resumeEvent("remove"); l.callTreeStore("onNodeRemove", [m, false, c]); e.endUpdate() } l.firstChild = l.lastChild = null; m.length = 0; if (!h) { l.triggerUIUpdate() } return l }, getChildAt: function (c) { return this.childNodes[c] }, replaceChild: function (c, g, e) { var d = g ? g.nextSibling : null; this.removeChild(g, false, e); this.insertBefore(c, d, e); return g }, indexOf: function (c) { return Ext.Array.indexOf(this.childNodes, c) }, indexOfId: function (g) { var e = this.childNodes, c = e.length, d = 0; for (; d < c; ++d) { if (e[d].getId() === g) { return d } } return -1 }, getPath: function (g, e) { g = g || this.idProperty; e = e || "/"; var d = [this.get(g)], c = this.parentNode; while (c) { d.unshift(c.get(g)); c = c.parentNode } return e + d.join(e) }, getDepth: function () { return this.get("depth") }, bubble: function (e, d, c) { var g = this; while (g) { if (e.apply(d || g, c || [g]) === false) { break } g = g.parentNode } }, cascade: function (j, e, c, l) { var h = this; if (arguments.length === 1 && !Ext.isFunction(j)) { l = j.after; e = j.scope; c = j.args; j = j.before } if (!j || j.apply(e || h, c || [h]) !== false) { var k = h.childNodes, g = k.length, d; for (d = 0; d < g; d++) { k[d].cascade.call(k[d], j, e, c, l) } if (l) { l.apply(e || h, c || [h]) } } }, cascadeBy: function () { return this.cascade.apply(this, arguments) }, eachChild: function (g, e, c) { var j = this.childNodes, h = j.length, d; for (d = 0; d < h; d++) { if (g.apply(e || this, c || [j[d]]) === false) { break } } }, findChild: function (d, e, c) { return this.findChildBy(function () { return this.get(d) == e }, null, c) }, findChildBy: function (k, j, d) { var h = this.childNodes, c = h.length, g = 0, l, e; for (; g < c; g++) { l = h[g]; if (k.call(j || l, l) === true) { return l } else { if (d) { e = l.findChildBy(k, j, d); if (e !== null) { return e } } } } return null }, contains: function (c) { return c.isAncestor(this) }, isAncestor: function (c) { var d = this.parentNode; while (d) { if (d === c) { return true } d = d.parentNode } return false }, sort: function (m, e, l) { var j = this, k = j.childNodes, h = k.length, g, d, c = { isFirst: true }; if (h > 0) { if (!m) { m = j.getTreeStore().getSortFn() } Ext.Array.sort(k, m); j.setFirstChild(k[0]); j.setLastChild(k[h - 1]); for (g = 0; g < h; g++) { d = k[g]; d.previousSibling = k[g - 1]; d.nextSibling = k[g + 1]; c.isLast = (g === h - 1); c.index = g; d.updateInfo(false, c); c.isFirst = false; if (e && !d.isLeaf()) { d.sort(m, true, true) } } if (l !== true) { j.fireBubbledEvent("sort", [j, k]); j.callTreeStore("onNodeSort", [k]) } } }, isExpanded: function () { return this.get("expanded") }, isLoaded: function () { return this.get("loaded") }, isBranchLoaded: function () { var c = !this.isLeaf() && this.isLoaded(); if (c) { this.cascade(function (d) { if (!d.isLeaf()) { c = c || d.isBranchLoaded() } return c }) } return c }, isLoading: function () { return this.get("loading") }, isRoot: function () { return !this.parentNode }, isVisible: function () { var c = this.parentNode; while (c) { if (!c.isExpanded()) { return false } c = c.parentNode } return true }, expand: function (c, i, d) { var e = this, g, h; if (!e.isLeaf()) { if (e.isLoading()) { e.on("expand", function () { e.expand(c, i, d) }, e, { single: true }) } else { if (!e.isExpanded()) { if (e.fireBubbledEvent("beforeexpand", [e]) !== false) { if (c) { if (e.parentNode && e.parentNode.isSynchronousRecursiveExpand) { e.isSynchronousRecursiveExpand = true } else { g = e.getTreeStore(); if (g.getProxy().isSynchronous || e.isBranchLoaded()) { e.isSynchronousRecursiveExpand = true; g.suspendEvent("add", "datachanged"); h = true } } } e.callTreeStore("onBeforeNodeExpand", [e.onChildNodesAvailable, e, [c, i, d]]); if (h) { g.resumeEvent("add", "datachanged"); g.fireEvent("datachanged", g); g.fireEvent("refresh", g) } e.isSynchronousRecursiveExpand = false } } else { if (c) { e.expandChildren(true, i, d) } else { Ext.callback(i, d || e, [e.childNodes]) } } } } else { Ext.callback(i, d || e) } }, onChildNodesAvailable: function (g, e, m, n) { var k = this, d = k.getTreeStore(), c = d && d.bulkUpdate, j, h, l; Ext.suspendLayouts(); for (j = k.parentNode; j; j = j.parentNode) { if (!j.isExpanded()) { (l || (l = [])).unshift(j) } } if (c || !d.isVisible(k)) { k.data.expanded = true } else { k.set("expanded", true) } if (l) { for (h = 1; h < l.length; h++) { j = l[h]; if (c || !d.isVisible(j)) { j.data.expanded = true } else { j.set("expanded", true) } } l[0].expand(); for (h = 1; h < l.length; h++) { j = l[h]; j.fireBubbledEvent("expand", [j, j.childNodes]) } } else { k.callTreeStore("onNodeExpand", [g, false]) } k.fireBubbledEvent("expand", [k, g]); if (e) { k.expandChildren(true, m, n) } else { Ext.callback(m, n || k, [k.childNodes]) } Ext.resumeLayouts(true) }, expandChildren: function (h, o, p, j) { var m = this, n, k, d, c, l, g, e; if (Ext.isBoolean(o)) { n = o; o = p; p = j; j = n } if (j === undefined) { e = m.getTreeStore(); j = e && e.singleExpand } d = m.childNodes; c = []; l = j ? Math.min(d.length, 1) : d.length; for (k = 0; k < l; ++k) { g = d[k]; if (!g.isLeaf()) { c[c.length] = g } } l = c.length; for (k = 0; k < l; ++k) { c[k].expand(h) } if (o) { Ext.callback(o, p || m, [m.childNodes]) } }, collapse: function (e, m, n) { var l = this, j = l.isExpanded(), d = l.getTreeStore(), c = d && d.bulkUpdate, k = l.childNodes.length, g, h; if (!l.isLeaf() && ((!j && e) || l.fireBubbledEvent("beforecollapse", [l]) !== false)) { Ext.suspendLayouts(); if (l.isExpanded()) { if (e) { h = function () { for (g = 0; g < k; g++) { l.childNodes[g].setCollapsed(true) } }; if (m) { m = Ext.Function.createSequence(h, Ext.Function.bind(m, n, [l.childNodes])) } else { m = h } } else { if (m) { m = Ext.Function.bind(m, n, [l.childNodes]) } } if (c || !d.contains(l)) { l.data.expanded = false } else { l.set("expanded", false) } l.callTreeStore("onNodeCollapse", [l.childNodes, m, n]); l.fireBubbledEvent("collapse", [l, l.childNodes]); m = null } else { if (e) { for (g = 0; g < k; g++) { l.childNodes[g].setCollapsed(true) } } } Ext.resumeLayouts(true) } Ext.callback(m, n || l, [l.childNodes]) }, setCollapsed: function (d) { var g = this, c = g.childNodes.length, e; if (!g.isLeaf() && g.fireBubbledEvent("beforecollapse", [g]) !== false) { g.data.expanded = false; g.fireBubbledEvent("collapse", [g, g.childNodes]); if (d) { for (e = 0; e < c; e++) { g.childNodes[e].setCollapsed(true) } } } }, collapseChildren: function (e, l, m) { var k = this, h, c = k.childNodes, j = c.length, g = [], d; for (h = 0; h < j; ++h) { d = c[h]; if (!d.isLeaf() && d.isLoaded() && d.isExpanded()) { g.push(d) } } j = g.length; if (j) { for (h = 0; h < j; ++h) { d = g[h]; if (h === j - 1) { d.collapse(e, l, m) } else { d.collapse(e) } } } else { Ext.callback(l, m) } }, fireEvent: function (c) { return this.fireBubbledEvent(c, Ext.Array.slice(arguments, 1)) }, fireBubbledEvent: function (d, g) { var c, h, e; if (a[d]) { for (h = this; c !== false && h; h = (e = h).parentNode) { c = h.fireEventArgs.call(h, d, g) } if (c !== false) { h = e.getTreeStore(); if (h && h.hasListeners && h.hasListeners[d = "node" + d]) { c = h.fireEventArgs(d, g) } } return c } else { return this.fireEventArgs.apply(this, arguments) } }, serialize: function (e) { var j = e || new Ext.data.writer.Json({ writeAllFields: true }), d = j.getRecordData(this), k = this.childNodes, c = k.length, h, g; if (c > 0) { d.children = h = []; for (g = 0; g < c; g++) { h.push(k[g].serialize(j)) } } return d }, callTreeStore: function (h, c) { var e = this, g = e.getTreeStore(), d = g && g[h]; if (g && d) { c = c || []; if (c[0] !== e) { c.unshift(e) } d.apply(g, c) } }, addCls: function (c) { this.replaceCls(null, c) }, removeCls: function (c) { this.replaceCls(c) }, replaceCls: function (c, e) { var d = this._parseCls(this.data.cls), g = this._parseCls(c); if (g.length) { d = Ext.Array.difference(d, g) } g = this._parseCls(e); if (g.length) { d = Ext.Array.unique(d.concat(g)) } this.set("cls", d.join(" ")) }, toggleCls: function (d, h) { if (h === undefined) { var g = this._parseCls(this.data.cls), k = this._parseCls(d), c = k.length, e, j; for (e = 0; e < c; ++e) { j = k[e]; if (Ext.Array.contains(g, j)) { Ext.Array.remove(g, j) } else { g.push(j) } } this.set("cls", g.join(" ")) } else { if (h) { this.addCls(d) } else { this.removeCls(d) } } }, privates: { _noCls: [], spacesRe: /\s+/, join: function (c) { if (c.isTreeStore) { if (this.isRoot()) { this.treeStore = this.store = c } } else { this.callParent([c]) } }, callJoined: function (d, c) { this.callParent([d, c]); this.callTreeStore(d, c) }, _parseCls: function (c) { if (!c) { return this._noCls } if (typeof c === "string") { return c.split(this.spacesRe) } return c } } } } } }, 0, 0, 0, 0, 0, 0, [Ext.data, "NodeInterface"], 0)); (Ext.cmd.derive("Ext.mixin.Queryable", Ext.Base, { mixinId: "queryable", isQueryable: true, query: function (a) { a = a || "*"; return Ext.ComponentQuery.query(a, this.getQueryRoot()) }, queryBy: function (g, e) { var c = [], b = this.getQueryRoot().getRefItems(true), d = 0, a = b.length, h; for (; d < a; ++d) { h = b[d]; if (g.call(e || h, h) !== false) { c.push(h) } } return c }, queryById: function (a) { return this.down(Ext.makeIdSelector(a)) }, child: function (a) { var b = this.getQueryRoot().getRefItems(); if (a && a.isComponent) { return this.matchById(b, a.getItemId()) } if (a) { b = Ext.ComponentQuery.query(a, b) } if (b.length) { return b[0] } return null }, down: function (a) { if (a && a.isComponent) { return this.matchById(this.getRefItems(true), a.getItemId()) } a = a || ""; return this.query(a)[0] || null }, visitPreOrder: function (a, d, c, b) { Ext.ComponentQuery._visit(true, a, this.getQueryRoot(), d, c, b) }, visitPostOrder: function (a, d, c, b) { Ext.ComponentQuery._visit(false, a, this.getQueryRoot(), d, c, b) }, getRefItems: function () { return [] }, getQueryRoot: function () { return this }, privates: { matchById: function (b, e) { var a = b.length, c, d; for (c = 0; c < a; ++c) { d = b[c]; if (d.getItemId() === e) { return d } } return null } } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "Queryable"], 0)); (Ext.cmd.derive("Ext.data.TreeModel", Ext.data.Model, { getRefItems: function () { return this.childNodes }, getRefOwner: function () { return this.parentNode }, statics: { defaultProxy: "memory" } }, 0, 0, 0, 0, 0, [[Ext.mixin.Queryable.prototype.mixinId || Ext.mixin.Queryable.$className, Ext.mixin.Queryable]], [Ext.data, "TreeModel"], function () { Ext.data.NodeInterface.decorate(this) })); (Ext.cmd.derive("Ext.data.NodeStore", Ext.data.Store, { isNodeStore: true, config: { node: null, recursive: false, rootVisible: false, folderSort: false }, implicitModel: "Ext.data.TreeModel", getTotalCount: function () { return this.getCount() }, updateFolderSort: function (b) { var a = this.getData(); a.setTrackGroups(false); if (b) { a.setGrouper({ groupFn: this.folderSortFn }) } else { a.setGrouper(null) } }, folderSortFn: function (a) { return a.data.leaf ? 1 : 0 }, afterReject: function (a) { var b = this; if (b.contains(a)) { b.onUpdate(a, Ext.data.Model.REJECT, null); b.fireEvent("update", b, a, Ext.data.Model.REJECT, null) } }, afterCommit: function (a, c) { var b = this; if (!c) { c = null } if (b.contains(a)) { b.onUpdate(a, Ext.data.Model.COMMIT, c); b.fireEvent("update", b, a, Ext.data.Model.COMMIT, c) } }, onNodeAppend: function (a, b) { if (a === this.getNode()) { this.add([b].concat(this.retrieveChildNodes(b))) } }, onNodeInsert: function (c, e, b) { var d = this, a; if (c === d.getNode()) { a = d.indexOf(b) || 0; d.insert(0, [e].concat(d.retrieveChildNodes(e))) } }, onNodeRemove: function (a, b) { if (a === this.getNode()) { this.remove([b].concat(this.retrieveChildNodes(b))) } }, onNodeExpand: function (b, a) { if (b === this.getNode()) { this.loadRecords(a) } }, applyNode: function (a) { if (a) { if (!a.isModel) { a = new (this.getModel())(a) } if (!a.isNode) { Ext.data.NodeInterface.decorate(a) } } return a }, updateNode: function (b, d) { var a = this, c; if (d && !d.destroyed) { d.un({ append: "onNodeAppend", insert: "onNodeInsert", remove: "onNodeRemove", scope: a }); d.unjoin(a) } if (b) { b.on({ scope: a, append: "onNodeAppend", insert: "onNodeInsert", remove: "onNodeRemove" }); b.join(a); c = []; if (b.childNodes.length) { c = c.concat(a.retrieveChildNodes(b)) } if (a.getRootVisible()) { c.push(b) } else { if (b.isLoaded() || b.isLoading()) { b.set("expanded", true) } } a.getData().clear(); a.fireEvent("clear", a); a.suspendEvents(); if (a.isInitializing) { a.inlineData = c } else { a.add(c) } a.resumeEvents(); if (c.length === 0) { a.loaded = b.loaded = true } a.fireEvent("refresh", a, a.data) } }, isVisible: function (b) { var a = b.parentNode; if (!this.getRecursive() && a !== this.getNode()) { return false } while (a) { if (!a.isExpanded()) { return false } if (a === this.getNode()) { break } a = a.parentNode } return true }, privates: { retrieveChildNodes: function (a) { var d = this.getNode(), b = this.getRecursive(), c = [], e = a; if (!a.childNodes.length || (!b && a !== d)) { return c } if (!b) { return a.childNodes } while (e) { if (e._added) { delete e._added; if (e === a) { break } else { e = e.nextSibling || e.parentNode } } else { if (e !== a) { c.push(e) } if (e.firstChild) { e._added = true; e = e.firstChild } else { e = e.nextSibling || e.parentNode } } } return c } } }, 0, 0, 0, 0, ["store.node"], 0, [Ext.data, "NodeStore"], 0)); (Ext.cmd.derive("Ext.data.Request", Ext.Base, { isDataRequest: true, config: { action: undefined, params: undefined, method: "GET", url: null, operation: null, proxy: null, disableCaching: false, headers: {}, callbackKey: null, rawRequest: null, jsonData: undefined, xmlData: undefined, withCredentials: false, username: null, password: null, binary: false, callback: null, scope: null, timeout: 30000, records: null, directFn: null, args: null, useDefaultXhrHeader: null }, constructor: function (a) { this.initConfig(a) }, getParam: function (a) { var c = this.getParams(), b; if (c) { return c[a] } return b }, setParam: function (a, b) { var c = this.getParams() || {}; c[a] = b; this.setParams(c) } }, 1, 0, 0, 0, 0, 0, [Ext.data, "Request"], 0)); (Ext.cmd.derive("Ext.data.TreeStore", Ext.data.Store, { isTreeStore: true, config: { root: null, rootVisible: false, defaultRootProperty: "children", parentIdProperty: null, clearOnLoad: true, clearRemovedOnLoad: true, nodeParam: "node", defaultRootId: "root", defaultRootText: "Root", folderSort: false, pageSize: null }, filterer: "topdown", lazyFill: false, fillCount: 0, bulkUpdate: 0, nodesToUnregister: 0, _silentOptions: { silent: true }, implicitModel: "Ext.data.TreeModel", constructor: function (a) { var b = this; b.byIdMap = {}; Ext.data.Store.prototype.constructor.call(this, a) }, applyFields: function (a, c) { var b = this; if (a) { if (b.defaultRootProperty !== b.self.prototype.config.defaultRootProperty) { a = a.concat({ name: b.defaultRootProperty, type: "auto", defaultValue: null, persist: false }) } } Ext.data.Store.prototype.applyFields.call(this, a, c) }, onSorterEndUpdate: function () { var c = this, a = c.getSorters(), d = a.getRange(), b = c.getRoot(), e = c.getFolderSort(); c.fireEvent("beforesort", c, d); if (b && (e || d.length)) { if (c.getRemoteSort()) { if (d.length) { c.load({ callback: function () { c.fireEvent("sort", c, d) } }) } } else { b.sort(this.getSortFn(), true); c.fireEvent("datachanged", c); c.fireEvent("refresh", c); c.fireEvent("sort", c, d) } } else { c.fireEvent("sort", c, d) } }, updateFolderSort: function (a) { this.needsFolderSort = a; this.onSorterEndUpdate() }, getSortFn: function () { return this._sortFn || (this._sortFn = this.createSortFn()) }, createSortFn: function () { var a = this, b = this.sorters.getSortFn(); return function (e, d) { var g, h, c = 0; if (a.needsFolderSort) { g = e.data.leaf ? 1 : 0; h = d.data.leaf ? 1 : 0; c = g - h } if (a.needsIndexSort && c === 0) { c = e.data.index - d.data.index } return c || b(e, d) } }, getTotalCount: function () { return this.getCount() }, afterEdit: function (a, b) { var i = this, c = a.parentNode, j = i.getRootVisible(), e = !c && !j, g, d = a.get("visible"), k, h; if (!e && d !== i.contains(a)) { if (d) { if (!c || i.isVisible(a)) { k = [a]; if (a.isExpanded()) { i.handleNodeExpand(a, a.childNodes, k) } g = a.previousSibling ? i.indexOfPreviousVisibleNode(a.previousSibling) : (c ? i.indexOf(c) : -1); i.insert(g + 1, k) } } else { h = i.indexOf(a); i.removeAt(h, i.indexOfNextVisibleNode(a) - h) } } else { if (i.getRoot() && i.needsLocalFilter()) { i.onFilterEndUpdate(i.getFilters()) } } Ext.data.Store.prototype.afterEdit.call(this, a, b) }, afterReject: function (a) { var b = this; if (b.contains(a)) { b.onUpdate(a, Ext.data.Model.REJECT, null); b.fireEvent("update", b, a, Ext.data.Model.REJECT, null) } }, afterCommit: function (a, c) { var b = this; if (!c) { c = null } if (b.contains(a)) { b.onUpdate(a, Ext.data.Model.COMMIT, c); b.fireEvent("update", b, a, Ext.data.Model.COMMIT, c) } }, updateRootVisible: function (b) { var a = this.getRoot(), c; if (a) { c = this.getData(); if (b) { c.insert(0, a) } else { c.remove(a) } } }, updateTrackRemoved: function (a) { Ext.data.Store.prototype.updateTrackRemoved.apply(this, arguments); this.removedNodes = this.removed; this.removed = null }, onDestroyRecords: function (b, a, c) { if (c) { this.removedNodes.length = 0 } }, updateProxy: function (b) { var a; if (b) { if (b.setIdParam) { b.setIdParam(this.getNodeParam()) } a = b.getReader(); if (Ext.isEmpty(a.getRootProperty())) { a.setRootProperty(this.getDefaultRootProperty()) } } }, setProxy: function (a) { this.changingProxy = true; (arguments.callee.$previous || Ext.data.Store.prototype.setProxy).call(this, a); this.changingProxy = false }, updateModel: function (a) { if (a) { var b = a.prototype.isNode; Ext.data.NodeInterface.decorate(a); if (!b && !this.changingProxy) { this.getProxy().getReader().buildExtractors(true) } } }, onCollectionFilter: Ext.emptyFn, onFilterEndUpdate: function (g) { var e = this, d = g.length, a = e.getRoot(), j, c, h, b; if (!e.getRemoteFilter()) { if (d) { e.doFilter(a) } else { a.cascade({ after: function (i) { i.set("visible", true, e._silentOptions) } }) } if (d) { h = []; j = a.childNodes; for (b = 0, d = j.length; b < d; b++) { c = j[b]; if (c.get("visible")) { h.push(c) } } } else { h = a.childNodes } e.onNodeFilter(a, h); a.fireEvent("filterchange", a, h); e.suppressNextFilter = true; Ext.data.Store.prototype.onFilterEndUpdate.call(this, g); e.suppressNextFilter = false } else { Ext.data.Store.prototype.onFilterEndUpdate.call(this, g) } }, onNodeFilter: function (a, e) { var c = this, d = c.getData(), b = []; if (c.getRootVisible() && a.get("visible")) { b.push(a) } c.handleNodeExpand(a, e, b); c.suspendEvents(); d.splice(0, d.getCount(), b); c.resumeEvents(); if (!c.suppressNextFilter) { c.fireEvent("datachanged", c); c.fireEvent("refresh", c) } }, onBeforeNodeExpand: function (b, k, l, g) { var h = this, i, d, j, e, a, c; if (b.isLoaded()) { c = [b.childNodes]; if (g) { c.push.apply(c, g) } Ext.callback(k, l || b, c) } else { if (b.isLoading()) { h.on("load", function () { c = [b.childNodes]; if (g) { c.push.apply(c, g) } Ext.callback(k, l || b, c) }, h, { single: true, priority: 1001 }) } else { i = h.getProxy().getReader(); d = b.getProxy(); j = d ? d.getReader() : null; e = j && j.initialConfig.rootProperty ? j : i; a = e.getRoot(b.raw || b.data); if (a || (b.phantom && !b.isRoot())) { if (a) { h.fillNode(b, e.extractData(a, { model: b.childType, recordCreator: h.recordCreator })) } c = [b.childNodes]; if (g) { c.push.apply(c, g) } Ext.callback(k, l || b, c) } else { h.read({ node: b, onChildNodesAvailable: function () { delete h.lastOptions.onChildNodesAvailable; c = [b.childNodes]; if (g) { c.push.apply(c, g) } Ext.callback(k, l || b, c) } }); h.flushLoad() } } } }, onNodeExpand: function (d, b) { var e = this, a = e.indexOf(d) + 1, c = []; e.handleNodeExpand(d, b, c); if (!e.refreshCounter && d.isRoot() && !d.get("visible")) { e.loadRecords(c) } else { e.insert(a, c) } }, handleNodeExpand: function (e, b, d) { var h = this, g = b ? b.length : 0, c, a; if (e !== this.getRoot() && !h.isVisible(e)) { return } if (g) { for (c = 0; c < g; c++) { a = b[c]; if (a.get("visible")) { d.push(a); if (a.isExpanded()) { if (a.isLoaded()) { h.handleNodeExpand(a, a.childNodes, d) } else { a.set("expanded", false); a.expand() } } } } } }, onNodeCollapse: function (d, a, h, c) { var e = this, b = e.indexOf(d) + 1, g; if (e.needsLocalFilter()) { a = Ext.Array.filter(a, e.filterVisible) } if (a.length && e.isVisible(d)) { g = e.indexOfNextVisibleNode(d); e.removeAt(b, g - b) } Ext.callback(h, c) }, indexOfNextVisibleNode: function (b) { var a; while (b.parentNode) { for (a = b.nextSibling; a && !a.get("visible"); a = a.nextSibling) { } if (a) { return this.indexOf(a) } b = b.parentNode } return this.getCount() }, indexOfPreviousVisibleNode: function (b) { var a; for (a = b; a && !a.get("visible"); a = a.previousSibling) { } if (a) { if (a.isExpanded() && a.lastChild) { return this.indexOfPreviousVisibleNode(a.lastChild) } } else { a = b.parentNode } return this.indexOf(a) }, filterNew: function (a) { return !a.get("root") && Ext.data.Store.prototype.filterNew.call(this, a) }, filterRejects: function (a) { return !a.get("root") && Ext.data.Store.prototype.filterRejects.call(this, a) }, getNewRecords: function () { return Ext.Array.filter(Ext.Object.getValues(this.byIdMap), this.filterNew, this) }, getRejectRecords: function () { return Ext.Array.filter(Ext.Object.getValues(this.byIdMap), this.filterRejects, this) }, getUpdatedRecords: function () { return Ext.Array.filter(Ext.Object.getValues(this.byIdMap), this.filterUpdated) }, beforeNodeRemove: function (d, k, j, a) { if (!Ext.isArray(k)) { k = [k] } var h = this, g = k.length, e = h.removedNodes, c, b; for (c = 0; !b && c < g; c++) { if (k[c].get("visible")) { b = k[c] } } if (b) { a[0] = h.indexOf(k[0]); a[1] = h.indexOfNextVisibleNode(k[k.length - 1]) - a[0] } else { a[0] = -1; a[1] = 0 } for (c = 0; c < g; c++) { k[c].cascade(function (i) { h.unregisterNode(i, true); if (e && !j) { if (!i.phantom && !i.erasing && !h.loading) { i.removedFrom = h.indexOf(i); e.push(i); h.needsSync = true } } }) } }, afterDrop: Ext.emptyFn, onNodeRemove: function (a, e, b, c) { var d = this; d.suspendAutoSync(); if (c[0] !== -1) { d.removeIsMove = b; d.removeAt.apply(d, c); d.removeIsMove = false } d.resumeAutoSync() }, onNodeAppend: function (b, c, a) { this.onNodeInsert(b, c, a) }, onNodeInsert: function (m, a, g) { var h = this, c = a.raw || a.data, e = h.removedNodes, i, b, j, d, l, k; if (m && h.needsLocalFilter()) { h.doFilter(m) } h.beginUpdate(); if (h.isVisible(a)) { if (g === 0 || !a.previousSibling) { k = h.indexOf(m) } else { k = h.indexOfPreviousVisibleNode(a.previousSibling) } h.insert(k + 1, a); if (!a.isLeaf() && a.isExpanded()) { if (a.isLoaded()) { h.onNodeExpand(a, a.childNodes) } else { if (!h.fillCount) { a.set("expanded", false); a.expand() } } } } Ext.Array.remove(e, a); h.needsSync = h.needsSync || a.phantom || a.dirty; if (!a.isLeaf() && !a.isLoaded() && !h.lazyFill) { i = h.getProxy().getReader(); b = a.getProxy(); j = b ? b.getReader() : null; d = j && j.initialConfig.rootProperty ? j : i; l = d.getRoot(c); if (l) { h.fillNode(a, d.extractData(l, { model: a.childType, recordCreator: h.recordCreator })) } } h.endUpdate() }, registerNode: function (g, a) { var e = this, h = e.byIdMap[g.id], c, d, b; e.byIdMap[g.id] = g; if (g.onRegisterTreeNode && g !== h) { g.onRegisterTreeNode(e) } if (g.onUnregisterTreeNode) { e.nodesToUnregister++ } if (a === true) { c = g.childNodes; d = c.length; for (b = 0; b < d; b++) { e.registerNode(c[b], true) } } }, unregisterNode: function (g, a) { var e = this, h = e.byIdMap[g.id], c, d, b; delete e.byIdMap[g.id]; if (a === true) { c = g.childNodes; d = c.length; for (b = 0; b < d; b++) { e.unregisterNode(c[b], true) } } if (g.onUnregisterTreeNode && g === h) { g.onUnregisterTreeNode(e); e.nodesToUnregister-- } }, onNodeSort: function (b, c) { var a = this; a.suspendAutoSync(); if ((a.indexOf(b) !== -1 && b.isExpanded()) || (b === a.getRoot() && !a.getRootVisible())) { Ext.suspendLayouts(); a.onNodeCollapse(b, c); a.onNodeExpand(b, c); Ext.resumeLayouts(true) } a.resumeAutoSync(a.autoSync) }, applyRoot: function (e) { var b = this, d = b.getModel(), a = d.prototype.idProperty, c = b.getDefaultRootId(); if (e && !e.isNode) { e = Ext.apply({ text: b.getDefaultRootText(), root: true, isFirst: true, isLast: true, depth: 0, index: 0, parentId: null, allowDrag: false }, e); if (c && e[a] === undefined) { e[a] = c } e = new d(e) } return e }, updateRoot: function (h, b) { var e = this, g, a = !b, d, c = []; e.getTrackRemoved(); e.suspendEvent("add", "remove"); if (b && b.isModel) { if (e.getRootVisible()) { d = [b] } else { d = b.childNodes } e.beforeNodeRemove(null, d, false, c); b.set("root", false); e.onNodeRemove(null, d, false, c); b.fireEvent("remove", null, b, false); b.fireEvent("rootchange", null); b.clearListeners(); b.store = b.treeStore = null; e.unregisterNode(b) } e.getData().clear(); if (h) { if (h.fireEventArgs("beforeappend", [null, h]) === false) { h = null } else { g = h.parentNode; if (g) { if (!g.removeChild(h, false, false, g.getTreeStore() === e)) { return } } else { if ((g = h.getTreeStore()) && g !== e && h === g.getRoot()) { g.setRoot(null) } } h.store = h.treeStore = e; h.set("root", true); h.updateInfo(true, { isFirst: true, isLast: true, depth: 0, index: 0, parentId: null }); e.registerNode(h, true); h.fireEvent("append", null, h, false); h.fireEvent("rootchange", h); e.onNodeAppend(null, h, 0); h.phantom = true } } e.fireEvent("rootchange", h, b); if (h && (e.getAutoLoad() || h.isExpanded())) { if (h.isLoaded()) { e.onNodeExpand(h, h.childNodes); e.fireEvent("datachanged", e); e.fireEvent("refresh", e) } else { h.data.expanded = false; h.expand(false); if (h.isLoaded && !e.getProxy().isSynchronous) { e.fireEvent("datachanged", e); e.fireEvent("refresh", e) } } } else { if (!a) { e.fireEvent("datachanged", e); e.fireEvent("refresh", e) } } e.resumeEvent("add", "remove") }, doDestroy: function () { var b = this, a = b.getRoot(); if (a && b.nodesToUnregister) { a.cascade(function (c) { if (c.onUnregisterTreeNode) { c.onUnregisterTreeNode(b) } }) } Ext.data.Store.prototype.doDestroy.call(this) }, each: function (d, c, e) { var a, b = 0; if (e && typeof e === "object") { a = e.collapsed; e = e.filtered } if (a) { this.getRoot().cascade(function (g) { if (e === true || g.get("visible")) { return d.call(c || g, g, b++) } }) } else { return Ext.data.Store.prototype.each.call(this, d, c, e) } }, collect: function (d, b, g) { var c, h = {}, a = [], i, e; if (b && typeof b === "object") { c = b.collapsed; g = b.filtered; b = b.allowNull } if (c || g) { this.getRoot().cascade(function (j) { if (g === true || j.get("visible")) { e = j.get(d); i = String(e); if ((b || !Ext.isEmpty(e)) && !h[i]) { h[i] = 1; a.push(e) } } if (!c && !j.isExpanded()) { return false } }) } else { a = Ext.data.Store.prototype.collect.call(this, d, b, g) } return a }, getNodeById: function (a) { return this.byIdMap[a] || null }, findNode: function (h, g, d, c, b) { if (Ext.isEmpty(g, false)) { return null } if (h === this.model.idProperty && arguments.length < 3) { return this.byIdMap[g] } var e = Ext.String.createRegex(g, d, c, b), a = null; Ext.Object.eachValue(this.byIdMap, function (i) { if (i && e.test(i.get(h))) { a = i; return false } }); return a }, load: function (a) { var b = a && a.node; if (!b & !(b = this.getRoot())) { b = this.setRoot({ expanded: true }); return } if (b.isLoading()) { return } return Ext.data.Store.prototype.load.call(this, a) }, reload: function (a) { var b = Ext.apply({}, a, this.lastOptions); b.node = this.getRoot(); return this.load(b) }, flushLoad: function () { var g = this, j = g.pendingLoadOptions, a, h, i, d = g.getClearOnLoad(), e, b, c; g.clearLoadTask(); if (!j) { return } a = j.node || g.getRoot(); e = a && a.isRoot(); h = j.callback; i = j.scope; j.params = j.params || {}; if (a.data.expanded && !e) { a.data.loaded = false; if (d) { a.data.expanded = false } j.callback = function (l, k, m) { if (!d) { a.collapse() } a.expand(); Ext.callback(h, i, [l, k, m]) } } j.id = a.getId(); g.setLoadOptions(j); if (g.getRemoteSort() && j.sorters) { g.fireEvent("beforesort", g, j.sorters) } j = Ext.apply({ node: j.node || a, internalScope: g, internalCallback: g.onProxyLoad }, j); g.lastOptions = Ext.apply({}, j); j.isRootLoad = e; b = g.createOperation("read", j); if (g.fireEvent("beforeload", g, b) !== false) { g.loading = true; if (e) { if (g.getClearRemovedOnLoad()) { g.removedNodes.length = 0 } if (d) { g.unregisterNode(a, true); a.clear(false, true); g.registerNode(a); c = true } } else { if (g.getTrackRemoved() && g.getClearRemovedOnLoad()) { g.clearRemoved(a) } if (d) { a.removeAll(false) } } if (g.loading && a) { a.set("loading", true) } if (c) { g.clearData(true); if (g.getRootVisible()) { g.suspendEvents(); g.add(a); g.resumeEvents() } } b.execute() } return g }, onProxyLoad: function (c) { var h = this, j = c.initialConfig, d = c.wasSuccessful(), b = c.getRecords(), a = j.node, e = j.isRootLoad, i = c.getScope() || h, g = [b, c, d]; if (h.destroyed) { return } h.loading = false; a.set("loading", false); if (d) { ++h.loadCount; if (!h.getClearOnLoad()) { b = h.cleanRecords(a, b) } if (h.getParentIdProperty()) { b = h.treeify(a, b) } if (e) { h.suspendEvent("add", "update") } b = h.fillNode(a, b) } Ext.callback(j.onChildNodesAvailable, i, g); if (e) { h.resumeEvent("add", "update"); h.callObservers("BeforePopulate"); h.fireEvent("datachanged", h); h.fireEvent("refresh", h); h.callObservers("AfterPopulate") } h.fireEvent("load", h, b, d, c, a) }, clearRemoved: function (b) { var k = this, e = k.removedNodes, a = b.getId(), d = e.length, c = d, n = {}, h = [], m = {}, j, g, l; if (b === k.getRoot()) { k.removedNodes.length = 0; return } for (; c--;) { j = e[c]; m[j.getId()] = j } for (c = d; c--;) { j = e[c]; g = j; while (g && g.getId() !== a) { l = g.get("parentId") || g.get("lastParentId"); g = g.parentNode || k.getNodeById(l) || m[l] } if (g) { n[j.getId()] = j } } for (c = 0; c < d; c++) { j = e[c]; if (!n[j.getId()]) { h.push(j) } } k.removedNodes = h }, fillNode: function (c, a) { var b = this, d = a ? a.length : 0; if (++b.bulkUpdate === 1) { b.suspendEvent("datachanged") } if (d) { b.setupNodes(a) } if (b.bulkUpdate === 1) { c.set("loaded", true) } else { c.data.loaded = true } if (a.length) { c.appendChild(a, undefined, true) } if (!--b.bulkUpdate) { b.resumeEvent("datachanged") } return a }, setupNodes: function (d) { var h = this, g = h.getSorters(), j = false, b = d.length, a = h.sortOnLoad && b > 1 && !h.getRemoteSort() && h.getFolderSort() || g.length, c = h.needsLocalFilter(), l, k, e; if (c) { h.doFilter(d[0]) } for (e = 1; e < b; e++) { l = d[e]; k = d[e - 1]; if (c) { h.doFilter(l) } j = l.data.index !== k.data.index } if (a) { h.needsIndexSort = true; Ext.Array.sort(d, h.getSortFn()); h.needsIndexSort = false } else { if (j) { Ext.Array.sort(d, h.sortByIndex) } } }, beginFill: function () { var a = this; if (!a.fillCount++) { a.beginUpdate(); a.suspendEvent("add", "update"); a.suspendAutoSync(); a.fillArray = [] } }, endFill: function (e, b) { var g = this, h = g.fillArray, d, a, c; h.push(b); if (!--g.fillCount) { g.resumeAutoSync(); g.resumeEvent("add", "update"); for (d = 0, a = h.length; d < a; d++) { c = g.indexOf(h[d][0]); if (c !== -1) { g.fireEvent("add", g, h[d], c) } } g.fillArray = null; g.endUpdate() } }, sortByIndex: function (b, a) { return b.data.index - a.data.index }, onIdChanged: function (d, g, b) { var e = d.childNodes, a = e && e.length, c; Ext.data.Store.prototype.onIdChanged.apply(this, arguments); delete this.byIdMap[g]; this.byIdMap[b] = d; for (c = 0; c < a; c++) { e[c].set("parentId", b) } }, treeify: function (j, e) { var m = this, o = j.getId(), c = m.getParentIdProperty(), k = e.length, p = [], l = {}, g, d, h, n, a, b; for (g = 0; g < k; g++) { d = e[g]; d.data.depth = 1; l[d.id] = d } for (g = 0; g < k; g++) { d = e[g]; h = d.data[c]; if (!(h || h === 0) || h === o) { p.push(d) } else { n = l[h]; n.$children = n.$children || []; n.$children.push(d); d.data.depth = n.data.depth + 1 } } for (a in l) { d = l[a]; b = d.$children; if (b) { delete d.$children; m.setupNodes(b); d.appendChild(b) } m.registerNode(d) } m.setupNodes(p); return p }, cleanRecords: function (g, b) { var e = {}, j = g.childNodes, d = 0, a = j.length, c = [], h; for (; d < a; ++d) { e[j[d].getId()] = true } for (d = 0, a = b.length; d < a; ++d) { h = b[d]; if (!e[h.getId()]) { c.push(h) } } return c }, removeAll: function () { this.suspendEvents(); this.setRoot(null); this.resumeEvents(); Ext.data.Store.prototype.removeAll.call(this) }, doSort: function (a) { var b = this; if (b.getRemoteSort()) { b.load() } else { b.tree.sort(a, true); b.fireEvent("datachanged", b); b.fireEvent("refresh", b) } b.fireEvent("sort", b, b.sorters.getRange()) }, filterVisible: function (a) { return a.get("visible") }, isVisible: function (c) { var a = c.parentNode, d = c.data.visible, b = this.getRoot(); while (d && a) { d = a.data.expanded && a.data.visible; a = a.parentNode } return d && !(c === b && !this.getRootVisible()) }, commitChanges: function () { var a = this.removedNodes; if (a) { a.length = 0 } Ext.data.Store.prototype.commitChanges.call(this) }, getRootNode: function () { return this.getRoot() }, setRootNode: function (a) { this.setRoot(a); return this.getRoot() }, privates: { fireChangeEvent: function (a) { return !!this.byIdMap[a.id] }, getRawRemovedRecords: function () { return this.removedNodes }, createOperation: function (c, a) { var e = this, d = a.node, b; if (e.useModelProxy && d && d !== e.getRootNode()) { b = d.getProxy() } if (b && b !== e.getProxy()) { return b.createOperation(c, a) } else { return Ext.data.Store.prototype.createOperation.call(this, c, a) } }, recordCreator: function (a, b) { return new b(a) }, doFilter: function (a) { this.filterNodes(a, this.getFilters().getFilterFn(), true) }, filterNodes: function (b, l, g) { var h = this, a = h.filterer === "bottomup", d = l(b) && g || (b.isRoot() && !h.getRootVisible()), k = b.childNodes, e = k && k.length, c, j; if (e) { for (c = 0; c < e; ++c) { j = h.filterNodes(k[c], l, d || a) || j } if (a) { d = j || d } } b.set("visible", d, h._silentOptions); return d }, needsLocalFilter: function () { return !this.getRemoteFilter() && this.getFilters().length }, onRemoteFilterSet: function (a, c) { var b = this.getData(); b.setFilters(null); if (a) { a.on("endupdate", this.onFilterEndUpdate, this) } }, onRemoteSortSet: function (b, c) { var a = this.getData(); a.setSorters(null); if (b) { b.on("endupdate", this.onSorterEndUpdate, this) } } }, deprecated: { 5: { properties: { tree: null } } } }, 1, 0, 0, 0, ["store.tree"], 0, [Ext.data, "TreeStore"], 0)); (Ext.cmd.derive("Ext.data.Types", Ext.Base, { singleton: true }, 0, 0, 0, 0, 0, 0, [Ext.data, "Types"], function (b) { var a = Ext.data.SortTypes; Ext.apply(b, { stripRe: /[\$,%]/g, AUTO: { sortType: a.none, type: "auto" }, STRING: { convert: function (d) { var c = this.getAllowNull() ? null : ""; return (d === undefined || d === null) ? c : String(d) }, sortType: a.asUCString, type: "string" }, INT: { convert: function (c) { if (typeof c === "number") { return parseInt(c, 10) } return c !== undefined && c !== null && c !== "" ? parseInt(String(c).replace(b.stripRe, ""), 10) : (this.getAllowNull() ? null : 0) }, sortType: a.none, type: "int" }, FLOAT: { convert: function (c) { if (typeof c === "number") { return c } return c !== undefined && c !== null && c !== "" ? parseFloat(String(c).replace(b.stripRe, ""), 10) : (this.getAllowNull() ? null : 0) }, sortType: a.none, type: "float" }, BOOL: { convert: function (c) { if (typeof c === "boolean") { return c } if (this.getAllowNull() && (c === undefined || c === null || c === "")) { return null } return c === "true" || c == 1 }, sortType: a.none, type: "bool" }, DATE: { convert: function (d) { var e = this.getDateReadFormat() || this.getDateFormat(), c; if (!d) { return null } if (d instanceof Date) { return d } if (e) { return Ext.Date.parse(d, e) } c = Date.parse(d); return c ? new Date(c) : null }, sortType: a.asDate, type: "date" } }); b.BOOLEAN = b.BOOL; b.INTEGER = b.INT; b.NUMBER = b.FLOAT })); (Ext.cmd.derive("Ext.data.Validation", Ext.data.Model, { isValidation: true, syncGeneration: 0, attach: function (a) { this.record = a; this.isBase = a.self === Ext.data.Model; delete this.data.id }, getValidation: function () { return null }, isValid: function () { var a = this; if (a.syncGeneration !== a.record.generation) { a.refresh() } return !a.dirty }, refresh: function (b) { if (this.isBase) { return } var u = this, v = u.data, d = u.record, l = d.fields, o = d.generation, t = d.data, k = d.validationSeparator, c = null, e, h, m, a, r, p, n, s, q, g, x, w; if (b || u.syncGeneration !== o) { u.syncGeneration = o; for (p = 0, q = l.length; p < q; ++p) { a = l[p]; w = a.name; x = t[w]; e = a.defaultInvalidMessage; m = 0; if (!(w in v)) { v[w] = h = true } else { h = v[w] } if (a.validate !== Ext.emptyFn) { g = a.validate(x, k, null, d); if (g !== true) { m = g || e } } if (!m) { m = true } if (m !== h) { (c || (c = {}))[w] = m } } if (c) { u.set(c) } } } }, 0, 0, 0, 0, 0, 0, [Ext.data, "Validation"], 0)); (Ext.cmd.derive("Ext.dom.Helper", Ext.Base, function () { var a = "afterbegin", g = "afterend", h = "beforebegin", d = "beforeend", i = ["BeforeBegin", "previousSibling"], e = ["AfterEnd", "nextSibling"], c = { beforebegin: i, afterend: e }, b = { beforebegin: i, afterend: e, afterbegin: ["AfterBegin", "firstChild"], beforeend: ["BeforeEnd", "lastChild"] }; return { singleton: true, alternateClassName: ["Ext.DomHelper", "Ext.core.DomHelper"], emptyTags: /^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i, confRe: /^(?:tag|children|cn|html|tpl|tplData)$/i, endRe: /end/i, attributeTransform: { cls: "class", htmlFor: "for" }, closeTags: {}, detachedDiv: document.createElement("div"), decamelizeName: function () { var l = /([a-z])([A-Z])/g, k = {}; function j(m, o, n) { return o + "-" + n.toLowerCase() } return function (m) { return k[m] || (k[m] = m.replace(l, j)) } }(), generateMarkup: function (q, k) { var p = this, o = typeof q, n, j, r, m, l; if (o === "string" || o === "number") { k.push(q) } else { if (Ext.isArray(q)) { for (m = 0; m < q.length; m++) { if (q[m]) { p.generateMarkup(q[m], k) } } } else { r = q.tag || "div"; k.push("<", r); for (n in q) { if (q.hasOwnProperty(n)) { j = q[n]; if (j !== undefined && !p.confRe.test(n)) { if (j && j.join) { j = j.join(" ") } if (typeof j === "object") { k.push(" ", n, '="'); p.generateStyles(j, k, true).push('"') } else { k.push(" ", p.attributeTransform[n] || n, '="', j, '"') } } } } if (p.emptyTags.test(r)) { k.push("/>") } else { k.push(">"); if ((j = q.tpl)) { j.applyOut(q.tplData, k) } if ((j = q.html)) { k.push(j) } if ((j = q.cn || q.children)) { p.generateMarkup(j, k) } l = p.closeTags; k.push(l[r] || (l[r] = "</" + r + ">")) } } } return k }, generateStyles: function (n, k, m) { var j = k || [], l, o; for (l in n) { if (n.hasOwnProperty(l)) { o = n[l]; l = this.decamelizeName(l); if (m && Ext.String.hasHtmlCharacters(o)) { o = Ext.String.htmlEncode(o) } j.push(l, ":", o, ";") } } return k || j.join("") }, markup: function (j) { if (typeof j === "string") { return j } var k = this.generateMarkup(j, []); return k.join("") }, applyStyles: function (j, k) { Ext.fly(j).applyStyles(k) }, createContextualFragment: function (k) { var n = this.detachedDiv, j = document.createDocumentFragment(), l, m; n.innerHTML = k; m = n.childNodes; l = m.length; while (l--) { j.appendChild(m[0]) } return j }, createDom: function (m, j) { var l = this, k = l.markup(m), p = l.detachedDiv, n; p.innerHTML = k; n = p.firstChild; return Ext.supports.ChildContentClearedWhenSettingInnerHTML ? n.cloneNode(true) : n }, insertHtml: function (m, j, n) { var r = this, k, o, l, q, s; m = m.toLowerCase(); if (j.insertAdjacentHTML) { if (r.ieInsertHtml) { s = r.ieInsertHtml(m, j, n); if (s) { return s } } k = b[m]; if (k) { j.insertAdjacentHTML(k[0], n); return j[k[1]] } } else { if (j.nodeType === 3) { m = m === a ? h : m; m = m === d ? g : m } o = Ext.supports.CreateContextualFragment ? j.ownerDocument.createRange() : undefined; q = "setStart" + (this.endRe.test(m) ? "After" : "Before"); if (c[m]) { if (o) { o[q](j); s = o.createContextualFragment(n) } else { s = this.createContextualFragment(n) } j.parentNode.insertBefore(s, m === h ? j : j.nextSibling); return j[(m === h ? "previous" : "next") + "Sibling"] } else { l = (m === a ? "first" : "last") + "Child"; if (j.firstChild) { if (o) { try { o[q](j[l]); s = o.createContextualFragment(n) } catch (p) { s = this.createContextualFragment(n) } } else { s = this.createContextualFragment(n) } if (m === a) { j.insertBefore(s, j.firstChild) } else { j.appendChild(s) } } else { j.innerHTML = n } return j[l] } } }, insertBefore: function (j, l, k) { return this.doInsert(j, l, k, h) }, insertAfter: function (j, l, k) { return this.doInsert(j, l, k, g) }, insertFirst: function (j, l, k) { return this.doInsert(j, l, k, a) }, append: function (j, l, k) { return this.doInsert(j, l, k, d) }, overwrite: function (l, k, n) { var m = this, j; l = Ext.getDom(l); k = m.markup(k); if (m.ieOverwrite) { j = m.ieOverwrite(l, k) } if (!j) { l.innerHTML = k; j = l.firstChild } return n ? Ext.get(j) : j }, doInsert: function (l, p, n, j) { var m = this, k; l = l.dom || Ext.getDom(l); if ("innerHTML" in l) { k = m.insertHtml(j, l, m.markup(p)) } else { k = m.createDom(p, null); if (l.nodeType === 3) { j = j === a ? h : j; j = j === d ? g : j } if (c[j]) { l.parentNode.insertBefore(k, j === h ? l : l.nextSibling) } else { if (l.firstChild && j === a) { l.insertBefore(k, l.firstChild) } else { l.appendChild(k) } } } return n ? Ext.get(k) : k }, createTemplate: function (k) { var j = this.markup(k); return new Ext.Template(j) }, createHtml: function (j) { return this.markup(j) } } }, 0, 0, 0, 0, 0, 0, [Ext.dom, "Helper", Ext, "DomHelper", Ext.core, "DomHelper"], 0)); Ext.define("Ext.overrides.dom.Helper", (function () { var c = /^(?:table|thead|tbody|tr|td)$/i, h = /td|tr|tbody|thead/i, g = "<table>", i = "</table>", b = g + "<tbody>", e = "</tbody>" + i, a = b + "<tr>", d = "</tr>" + e; return { override: "Ext.dom.Helper", ieInsertHtml: function (j, l, k) { var m = null; if (Ext.isIE9m && c.test(l.tagName)) { m = this.insertIntoTable(l.tagName.toLowerCase(), j, l, k) } return m }, ieOverwrite: function (k, j) { if (Ext.isIE9m && c.test(k.tagName)) { while (k.firstChild) { k.removeChild(k.firstChild) } if (j) { return this.insertHtml("afterbegin", k, j) } } }, ieTable: function (p, k, q, o) { var l = -1, n = this.detachedDiv, m, j; n.innerHTML = [k, q, o].join(""); while (++l < p) { n = n.firstChild } m = n.nextSibling; if (m) { m = n; n = document.createDocumentFragment(); while (m) { j = m.nextSibling; n.appendChild(m); m = j } } return n }, insertIntoTable: function (s, l, k, m) { var j, p, o = l === "beforebegin", r = l === "afterbegin", n = l === "beforeend", q = l === "afterend"; if (s === "td" && (r || n) || !h.test(s) && (o || q)) { return null } p = o ? k : q ? k.nextSibling : r ? k.firstChild : null; if (o || q) { k = k.parentNode } if (s === "td" || (s === "tr" && (n || r))) { j = this.ieTable(4, a, m, d) } else { if (((s === "tbody" || s === "thead") && (n || r)) || (s === "tr" && (o || q))) { j = this.ieTable(3, b, m, e) } else { j = this.ieTable(2, g, m, i) } } k.insertBefore(j, p); return j } } })()); (Ext.cmd.derive("Ext.dom.Query", Ext.Base, function () { var DQ, doc = document, cache, simpleCache, valueCache, useClassList = !!doc.documentElement.classList, useElementPointer = !!doc.documentElement.firstElementChild, useChildrenCollection = (function () { var d = doc.createElement("div"); d.innerHTML = "<!-- -->text<!-- -->"; return d.children && (d.children.length === 0) })(), nonSpace = /\S/, trimRe = /^\s+|\s+$/g, tplRe = /\{(\d+)\}/g, modeRe = /^(\s?[\/>+~]\s?|\s|$)/, tagTokenRe = /^(#)?([\w\-\*\|\\]+)/, nthRe = /(\d*)n\+?(\d*)/, nthRe2 = /\D/, startIdRe = /^\s*#/, isIE = window.ActiveXObject ? true : false, key = 30803, longHex = /\\([0-9a-fA-F]{6})/g, shortHex = /\\([0-9a-fA-F]{1,6})\s{0,1}/g, nonHex = /\\([^0-9a-fA-F]{1})/g, escapes = /\\/g, num, hasEscapes, supportsColonNsSeparator = (function () { var xmlDoc, xmlString = '<r><a:b xmlns:a="n"></a:b></r>'; if (window.DOMParser) { xmlDoc = (new DOMParser()).parseFromString(xmlString, "application/xml") } else { xmlDoc = new ActiveXObject("Microsoft.XMLDOM"); xmlDoc.loadXML(xmlString) } return !!xmlDoc.getElementsByTagName("a:b").length })(), longHexToChar = function ($0, $1) { return String.fromCharCode(parseInt($1, 16)) }, shortToLongHex = function ($0, $1) { while ($1.length < 6) { $1 = "0" + $1 } return "\\" + $1 }, charToLongHex = function ($0, $1) { num = $1.charCodeAt(0).toString(16); if (num.length === 1) { num = "0" + num } return "\\0000" + num }, unescapeCssSelector = function (selector) { return (hasEscapes) ? selector.replace(longHex, longHexToChar) : selector }, setupEscapes = function (path) { hasEscapes = (path.indexOf("\\") > -1); if (hasEscapes) { path = path.replace(shortHex, shortToLongHex).replace(nonHex, charToLongHex).replace(escapes, "\\\\") } return path }; eval("var batch = 30803, child, next, prev, byClassName;"); child = useChildrenCollection ? function child(parent, index) { return parent.children[index] } : function child(parent, index) { var i = 0, n = parent.firstChild; while (n) { if (n.nodeType == 1) { if (++i == index) { return n } } n = n.nextSibling } return null }; next = useElementPointer ? function (n) { return n.nextElementSibling } : function (n) { while ((n = n.nextSibling) && n.nodeType != 1) { } return n }; prev = useElementPointer ? function (n) { return n.previousElementSibling } : function (n) { while ((n = n.previousSibling) && n.nodeType != 1) { } return n }; function children(parent) { var n = parent.firstChild, nodeIndex = -1, nextNode; while (n) { nextNode = n.nextSibling; if (n.nodeType == 3 && !nonSpace.test(n.nodeValue)) { parent.removeChild(n) } else { n.nodeIndex = ++nodeIndex } n = nextNode } return this } byClassName = useClassList ? function (nodeSet, cls) { cls = unescapeCssSelector(cls); if (!cls) { return nodeSet } var result = [], ri = -1, i, ci, classList; for (i = 0; ci = nodeSet[i]; i++) { classList = ci.classList; if (classList) { if (classList.contains(cls)) { result[++ri] = ci } } else { if ((" " + ci.className + " ").indexOf(cls) !== -1) { result[++ri] = ci } } } return result } : function (nodeSet, cls) { cls = unescapeCssSelector(cls); if (!cls) { return nodeSet } var result = [], ri = -1, i, ci; for (i = 0; ci = nodeSet[i]; i++) { if ((" " + ci.className + " ").indexOf(cls) !== -1) { result[++ri] = ci } } return result }; function attrValue(n, attr) { if (!n.tagName && typeof n.length != "undefined") { n = n[0] } if (!n) { return null } if (attr == "for") { return n.htmlFor } if (attr == "class" || attr == "className") { return n.className } return n.getAttribute(attr) || n[attr] } function getNodes(ns, mode, tagName) { var result = [], ri = -1, cs, i, ni, j, ci, cn, utag, n, cj; if (!ns) { return result } tagName = tagName.replace("|", ":") || "*"; if (typeof ns.getElementsByTagName != "undefined") { ns = [ns] } if (!mode) { tagName = unescapeCssSelector(tagName); if (!supportsColonNsSeparator && DQ.isXml(ns[0]) && tagName.indexOf(":") !== -1) { for (i = 0; ni = ns[i]; i++) { cs = ni.getElementsByTagName(tagName.split(":").pop()); for (j = 0; ci = cs[j]; j++) { if (ci.tagName === tagName) { result[++ri] = ci } } } } else { for (i = 0; ni = ns[i]; i++) { cs = ni.getElementsByTagName(tagName); for (j = 0; ci = cs[j]; j++) { result[++ri] = ci } } } } else { if (mode == "/" || mode == ">") { utag = tagName.toUpperCase(); for (i = 0; ni = ns[i]; i++) { cn = ni.childNodes; for (j = 0; cj = cn[j]; j++) { if (cj.nodeName == utag || cj.nodeName == tagName || tagName == "*") { result[++ri] = cj } } } } else { if (mode == "+") { utag = tagName.toUpperCase(); for (i = 0; n = ns[i]; i++) { while ((n = n.nextSibling) && n.nodeType != 1) { } if (n && (n.nodeName == utag || n.nodeName == tagName || tagName == "*")) { result[++ri] = n } } } else { if (mode == "~") { utag = tagName.toUpperCase(); for (i = 0; n = ns[i]; i++) { while ((n = n.nextSibling)) { if (n.nodeName == utag || n.nodeName == tagName || tagName == "*") { result[++ri] = n } } } } } } } return result } function concat(a, b) { a.push.apply(a, b); return a } function byTag(cs, tagName) { if (cs.tagName || cs === doc) { cs = [cs] } if (!tagName) { return cs } var result = [], ri = -1, i, ci; tagName = tagName.toLowerCase(); for (i = 0; ci = cs[i]; i++) { if (ci.nodeType == 1 && ci.tagName.toLowerCase() == tagName) { result[++ri] = ci } } return result } function byId(cs, id) { id = unescapeCssSelector(id); if (cs.tagName || cs === doc) { cs = [cs] } if (!id) { return cs } var result = [], ri = -1, i, ci; for (i = 0; ci = cs[i]; i++) { if (ci && ci.id == id) { result[++ri] = ci; return result } } return result } function byAttribute(cs, attr, value, op, custom) { var result = [], ri = -1, useGetStyle = custom == "{", fn = DQ.operators[op], a, xml, hasXml, i, ci; value = unescapeCssSelector(value); for (i = 0; ci = cs[i]; i++) { if (ci.nodeType === 1) { if (!hasXml) { xml = DQ.isXml(ci); hasXml = true } if (!xml) { if (useGetStyle) { a = DQ.getStyle(ci, attr) } else { if (attr == "class" || attr == "className") { a = ci.className } else { if (attr == "for") { a = ci.htmlFor } else { if (attr == "href") { a = ci.getAttribute("href", 2) } else { a = ci.getAttribute(attr) } } } } } else { a = ci.getAttribute(attr) } if ((fn && fn(a, value)) || (!fn && a)) { result[++ri] = ci } } } return result } function byPseudo(cs, name, value) { value = unescapeCssSelector(value); return DQ.pseudos[name](cs, value) } function nodupIEXml(cs) { var d = ++key, r, i, len, c; cs[0].setAttribute("_nodup", d); r = [cs[0]]; for (i = 1, len = cs.length; i < len; i++) { c = cs[i]; if (!c.getAttribute("_nodup") != d) { c.setAttribute("_nodup", d); r[r.length] = c } } for (i = 0, len = cs.length; i < len; i++) { cs[i].removeAttribute("_nodup") } return r } function nodup(cs) { if (!cs) { return [] } var len = cs.length, c, i, r = cs, cj, ri = -1, d, j; if (!len || typeof cs.nodeType != "undefined" || len == 1) { return cs } if (isIE && typeof cs[0].selectSingleNode != "undefined") { return nodupIEXml(cs) } d = ++key; cs[0]._nodup = d; for (i = 1; c = cs[i]; i++) { if (c._nodup != d) { c._nodup = d } else { r = []; for (j = 0; j < i; j++) { r[++ri] = cs[j] } for (j = i + 1; cj = cs[j]; j++) { if (cj._nodup != d) { cj._nodup = d; r[++ri] = cj } } return r } } return r } function quickDiffIEXml(c1, c2) { var d = ++key, r = [], i, len; for (i = 0, len = c1.length; i < len; i++) { c1[i].setAttribute("_qdiff", d) } for (i = 0, len = c2.length; i < len; i++) { if (c2[i].getAttribute("_qdiff") != d) { r[r.length] = c2[i] } } for (i = 0, len = c1.length; i < len; i++) { c1[i].removeAttribute("_qdiff") } return r } function quickDiff(c1, c2) { var len1 = c1.length, d = ++key, r = [], i, len; if (!len1) { return c2 } if (isIE && typeof c1[0].selectSingleNode != "undefined") { return quickDiffIEXml(c1, c2) } for (i = 0; i < len1; i++) { c1[i]._qdiff = d } for (i = 0, len = c2.length; i < len; i++) { if (c2[i]._qdiff != d) { r[r.length] = c2[i] } } return r } function quickId(ns, mode, root, id) { if (ns == root) { id = unescapeCssSelector(id); var d = root.ownerDocument || root; return d.getElementById(id) } ns = getNodes(ns, mode, "*"); return byId(ns, id) } return { singleton: true, alternateClassName: ["Ext.core.DomQuery", "Ext.DomQuery"], _init: function () { DQ = this; DQ.operators = Ext.Object.chain(Ext.util.Operators); DQ._cache = cache = new Ext.util.LruCache({ maxSize: 200 }); DQ._valueCache = valueCache = new Ext.util.LruCache({ maxSize: 200 }); DQ._simpleCache = simpleCache = new Ext.util.LruCache({ maxSize: 200 }) }, clearCache: function () { cache.clear(); valueCache.clear(); simpleCache.clear() }, getStyle: function (el, name) { return Ext.fly(el, "_DomQuery").getStyle(name) }, compile: function (path, type) { type = type || "select"; var fn = ["var f = function(root) {\n var mode; ++batch; var n = root || document;\n"], lastPath, matchers = DQ.matchers, matchersLn = matchers.length, modeMatch, lmode = path.match(modeRe), tokenMatch, matched, j, t, m; path = setupEscapes(path); if (lmode && lmode[1]) { fn[fn.length] = 'mode="' + lmode[1].replace(trimRe, "") + '";'; path = path.replace(lmode[1], "") } while (path.substr(0, 1) == "/") { path = path.substr(1) } while (path && lastPath != path) { lastPath = path; tokenMatch = path.match(tagTokenRe); if (type == "select") { if (tokenMatch) { if (tokenMatch[1] == "#") { fn[fn.length] = 'n = quickId(n, mode, root, "' + tokenMatch[2] + '");' } else { fn[fn.length] = 'n = getNodes(n, mode, "' + tokenMatch[2] + '");' } path = path.replace(tokenMatch[0], "") } else { if (path.substr(0, 1) != "@") { fn[fn.length] = 'n = getNodes(n, mode, "*");' } } } else { if (tokenMatch) { if (tokenMatch[1] == "#") { fn[fn.length] = 'n = byId(n, "' + tokenMatch[2] + '");' } else { fn[fn.length] = 'n = byTag(n, "' + tokenMatch[2] + '");' } path = path.replace(tokenMatch[0], "") } } while (!(modeMatch = path.match(modeRe))) { matched = false; for (j = 0; j < matchersLn; j++) { t = matchers[j]; m = path.match(t.re); if (m) { fn[fn.length] = t.select.replace(tplRe, function (x, i) { return m[i] }); path = path.replace(m[0], ""); matched = true; break } } if (!matched) { Ext.raise({ sourceClass: "Ext.DomQuery", sourceMethod: "compile", msg: 'Error parsing selector. Parsing failed at "' + path + '"' }) } } if (modeMatch[1]) { fn[fn.length] = 'mode="' + modeMatch[1].replace(trimRe, "") + '";'; path = path.replace(modeMatch[1], "") } } fn[fn.length] = "return nodup(n);\n}"; eval(fn.join("")); return f }, jsSelect: function (path, root, type) { root = root || doc; if (typeof root == "string") { root = doc.getElementById(root) } var paths = Ext.splitAndUnescape(path, ","), results = [], query, i, len, subPath, result; for (i = 0, len = paths.length; i < len; i++) { subPath = paths[i].replace(trimRe, ""); query = cache.get(subPath); if (!query) { query = DQ.compile(subPath, type); if (!query) { Ext.raise({ sourceClass: "Ext.DomQuery", sourceMethod: "jsSelect", msg: subPath + " is not a valid selector" }) } cache.add(subPath, query) } else { setupEscapes(subPath) } result = query(root); if (result && result !== doc) { results = results.concat(result) } } if (paths.length > 1) { return nodup(results) } return results }, isXml: function (el) { var docEl = (el ? el.ownerDocument || el : 0).documentElement; return docEl ? docEl.nodeName !== "HTML" : false }, select: doc.querySelectorAll ? function (path, root, type, single) { root = root || doc; if (!DQ.isXml(root)) { try { if (root.parentNode && (root.nodeType !== 9) && path.indexOf(",") === -1 && !startIdRe.test(path)) { path = Ext.makeIdSelector(Ext.id(root)) + " " + path; root = root.parentNode } return single ? [root.querySelector(path)] : Ext.Array.toArray(root.querySelectorAll(path)) } catch (e) { } } return DQ.jsSelect.call(this, path, root, type) } : function (path, root, type) { return DQ.jsSelect.call(this, path, root, type) }, selectNode: function (path, root) { return Ext.DomQuery.select(path, root, null, true)[0] }, selectValue: function (path, root, defaultValue) { path = path.replace(trimRe, ""); var query = valueCache.get(path), n, v; if (!query) { query = DQ.compile(path, "select"); valueCache.add(path, query) } else { setupEscapes(path) } n = query(root); return DQ.getNodeValue(n[0] || n, defaultValue) }, getNodeValue: function (node, defaultValue) { if (typeof node.normalize == "function") { node.normalize() } var firstChild = node && node.firstChild, v = firstChild ? firstChild.nodeValue : null; if (defaultValue !== undefined && (v == null || v === "")) { v = defaultValue } return v }, selectNumber: function (path, root, defaultValue) { var v = DQ.selectValue(path, root, defaultValue || 0); return parseFloat(v) }, is: function (el, ss) { if (typeof el == "string") { el = doc.getElementById(el) } var isArray = Ext.isArray(el), result = DQ.filter(isArray ? el : [el], ss); return isArray ? (result.length == el.length) : (result.length > 0) }, filter: function (els, ss, nonMatches) { ss = ss.replace(trimRe, ""); var query = simpleCache.get(ss), result; if (!query) { query = DQ.compile(ss, "simple"); simpleCache.add(ss, query) } else { setupEscapes(ss) } result = query(els); return nonMatches ? quickDiff(result, els) : result }, matchers: [{ re: /^\.([\w\-\\]+)/, select: useClassList ? 'n = byClassName(n, "{1}");' : 'n = byClassName(n, " {1} ");' }, { re: /^\:([\w\-]+)(?:\(((?:[^\s>\/]*|.*?))\))?/, select: 'n = byPseudo(n, "{1}", "{2}");' }, { re: /^(?:([\[\{])(?:@)?([\w\-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]\}])/, select: 'n = byAttribute(n, "{2}", "{4}", "{3}", "{1}");' }, { re: /^#([\w\-\\]+)/, select: 'n = byId(n, "{1}");' }, { re: /^@([\w\-\.]+)/, select: 'return {firstChild:{nodeValue:attrValue(n, "{1}")}};' }], pseudos: { "first-child": function (c) { var r = [], ri = -1, n, i, ci; for (i = 0; (ci = n = c[i]); i++) { while ((n = n.previousSibling) && n.nodeType != 1) { } if (!n) { r[++ri] = ci } } return r }, "last-child": function (c) { var r = [], ri = -1, n, i, ci; for (i = 0; (ci = n = c[i]); i++) { while ((n = n.nextSibling) && n.nodeType != 1) { } if (!n) { r[++ri] = ci } } return r }, "nth-child": function (c, a) { var r = [], ri = -1, m = nthRe.exec(a == "even" && "2n" || a == "odd" && "2n+1" || !nthRe2.test(a) && "n+" + a || a), f = (m[1] || 1) - 0, l = m[2] - 0, i, n, j, cn, pn; for (i = 0; n = c[i]; i++) { pn = n.parentNode; if (batch != pn._batch) { j = 0; for (cn = pn.firstChild; cn; cn = cn.nextSibling) { if (cn.nodeType == 1) { cn.nodeIndex = ++j } } pn._batch = batch } if (f == 1) { if (l === 0 || n.nodeIndex == l) { r[++ri] = n } } else { if ((n.nodeIndex + l) % f === 0) { r[++ri] = n } } } return r }, "only-child": function (c) { var r = [], ri = -1, i, ci; for (i = 0; ci = c[i]; i++) { if (!prev(ci) && !next(ci)) { r[++ri] = ci } } return r }, empty: function (c) { var r = [], ri = -1, i, ci, cns, j, cn, empty; for (i = 0; ci = c[i]; i++) { cns = ci.childNodes; j = 0; empty = true; while (cn = cns[j]) { ++j; if (cn.nodeType == 1 || cn.nodeType == 3) { empty = false; break } } if (empty) { r[++ri] = ci } } return r }, contains: function (c, v) { var r = [], ri = -1, i, ci; for (i = 0; ci = c[i]; i++) { if ((ci.textContent || ci.innerText || ci.text || "").indexOf(v) != -1) { r[++ri] = ci } } return r }, nodeValue: function (c, v) { var r = [], ri = -1, i, ci; for (i = 0; ci = c[i]; i++) { if (ci.firstChild && ci.firstChild.nodeValue == v) { r[++ri] = ci } } return r }, checked: function (c) { var r = [], ri = -1, i, ci; for (i = 0; ci = c[i]; i++) { if (ci.checked === true) { r[++ri] = ci } } return r }, not: function (c, ss) { return DQ.filter(c, ss, true) }, any: function (c, selectors) { var ss = selectors.split("|"), r = [], ri = -1, s, i, ci, j; for (i = 0; ci = c[i]; i++) { for (j = 0; s = ss[j]; j++) { if (DQ.is(ci, s)) { r[++ri] = ci; break } } } return r }, odd: function (c) { return this["nth-child"](c, "odd") }, even: function (c) { return this["nth-child"](c, "even") }, nth: function (c, a) { return c[a - 1] || [] }, first: function (c) { return c[0] || [] }, last: function (c) { return c[c.length - 1] || [] }, has: function (c, ss) { var s = DQ.select, r = [], ri = -1, i, ci; for (i = 0; ci = c[i]; i++) { if (s(ss, ci).length > 0) { r[++ri] = ci } } return r }, next: function (c, ss) { var is = DQ.is, r = [], ri = -1, i, ci, n; for (i = 0; ci = c[i]; i++) { n = next(ci); if (n && is(n, ss)) { r[++ri] = ci } } return r }, prev: function (c, ss) { var is = DQ.is, r = [], ri = -1, i, ci, n; for (i = 0; ci = c[i]; i++) { n = prev(ci); if (n && is(n, ss)) { r[++ri] = ci } } return r }, focusable: function (candidates) { var len = candidates.length, results = [], i = 0, c; for (; i < len; i++) { c = candidates[i]; if (Ext.fly(c, "_DomQuery").isFocusable()) { results.push(c) } } return results }, visible: function (candidates, deep) { var len = candidates.length, results = [], i = 0, c; for (; i < len; i++) { c = candidates[i]; if (Ext.fly(c, "_DomQuery").isVisible(deep)) { results.push(c) } } return results }, isScrolled: function (c) { var r = [], ri = -1, i, ci, s; for (i = 0; ci = c[i]; i++) { s = Ext.fly(ci, "_DomQuery").getScroll(); if (s.top > 0 || s.left > 0) { r[++ri] = ci } } return r } } } }, 0, 0, 0, 0, 0, 0, [Ext.dom, "Query", Ext.core, "DomQuery", Ext, "DomQuery"], function () { this._init() })); (Ext.cmd.derive("Ext.data.reader.Xml", Ext.data.reader.Reader, { alternateClassName: "Ext.data.XmlReader", config: { record: "", namespace: "" }, createAccessor: function (a) { if (Ext.isEmpty(a)) { return Ext.emptyFn } if (Ext.isFunction(a)) { return a } return function (b) { return this.getNodeValue(Ext.DomQuery.selectNode(a, b)) } }, getNodeValue: function (a) { if (a) { if (typeof a.normalize === "function") { a.normalize() } a = a.firstChild; if (a) { return a.nodeValue } } return undefined }, getResponseData: function (a) { var c = a.responseXML, b = "XML data not found in the response"; if (!c) { Ext.Logger.warn(b); return this.createReadError(b) } return c }, getData: function (a) { return a.documentElement || a }, getRoot: function (b) { var c = b.nodeName, a = this.getRootProperty(); if (!a || (c && c == a)) { return b } else { if (Ext.DomQuery.isXml(b)) { return Ext.DomQuery.selectNode(a, b) } } }, extractData: function (a, b) { var c = this.getRecord(); if (c !== a.nodeName) { a = Ext.DomQuery.select(c, a) } else { a = [a] } return Ext.data.reader.Reader.prototype.extractData.call(this, a, b) }, readRecords: function (c, b, a) { if (Ext.isArray(c)) { c = c[0] } return Ext.data.reader.Reader.prototype.readRecords.call(this, c, b, a) }, createFieldAccessor: function (e) { var d = this, c = d.getNamespace(), b, a; b = e.mapping || ((c ? c + "|" : "") + e.name); if (typeof b === "function") { a = function (g) { return e.mapping(g, d) } } else { a = function (g) { return d.getNodeValue(Ext.DomQuery.selectNode(b, g)) } } return a }, deprecated: { "5.1.1": { properties: { xmlData: null } } } }, 0, 0, 0, 0, ["reader.xml"], 0, [Ext.data.reader, "Xml", Ext.data, "XmlReader"], 0)); (Ext.cmd.derive("Ext.data.writer.Xml", Ext.data.writer.Writer, { alternateClassName: "Ext.data.XmlWriter", config: { documentRoot: "xmlData", defaultDocumentRoot: "xmlData", header: "", record: "record" }, selectorRe: /[^>\s]+/g, writeRecords: function (b, c) { var j = this, g = [], d = 0, h = c.length, l = j.getDocumentRoot(), k = j.getRecord(), e = k.match(this.selectorRe), m = e.length, n = c.length !== 1 && m === 1, a; a = this.getTransform(); if (a) { c = a(c, b) } g.push(j.getHeader() || ""); if (!l && n) { l = j.getDefaultDocumentRoot() } if (l) { g.push("<", l, ">") } for (d = 0; d < m - 1; d++) { g.push("<", e[d], ">") } k = e[d]; for (d = 0; d < h; ++d) { this.objectToElement(k, c[d], g) } for (d = m - 2; d > -1; d--) { g.push("</", e[d], ">") } if (l) { g.push("</", l, ">") } b.setXmlData(g.join("")); return b }, objectToElement: function (b, e, g) { var p, m, h = [], d, c, k, j, l, a, n; if (!g) { g = [] } g.push("<", b); for (p in e) { m = e[p]; if (p[0] === "@") { g.push(" ", p.substr(1), '="', m, '"') } else { if (typeof m === "object") { this.objectToElement(p, m, h) } else { d = p.match(this.selectorRe); if ((c = d.length) > 1) { l = l || {}; for (j = l, k = 0; k < c; k++) { a = j; n = d[k]; j = j[n] || (j[n] = {}) } a[n] = m } else { h.push("<", p, ">", m, "</", p, ">") } } } } g.push(">"); g.push.apply(g, h); if (l) { for (p in l) { m = l[p]; this.objectToElement(p, m, g) } } g.push("</", b, ">"); return g } }, 0, 0, 0, 0, ["writer.xml"], 0, [Ext.data.writer, "Xml", Ext.data, "XmlWriter"], 0)); (Ext.cmd.derive("Ext.data.XmlStore", Ext.data.Store, { constructor: function (a) { a = Ext.apply({ proxy: { type: "ajax", reader: "xml", writer: "xml" } }, a); Ext.data.Store.prototype.constructor.call(this, a) } }, 1, 0, 0, 0, ["store.xml"], 0, [Ext.data, "XmlStore"], 0)); (Ext.cmd.derive("Ext.data.identifier.Negative", Ext.data.identifier.Sequential, { config: { increment: -1, seed: -1 } }, 0, 0, 0, 0, ["data.identifier.negative"], 0, [Ext.data.identifier, "Negative"], 0)); (Ext.cmd.derive("Ext.data.identifier.Uuid", Ext.data.identifier.Generator, { isUnique: true, config: { id: null }, constructor: function (a) { Ext.data.identifier.Generator.prototype.constructor.call(this, a); this.reconfigure(a) }, reconfigure: function (b) { var a = this.self; this.generate = (b && b.version === 1) ? a.createSequential(b.salt, b.timestamp, b.clockSeq) : a.createRandom() }, clone: null, statics: { createRandom: function () { var c = "xxxxxxxx-xxxx-4xxx-Rxxx-xMxxxxxxxxxx".split(""), b = "0123456789abcdef".split(""), a = c.length, d = []; return function () { for (var g, h, e = 0; e < a; ++e) { h = c[e]; if (h !== "-" && h !== "4") { g = Math.random() * 16; g = (h === "R") ? (g & 3 | 8) : (g | ((h === "M") ? 1 : 0)); h = b[g] } d[e] = h } return d.join("") } }, createSequential: function (h, b, e) { var g = [], k = Math.pow(2, 32), i = h.lo, c = h.hi, j = b.lo, d = b.hi, a = function (n, m) { var l = n.toString(16).toLowerCase(); if (l.length > m) { l = l.substring(l.length - m) } else { if (l.length < m) { l = Ext.String.leftPad(l, m, "0") } } return l }; if (typeof h === "number") { c = Math.floor(h / k); i = Math.floor(h - c * k) } if (typeof b === "number") { d = Math.floor(b / k); j = Math.floor(b - d * k) } c |= 256; g[3] = a(128 | ((e >>> 8) & 63), 2) + a(e & 255, 2); g[4] = a(c, 4) + a(i, 8); return function () { g[0] = a(j, 8); g[1] = a(d & 65535, 4); g[2] = a(((d >>> 16) & 4095) | (1 << 12), 4); ++j; if (j >= k) { j = 0; ++d } return g.join("-") } } } }, 1, 0, 0, 0, ["data.identifier.uuid"], 0, [Ext.data.identifier, "Uuid"], function () { this.Global = new this({ id: "uuid" }) })); (Ext.cmd.derive("Ext.data.proxy.WebStorage", Ext.data.proxy.Client, { alternateClassName: "Ext.data.WebStorageProxy", config: { id: undefined }, constructor: function (a) { Ext.data.proxy.Client.prototype.constructor.apply(this, arguments); this.cache = {}; this.initialize() }, create: function (e) { var k = this, d = e.getRecords(), c = d.length, a = k.getIds(), b, h, g, j; if (k.isHierarchical === undefined) { k.isHierarchical = !!d[0].isNode; if (k.isHierarchical) { k.getStorageObject().setItem(k.getTreeKey(), true) } } for (g = 0; g < c; g++) { h = d[g]; if (h.phantom) { h.phantom = false; j = h.identifier; if (j && j.isUnique) { b = h.getId() } else { b = k.getNextId() } } else { b = h.getId() } k.setRecord(h, b); h.commit(); a.push(b) } k.setIds(a); e.setSuccessful(true) }, read: function (k) { var v = this, u, r = [], d = true, h = v.getModel(), e = 0, t = k.getRecordCreator(), g, a, s, n, m, b, o, c, w, l, q, p; if (v.isHierarchical) { r = v.getTreeData() } else { o = v.getIds(); c = o.length; l = k.getId(); if (l) { w = v.getRecord(l); if (w !== null) { b = t ? t(w, h) : new h(w) } if (b) { r.push(b) } else { d = false } } else { a = k.getSorters(); g = k.getFilters(); s = k.getLimit(); u = []; for (q = 0; q < c; q++) { w = v.getRecord(o[q]); b = t ? t(w, h) : new h(w); u.push(b) } if (a) { Ext.Array.sort(u, Ext.util.Sorter.createComparator(a)) } for (q = k.getStart() || 0; q < c; q++) { b = u[q]; m = true; if (g) { for (p = 0, n = g.length; p < n; p++) { m = g[p].filter(b) } } if (m) { r.push(b); e++ } if (s && e === s) { break } } } } if (d) { k.setResultSet(new Ext.data.ResultSet({ records: r, total: r.length, loaded: true })); k.setSuccessful(true) } else { k.setException("Unable to load records") } }, update: function (c) { var b = c.getRecords(), g = b.length, e = this.getIds(), a, h, d; for (d = 0; d < g; d++) { a = b[d]; this.setRecord(a); a.commit(); h = a.getId(); if (h !== undefined && Ext.Array.indexOf(e, h) === -1) { e.push(h) } } this.setIds(e); c.setSuccessful(true) }, erase: function (d) { var g = this, c = d.getRecords(), a = g.getIds(), h = a.length, k = [], j = {}, e = c.length, b; for (; e--;) { Ext.apply(j, g.removeRecord(c[e])) } for (e = 0; e < h; e++) { b = a[e]; if (!j[b]) { k.push(b) } } g.setIds(k); d.setSuccessful(true) }, getRecord: function (d) { var b = this, a = b.cache, c = !a[d] ? Ext.decode(b.getStorageObject().getItem(b.getRecordKey(d))) : a[d]; if (!c) { return null } a[d] = c; c[b.getModel().prototype.idProperty] = d; return Ext.merge({}, c) }, setRecord: function (k, c) { if (c) { k.set("id", c, { commit: true }) } else { c = k.getId() } var m = this, a = k.getData(), h = {}, j = m.getModel(), l = j.getFields(), d = l.length, g = 0, n, b, e, p, o; for (; g < d; g++) { n = l[g]; b = n.name; if (n.persist) { o = a[b]; if (n.isDateField && n.dateFormat && Ext.isDate(o)) { o = Ext.Date.format(o, n.dateFormat) } else { if (n.serialize) { o = n.serialize(o, k) } } h[b] = o } } delete h[j.prototype.idProperty]; if (k.isNode && k.get("depth") === 1) { delete h.parentId } e = m.getStorageObject(); p = m.getRecordKey(c); m.cache[c] = h; e.removeItem(p); e.setItem(p, Ext.encode(h)) }, removeRecord: function (a) { var d = this, g = a.getId(), b = {}, c, e; b[g] = a; d.getStorageObject().removeItem(d.getRecordKey(g)); delete d.cache[g]; if (a.childNodes) { e = a.childNodes; for (c = e.length; c--;) { Ext.apply(b, d.removeRecord(e[c])) } } return b }, getRecordKey: function (a) { if (a.isModel) { a = a.getId() } return Ext.String.format("{0}-{1}", this.getId(), a) }, getRecordCounterKey: function () { return Ext.String.format("{0}-counter", this.getId()) }, getTreeKey: function () { return Ext.String.format("{0}-tree", this.getId()) }, getIds: function () { var e = this, c = (e.getStorageObject().getItem(e.getId()) || "").split(","), d = c.length, a = this.getIdField().isStringField, b; if (d === 1 && c[0] === "") { c = [] } else { for (b = 0; b < d; b++) { c[b] = a ? c[b] : +c[b] } } return c }, getIdField: function () { return this.getModel().prototype.idField }, setIds: function (a) { var b = this.getStorageObject(), c = a.join(","), d = this.getId(); b.removeItem(d); if (!Ext.isEmpty(c)) { b.setItem(d, c) } }, getNextId: function () { var c = this, d = c.getStorageObject(), b = c.getRecordCounterKey(), a = c.getIdField().isStringField, e; e = c.idGenerator.generate(); d.setItem(b, e); if (a) { e = e + "" } return e }, getTreeData: function () { var n = this, a = n.getIds(), e = a.length, j = [], b = {}, o = [], k = 0, h = n.getModel(), q = h.prototype.idProperty, g, m, p, l, d, c; for (; k < e; k++) { c = a[k]; m = n.getRecord(c); j.push(m); b[c] = m; if (!m.parentId) { o.push(m) } } g = o.length; Ext.Array.sort(j, n.sortByParentId); for (k = g; k < e; k++) { m = j[k]; l = m.parentId; if (!p || p[q] !== l) { p = b[l]; p.children = d = [] } d.push(m) } for (k = e; k--;) { m = j[k]; if (!m.children && !m.leaf) { m.loaded = true } } for (k = g; k--;) { m = o[k]; o[k] = new h(m) } return o }, sortByParentId: function (b, a) { return (b.parentId || 0) - (a.parentId || 0) }, initialize: function () { var b = this, a = b.getStorageObject(), c = +a.getItem(b.getRecordCounterKey()), d = b.getId(); a.setItem(d, a.getItem(d) || ""); if (a.getItem(b.getTreeKey())) { b.isHierarchical = true } b.idGenerator = new Ext.data.identifier.Sequential({ seed: c ? c + 1 : 1 }) }, clear: function () { var d = this, e = d.getStorageObject(), c = d.getIds(), a = c.length, b; for (b = 0; b < a; b++) { e.removeItem(d.getRecordKey(c[b])) } e.removeItem(d.getRecordCounterKey()); e.removeItem(d.getTreeKey()); e.removeItem(d.getId()); d.cache = {} }, getStorageObject: function () { } }, 1, 0, 0, 0, 0, 0, [Ext.data.proxy, "WebStorage", Ext.data, "WebStorageProxy"], 0)); (Ext.cmd.derive("Ext.data.proxy.LocalStorage", Ext.data.proxy.WebStorage, { alternateClassName: "Ext.data.LocalStorageProxy", getStorageObject: function () { return window.localStorage } }, 0, 0, 0, 0, ["proxy.localstorage"], 0, [Ext.data.proxy, "LocalStorage", Ext.data, "LocalStorageProxy"], 0)); (Ext.cmd.derive("Ext.data.proxy.Rest", Ext.data.proxy.Ajax, { alternateClassName: "Ext.data.RestProxy", defaultActionMethods: { create: "POST", read: "GET", update: "PUT", destroy: "DELETE" }, slashRe: /\/$/, periodRe: /\.$/, config: { appendId: true, format: null, batchActions: false, actionMethods: { create: "POST", read: "GET", update: "PUT", destroy: "DELETE" } }, buildUrl: function (g) { var i = this, e = g.getOperation(), c = e.getRecords(), h = c ? c[0] : null, j = i.getFormat(), a = i.getUrl(g), b, d; if (h && !h.phantom) { b = h.getId() } else { b = e.getId() } if (i.getAppendId() && i.isValidId(b)) { if (!a.match(i.slashRe)) { a += "/" } a += encodeURIComponent(b); d = g.getParams(); if (d) { delete d[i.getIdParam()] } } if (j) { if (!a.match(i.periodRe)) { a += "." } a += j } g.setUrl(a); return Ext.data.proxy.Ajax.prototype.buildUrl.call(this, g) }, isValidId: function (a) { return a || a === 0 } }, 0, 0, 0, 0, ["proxy.rest"], 0, [Ext.data.proxy, "Rest", Ext.data, "RestProxy"], 0)); (Ext.cmd.derive("Ext.data.proxy.SessionStorage", Ext.data.proxy.WebStorage, { alternateClassName: "Ext.data.SessionStorageProxy", getStorageObject: function () { return window.sessionStorage } }, 0, 0, 0, 0, ["proxy.sessionstorage"], 0, [Ext.data.proxy, "SessionStorage", Ext.data, "SessionStorageProxy"], 0)); (Ext.cmd.derive("Ext.data.validator.Bound", Ext.data.validator.Validator, { type: "bound", config: { min: undefined, max: undefined, emptyMessage: "Must be present", minOnlyMessage: null, maxOnlyMessage: null, bothOnlyMessage: null }, constructor: function () { var a = this; a.preventConfigure = true; Ext.data.validator.Validator.prototype.constructor.apply(this, arguments); delete a.preventConfigure; a.configure() }, setConfig: function () { var a = this; a.preventConfigure = true; a.callParent(arguments); delete a.preventConfigure; a.configure() }, configure: function () { var d = this, b, e, c, a; if (d.preventConfigure) { return } c = d.getMin(); a = d.getMax(); b = d.hasMin = c !== undefined; e = d.hasMax = a !== undefined; if (b && e) { d._bothMsg = Ext.String.format(d.getBothMessage(), c, a) } else { if (b) { d._minMsg = Ext.String.format(d.getMinOnlyMessage(), c) } else { if (e) { d._maxMsg = Ext.String.format(d.getMaxOnlyMessage(), a) } } } }, updateMin: function () { this.configure() }, updateMax: function () { this.configure() }, updateMinOnlyMessage: function (a) { this.configure() }, updateMaxOnlyMessage: function () { this.configure() }, updateBothMessage: function () { this.configure() }, validate: function (g) { var e = this, c = e.hasMin, i = e.hasMax, d = e.getMin(), b = e.getMax(), h = this.validateValue(g), a; if (h !== true) { return h } g = e.getValue(g); if (c && i) { if (g < d || g > b) { h = e._bothMsg } } else { if (c) { if (g < d) { h = e._minMsg } } else { if (i) { if (g > b) { h = e._maxMsg } } } } return h }, validateValue: function (a) { if (a === undefined || a === null) { return this.getEmptyMessage() } return true }, getValue: Ext.identityFn }, 1, 0, 0, 0, ["data.validator.bound"], 0, [Ext.data.validator, "Bound"], 0)); (Ext.cmd.derive("Ext.data.validator.Format", Ext.data.validator.Validator, { type: "format", config: { message: "Is in the wrong format", matcher: undefined }, validate: function (b) { var c = this.getMatcher(), a = c && c.test(b); return a ? a : this.getMessage() } }, 0, 0, 0, 0, ["data.validator.format"], 0, [Ext.data.validator, "Format"], 0)); (Ext.cmd.derive("Ext.data.validator.Email", Ext.data.validator.Format, { type: "email", config: { message: "Is not a valid email address", matcher: /^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+\/=?\^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/ } }, 0, 0, 0, 0, ["data.validator.email"], 0, [Ext.data.validator, "Email"], 0)); (Ext.cmd.derive("Ext.data.validator.List", Ext.data.validator.Validator, { type: "list", config: { list: null }, inclusion: null, validate: function (c) { var b = Ext.Array.contains(this.getList(), c), e = this.inclusion, d = !e, a; a = (e && b) || (d && !b); return a || this.getMessage() } }, 0, 0, 0, 0, ["data.validator.list"], 0, [Ext.data.validator, "List"], 0)); (Ext.cmd.derive("Ext.data.validator.Exclusion", Ext.data.validator.List, { type: "exclusion", config: { message: "Is a value that has been excluded" }, inclusion: false }, 0, 0, 0, 0, ["data.validator.exclusion"], 0, [Ext.data.validator, "Exclusion"], 0)); (Ext.cmd.derive("Ext.data.validator.Inclusion", Ext.data.validator.List, { type: "inclusion", config: { message: "Is not in the list of acceptable values" }, inclusion: true }, 0, 0, 0, 0, ["data.validator.inclusion"], 0, [Ext.data.validator, "Inclusion"], 0)); (Ext.cmd.derive("Ext.data.validator.Length", Ext.data.validator.Bound, { type: "length", config: { minOnlyMessage: "Length must be at least {0}", maxOnlyMessage: "Length must be no more than {0}", bothMessage: "Length must be between {0} and {1}" }, getValue: function (a) { return String(a).length } }, 0, 0, 0, 0, ["data.validator.length"], 0, [Ext.data.validator, "Length"], 0)); (Ext.cmd.derive("Ext.data.validator.Presence", Ext.data.validator.Validator, { type: "presence", config: { message: "Must be present", allowEmpty: false }, validate: function (b) { var a = !(b === undefined || b === null); if (a && !this.getAllowEmpty()) { a = !(b === "") } return a ? true : this.getMessage() } }, 0, 0, 0, 0, ["data.validator.presence"], 0, [Ext.data.validator, "Presence"], 0)); (Ext.cmd.derive("Ext.data.validator.Range", Ext.data.validator.Bound, { type: "range", config: { minOnlyMessage: "Must be must be at least {0}", maxOnlyMessage: "Must be no more than than {0}", bothMessage: "Must be between {0} and {1}", nanMessage: "Must be numeric" }, validateValue: function (a) { var b = Ext.data.validator.Bound.prototype.validateValue.call(this, a); if (b === true && isNaN(a)) { b = this.getNanMessage() } return b } }, 0, 0, 0, 0, ["data.validator.range"], 0, [Ext.data.validator, "Range"], 0)); (Ext.cmd.derive("Ext.direct.Event", Ext.Base, { status: true, constructor: function (a) { Ext.apply(this, a) }, getName: function () { return this.name }, getData: function () { return this.data } }, 1, 0, 0, 0, ["direct.event"], 0, [Ext.direct, "Event"], 0)); (Ext.cmd.derive("Ext.direct.RemotingEvent", Ext.direct.Event, { getTransaction: function () { var a = this; return a.transaction || Ext.direct.Manager.getTransaction(a.tid) } }, 0, 0, 0, 0, ["direct.rpc"], 0, [Ext.direct, "RemotingEvent"], 0)); (Ext.cmd.derive("Ext.direct.ExceptionEvent", Ext.direct.RemotingEvent, { status: false }, 0, 0, 0, 0, ["direct.exception"], 0, [Ext.direct, "ExceptionEvent"], 0)); (Ext.cmd.derive("Ext.direct.JsonProvider", Ext.direct.Provider, { parseResponse: function (a) { var b = a && a.responseText; if (b != null) { if (Ext.isObject(b) || Ext.isArray(b)) { return b } return Ext.decode(b) } return null }, createEvents: function (b) { var h = this, j = null, d = [], g, c, a; try { j = h.parseResponse(b) } catch (k) { g = new Ext.direct.ExceptionEvent({ parsingError: true, data: k, xhr: b, code: Ext.direct.Manager.exceptions.PARSE, message: "Error parsing json response: \n\n " + k }); return [g] } if (Ext.isArray(j)) { for (c = 0, a = j.length; c < a; ++c) { d.push(h.createEvent(j[c])) } } else { if (Ext.isObject(j)) { d.push(h.createEvent(j)) } } return d }, createEvent: function (a) { if (typeof a !== "object" || !("type" in a)) { return new Ext.direct.ExceptionEvent({ data: a, code: Ext.direct.Manager.exceptions.DATA, message: "Invalid data: event type is not specified" }) } return Ext.create("direct." + a.type, a) } }, 0, 0, 0, 0, ["direct.jsonprovider"], 0, [Ext.direct, "JsonProvider"], 0)); (Ext.cmd.derive("Ext.direct.PollingProvider", Ext.direct.JsonProvider, { type: "polling", interval: 3000, constructor: function (a) { var b = this; Ext.direct.JsonProvider.prototype.constructor.call(this, a); b.pollTask = Ext.TaskManager.newTask({ run: b.runPoll, interval: b.interval, scope: b }) }, destroy: function () { this.pollTask = null; Ext.direct.JsonProvider.prototype.destroy.call(this) }, doConnect: function () { var c = this, a = c.url, b = c.pollFn; if (b && Ext.isString(b)) { c.pollFn = b = Ext.direct.Manager.parseMethod(b) } else { if (Ext.isFunction(a)) { c.pollFn = b = a; c.url = a = null } } if (a || b) { c.setInterval(c.interval); c.pollTask.start() } }, doDisconnect: function () { if (this.pollTask) { this.pollTask.stop() } }, getInterval: function () { return this.pollTask && this.pollTask.interval }, setInterval: function (a) { var b = this, c = b.pollTask; b.interval = c.interval = a; if (b.isConnected()) { c.restart(a) } }, runPoll: function () { var e = this, b = e.url, c = e.pollFn, g = e.baseParams, a, d; if (e.fireEvent("beforepoll", e) !== false) { if (c) { a = c.directCfg.method.getArgs({ params: g !== undefined ? g : {}, callback: e.onPollFn, scope: e }); c.apply(window, a) } else { d = { url: b, callback: e.onData, scope: e, params: g, headers: e.getHeaders() }; if (e.timeout != null) { d.timeout = e.timeout } e.sendAjaxRequest(d) } e.fireEvent("poll", e) } }, onData: function (e, j, b) { var h = this, d, a, c, g; if (j) { c = h.createEvents(b); for (d = 0, a = c.length; d < a; ++d) { g = c[d]; h.fireEvent("data", h, g); if (!g.status) { h.fireEvent("exception", h, g) } } } else { g = new Ext.direct.ExceptionEvent({ data: null, code: Ext.direct.Manager.exceptions.TRANSPORT, message: "Unable to connect to the server.", xhr: b }); h.fireEvent("data", h, g); h.fireEvent("exception", h, g) } Ext.direct.JsonProvider.prototype.onData.call(this, e, j, b) }, onPollFn: function (a, c, d, b) { this.onData(null, d, { responseText: a }) }, inheritableStatics: { checkConfig: function (a) { return a && a.type === "polling" && (a.url || a.pollFn) } } }, 1, 0, 0, 0, ["direct.pollingprovider"], 0, [Ext.direct, "PollingProvider"], 0)); (Ext.cmd.derive("Ext.direct.RemotingMethod", Ext.Base, { constructor: function (c) { var i = this, e = c.params, h = c.len, k = c.metadata, j = {}, a, g, b, d; i.name = c.name; i.disableBatching = c.batched != null ? !c.batched : false; if (c.formHandler) { i.formHandler = c.formHandler } else { if (Ext.isNumeric(h)) { i.len = h; i.ordered = true } else { i.named = true; i.strict = c.strict !== undefined ? c.strict : true; i.params = {}; g = e && e.length; for (b = 0; b < g; b++) { d = e[b]; a = Ext.isObject(d) ? d.name : d; i.params[a] = true } } } if (k) { e = k.params; h = k.len; if (Ext.isNumeric(h)) { j.ordered = true; j.len = h } else { if (Ext.isArray(e)) { j.named = true; j.params = {}; for (b = 0, g = e.length; b < g; b++) { d = e[b]; j.params[d] = true } j.strict = k.strict !== undefined ? k.strict : true } } i.metadata = j } }, getArgs: function (b) { var h = this, c = b.params, j = b.paramOrder, l = b.paramsAsArray, k = b.metadata, m = b.options, g = [], a, d, e; if (h.ordered) { if (h.len > 0) { if (j) { a = b.paramsAsArray && h.len === 1 && (j.length > 1 || Ext.isArray(c)); if (a) { if (Ext.isArray(c)) { for (d = 0, e = c.length; d < e; d++) { g.push(h.convertParams(c[d], j, j.length, true)) } } else { g = h.convertParams(c, j, j.length, true) } if (!c.allowSingle || g.length > 1) { g = [g] } } else { g = h.convertParams(c, j, h.len, false) } } else { g.push(c) } } } else { g.push(c) } g.push(b.callback, b.scope || window); if (m || k) { m = Ext.apply({}, m); if (k) { m.metadata = k } g.push(m) } return g }, convertParams: function (h, b, e, j) { var c = [], g, d, a; for (d = 0, a = e; d < a; d++) { g = b[d]; c.push(h[g]) } if (j) { return c.length === 0 ? undefined : c.length === 1 ? c[0] : c } else { return c } }, getCallData: function (g) { var h = this, d = null, e = h.len, c = h.params, j = h.strict, b, k, l, a, m, i; if (h.ordered) { k = g[e]; l = g[e + 1]; m = g[e + 2]; if (e !== 0) { d = g.slice(0, e) } } else { if (h.formHandler) { b = g[0]; k = g[1]; l = g[2]; m = g[3] } else { d = Ext.apply({}, g[0]); k = g[1]; l = g[2]; m = g[3]; if (j) { for (a in d) { if (d.hasOwnProperty(a) && !c[a]) { delete d[a] } } } } } if (h.metadata && m && m.metadata) { if (h.metadata.ordered) { i = m.metadata.slice(0, h.metadata.len) } else { i = Ext.apply({}, m.metadata); if (h.metadata.strict) { for (a in i) { if (i.hasOwnProperty(a) && !h.metadata.params[a]) { delete i[a] } } } } delete m.metadata } return { form: b, data: d, metadata: i, callback: k, scope: l, options: m } } }, 1, 0, 0, 0, 0, 0, [Ext.direct, "RemotingMethod"], 0)); (Ext.cmd.derive("Ext.direct.Transaction", Ext.Base, { statics: { TRANSACTION_ID: 0 }, constructor: function (a) { var b = this; Ext.apply(b, a); b.id = b.tid = ++b.self.TRANSACTION_ID; b.retryCount = 0 }, send: function () { var a = this; a.provider.queueTransaction(a) }, retry: function () { var a = this; a.retryCount++; a.send() }, getProvider: function () { return this.provider } }, 1, 0, 0, 0, ["direct.transaction"], 0, [Ext.direct, "Transaction"], 0)); (Ext.cmd.derive("Ext.direct.RemotingProvider", Ext.direct.JsonProvider, { type: "remoting", enableBuffer: 10, bufferLimit: Number.MAX_VALUE, maxRetries: 1, constructor: function (a) { var b = this; Ext.direct.JsonProvider.prototype.constructor.call(this, a); b.namespace = (Ext.isString(b.namespace)) ? Ext.ns(b.namespace) : b.namespace || Ext.global; b.callBuffer = [] }, connect: function () { var a = this; Ext.direct.JsonProvider.prototype.connect.call(this) }, doConnect: function () { if (!this.apiCreated) { this.initAPI(); this.apiCreated = true } }, getNamespace: function (b, e) { var g, d, c, a; b = b || Ext.global; g = e.toString().split("."); for (c = 0, a = g.length; c < a; c++) { d = g[c]; b = b[d]; if (typeof b === "undefined") { return b } } return b }, createNamespaces: function (b, e) { var g, d, c, a; b = b || Ext.global; g = e.toString().split("."); for (c = 0, a = g.length; c < a; c++) { d = g[c]; b[d] = b[d] || {}; b = b[d] } return b }, initAPI: function () { var k = this, g = k.actions, d = k.namespace, b = Ext.direct.Manager, e, m, c, h, j, a, l; for (e in g) { if (g.hasOwnProperty(e)) { if (k.disableNestedActions) { m = d[e]; if (!m) { m = d[e] = {} } } else { m = k.getNamespace(d, e); if (!m) { m = k.createNamespaces(d, e) } } c = g[e]; for (h = 0, j = c.length; h < j; ++h) { a = new Ext.direct.RemotingMethod(c[h]); m[a.name] = l = k.createHandler(e, a); b.registerMethod(l.$name, l) } } } }, createHandler: function (c, d) { var b = this, a; a = function () { b.invokeFunction(c, d, Array.prototype.slice.call(arguments, 0)) }; a.name = a.$name = c + "." + d.name; a.$directFn = true; a.directCfg = a.$directCfg = { action: c, method: d }; return a }, invokeFunction: function (e, i, b) { var d = this, g, c, a, h; g = d.configureTransaction(e, i, b); if (d.fireEvent("beforecall", d, g, i) !== false) { Ext.direct.Manager.addTransaction(g); if (g.isForm) { c = g.form; a = String(c.getAttribute("enctype")).toLowerCase() === "multipart/form-data"; h = { extTID: g.id, extAction: e, extMethod: i.name, extType: "rpc", extUpload: String(a) }; if (g.metadata) { h.extMetadata = Ext.JSON.encode(g.metadata) } Ext.apply(g, { form: c, isUpload: a, params: h }) } d.queueTransaction(g); d.fireEvent("call", d, g, i) } }, configureTransaction: function (g, i, c) { var e, a, d, b, h; e = i.getCallData(c); a = e.callback; d = e.scope; b = e.options; a = a && d ? Ext.Function.bind(a, d) : a; h = Ext.apply({}, { provider: this, args: c, action: g, method: i.name, form: e.form, data: e.data, metadata: e.metadata, callbackOptions: b, callback: a, isForm: !!i.formHandler, disableBatching: i.disableBatching }); if (b && b.timeout != null) { h.timeout = b.timeout } return new Ext.direct.Transaction(h) }, queueTransaction: function (d) { var c = this, b = c.callBuffer, a = c.enableBuffer; if (d.isForm || a === false || d.disableBatching || d.timeout != null) { c.sendTransaction(d); return } b.push(d); if (a && b.length < c.bufferLimit) { if (!c.callTask) { c.callTask = new Ext.util.DelayedTask(c.combineAndSend, c) } c.callTask.delay(Ext.isNumber(a) ? a : 10) } else { c.combineAndSend() } }, combineAndSend: function () { var c = this, b = c.callBuffer, a = b.length; if (a > 0) { c.sendTransaction(a === 1 ? b[0] : b); c.callBuffer = [] } }, sendTransaction: function (a) { var h = this, d, b, c, k = h.enableUrlEncode, j, e, g; d = { url: h.url, callback: h.onData, scope: h, transaction: a, headers: h.getHeaders() }; if (a.timeout != null) { d.timeout = a.timeout } else { if (h.timeout != null) { d.timeout = h.timeout } } if (a.isForm) { Ext.apply(d, { params: a.params, form: a.form, isUpload: a.isUpload }) } else { if (Ext.isArray(a)) { b = []; for (e = 0, g = a.length; e < g; ++e) { j = h.getPayload(a[e]); b.push(j) } } else { b = h.getPayload(a) } if (k) { c = {}; c[Ext.isString(k) ? k : "data"] = Ext.encode(b); d.params = c } else { d.jsonData = b } } return h.sendAjaxRequest(d) }, getPayload: function (b) { var a = { action: b.action, method: b.method, data: b.data, type: "rpc", tid: b.id }; if (b.metadata) { a.metadata = b.metadata } return a }, onData: function (l, j, c) { var g = this, d, e, k, a, b, h; k = j && g.createEvents(c); j = k && k.length && !k[0].parsingError; if (j) { for (d = 0, e = k.length; d < e; ++d) { a = k[d]; g.fireEvent("data", g, a); b = g.getTransaction(a); if (b) { if (g.fireEvent("beforecallback", g, a, b) !== false) { g.runCallback(b, a, true) } Ext.direct.Manager.removeTransaction(b) } } } else { h = [].concat(l.transaction); a = k[0] || new Ext.direct.ExceptionEvent({ data: null, transaction: b, code: Ext.direct.Manager.exceptions.TRANSPORT, message: "Unable to connect to the server.", xhr: c }); for (d = 0, e = h.length; d < e; ++d) { b = g.getTransaction(h[d]); if (b && b.retryCount < g.maxRetries) { b.retry() } else { g.fireEvent("data", g, a); g.fireEvent("exception", g, a); if (b && g.fireEvent("beforecallback", g, a, b) !== false) { g.runCallback(b, a, false) } Ext.direct.Manager.removeTransaction(b) } } } Ext.direct.JsonProvider.prototype.onData.call(this, l, j, c) }, getTransaction: function (a) { return a && a.tid ? Ext.direct.Manager.getTransaction(a.tid) : null }, runCallback: function (g, c) { var e = !!c.status, d = e ? "success" : "failure", h, b, a; if (g && g.callback) { h = g.callback; b = g.callbackOptions; a = typeof c.result !== "undefined" ? c.result : c.data; if (Ext.isFunction(h)) { h(a, c, e, b) } else { Ext.callback(h[d], h.scope, [a, c, e, b]); Ext.callback(h.callback, h.scope, [a, c, e, b]) } } }, inheritableStatics: { checkConfig: function (a) { return a && a.type === "remoting" && a.url && Ext.isArray(a.actions) } } }, 1, 0, 0, 0, ["direct.remotingprovider"], 0, [Ext.direct, "RemotingProvider"], 0)); (Ext.cmd.derive("Ext.dom.GarbageCollector", Ext.Base, { singleton: true, interval: 30000, constructor: function () { var a = this; a.lastTime = Ext.now(); a.onTick = a.onTick.bind(a); a.resume() }, collect: function () { var j = this, a = Ext.cache, b, g, c, k, h, d; for (b in a) { if (!a.hasOwnProperty(b)) { continue } c = a[b]; if (c.skipGarbageCollection) { continue } g = c.dom; try { h = Ext.isGarbage(g) } catch (i) { delete a[b]; continue } if (h) { if (c && c.dom) { c.collect() } } } if (Ext.isIE9m) { k = {}; for (b in a) { if (a.hasOwnProperty(b)) { k[b] = a[b] } } Ext.cache = Ext.dom.Element.cache = k } j.lastTime = Ext.now() }, onTick: function () { this.timerId = null; if (Ext.enableGarbageCollector) { this.collect() } this.resume() }, pause: function () { var a = this.timerId; if (a) { this.timerId = null; clearTimeout(a) } }, resume: function () { var a = this, b = a.lastTime; if (Ext.enableGarbageCollector && (Ext.now() - b) > a.interval) { a.collect() } if (!a.timerId) { a.timerId = Ext.defer(a.onTick, a.interval) } } }, 1, 0, 0, 0, 0, 0, [Ext.dom, "GarbageCollector"], 0)); (Ext.cmd.derive("Ext.dom.TouchAction", Ext.Base, { singleton: true, lastTouchStartTime: 0, minMoveDistance: 8, spaceRe: /\s+/, preventSingle: null, preventMulti: null, disabledOverflowDom: null, panXCls: "x-touch-action-pan-x", panYCls: "x-touch-action-pan-y", cssValues: ["none", "pan-x", "pan-y", "pan-x pan-y", "pinch-zoom", "pan-x pinch-zoom", "pan-y pinch-zoom", "manipulation", "double-tap-zoom", "pan-x double-tap-zoom", "pan-y double-tap-zoom", "pan-x pan-y double-tap-zoom", "pinch-zoom double-tap-zoom", "pan-x pinch-zoom double-tap-zoom", "pan-y pinch-zoom double-tap-zoom", ""], objectValues: [{ panX: false, panY: false, pinchZoom: false, doubleTapZoom: false }, { panX: true, panY: false, pinchZoom: false, doubleTapZoom: false }, { panX: false, panY: true, pinchZoom: false, doubleTapZoom: false }, { panX: true, panY: true, pinchZoom: false, doubleTapZoom: false }, { panX: false, panY: false, pinchZoom: true, doubleTapZoom: false }, { panX: true, panY: false, pinchZoom: true, doubleTapZoom: false }, { panX: false, panY: true, pinchZoom: true, doubleTapZoom: false }, { panX: true, panY: true, pinchZoom: true, doubleTapZoom: false }, { panX: false, panY: false, pinchZoom: false, doubleTapZoom: true }, { panX: true, panY: false, pinchZoom: false, doubleTapZoom: true }, { panX: false, panY: true, pinchZoom: false, doubleTapZoom: true }, { panX: true, panY: true, pinchZoom: false, doubleTapZoom: true }, { panX: false, panY: false, pinchZoom: true, doubleTapZoom: true }, { panX: true, panY: false, pinchZoom: true, doubleTapZoom: true }, { panX: false, panY: true, pinchZoom: true, doubleTapZoom: true }, { panX: true, panY: true, pinchZoom: true, doubleTapZoom: true }], attributeName: "data-extTouchAction", constructor: function () { var b = this, a = Ext.supports; if (a.PointerEvents) { b.cssProp = "touch-action" } else { if (a.MSPointerEvents) { b.cssProp = "-ms-touch-action" } else { if (a.TouchEvents) { Ext.getWin().on({ touchstart: "onTouchStart", touchmove: "onTouchMove", touchend: "onTouchEnd", scope: b, translate: false, capture: true, priority: 5000 }); Ext.on({ scroll: "onScroll", scope: b, destroyable: true }) } } } }, containsTargets: function (h, g) { var b = true, d = g.type === "touchend" ? g.changedTouches : g.touches, a, c; for (a = 0, c = d.length; a < c; a++) { if (!h.contains(d[a].target)) { b = false; break } } return b }, disableOverflow: function (e, c) { var d = this, g = c ? "overflow-y" : "overflow-x", a, b; if (!d.disabledOverflowDom && !Ext.isiOS && !Ext.getScrollbarSize().width) { d.disabledOverflowDom = e; b = c ? d.panXCls : d.panYCls; while (e) { a = Ext.fly(e).getStyle(g); if (a === "auto" || a === "scroll") { Ext.fly(e).addCls(b) } e = e.parentNode } } }, get: function (c) { var a = c.getAttribute(this.attributeName), b = null; if (a != null) { b = this.objectValues[a] } return b }, getFlags: function (b) { var a; if (typeof b === "number") { a = b } else { a = 0; if (b.panX !== false) { a |= 1 } if (b.panY !== false) { a |= 2 } if (b.pinchZoom !== false) { a |= 4 } if (b.doubleTapZoom !== false) { a |= 8 } } return a }, lookupFlags: function (a) { return a.getAttribute && a.getAttribute(this.attributeName) }, onScroll: function () { this.scrollOccurred = true; this.isDoubleTap = false }, onTouchEnd: function (g) { var d = this, h = g.target, a, b, c; a = g.touches.length; if (a === 0) { if (d.isDoubleTap) { while (h) { b = d.lookupFlags(h); if (b != null) { c = b & 8; if (!c) { g.preventDefault() } } h = h.parentNode } } d.isDoubleTap = false; d.preventSingle = null; d.preventMulti = null; d.resetOverflow() } }, onTouchMove: function (l) { var m = this, o = null, j = l.target, c, n, q, p, r, b, g, a, i, h, k, d; k = m.preventSingle; d = m.preventMulti; n = l.touches.length; if ((n === 1 && (k === false)) || (d === false)) { return } if ((n > 1 && (d === true)) || (n === 1 && (k === true))) { o = true } else { while (j) { c = m.lookupFlags(j); if (c != null) { if (!c) { o = true } else { if (n === 1) { q = !!(c & 1); p = !!(c & 2); if (q && p) { o = false } else { if (!q && !p) { o = true } else { r = l.getPoint(); b = m.startPoint; g = Ext.Element.getViewportScale(); a = Math.abs(r.getDistanceTo(m.startPoint) * g); if (a >= m.minMoveDistance) { i = Math.abs(r.x - b.x); h = Math.abs(r.y - b.y); o = !!((q && (h > i)) || (p && (i > h))) } } } } else { if (m.containsTargets(j, l)) { o = !(c & 4) } else { o = false } } } if (o) { break } } j = j.parentNode } } if (n === 1) { m.preventSingle = o } else { if (n > 1) { m.preventMulti = o } } if (o) { l.preventDefault() } }, onTouchStart: function (h) { var d = this, g, c, i, b, a; if (h.touches.length === 1) { g = h.time; if (!d.scrollOccurred && ((g - d.lastTouchStartTime) <= 500)) { d.isDoubleTap = true } d.lastTouchStartTime = g; d.scrollOccurred = false; d.startPoint = h.getPoint(); i = h.target; while (i) { c = d.lookupFlags(i); if (c != null) { b = !!(c & 1); a = !!(c & 2); if (b !== a) { d.disableOverflow(i, b); break } } i = i.parentNode } } else { d.isDoubleTap = false } }, resetOverflow: function () { var a = this, b = a.disabledOverflowDom; while (b) { Ext.fly(b).removeCls([a.panXCls, a.panYCls]); b = b.parentNode } a.disabledOverflowDom = null }, set: function (g, e) { var d = this, c = d.cssProp, a = d.getFlags(e), b = d.attributeName; if (c) { Ext.fly(g).setStyle(c, d.cssValues[a]) } if (a === 15) { g.removeAttribute(b) } else { g.setAttribute(b, a) } } }, 1, 0, 0, 0, 0, 0, [Ext.dom, "TouchAction"], 0)); (Ext.cmd.derive("Ext.drag.Constraint", Ext.Base, { factoryConfig: { defaultType: "base", type: "drag.constraint" }, config: { element: null, horizontal: false, region: null, snap: null, source: null, vertical: false, x: null, y: null }, constructor: function (a) { this.initConfig(a) }, applyElement: function (a) { if (a) { if (typeof a === "boolean") { a = this.getSource().getElement().parent() } else { a = Ext.get(a) } } return a || null }, applySnap: function (a) { if (typeof a === "number") { a = { x: a, y: a } } return a }, constrain: function (m, a) { var h = this, k = m[0], j = m[1], l = h.constrainInfo, g = l.initial, d = l.x, c = l.y, b = l.snap, e, i; if (!l.vertical) { if (b && b.x) { if (b.xFn) { k = b.x.call(h, a, k) } else { k = h.doSnap(k, g.x, b.x) } } if (d) { e = d[0]; i = d[1]; if (e !== null && k < e) { k = e } if (i !== null && k > i) { k = i } } } else { k = g.x } if (!l.horizontal) { if (b && b.y) { if (b.yFn) { j = b.y.call(h, a, j) } else { j = h.doSnap(j, g.y, b.y) } } if (c) { e = c[0]; i = c[1]; if (e !== null && j < e) { j = e } if (i !== null && j > i) { j = i } } } else { j = g.y } return [k, j] }, destroy: function () { this.setSource(null); this.setElement(null); this.callParent() }, privates: { constrainValue: function (d, c, i) { var h = null, g = d === null, e = c === null; if (!(g && e)) { if (g) { h = c } else { if (e) { h = d } else { h = i(d, c) } } } return h }, doSnap: function (b, c, a) { if (!a) { return b } var d = (b - c) / a, e = Math.floor(d); if (d - e <= 0.5) { d = e } else { d = e + 1 } return c + (a * d) }, onDragStart: function (n) { var t = this, l = t.getSnap(), a = t.getVertical(), q = t.getHorizontal(), b = t.getElement(), d = t.getRegion(), m = n.proxy, i = m.element, k = t.getX(), j = t.getY(), s = null, r = null, p = null, o = null, h = null, g = null, e = null, c = null; if (b) { d = b.getRegion(true) } if (d) { if (!a) { h = d.left; g = d.right - (i ? m.width : 0) } if (!q) { e = d.top; c = d.bottom - (i ? m.height : 0) } } if (!a && (d || k)) { if (k) { s = k[0]; r = k[1] } if (s !== null || r !== null || h !== null || g !== null) { s = t.constrainValue(s, h, Math.max); r = t.constrainValue(r, g, Math.min); k = [s, r] } } if (!q && (d || j)) { if (j) { p = j[0]; o = j[1] } if (p !== null || o !== null || e !== null || c !== null) { p = t.constrainValue(p, e, Math.max); o = t.constrainValue(o, c, Math.min); j = [p, o] } } if (l) { l = { x: l.x, xFn: typeof l.x === "function", y: l.y, yFn: typeof l.y === "function" } } t.constrainInfo = { initial: n.element.initial, vertical: t.getVertical(), horizontal: t.getHorizontal(), x: k, y: j, snap: l } } } }, 1, 0, 0, 0, ["drag.constraint.base"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.drag, "Constraint"], 0)); (Ext.cmd.derive("Ext.drag.Info", Ext.Base, { constructor: function (a, h) { if (!a) { return } var j = this, m = h.getXY(), g = m[0], d = m[1], b, l, k, c, i; j.source = a; b = a.getElement(); m = b.getXY(); l = m[0]; k = m[1]; j.eventTarget = h.target; j.cursor = { current: { x: g, y: d }, delta: { x: 0, y: 0 }, initial: { x: g, y: d }, offset: { x: g - l, y: d - k } }; j.element = { current: { x: l, y: k }, delta: { x: 0, y: 0 }, initial: { x: l, y: k } }; j.proxy = { current: { x: l, y: k }, delta: { x: 0, y: 0 }, initial: { x: l, y: k }, element: b, isUnderCursor: false, isElement: true }; j.types = []; j.data = {}; a.describe(j); c = a.getProxy().getElement(j); i = j.proxy; i.isElement = c === a.getElement(); i.element = c; if (c) { i.width = c.getWidth(); i.height = c.getHeight() } if (i.isElement) { b = j.element; b.current = i.current; b.delta = i.delta } j.needsCursorCheck = i.element && a.manager && a.manager.pointerBug }, cursor: null, element: null, eventTarget: null, files: null, isNative: false, proxy: null, source: null, target: null, types: null, valid: false, clearData: function (a) { Ext.Array.remove(this.types, a); delete this.data[a] }, clone: function () { var b = this, a = new Ext.drag.Info(); a.cursor = Ext.merge({}, b.cursor); a.data = Ext.apply({}, b.data); a.element = Ext.merge({}, b.element); a.eventTarget = b.eventTarget; a.proxy = Ext.merge({}, b.proxy); a.source = b.source; a.target = b.target; a.types = Ext.Array.clone(b.types); a.valid = b.valid; return a }, getData: function (b) { var d = this, e = d.data, c = d.dataTransfer, a; if (c) { a = c.getData(b) } else { a = e[b]; if (typeof a === "function") { e[b] = a = a.call(d.source, d) } if (!a && a !== 0) { a = "" } } return Ext.Promise.resolve(a) }, setData: function (a, b) { Ext.Array.include(this.types, a); this.data[a] = b }, destroy: function () { var a = this; a.eventTarget = a.data = a.proxy = a.targetMap = a.targetMap = a.types = a.elementMap = a.possibleTargets = a.target = null; a.callParent() }, privates: { data: null, dataTransfer: null, elementMap: null, possibleTargets: null, targetMap: null, copyNativeData: function (c, b) { var a = b.browserEvent.dataTransfer; this.target = c; this.dataTransfer = a; this.files = a.files }, finalize: function () { var b = this, d = b.target, c = b.source, a; b.finalized = true; if (d) { d.info = null; d.handleDrop(b) } }, getAlignXY: function (i, g) { var e = this, a = e.source, b = e.cursor.offset, d = a.getProxy(), c = e.proxy.element, h = a.getConstrain(), j = [i, g]; if (c) { if (e.proxy.isElement) { j[0] -= b.x; j[1] -= b.y } else { j = d.adjustCursorOffset(e, j) } if (h) { j = h.constrain(j, e) } } return j }, onNativeDragEnter: function (c, b) { var a = this; a.valid = c.accepts(a); c.info = a; a.copyNativeData(c, b) }, onNativeDragLeave: function (c, b) { var a = this; if (a.target === c) { c.info = null; a.valid = false; a.target = a.dataTransfer = a.files = null } }, onNativeDragMove: function (b, a) { this.copyNativeData(b, a) }, onNativeDrop: function (b, a) { this.copyNativeData(b, a); b.info = null }, setActive: function (d) { var a = this, b = a.source, c = a.target, e = c !== d; if (c && e) { c.handleDragLeave(a); c.info = null } a.target = d; if (d) { if (e) { a.valid = !!a.possibleTargets[d.getId()] && d.accepts(a) !== false; d.handleDragEnter(a); d.info = a } d.handleDragMove(a) } else { a.valid = false } if (e) { b.getProxy().update(a) } }, update: function (i, m) { var k = this, q = i.getXY(), n = q[0], l = q[1], a = k.getAlignXY(n, l), d = a[0], b = a[1], j = k.proxy, p = k.cursor, h = p.current, o = p.delta, g = p.initial, c = j.element; h.x = n; h.y = l; o.x = n - g.x; o.y = l - g.y; h = j.current; o = j.delta; g = j.initial; h.x = d; h.y = b; o.x = d - g.x; o.y = b - g.y; if (k.needsCursorCheck) { j.isUnderCursor = !(n < d || l < b || n > j.width + d || l > j.height + b) } if (!m && c) { c.setXY(a) } } } }, 1, 0, 0, 0, 0, 0, [Ext.drag, "Info"], 0)); (Ext.cmd.derive("Ext.drag.Item", Ext.Base, { config: { autoDestroy: true, element: null, groups: null }, constructor: function (a) { this.mixins.observable.constructor.call(this, a) }, isDisabled: function () { return this.disabled }, disable: function () { this.disabled = true }, enable: function () { this.disabled = false }, applyElement: function (a) { return a ? Ext.get(a) : null }, updateElement: function (a) { this.setupListeners() }, applyGroups: function (a) { if (typeof a === "string") { a = [a] } return a }, destroy: function () { var b = this, a = b.getElement(); b.destroying = true; b.setElement(null); if (a && b.getAutoDestroy()) { a.destroy() } b.callParent(); b.destroying = false }, privates: { disabled: false, getElListeners: Ext.privateFn, setupListeners: function (a) { var b = this, c = b.elListeners; a = a || b.getElement(); if (c) { c.destroy(); b.elListeners = null } if (a) { b.elListeners = a.on(Ext.apply({ scope: b, destroyable: true }, b.getElListeners())) } } } }, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable], [Ext.mixin.Identifiable.prototype.mixinId || Ext.mixin.Identifiable.$className, Ext.mixin.Identifiable]], [Ext.drag, "Item"], 0)); (Ext.cmd.derive("Ext.drag.Manager", Ext.Base, { singleton: true, dragCls: "x-drag-body", pointerBug: Ext.isTouch || (!Ext.supports.CSSPointerEvents || Ext.isIE10m || Ext.isOpera), constructor: function () { this.targets = {}; this.nativeTargets = []; Ext.onReady(this.init, this) }, init: function () { Ext.getDoc().on({ scope: this, dragenter: { capture: true, fn: "onNativeDragEnter" }, dragleave: "onNativeDragLeave", dragover: "onNativeDragOver", drop: "onNativeDrop" }) }, destroy: function () { var c = this, a = c.targets, b; c.destroying = true; for (b in a) { a[b].destroy() } c.targets = null; c.callParent(); c.destroying = false }, privates: { elementFromPoint: function (a, b) { if (Ext.rootInheritedState.rtl) { a = Ext.Element.getViewportWidth() - a } return Ext.dom.Element.fromPagePoint(a, b, true) }, getAtPoint: function (h) { var g = h.cursor.current, b = h.elementMap, d = h.proxy.isUnderCursor, a = this.pointerBug && d ? h.proxy.element.dom : null, e, c; if (a) { a.style.visibility = "hidden" } c = this.elementFromPoint(g.x, g.y); if (a) { a.style.visibility = "visible" } while (c) { e = b[c.id]; if (e) { return e } c = c.parentNode } return null }, getNativeDragInfo: function (b) { var a = this.nativeDragInfo; if (!a) { this.nativeDragInfo = a = new Ext.drag.Info(); a.isNative = true } return a }, onDragCancel: function () { Ext.getBody().removeCls(this.dragCls) }, onDragEnd: function (b, a) { b.finalize(); Ext.getBody().removeCls(this.dragCls) }, onDragMove: function (b, a) { this.processDrag(b) }, onDragStart: function (g, p) { var q = this, a = g.source, n = q.targets, h = a.getGroups(), j = {}, c = {}, m = {}, b, o, r, d, s, l, k; m = {}; c = {}; if (h) { d = Ext.Array.toMap(h) } for (b in n) { o = n[b]; if (!o.isDisabled()) { s = false; r = o.getGroups(); if (!d && !r) { s = true } else { if (d && r) { for (k = 0, l = r.length; k < l; ++k) { if (d[r[k]]) { s = true; break } } } } if (s) { c[b] = o } } j[b] = o; m[o.getElement().id] = o } g.possibleTargets = c; g.targetMap = j; g.elementMap = m; Ext.getBody().addCls(q.dragCls); q.processDrag(g) }, onNativeDragEnter: function (c) { var a = this.nativeTargets, b = c.target; c.preventDefault(); if (a[a.length - 1] !== b) { a.push(b) } }, onNativeDragLeave: function (b) { var a = this.nativeTargets; Ext.Array.remove(a, b.target); if (a.length === 0) { this.nativeDragInfo = null } }, onNativeDragOver: function (a) { a.preventDefault() }, onNativeDrop: function (a) { a.preventDefault(); this.nativeTargets.length = 0; this.nativeDragInfo = null }, processDrag: function (a) { a.setActive(this.getAtPoint(a)) }, register: function (a) { this.targets[a.getId()] = a }, unregister: function (a) { if (this.destroying) { return } delete this.targets[a.getId()] } } }, 1, 0, 0, 0, 0, 0, [Ext.drag, "Manager"], 0)); (Ext.cmd.derive("Ext.drag.Source", Ext.drag.Item, { defaultIdPrefix: "source-", config: { activateOnLongPress: false, activeCls: null, constrain: null, handle: null, proxy: "original", revert: false }, dragging: false, constructor: function (a) { var b = a && a.describe; if (b) { this.describe = b; a = Ext.apply({}, a); delete a.describe } Ext.drag.Item.prototype.constructor.call(this, a); this.manager = Ext.drag.Manager }, describe: Ext.emptyFn, isDragging: function () { return this.dragging }, beforeDragStart: Ext.emptyFn, onDragCancel: Ext.emptyFn, onDragEnd: Ext.emptyFn, onDragMove: Ext.emptyFn, onDragStart: Ext.emptyFn, applyActivateOnLongPress: function (a) { if (typeof a === "string") { a = [a] } return a }, updateActivateOnLongPress: function (a) { if (!this.isConfiguring) { this.setupListeners() } }, updateActiveCls: function (a, b) { if (this.dragging) { if (b) { this.getElement().removeCls(b) } if (a) { this.getElement().addCls(a) } } }, applyConstrain: function (a) { if (a && !a.$isClass) { if (a.isRegion) { a = { region: a } } else { if (a.isElement || !Ext.isObject(a)) { a = { element: a } } } a = Ext.apply({ source: this }, a); a = Ext.Factory.dragConstraint(a) } return a }, updateElement: function (b, a) { if (b && !this.getHandle()) { b.setTouchAction({ panX: false, panY: false }) } Ext.drag.Item.prototype.updateElement.call(this, b, a) }, updateHandle: function () { if (!this.isConfiguring) { this.setupListeners() } }, applyProxy: function (a) { if (a) { a = Ext.Factory.dragproxy(a) } return a }, updateProxy: function (b, a) { if (a) { a.destroy() } if (b) { b.setSource(this) } }, destroy: function () { var a = this; a.manager = a.initialEvent = null; a.setConstrain(null); a.setProxy(null); Ext.drag.Item.prototype.destroy.call(this) }, privates: { draggingCls: "x-drag-dragging", info: null, revertCls: "x-drag-revert", canActivateOnLongPress: function (b) { var a = this.getActivateOnLongPress(); return !!(a && (a === true || Ext.Array.contains(a, b.pointerType))) }, dragCleanup: function (g) { var e = this, b = e.getActiveCls(), c = e.getProxy(), d = e.getElement(), a = g ? g.proxy.element : null; if (b) { d.removeCls(b) } if (a) { a.removeCls(e.draggingCls) } c.cleanup(g); e.dragging = false; e.initialEvent = e.info = null }, getElListeners: function () { var b = { touchstart: "handleTouchStart", dragstart: "handleDragStart", drag: "handleDragMove", dragend: "handleDragEnd", dragcancel: "handleDragCancel" }, a = this.getHandle(); if (a) { b.delegate = a } if (this.getActivateOnLongPress()) { b.longpress = "handleLongPress" } return b }, handleDragCancel: function (d) { var b = this, c = b.info, a = b.manager; if (a) { a.onDragCancel(c, d) } b.onDragCancel(c); if (b.hasListeners.dragcancel) { b.fireEvent("dragcancel", b, c, d) } Ext.fireEvent("dragcancel", b, c, d); b.dragCleanup(c) }, handleDragEnd: function (i) { if (!this.dragging) { return } var g = this, d = g.manager, b = g.getRevert(), h = g.info, c = h.proxy.initial, a = g.info.proxy.element; h.update(i); if (d) { d.onDragEnd(h, i) } g.onDragEnd(h); if (g.hasListeners.dragend) { g.fireEvent("dragend", g, h, i) } Ext.fireEvent("dragend", g, h, i); if (b && a) { a.addCls(g.revertCls); a.setXY([c.x, c.y], Ext.apply({ callback: function () { a.removeCls(g.revertCls); g.dragCleanup(h) } }, b)) } else { g.dragCleanup(h) } }, handleDragMove: function (d) { var b = this, c = b.info, a = b.manager; if (!b.dragging) { return } d.stopPropagation(); d.claimGesture(); c.update(d); if (a) { a.onDragMove(c, d) } b.onDragMove(c); if (b.hasListeners.dragmove) { b.fireEvent("dragmove", b, c, d) } }, handleDragStart: function (h) { var j = this, i = j.hasListeners, g = j.manager, k = j.getConstrain(), a = j.initialEvent, b, m, c, l, d; if (j.preventStart(h)) { return false } j.info = c = new Ext.drag.Info(j, a); j.setup(c); if (k) { k.onDragStart(c) } c.update(h, true); l = j.beforeDragStart(c) === false; if (!l && i.beforedragstart) { l = j.fireEvent("beforedragstart", j, c, h) === false } if (l) { j.dragCleanup(); return false } h.claimGesture(); j.dragging = true; m = j.getActiveCls(); b = j.getElement(); if (m) { b.addCls(m) } d = c.proxy.element; if (d) { d.addCls(j.draggingCls) } c.update(h); if (g) { g.onDragStart(c, h) } j.onDragStart(c); if (i.dragstart) { j.fireEvent("dragstart", j, c, h) } Ext.fireEvent("dragstart", j, c, h) }, handleLongPress: function (a) { if (!this.isDisabled() && this.canActivateOnLongPress(a)) { this.initialEvent = a; a.startDrag() } }, handleTouchStart: function (a) { if (!this.isDisabled()) { this.initialEvent = a } }, preventStart: function (a) { return this.isDisabled() || (!a.longpress && this.canActivateOnLongPress(a)) }, setup: Ext.privateFn } }, 1, 0, 0, 0, 0, 0, [Ext.drag, "Source"], 0)); (Ext.cmd.derive("Ext.drag.Target", Ext.drag.Item, { defaultIdPrefix: "target-", config: { invalidCls: "", validCls: "" }, constructor: function (a) { var c = this, b = a && a.accepts; if (b) { c.accepts = b; a = Ext.apply({}, a); delete a.accepts } Ext.drag.Item.prototype.constructor.call(this, a); Ext.drag.Manager.register(c) }, accepts: function (a) { return true }, disable: function () { Ext.drag.Item.prototype.disable.call(this); this.setupListeners(null) }, enable: function () { Ext.drag.Item.prototype.enable.call(this); this.setupListeners() }, beforeDrop: Ext.emptyFn, onDrop: Ext.emptyFn, onDragEnter: Ext.emptyFn, onDragLeave: Ext.emptyFn, onDragMove: Ext.emptyFn, updateInvalidCls: function (a, b) { var c = this.info; this.doUpdateCls(c && !c.valid, a, b) }, updateValidCls: function (a, b) { var c = this.info; this.doUpdateCls(c && c.valid, a, b) }, destroy: function () { Ext.drag.Manager.unregister(this); Ext.drag.Item.prototype.destroy.call(this) }, privates: { doUpdateCls: function (d, a, c) { var b = this.getElement(); if (c) { b.removeCls(c) } if (a && d) { b.addCls(a) } }, getElListeners: function () { return { dragenter: "handleNativeDragEnter", dragleave: "handleNativeDragLeave", dragover: "handleNativeDragMove", drop: "handleNativeDrop" } }, handleDrop: function (d) { var c = this, a = c.hasListeners, b = d.valid; c.getElement().removeCls([c.getInvalidCls(), c.getValidCls()]); if (b && c.beforeDrop(d) !== false) { if (a.beforedrop && c.fireEvent("beforedrop", c, d) === false) { return false } c.onDrop(d); if (a.drop) { c.fireEvent("drop", c, d) } } else { return false } }, handleDragEnter: function (c) { var b = this, a = c.valid ? b.getValidCls() : b.getInvalidCls(); if (a) { b.getElement().addCls(a) } b.onDragEnter(c); if (b.hasListeners.dragenter) { b.fireEvent("dragenter", b, c) } }, handleDragLeave: function (b) { var a = this; a.getElement().removeCls([a.getInvalidCls(), a.getValidCls()]); a.onDragLeave(b); if (a.hasListeners.dragleave) { a.fireEvent("dragleave", a, b) } }, handleDragMove: function (b) { var a = this; a.onDragMove(b); if (a.hasListeners.dragmove) { a.fireEvent("dragmove", a, b) } }, handleNativeDragEnter: function (c) { var a = this, b = Ext.drag.Manager.getNativeDragInfo(c); b.onNativeDragEnter(a, c); if (a.hasListeners.dragenter) { a.fireEvent("dragenter", a, b) } }, handleNativeDragLeave: function (c) { var a = this, b = Ext.drag.Manager.getNativeDragInfo(c); b.onNativeDragLeave(a, c); if (a.hasListeners.dragleave) { a.fireEvent("dragleave", a, b) } }, handleNativeDragMove: function (c) { var a = this, b = Ext.drag.Manager.getNativeDragInfo(c); b.onNativeDragMove(a, c); if (a.hasListeners.dragmove) { a.fireEvent("dragmove", a, b) } }, handleNativeDrop: function (g) { var c = this, a = c.hasListeners, d = Ext.drag.Manager.getNativeDragInfo(g), b = d.valid; d.onNativeDrop(c, g); if (b) { if (a.beforedrop && c.fireEvent("beforedrop", c, d) === false) { return } if (a.drop) { c.fireEvent("drop", c, d) } } } } }, 1, 0, 0, 0, 0, 0, [Ext.drag, "Target"], 0)); (Ext.cmd.derive("Ext.drag.proxy.None", Ext.Base, { factoryConfig: { aliasPrefix: "drag.proxy.", type: "dragproxy" }, config: { source: null }, constructor: function (a) { var b = a && a.getElement; if (b) { this.getElement = b; a = Ext.apply({}, a); delete a.getElement } this.initConfig(a) }, cleanup: Ext.emptyFn, getElement: function () { return null }, update: Ext.emptyFn, privates: { adjustCursorOffset: function (a, b) { return b } } }, 1, 0, 0, 0, ["drag.proxy.none"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.drag.proxy, "None"], 0)); (Ext.cmd.derive("Ext.drag.proxy.Original", Ext.drag.proxy.None, { getElement: function (a) { return a.source.getElement() } }, 0, 0, 0, 0, ["drag.proxy.original"], 0, [Ext.drag.proxy, "Original"], 0)); (Ext.cmd.derive("Ext.drag.proxy.Placeholder", Ext.drag.proxy.None, { config: { cls: "", cursorOffset: [12, 20], html: null, invalidCls: "", validCls: "" }, placeholderCls: "x-drag-proxy-placeholder", cleanup: function () { var a = this.element; if (a) { a.hide() } }, getElement: function (c) { var b = this, a = b.element; if (!a) { b.element = a = Ext.getBody().createChild({ cls: b.getCls(), html: b.getHtml() }); a.addCls(b.placeholderCls); a.setTouchAction({ panX: false, panY: false }) } a.show(); return a }, update: function (e) { var c = this.element, b = this.getInvalidCls(), a = this.getValidCls(), d = e.valid; if (e.target) { c.replaceCls(d ? b : a, d ? a : b) } else { c.removeCls([b, a]) } }, updateCls: function (a, c) { var b = this.element; if (b) { if (c) { b.removeCls(c) } if (a) { b.addCls(a) } } }, updateHtml: function (a) { var b = this.element; if (b) { b.setHtml(a || "") } }, updateInvalidCls: function (a, b) { this.doUpdateCls(a, b) }, updateValidCls: function (a, b) { this.doUpdateCls(a, b) }, destroy: function () { this.element = Ext.destroy(this.element); this.callParent() }, privates: { adjustCursorOffset: function (b, a) { var c = this.getCursorOffset(); if (c) { a[0] += (c[0] || 0); a[1] += (c[1] || 0) } return a }, doUpdateCls: function (b, d) { var c = this.element, a; if (c) { if (d) { a = b && c.hasCls(d); c.removeCls(d) } if (b && a) { c.addCls(b) } } } } }, 0, 0, 0, 0, ["drag.proxy.placeholder"], 0, [Ext.drag.proxy, "Placeholder"], 0)); (Ext.cmd.derive("Ext.event.gesture.Recognizer", Ext.Base, { priority: 0, handledEvents: [], isStarted: false, config: { onRecognized: Ext.emptyFn, callbackScope: null }, constructor: function (a) { this.initConfig(a); Ext.event.publisher.Gesture.instance.registerRecognizer(this) }, onStart: Ext.emptyFn, onEnd: Ext.emptyFn, onTouchStart: Ext.emptyFn, onTouchMove: Ext.emptyFn, onTouchEnd: function () { return this.reset() }, onTouchCancel: function (a) { return this.cancel(a) }, fire: function (a, d, c, b) { this.getOnRecognized().call(this.getCallbackScope(), this, a, d, c, b) }, cancel: function (a) { if (this.isStarted) { this.onCancel(a) } return this.reset() }, onCancel: Ext.emptyFn, reset: function () { this.isStarted = false; return false } }, 1, 0, 0, 0, 0, [[Ext.mixin.Identifiable.prototype.mixinId || Ext.mixin.Identifiable.$className, Ext.mixin.Identifiable]], [Ext.event.gesture, "Recognizer"], 0)); (Ext.cmd.derive("Ext.event.gesture.SingleTouch", Ext.event.gesture.Recognizer, { isSingleTouch: true, onTouchStart: function (a) { if (a.touches.length > 1) { return this.cancel(a) } } }, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, "SingleTouch"], 0)); (Ext.cmd.derive("Ext.event.gesture.DoubleTap", Ext.event.gesture.SingleTouch, { priority: 300, config: { moveDistance: 8, tapDistance: 24, maxDuration: 300 }, handledEvents: ["singletap", "doubletap"], singleTapTimer: null, startTime: 0, lastTapTime: 0, onTouchStart: function (d) { var c = this, b = Ext.event.gesture.SingleTouch.prototype.onTouchStart.call(this, d), a; if (b !== false) { c.isStarted = true; a = c.lastStartPoint = d.changedTouches[0].point; c.startPoint = c.startPoint || a; c.startTime = d.time; clearTimeout(c.singleTapTimer) } return b }, onTouchMove: function (c) { var b = this, a = c.changedTouches[0].point, d = Ext.Element.getViewportScale(), g = Math.round(Math.abs(a.getDistanceTo(b.lastStartPoint) * d)); if (g >= b.getMoveDistance()) { return b.cancel(c) } }, onTouchEnd: function (i) { var k = this, h = k.getMaxDuration(), b = i.time, j = i.target, l = k.lastTapTime, d = k.lastTarget, m = i.changedTouches[0].point, g, c, a; k.lastTapTime = b; k.lastTarget = j; if (l) { g = b - l; if (g <= h) { c = Ext.Element.getViewportScale(); a = Math.round(Math.abs(m.getDistanceTo(k.startPoint) * c)); if (a <= k.getTapDistance()) { if (j !== d) { return k.cancel(i) } k.lastTarget = null; k.lastTapTime = 0; k.fire("doubletap", i, { touch: i.changedTouches[0], duration: g }); return Ext.event.gesture.SingleTouch.prototype.onTouchEnd.call(this, i) } } } if (b - k.startTime > h) { k.fire("singletap", i); k.reset() } else { k.setSingleTapTimer(i) } }, setSingleTapTimer: function (b) { var a = this; a.singleTapTimer = Ext.defer(function () { a.fire("singletap", b); a.reset() }, a.getMaxDuration()) }, reset: function () { var a = this; clearTimeout(a.singleTapTimer); a.startTime = a.lastTapTime = 0; a.lastStartPoint = a.startPoint = a.singleTapTimer = null; return Ext.event.gesture.SingleTouch.prototype.reset.call(this) } }, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, "DoubleTap"], function (a) { var b = Ext.manifest.gestures; a.instance = new a(b && b.doubleTap) })); (Ext.cmd.derive("Ext.event.gesture.Drag", Ext.event.gesture.SingleTouch, { priority: 100, startPoint: null, previousPoint: null, lastPoint: null, handledEvents: ["dragstart", "drag", "dragend", "dragcancel"], config: { minDistance: 8 }, constructor: function () { Ext.event.gesture.SingleTouch.prototype.constructor.apply(this, arguments); this.initInfo() }, initInfo: function () { this.info = { touch: null, previous: { x: 0, y: 0 }, x: 0, y: 0, delta: { x: 0, y: 0 }, absDelta: { x: 0, y: 0 }, flick: { velocity: { x: 0, y: 0 } }, direction: { x: 0, y: 0 }, time: 0, previousTime: { x: 0, y: 0 }, longpress: false } }, onTouchStart: function (c) { var b = this, a = Ext.event.gesture.SingleTouch.prototype.onTouchStart.call(this, c); if (a !== false) { b.startTime = c.time; b.startPoint = c.changedTouches[0].point } return a }, tryDragStart: function (c) { var b = this, a = c.changedTouches[0].point, g = b.getMinDistance(), d = Ext.Element.getViewportScale(), h = Math.round(Math.abs(a.getDistanceTo(b.startPoint) * d)); if (h >= g) { b.doDragStart(c) } }, doDragStart: function (h, b) { var c = this, i = h.changedTouches[0], a = i.point, g = c.info, d; if (b) { d = Ext.now(); c.startTime = d; c.startPoint = a; g.longpress = true } else { d = h.time } c.isStarted = true; c.previousPoint = c.lastPoint = a; c.resetInfo("x", h, i); c.resetInfo("y", h, i); g.time = d; c.fire("dragstart", h, g) }, onTouchMove: function (c) { var b = this, d, a; if (!b.startPoint) { return } if (!b.isStarted) { b.tryDragStart(c) } if (!b.isStarted) { return } d = c.changedTouches[0]; a = d.point; if (b.lastPoint) { b.previousPoint = b.lastPoint } b.lastPoint = a; b.lastMoveEvent = c; b.updateInfo("x", c, d); b.updateInfo("y", c, d); b.info.time = c.time; b.fire("drag", c, b.info) }, onAxisDragEnd: function (a, c) { var b = c.time - c.previousTime[a]; if (b > 0) { c.flick.velocity[a] = (c[a] - c.previous[a]) / b } }, resetInfo: function (c, h, g) { var i = this, j = i.lastPoint[c], a = i.startPoint[c], k = j - a, d = c.toUpperCase(), b = i.info; b.touch = g; b.delta[c] = k; b.absDelta[c] = Math.abs(k); b.previousTime[c] = i.startTime; b.previous[c] = a; b[c] = j; b.direction[c] = 0; b["start" + d] = i.startPoint[c]; b["previous" + d] = b.previous[c]; b["page" + d] = b[c]; b["delta" + d] = b.delta[c]; b["absDelta" + d] = b.absDelta[c]; b["previousDelta" + d] = 0; b.startTime = i.startTime }, updateInfo: function (d, j, i) { var k = this, m = k.lastPoint[d], g = k.previousPoint[d], a = k.startPoint[d], n = m - a, c = k.info, l = c.direction, h = d.toUpperCase(), b = c.previous[d]; c.touch = i; c.delta[d] = n; c.absDelta[d] = Math.abs(n); if (m !== b && m !== c[d]) { c.previous[d] = c[d]; c.previousTime[d] = c.time } c[d] = m; if (m > g) { l[d] = 1 } else { if (m < g) { l[d] = -1 } } c["start" + h] = a; c["previous" + h] = c.previous[d]; c["page" + h] = c[d]; c["delta" + h] = c.delta[d]; c["absDelta" + h] = c.absDelta[d]; c["previousDelta" + h] = c.previous[d] - a; c.startTime = k.startTime }, onTouchEnd: function (d) { var b = this, g, a, c; if (b.isStarted) { g = d.changedTouches[0]; a = g.point; c = b.info; b.lastPoint = a; b.updateInfo("x", d, g); b.updateInfo("y", d, g); c.time = d.time; b.onAxisDragEnd("x", c); b.onAxisDragEnd("y", c); b.fire("dragend", d, c) } return Ext.event.gesture.SingleTouch.prototype.onTouchEnd.call(this, d) }, onCancel: function (c) { var a = this, d = c.changedTouches[0], b = a.info; if (!c.touches.length) { a.lastPoint = d.point } a.updateInfo("x", c, d); a.updateInfo("y", c, d); b.time = c.time; a.fire("dragcancel", c, b, true) }, reset: function () { var a = this; a.lastPoint = a.startPoint = a.previousPoint = a.lastPoint = a.lastMoveEvent = null; a.initInfo(); return Ext.event.gesture.SingleTouch.prototype.reset.call(this) } }, 1, 0, 0, 0, 0, 0, [Ext.event.gesture, "Drag"], function (a) { var b = Ext.manifest.gestures; a.instance = new a(b && b.drag) })); (Ext.cmd.derive("Ext.event.gesture.Swipe", Ext.event.gesture.SingleTouch, { priority: 600, handledEvents: ["swipestart", "swipe", "swipecancel"], config: { minDistance: 80, maxOffset: 35, maxDuration: 1000 }, onTouchStart: function (c) { var b = this, a = Ext.event.gesture.SingleTouch.prototype.onTouchStart.call(this, c), d; if (a !== false) { d = c.changedTouches[0]; b.startTime = c.time; b.isHorizontal = true; b.isVertical = true; b.startX = d.pageX; b.startY = d.pageY } return a }, onTouchMove: function (j) { var k = this, i = j.changedTouches[0], n = i.pageX, l = i.pageY, h = n - k.startX, g = l - k.startY, c = Math.abs(n - k.startX), b = Math.abs(l - k.startY), d = j.time - k.startTime, o, m, a; if ((c === 0 && b === 0) || (d > k.getMaxDuration())) { return k.cancel(j) } if (k.isHorizontal && b > k.getMaxOffset()) { k.isHorizontal = false } if (k.isVertical && c > k.getMaxOffset()) { k.isVertical = false } if (!k.isVertical || !k.isHorizontal) { o = k.getMinDistance(); if (k.isHorizontal && c < o) { m = (h < 0) ? "left" : "right"; a = c } else { if (k.isVertical && b < o) { m = (g < 0) ? "up" : "down"; a = b } } } if (!k.isHorizontal && !k.isVertical) { return k.cancel(j) } if (m && !k.isStarted) { k.isStarted = true; k.fire("swipestart", j, { touch: i, direction: m, distance: a, duration: d }) } }, onTouchEnd: function (j) { var k = this, i, n, l, h, g, c, b, o, d, m, a; if (k.onTouchMove(j) !== false) { i = j.changedTouches[0]; n = i.pageX; l = i.pageY; h = n - k.startX; g = l - k.startY; c = Math.abs(h); b = Math.abs(g); o = k.getMinDistance(); d = j.time - k.startTime; if (k.isVertical && b < o) { k.isVertical = false } if (k.isHorizontal && c < o) { k.isHorizontal = false } if (k.isHorizontal) { m = (h < 0) ? "left" : "right"; a = c } else { if (k.isVertical) { m = (g < 0) ? "up" : "down"; a = b } } k.fire("swipe", j, { touch: i, direction: m, distance: a, duration: d }) } return Ext.event.gesture.SingleTouch.prototype.onTouchEnd.call(this, j) }, onCancel: function (a) { this.fire("swipecancel", a, null, true) }, reset: function () { var a = this; a.startTime = a.isHorizontal = a.isVertical = a.startX = a.startY = null; return Ext.event.gesture.SingleTouch.prototype.reset.call(this) } }, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, "Swipe"], function (a) { var b = Ext.manifest.gestures; a.instance = new a(b && b.swipe) })); (Ext.cmd.derive("Ext.event.gesture.EdgeSwipe", Ext.event.gesture.Swipe, { priority: 500, handledEvents: ["edgeswipe", "edgeswipestart", "edgeswipeend", "edgeswipecancel"], config: { minDistance: 60 }, onTouchStart: function (c) { var b = this, a = Ext.event.gesture.Swipe.prototype.onTouchStart.call(this, c), d; if (a !== false) { d = c.changedTouches[0]; b.direction = null; b.isHorizontal = true; b.isVertical = true; b.startX = d.pageX; b.startY = d.pageY } return a }, onTouchMove: function (l) { var m = this, j = l.changedTouches[0], q = j.pageX, n = j.pageY, i = q - m.startX, h = n - m.startY, b = Math.abs(n - m.startY), c = Math.abs(q - m.startX), r = m.getMinDistance(), g = m.getMaxOffset(), d = l.time - m.startTime, p = Ext.Viewport && Ext.Element.getViewportWidth(), k = Ext.Viewport && Ext.Element.getViewportHeight(), o, a; if (m.isVertical && c > g) { m.isVertical = false } if (m.isHorizontal && b > g) { m.isHorizontal = false } if (m.isVertical && m.isHorizontal) { if (b > c) { m.isHorizontal = false } else { m.isVertical = false } } if (m.isHorizontal) { o = (i < 0) ? "left" : "right"; a = i } else { if (m.isVertical) { o = (h < 0) ? "up" : "down"; a = h } } o = m.direction || (m.direction = o); if (o === "up") { a = h * -1 } else { if (o === "left") { a = i * -1 } } m.distance = a; if (!a) { return m.cancel(l) } if (!m.isStarted) { if ((o === "right" && m.startX > r) || (o === "down" && m.startY > r) || (o === "left" && (p - m.startX) > r) || (o === "up" && (k - m.startY) > r)) { return m.cancel(l) } m.isStarted = true; m.startTime = l.time; m.fire("edgeswipestart", l, { touch: j, direction: o, distance: a, duration: d }) } else { m.fire("edgeswipe", l, { touch: j, direction: o, distance: a, duration: d }) } }, onTouchEnd: function (c) { var a = this, b; if (a.onTouchMove(c) !== false) { b = c.time - a.startTime; a.fire("edgeswipeend", c, { touch: c.changedTouches[0], direction: a.direction, distance: a.distance, duration: b }) } return this.reset() }, onCancel: function (a) { this.fire("edgeswipecancel", a, { touch: a.changedTouches[0] }, true) }, reset: function () { var a = this; a.direction = a.isHorizontal = a.isVertical = a.startX = a.startY = a.startTime = a.distance = null; return Ext.event.gesture.Swipe.prototype.reset.call(this) } }, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, "EdgeSwipe"], function (a) { var b = Ext.manifest.gestures; a.instance = new a(b && b.edgeSwipe) })); (Ext.cmd.derive("Ext.event.gesture.LongPress", Ext.event.gesture.SingleTouch, { priority: 400, config: { moveDistance: 8, minDuration: 1000 }, handledEvents: ["longpress", "taphold"], onTouchStart: function (c) { var b = this, a = Ext.event.gesture.SingleTouch.prototype.onTouchStart.call(this, c); if (a !== false) { b.startPoint = c.changedTouches[0].point; b.setLongPressTimer(c) } return a }, setLongPressTimer: function (b) { var a = this; a.timer = Ext.defer(a.fireLongPress, a.getMinDuration(), a, [b]) }, onTouchMove: function (c) { var b = this, a = c.changedTouches[0].point, d = Ext.Element.getViewportScale(), g = Math.round(Math.abs(a.getDistanceTo(b.startPoint) * d)); if (g >= b.getMoveDistance()) { return b.cancel(c) } }, reset: function () { var a = this; clearTimeout(a.timer); a.timer = a.startPoint = null; return Ext.event.gesture.SingleTouch.prototype.reset.call(this) }, fireLongPress: function (c) { var a = this, b = { touch: c.changedTouches[0], duration: a.getMinDuration(), startDrag: a.startDrag }; this.fire("taphold", c, b); this.fire("longpress", c, b); this.reset() }, startDrag: function () { var b = Ext.event.gesture.Drag.instance, a = this.parentEvent; b.doDragStart(a, true); Ext.event.publisher.Gesture.instance.claimRecognizer(b, a) } }, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, "LongPress"], function (a) { var b = Ext.manifest.gestures; a.instance = new a(b && b.longPress) })); (Ext.cmd.derive("Ext.event.gesture.MultiTouch", Ext.event.gesture.Recognizer, { requiredTouchesCount: 2, isTracking: false, isMultiTouch: true, onTouchStart: function (g) { var b = this, a = b.requiredTouchesCount, d = g.touches, c = d.length; if (c === a) { b.isTracking = true } else { if (c > a) { return b.cancel(g) } } }, reset: function () { this.isTracking = false; return Ext.event.gesture.Recognizer.prototype.reset.call(this) } }, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, "MultiTouch"], 0)); (Ext.cmd.derive("Ext.event.gesture.Pinch", Ext.event.gesture.MultiTouch, { priority: 700, handledEvents: ["pinchstart", "pinch", "pinchend", "pinchcancel"], startDistance: 0, lastTouches: null, onTouchMove: function (d) { var b = this, c, g, a, h; if (b.isTracking) { c = d.touches; g = c[0].point; a = c[1].point; h = g.getDistanceTo(a); if (h === 0) { return } if (!b.isStarted) { b.isStarted = true; b.startDistance = h; b.fire("pinchstart", d, { touches: c, distance: h, scale: 1 }) } else { b.fire("pinch", d, { touches: c, distance: h, scale: h / b.startDistance }) } } }, onTouchEnd: function (a) { if (this.isStarted) { this.fire("pinchend", a) } return Ext.event.gesture.MultiTouch.prototype.onTouchEnd.call(this, a) }, onCancel: function (a) { this.fire("pinchcancel", a, null, true) }, reset: function () { this.lastTouches = null; this.startDistance = 0; return Ext.event.gesture.MultiTouch.prototype.reset.call(this) } }, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, "Pinch"], function (a) { var b = Ext.manifest.gestures; a.instance = new a(b && b.pinch) })); (Ext.cmd.derive("Ext.event.gesture.Rotate", Ext.event.gesture.MultiTouch, { priority: 800, handledEvents: ["rotatestart", "rotate", "rotateend", "rotatecancel"], startAngle: 0, lastTouches: null, lastAngle: null, onTouchMove: function (i) { var j = this, h, b, d, g, c, a, k, l; if (j.isTracking) { h = i.touches; b = j.lastAngle; d = h[0].point; g = h[1].point; c = d.getAngleTo(g); if (b !== null) { l = Math.abs(b - c); a = c + 360; k = c - 360; if (Math.abs(a - b) < l) { c = a } else { if (Math.abs(k - b) < l) { c = k } } } j.lastAngle = c; if (!j.isStarted) { j.isStarted = true; j.startAngle = c; j.fire("rotatestart", i, { touches: h, angle: c, rotation: 0 }) } else { j.fire("rotate", i, { touches: h, angle: c, rotation: c - j.startAngle }) } j.lastTouches = Ext.Array.clone(h) } }, onTouchEnd: function (a) { if (this.isStarted) { this.fire("rotateend", a) } return Ext.event.gesture.MultiTouch.prototype.onTouchEnd.call(this, a) }, onCancel: function (a) { this.fire("rotatecancel", a, null, true) }, reset: function () { var a = this; a.lastTouches = a.lastAngle = a.startAngle = null; return Ext.event.gesture.MultiTouch.prototype.reset.call(this) } }, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, "Rotate"], function (a) { var b = Ext.manifest.gestures; a.instance = new a(b && b.rotate) })); (Ext.cmd.derive("Ext.event.gesture.Tap", Ext.event.gesture.SingleTouch, { priority: 200, handledEvents: ["tap", "tapcancel"], config: { moveDistance: 8 }, onTouchStart: function (c) { var b = this, a = Ext.event.gesture.SingleTouch.prototype.onTouchStart.call(this, c); if (a !== false) { b.isStarted = true; b.startPoint = c.changedTouches[0].point } return a }, onTouchMove: function (c) { var b = this, a = c.changedTouches[0].point, d = Ext.Element.getViewportScale(), g = Math.round(Math.abs(a.getDistanceTo(b.startPoint) * d)); if (g >= b.getMoveDistance()) { return b.cancel(c) } }, onTouchEnd: function (a) { this.fire("tap", a, { touch: a.changedTouches[0] }); return Ext.event.gesture.SingleTouch.prototype.onTouchEnd.call(this, a) }, onCancel: function (a) { this.fire("tapcancel", a, { touch: a.changedTouches[0] }, true) }, reset: function () { this.startPoint = null; return Ext.event.gesture.SingleTouch.prototype.reset.call(this) } }, 0, 0, 0, 0, 0, 0, [Ext.event.gesture, "Tap"], function (b) { var a = Ext.manifest.gestures; b.instance = new b(a && a.tap) })); (Ext.cmd.derive("Ext.event.publisher.Focus", Ext.event.publisher.Dom, { type: "focus", handledEvents: ["focusenter", "focusleave", "focusmove"], handledDomEvents: ["focusin", "focusout"], publishDelegatedDomEvent: function (c) { var b = this, a = c.relatedTarget; if (c.type === "focusout") { if (a == null) { b.processFocusIn(c, c.target, document.body) } } else { if (a == null || !a.tagName) { a = document.body } b.processFocusIn(c, a, c.target) } }, processFocusIn: function (j, k, c) { var l = this, m, b, i = [], a, h, g, d; g = Ext.fly(k); d = Ext.fly(c); if ((g && g.isFocusSuspended()) || (d && d.isFocusSuspended())) { return } for (b = k, m = Ext.dom.Element.getCommonAncestor(c, k, true); b && b !== m; b = b.parentNode) { i.push(b) } if (i.length) { a = l.createSyntheticEvent("focusleave", j, k, c); l.publish(a, i); if (a.stopped) { return } } i.length = 0; for (b = c; b && b !== m; b = b.parentNode) { i.push(b) } h = l.createSyntheticEvent("focusenter", j, c, k); if (i.length) { l.publish(h, i); if (h.stopped) { return } } i = l.getPropagatingTargets(m); if (i.length) { a = l.createSyntheticEvent("focusmove", j, c, k); l.publish(a, i); if (a.stopped) { return } } Ext.GlobalEvents.fireEvent("focus", { event: h, toElement: c, fromElement: k }) }, createSyntheticEvent: function (b, e, d, a) { var c = new Ext.event.Event(e); c.type = b; c.relatedTarget = a; c.target = d; return c } }, 0, 0, 0, 0, 0, 0, [Ext.event.publisher, "Focus"], function (b) { var a; b.instance = new b(); if (!Ext.supports.FocusinFocusoutEvents) { this.override({ handledDomEvents: ["focus", "blur"], publishDelegatedDomEvent: function (d) { var c = this, g; c.callSuper([d]); g = d.target !== window && d.target !== document; if (d.type === "blur") { if (!g) { if (d.explicitOriginalTarget === b.previousActiveElement) { if (d.target === window) { clearTimeout(a); a = 0; c.processFocusIn(d, b.previousActiveElement, document.body); b.previousActiveElement = null } } } else { a = setTimeout(function () { a = 0; c.processFocusIn(d, d.target, document.body); b.previousActiveElement = null }, 0) } b.previousActiveElement = g ? d.target : null } else { clearTimeout(a); a = 0; c.processFocusIn(d, b.previousActiveElement || document.body, g ? d.target : document.body) } } }) } })); (Ext.cmd.derive("Ext.fx.State", Ext.Base, { isAnimatable: { "background-color": true, "background-image": true, "background-position": true, "border-bottom-color": true, "border-bottom-width": true, "border-color": true, "border-left-color": true, "border-left-width": true, "border-right-color": true, "border-right-width": true, "border-spacing": true, "border-top-color": true, "border-top-width": true, "border-width": true, bottom: true, color: true, crop: true, "font-size": true, "font-weight": true, height: true, left: true, "letter-spacing": true, "line-height": true, "margin-bottom": true, "margin-left": true, "margin-right": true, "margin-top": true, "max-height": true, "max-width": true, "min-height": true, "min-width": true, opacity: true, "outline-color": true, "outline-offset": true, "outline-width": true, "padding-bottom": true, "padding-left": true, "padding-right": true, "padding-top": true, right: true, "text-indent": true, "text-shadow": true, top: true, "vertical-align": true, visibility: true, width: true, "word-spacing": true, "z-index": true, zoom: true, transform: true }, constructor: function (a) { this.data = {}; this.set(a) }, setConfig: function (a) { this.set(a); return this }, setRaw: function (a) { this.data = a; return this }, clear: function () { return this.setRaw({}) }, setTransform: function (c, h) { var g = this.data, a = Ext.isArray(h), b = g.transform, e, d; if (!b) { b = g.transform = { translateX: 0, translateY: 0, translateZ: 0, scaleX: 1, scaleY: 1, scaleZ: 1, rotate: 0, rotateX: 0, rotateY: 0, rotateZ: 0, skewX: 0, skewY: 0 } } if (typeof c == "string") { switch (c) { case "translate": if (a) { e = h.length; if (e == 0) { break } b.translateX = h[0]; if (e == 1) { break } b.translateY = h[1]; if (e == 2) { break } b.translateZ = h[2] } else { b.translateX = h } break; case "rotate": if (a) { e = h.length; if (e == 0) { break } b.rotateX = h[0]; if (e == 1) { break } b.rotateY = h[1]; if (e == 2) { break } b.rotateZ = h[2] } else { b.rotate = h } break; case "scale": if (a) { e = h.length; if (e == 0) { break } b.scaleX = h[0]; if (e == 1) { break } b.scaleY = h[1]; if (e == 2) { break } b.scaleZ = h[2] } else { b.scaleX = h; b.scaleY = h } break; case "skew": if (a) { e = h.length; if (e == 0) { break } b.skewX = h[0]; if (e == 1) { break } b.skewY = h[1] } else { b.skewX = h } break; default: b[c] = h } } else { for (d in c) { if (c.hasOwnProperty(d)) { h = c[d]; this.setTransform(d, h) } } } }, set: function (a, d) { var c = this.data, b; if (typeof a != "string") { for (b in a) { d = a[b]; if (b === "transform") { this.setTransform(d) } else { c[b] = d } } } else { if (a === "transform") { this.setTransform(d) } else { c[a] = d } } return this }, unset: function (a) { var b = this.data; if (b.hasOwnProperty(a)) { delete b[a] } return this }, getData: function () { return this.data } }, 1, 0, 0, 0, 0, 0, [Ext.fx, "State"], 0)); (Ext.cmd.derive("Ext.fx.animation.Abstract", Ext.Evented, { isAnimation: true, config: { name: "", element: null, before: null, from: {}, to: {}, after: null, states: {}, duration: 300, easing: "linear", iteration: 1, direction: "normal", delay: 0, onBeforeStart: null, callback: null, onEnd: null, onBeforeEnd: null, scope: null, reverse: null, preserveEndState: false, replacePrevious: true }, STATE_FROM: "0%", STATE_TO: "100%", DIRECTION_UP: "up", DIRECTION_DOWN: "down", DIRECTION_LEFT: "left", DIRECTION_RIGHT: "right", stateNameRegex: /^(?:[\d\.]+)%$/, constructor: function () { this.states = {}; Ext.Evented.prototype.constructor.apply(this, arguments); return this }, applyElement: function (a) { return Ext.get(a) }, applyBefore: function (a, b) { if (a) { return Ext.factory(a, Ext.fx.State, b) } }, applyAfter: function (b, a) { if (b) { return Ext.factory(b, Ext.fx.State, a) } }, setFrom: function (a) { return this.setState(this.STATE_FROM, a) }, setTo: function (a) { return this.setState(this.STATE_TO, a) }, getFrom: function () { return this.getState(this.STATE_FROM) }, getTo: function () { return this.getState(this.STATE_TO) }, setStates: function (a) { var c = this.stateNameRegex, b; for (b in a) { if (c.test(b)) { this.setState(b, a[b]) } } return this }, getStates: function () { return this.states }, updateCallback: function (a) { if (a) { this.setOnEnd(a) } }, end: function () { this.stop() }, stop: function () { this.fireEvent("stop", this) }, destroy: function () { this.stop(); Ext.Evented.prototype.destroy.call(this) }, setState: function (b, d) { var a = this.getStates(), c; c = Ext.factory(d, Ext.fx.State, a[b]); if (c) { a[b] = c } return this }, getState: function (a) { return this.getStates()[a] }, getData: function () { var h = this, m = h.getStates(), e = {}, i = h.getBefore(), c = h.getAfter(), j = m[h.STATE_FROM], k = m[h.STATE_TO], l = j.getData(), g = k.getData(), d, b, a; for (b in m) { if (m.hasOwnProperty(b)) { a = m[b]; d = a.getData(); e[b] = d } } return { before: i ? i.getData() : {}, after: c ? c.getData() : {}, states: e, from: l, to: g, duration: h.getDuration(), iteration: h.getIteration(), direction: h.getDirection(), easing: h.getEasing(), delay: h.getDelay(), onEnd: h.getOnEnd(), onBeforeEnd: h.getOnBeforeEnd(), onBeforeStart: h.getOnBeforeStart(), scope: h.getScope(), preserveEndState: h.getPreserveEndState(), replacePrevious: h.getReplacePrevious() } } }, 1, 0, 0, 0, 0, 0, [Ext.fx.animation, "Abstract"], 0)); (Ext.cmd.derive("Ext.fx.animation.Slide", Ext.fx.animation.Abstract, { alternateClassName: "Ext.fx.animation.SlideIn", config: { direction: "left", out: false, offset: 0, easing: "auto", containerBox: "auto", elementBox: "auto", isElementBoxFit: true, useCssTransform: true }, reverseDirectionMap: { up: "down", down: "up", left: "right", right: "left" }, applyEasing: function (a) { if (a === "auto") { return "ease-" + ((this.getOut()) ? "in" : "out") } return a }, getContainerBox: function () { var a = this._containerBox; if (a === "auto") { a = this.getElement().getParent().getBox() } return a }, getElementBox: function () { var a = this._elementBox; if (this.getIsElementBoxFit()) { return this.getContainerBox() } if (a === "auto") { a = this.getElement().getBox() } return a }, getData: function () { var q = this.getElementBox(), c = this.getContainerBox(), h = q ? q : c, o = this.getFrom(), p = this.getTo(), g = this.getOut(), e = this.getOffset(), n = this.getDirection(), b = this.getUseCssTransform(), i = this.getReverse(), d = 0, a = 0, m, k, l, j; if (i) { n = this.reverseDirectionMap[n] } switch (n) { case this.DIRECTION_UP: if (g) { a = c.top - h.top - h.height - e } else { a = c.bottom - h.bottom + h.height + e } break; case this.DIRECTION_DOWN: if (g) { a = c.bottom - h.bottom + h.height + e } else { a = c.top - h.height - h.top - e } break; case this.DIRECTION_RIGHT: if (g) { d = c.right - h.right + h.width + e } else { d = c.left - h.left - h.width - e } break; case this.DIRECTION_LEFT: if (g) { d = c.left - h.left - h.width - e } else { d = c.right - h.right + h.width + e } break }m = (g) ? 0 : d; k = (g) ? 0 : a; if (b) { o.setTransform({ translateX: m, translateY: k }) } else { o.set("left", m); o.set("top", k) } l = (g) ? d : 0; j = (g) ? a : 0; if (b) { p.setTransform({ translateX: l, translateY: j }) } else { p.set("left", l); p.set("top", j) } return Ext.fx.animation.Abstract.prototype.getData.apply(this, arguments) } }, 0, 0, 0, 0, ["animation.slide", "animation.slideIn"], 0, [Ext.fx.animation, "Slide", Ext.fx.animation, "SlideIn"], 0)); (Ext.cmd.derive("Ext.fx.animation.SlideOut", Ext.fx.animation.Slide, { config: { out: true } }, 0, 0, 0, 0, ["animation.slideOut"], 0, [Ext.fx.animation, "SlideOut"], 0)); (Ext.cmd.derive("Ext.fx.animation.Fade", Ext.fx.animation.Abstract, { alternateClassName: "Ext.fx.animation.FadeIn", config: { out: false, before: { display: null, opacity: 0 }, after: { opacity: null }, reverse: null }, updateOut: function (a) { var c = this.getTo(), b = this.getFrom(); if (a) { b.set("opacity", 1); c.set("opacity", 0) } else { b.set("opacity", 0); c.set("opacity", 1) } } }, 0, 0, 0, 0, ["animation.fade", "animation.fadeIn"], 0, [Ext.fx.animation, "Fade", Ext.fx.animation, "FadeIn"], 0)); (Ext.cmd.derive("Ext.fx.animation.FadeOut", Ext.fx.animation.Fade, { config: { out: true, before: {} } }, 0, 0, 0, 0, ["animation.fadeOut"], 0, [Ext.fx.animation, "FadeOut"], 0)); (Ext.cmd.derive("Ext.fx.animation.Flip", Ext.fx.animation.Abstract, { config: { easing: "ease-in", direction: "right", half: false, out: null }, getData: function () { var h = this, j = h.getFrom(), k = h.getTo(), i = h.getDirection(), b = h.getOut(), n = h.getHalf(), c = n ? 90 : 180, e = 1, a = 1, m = 0, l = 0, g = 0, d = 0; if (b) { a = 0.8 } else { e = 0.8 } switch (i) { case this.DIRECTION_UP: if (b) { g = c } else { m = -c } break; case this.DIRECTION_DOWN: if (b) { g = -c } else { m = c } break; case this.DIRECTION_RIGHT: if (b) { d = c } else { l = -c } break; case this.DIRECTION_LEFT: if (b) { d = -c } else { l = c } break }j.setTransform({ rotateX: m, rotateY: l, scale: e }); k.setTransform({ rotateX: g, rotateY: d, scale: a }); return Ext.fx.animation.Abstract.prototype.getData.call(this) } }, 0, 0, 0, 0, ["animation.flip"], 0, [Ext.fx.animation, "Flip"], 0)); (Ext.cmd.derive("Ext.fx.animation.Pop", Ext.fx.animation.Abstract, { alternateClassName: "Ext.fx.animation.PopIn", config: { out: false, before: { display: null, opacity: 0 }, after: { opacity: null } }, getData: function () { var c = this.getTo(), b = this.getFrom(), a = this.getOut(); if (a) { b.set("opacity", 1); b.setTransform({ scale: 1 }); c.set("opacity", 0); c.setTransform({ scale: 0 }) } else { b.set("opacity", 0); b.setTransform({ scale: 0 }); c.set("opacity", 1); c.setTransform({ scale: 1 }) } return Ext.fx.animation.Abstract.prototype.getData.apply(this, arguments) } }, 0, 0, 0, 0, ["animation.pop", "animation.popIn"], 0, [Ext.fx.animation, "Pop", Ext.fx.animation, "PopIn"], 0)); (Ext.cmd.derive("Ext.fx.animation.PopOut", Ext.fx.animation.Pop, { config: { out: true, before: {} } }, 0, 0, 0, 0, ["animation.popOut"], 0, [Ext.fx.animation, "PopOut"], 0)); (Ext.cmd.derive("Ext.fx.Animation", Ext.Base, { constructor: function (b) { var a = Ext.fx.animation.Abstract, c; if (typeof b == "string") { c = b; b = {} } else { if (b && b.type) { c = b.type } } if (c) { a = Ext.ClassManager.getByAlias("animation." + c) } return Ext.factory(b, a) } }, 1, 0, 0, 0, 0, 0, [Ext.fx, "Animation"], 0)); (Ext.cmd.derive("Ext.fx.runner.Css", Ext.Evented, { prefixedProperties: { transform: true, "transform-origin": true, perspective: true, "transform-style": true, transition: true, "transition-property": true, "transition-duration": true, "transition-timing-function": true, "transition-delay": true, animation: true, "animation-name": true, "animation-duration": true, "animation-iteration-count": true, "animation-direction": true, "animation-timing-function": true, "animation-delay": true }, lengthProperties: { top: true, right: true, bottom: true, left: true, width: true, height: true, "max-height": true, "max-width": true, "min-height": true, "min-width": true, "margin-bottom": true, "margin-left": true, "margin-right": true, "margin-top": true, "padding-bottom": true, "padding-left": true, "padding-right": true, "padding-top": true, "border-bottom-width": true, "border-left-width": true, "border-right-width": true, "border-spacing": true, "border-top-width": true, "border-width": true, "outline-width": true, "letter-spacing": true, "line-height": true, "text-indent": true, "word-spacing": true, "font-size": true, translate: true, translateX: true, translateY: true, translateZ: true, translate3d: true, x: true, y: true }, durationProperties: { "transition-duration": true, "transition-delay": true, "animation-duration": true, "animation-delay": true }, angleProperties: { rotate: true, rotateX: true, rotateY: true, rotateZ: true, skew: true, skewX: true, skewY: true }, lengthUnitRegex: /([a-z%]*)$/, DEFAULT_UNIT_LENGTH: "px", DEFAULT_UNIT_ANGLE: "deg", DEFAULT_UNIT_DURATION: "ms", customProperties: { x: true, y: true }, formattedNameCache: { x: "left", y: "top" }, transformMethods3d: ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "skewX", "skewY", "scaleX", "scaleY", "scaleZ"], transformMethodsNo3d: ["translateX", "translateY", "rotate", "skewX", "skewY", "scaleX", "scaleY"], constructor: function () { var a = this; a.transformMethods = Ext.feature.has.Css3dTransforms ? a.transformMethods3d : a.transformMethodsNo3d; a.vendorPrefix = Ext.browser.getStyleDashPrefix(); a.ruleStylesCache = {}; Ext.Evented.prototype.constructor.call(this) }, getStyleSheet: function () { var c = this.styleSheet, a, b; if (!c) { a = document.createElement("style"); a.type = "text/css"; (document.head || document.getElementsByTagName("head")[0]).appendChild(a); b = document.styleSheets; this.styleSheet = c = b[b.length - 1] } return c }, applyRules: function (j) { var h = this.getStyleSheet(), l = this.ruleStylesCache, k = h.cssRules, c, e, i, b, d, a, g; for (c in j) { e = j[c]; i = l[c]; if (i === undefined) { d = k.length; h.insertRule(c + "{}", d); i = l[c] = k.item(d).style } b = i.$cache; if (!b) { b = i.$cache = {} } for (a in e) { g = this.formatValue(e[a], a); a = this.formatName(a); if (b[a] !== g) { b[a] = g; if (g === null) { i.removeProperty(a) } else { i.setProperty(a, g, "important") } } } } return this }, applyStyles: function (d) { var h, c, g, b, a, e; for (h in d) { if (d.hasOwnProperty(h)) { this.activeElement = c = document.getElementById(h); if (!c) { continue } g = c.style; b = d[h]; for (a in b) { if (b.hasOwnProperty(a)) { e = this.formatValue(b[a], a); a = this.formatName(a); if (e === null) { g.removeProperty(a) } else { g.setProperty(a, e, "important") } } } } } this.activeElement = null; return this }, formatName: function (b) { var a = this.formattedNameCache, c = a[b]; if (!c) { if ((Ext.os.is.Tizen || !Ext.feature.has.CssTransformNoPrefix) && this.prefixedProperties[b]) { c = this.vendorPrefix + b } else { c = b } a[b] = c } return c }, formatValue: function (l, b) { var h = typeof l, n = this.DEFAULT_UNIT_LENGTH, j = this.customProperties[b], e, a, d, g, c, m, k; if (l === null) { return "" } if (h === "string") { if (this.lengthProperties[b]) { k = l.match(this.lengthUnitRegex)[1]; if (k.length > 0) { } else { l = l + n; if (j) { l = this.getCustomValue(l, b) } return l } } return l } else { if (h === "number") { if (l == 0) { return "0" } if (this.lengthProperties[b]) { l = l + n; if (j) { l = this.getCustomValue(l, b) } return l } if (this.angleProperties[b]) { return l + this.DEFAULT_UNIT_ANGLE } if (this.durationProperties[b]) { return l + this.DEFAULT_UNIT_DURATION } } else { if (b === "transform") { e = this.transformMethods; c = []; for (d = 0, g = e.length; d < g; d++) { a = e[d]; c.push(a + "(" + this.formatValue(l[a], a) + ")") } return c.join(" ") } else { if (Ext.isArray(l)) { m = []; for (d = 0, g = l.length; d < g; d++) { m.push(this.formatValue(l[d], b)) } return (m.length > 0) ? m.join(", ") : "none" } } } } return l }, getCustomValue: function (d, a) { var b = Ext.fly(this.activeElement), c = d.match(this.lengthUnitRegex)[1]; if (a === "x") { d = b.translateXY(parseInt(d, 10)).x } else { if (a === "y") { d = b.translateXY(null, parseInt(d, 10)).y } } return d + c } }, 1, 0, 0, 0, 0, 0, [Ext.fx.runner, "Css"], 0)); (Ext.cmd.derive("Ext.fx.runner.CssTransition", Ext.fx.runner.Css, { alternateClassName: "Ext.Animator", singleton: true, listenersAttached: false, constructor: function () { this.runningAnimationsData = {}; return this.callParent(arguments) }, attachListeners: function () { this.listenersAttached = true; Ext.getWin().on("transitionend", "onTransitionEnd", this) }, onTransitionEnd: function (b) { var a = b.target, c = a.id; if (c && this.runningAnimationsData.hasOwnProperty(c)) { this.refreshRunningAnimationsData(Ext.get(a), [b.browserEvent.propertyName]) } }, getElementId: function (a) { return a.getId ? a.getId() : a.id }, onAnimationEnd: function (h, g, d, k, o) { var c = this.getElementId(h), l = this.runningAnimationsData[c], p = {}, n = {}, b, j, e, m, a; d.un("stop", "onAnimationStop", this); if (l) { b = l.nameMap } p[c] = n; if (g.onBeforeEnd) { g.onBeforeEnd.call(g.scope || this, h, k) } d.fireEvent("animationbeforeend", d, h, k); this.fireEvent("animationbeforeend", this, d, h, k); if (o || (!k && !g.preserveEndState)) { j = g.toPropertyNames; for (e = 0, m = j.length; e < m; e++) { a = j[e]; if (b && !b.hasOwnProperty(a)) { n[a] = null } } } if (g.after) { Ext.merge(n, g.after) } this.applyStyles(p); if (g.onEnd) { g.onEnd.call(g.scope || this, h, k) } d.fireEvent("animationend", d, h, k); this.fireEvent("animationend", this, d, h, k); Ext.AnimationQueue.stop(Ext.emptyFn, d) }, onAllAnimationsEnd: function (b) { var c = this.getElementId(b), a = {}; delete this.runningAnimationsData[c]; a[c] = { "transition-property": null, "transition-duration": null, "transition-timing-function": null, "transition-delay": null }; this.applyStyles(a); this.fireEvent("animationallend", this, b) }, hasRunningAnimations: function (a) { var c = this.getElementId(a), b = this.runningAnimationsData; return b.hasOwnProperty(c) && b[c].sessions.length > 0 }, refreshRunningAnimationsData: function (d, l, u, q) { var h = this.getElementId(d), r = this.runningAnimationsData, a = r[h]; if (!a) { return } var n = a.nameMap, t = a.nameList, b = a.sessions, g, k, e, v, m, c, s, p, o = false; u = Boolean(u); q = Boolean(q); if (!b) { return this } g = b.length; if (g === 0) { return this } if (q) { a.nameMap = {}; t.length = 0; for (m = 0; m < g; m++) { c = b[m]; this.onAnimationEnd(d, c.data, c.animation, u, q) } b.length = 0 } else { for (m = 0; m < g; m++) { c = b[m]; s = c.map; p = c.list; for (k = 0, e = l.length; k < e; k++) { v = l[k]; if (s[v]) { delete s[v]; Ext.Array.remove(p, v); c.length--; if (--n[v] == 0) { delete n[v]; Ext.Array.remove(t, v) } } } if (c.length == 0) { b.splice(m, 1); m--; g--; o = true; this.onAnimationEnd(d, c.data, c.animation, u) } } } if (!q && !u && b.length == 0 && o) { this.onAllAnimationsEnd(d) } }, getRunningData: function (b) { var a = this.runningAnimationsData; if (!a.hasOwnProperty(b)) { a[b] = { nameMap: {}, nameList: [], sessions: [] } } return a[b] }, getTestElement: function () { var c = this, d = c.testElement, b = c.iframe, e, a; if (d) { if (d.ownerDocument.defaultView !== b.contentWindow) { b.contentDocument.body.appendChild(d); c.testElementComputedStyle = e.defaultView.getComputedStyle(d) } } else { b = c.iframe = document.createElement("iframe"); b.setAttribute("tabIndex", -1); a = b.style; a.setProperty("visibility", "hidden", "important"); a.setProperty("width", "0px", "important"); a.setProperty("height", "0px", "important"); a.setProperty("position", "absolute", "important"); a.setProperty("border", "0px", "important"); a.setProperty("zIndex", "-1000", "important"); document.body.appendChild(b); e = b.contentDocument; e.open(); e.writeln("</body>"); e.close(); c.testElement = d = e.createElement("div"); d.style.setProperty("position", "absolute", "important"); e.body.appendChild(d); c.testElementComputedStyle = e.defaultView.getComputedStyle(d) } return d }, getCssStyleValue: function (b, e) { var d = this.getTestElement(), a = this.testElementComputedStyle, c = d.style; c.setProperty(b, e); if (Ext.browser.is.Firefox) { d.offsetHeight } e = a.getPropertyValue(b); c.removeProperty(b); return e }, run: function (K) { var q = this, v = Ext.Function, x = q.lengthProperties, w = {}, h = {}, I = {}, C = {}, l, a, m, L, z, J, u, p, d, c, b, G, F, y, M, H, A, t, o, g, k, r, D, s, n, e, E, B; if (!q.listenersAttached) { q.attachListeners() } K = Ext.Array.from(K); for (G = 0, y = K.length; G < y; G++) { M = K[G]; M = Ext.factory(M, Ext.fx.Animation); q.activeElement = l = M.getElement(); Ext.AnimationQueue.start(Ext.emptyFn, M); t = window.getComputedStyle(l.dom); a = q.getElementId(l); I[a] = I = Ext.merge({}, M.getData()); if (M.onBeforeStart) { M.onBeforeStart.call(M.scope || q, l) } M.fireEvent("animationstart", M, I); q.fireEvent("animationstart", q, M, I); z = I.before; m = I.from; L = I.to; I.fromPropertyNames = J = []; I.toPropertyNames = u = []; for (g in L) { if (L.hasOwnProperty(g)) { L[g] = k = q.formatValue(L[g], g); o = q.formatName(g); s = x.hasOwnProperty(g); if (!s) { k = q.getCssStyleValue(o, k) } if (m.hasOwnProperty(g)) { m[g] = D = q.formatValue(m[g], g); if (!s) { D = q.getCssStyleValue(o, D) } if (k !== D) { J.push(o); u.push(o) } } else { r = t.getPropertyValue(o); if (k !== r) { u.push(o) } } } } H = u.length; if (H === 0) { q.onAnimationEnd(l, I, M); continue } c = q.getRunningData(a); E = c.sessions; if (E.length > 0) { q.refreshRunningAnimationsData(l, Ext.Array.merge(J, u), true, I.replacePrevious) } n = c.nameMap; e = c.nameList; A = {}; for (F = 0; F < H; F++) { g = u[F]; A[g] = true; if (!n.hasOwnProperty(g)) { n[g] = 1; e.push(g) } else { n[g]++ } } B = { element: l, map: A, list: u.slice(), length: H, data: I, animation: M }; E.push(B); M.on("stop", "onAnimationStop", q); b = Ext.apply({}, z); Ext.apply(b, m); if (e.length > 0) { J = Ext.Array.difference(e, J); u = Ext.Array.merge(J, u); b["transition-property"] = J } w[a] = b; h[a] = Ext.apply({}, L); C[a] = { "transition-property": u, "transition-duration": I.duration, "transition-timing-function": I.easing, "transition-delay": I.delay }; M.startTime = Date.now() } q.activeElement = null; d = q.$className; q.applyStyles(w); p = function (i) { if (i.data === d && i.source === window) { window.removeEventListener("message", p, false); q.applyStyles(h) } }; v.requestAnimationFrame(function () { if (Ext.isIE) { q.applyStyles(C); v.requestAnimationFrame(function () { window.addEventListener("message", p, false); window.postMessage(d, "*") }) } else { Ext.merge(h, C); window.addEventListener("message", p, false); window.postMessage(d, "*") } }) }, onAnimationStop: function (d) { var g = this.runningAnimationsData, j, a, h, b, c, e; for (j in g) { if (g.hasOwnProperty(j)) { a = g[j]; h = a.sessions; for (b = 0, c = h.length; b < c; b++) { e = h[b]; if (e.animation === d) { this.refreshRunningAnimationsData(e.element, e.list.slice(), false) } } } } } }, 1, 0, 0, 0, 0, 0, [Ext.fx.runner, "CssTransition", Ext, "Animator"], 0)); (Ext.cmd.derive("Ext.fx.Runner", Ext.Base, { constructor: function () { return new Ext.fx.runner.CssTransition() } }, 1, 0, 0, 0, 0, 0, [Ext.fx, "Runner"], 0)); (Ext.cmd.derive("Ext.fx.animation.Cube", Ext.fx.animation.Abstract, { config: { before: {}, after: {}, direction: "right", out: false }, getData: function () { var n = this.getTo(), o = this.getFrom(), l = this.getBefore(), a = this.getAfter(), e = this.getOut(), k = this.getDirection(), b = this.getElement(), h = b.getWidth(), c = b.getHeight(), m = e ? "100% 100%" : "0% 0%", j = 1, d = 1, g = { rotateY: 0, translateZ: 0 }, i = { rotateY: 0, translateZ: 0 }; if (k == "left" || k == "right") { if (e) { d = 0.5; i.translateZ = h; i.rotateY = -90 } else { j = 0.5; g.translateZ = h; g.rotateY = 90 } } l["transform-origin"] = m; a["transform-origin"] = null; n.set("transform", i); o.set("transform", g); o.set("opacity", j); n.set("opacity", d); return Ext.fx.animation.Abstract.prototype.getData.apply(this, arguments) } }, 0, 0, 0, 0, ["animation.cube"], 0, [Ext.fx.animation, "Cube"], 0)); (Ext.cmd.derive("Ext.fx.animation.Wipe", Ext.fx.Animation, { alternateClassName: "Ext.fx.animation.WipeIn", config: { easing: "ease-out", direction: "right", out: false }, refresh: function () { var i = this, a = i.getElement(), h = a.dom.getBoundingClientRect(), o = h.width, g = h.height, m = i.getFrom(), n = i.getTo(), d = i.getOut(), k = i.getDirection(), c = 0, b = 0, l = 0, j = 0, p, e; switch (k) { case "up": if (d) { p = "-webkit-gradient(linear, left top, left bottom, from(#000), to(transparent), color-stop(33%, #000), color-stop(66%, transparent))"; b = g * 3 + "px"; j = g + "px" } else { p = "-webkit-gradient(linear, left top, left bottom, from(transparent), to(#000), color-stop(66%, #000), color-stop(33%, transparent))"; b = -g * 2 + "px"; j = 0 } break; case "down": if (d) { p = "-webkit-gradient(linear, left top, left bottom, from(transparent), to(#000), color-stop(66%, #000), color-stop(33%, transparent))"; b = -g * 2 + "px"; j = 0 } else { p = "-webkit-gradient(linear, left top, left bottom, from(#000), to(transparent), color-stop(33%, #000), color-stop(66%, transparent))"; b = g * 3 + "px"; j = g + "px" } break; case "right": if (d) { p = "-webkit-gradient(linear, right top, left top, from(#000), to(transparent), color-stop(33%, #000), color-stop(66%, transparent))"; c = -o * 2 + "px"; l = 0 } else { p = "-webkit-gradient(linear, right top, left top, from(transparent), to(#000), color-stop(66%, #000), color-stop(33%, transparent))"; l = -o * 2 + "px" } break; case "left": if (d) { p = "-webkit-gradient(linear, right top, left top, from(transparent), to(#000), color-stop(66%, #000), color-stop(33%, transparent))"; l = -o * 2 + "px" } else { p = "-webkit-gradient(linear, right top, left top, from(#000), to(transparent), color-stop(33%, #000), color-stop(66%, transparent))"; c = -o * 2 + "px"; l = 0 } break }if (!d) { e = b; b = j; j = e; e = c; c = l; l = e } m.set("mask-image", p); m.set("mask-size", o * 3 + "px " + g * 3 + "px"); m.set("mask-position-x", c); m.set("mask-position-y", b); n.set("mask-position-x", l); n.set("mask-position-y", j) } }, 0, 0, 0, 0, 0, 0, [Ext.fx.animation, "Wipe", Ext.fx.animation, "WipeIn"], 0)); (Ext.cmd.derive("Ext.fx.animation.WipeOut", Ext.fx.animation.Wipe, { config: { out: true } }, 0, 0, 0, 0, 0, 0, [Ext.fx.animation, "WipeOut"], 0)); (Ext.cmd.derive("Ext.fx.easing.Bounce", Ext.fx.easing.Abstract, { config: { springTension: 0.3, acceleration: 30, startVelocity: 0 }, getValue: function () { var b = Ext.Date.now() - this.getStartTime(), c = (b / this.getAcceleration()), a = c * Math.pow(Math.E, -this.getSpringTension() * c); return this.getStartValue() + (this.getStartVelocity() * a) } }, 0, 0, 0, 0, 0, 0, [Ext.fx.easing, "Bounce"], 0)); (Ext.cmd.derive("Ext.fx.easing.Momentum", Ext.fx.easing.Abstract, { config: { acceleration: 30, friction: 0, startVelocity: 0 }, alpha: 0, updateFriction: function (b) { var a = Math.log(1 - (b / 10)); this.theta = a; this.alpha = a / this.getAcceleration() }, updateStartVelocity: function (a) { this.velocity = a * this.getAcceleration() }, updateAcceleration: function (a) { this.velocity = this.getStartVelocity() * a; this.alpha = this.theta / a }, getValue: function () { return this.getStartValue() - this.velocity * (1 - this.getFrictionFactor()) / this.theta }, getFrictionFactor: function () { var a = Ext.Date.now() - this.getStartTime(); return Math.exp(a * this.alpha) }, getVelocity: function () { return this.getFrictionFactor() * this.velocity } }, 0, 0, 0, 0, 0, 0, [Ext.fx.easing, "Momentum"], 0)); (Ext.cmd.derive("Ext.fx.easing.BoundMomentum", Ext.fx.easing.Abstract, { config: { momentum: null, bounce: null, minMomentumValue: 0, maxMomentumValue: 0, minVelocity: 0.01, startVelocity: 0 }, applyMomentum: function (a, b) { return Ext.factory(a, Ext.fx.easing.Momentum, b) }, applyBounce: function (a, b) { return Ext.factory(a, Ext.fx.easing.Bounce, b) }, updateStartTime: function (a) { this.getMomentum().setStartTime(a); Ext.fx.easing.Abstract.prototype.updateStartTime.apply(this, arguments) }, updateStartVelocity: function (a) { this.getMomentum().setStartVelocity(a) }, updateStartValue: function (a) { this.getMomentum().setStartValue(a) }, reset: function () { this.lastValue = null; this.isBouncingBack = false; this.isOutOfBound = false; return Ext.fx.easing.Abstract.prototype.reset.apply(this, arguments) }, getValue: function () { var a = this.getMomentum(), k = this.getBounce(), e = a.getStartVelocity(), g = e > 0 ? 1 : -1, h = this.getMinMomentumValue(), d = this.getMaxMomentumValue(), c = (g == 1) ? d : h, i = this.lastValue, j, b; if (e === 0) { return this.getStartValue() } if (!this.isOutOfBound) { j = a.getValue(); b = a.getVelocity(); if (Math.abs(b) < this.getMinVelocity()) { this.isEnded = true } if (j >= h && j <= d) { return j } this.isOutOfBound = true; k.setStartTime(Ext.Date.now()).setStartVelocity(b).setStartValue(c) } j = k.getValue(); if (!this.isEnded) { if (!this.isBouncingBack) { if (i !== null) { if ((g == 1 && j < i) || (g == -1 && j > i)) { this.isBouncingBack = true } } } else { if (Math.round(j) == c) { this.isEnded = true } } } this.lastValue = j; return j } }, 0, 0, 0, 0, 0, 0, [Ext.fx.easing, "BoundMomentum"], 0)); (Ext.cmd.derive("Ext.fx.easing.EaseIn", Ext.fx.easing.Linear, { config: { exponent: 4, duration: 1500 }, getValue: function () { var c = Ext.Date.now() - this.getStartTime(), h = this.getDuration(), b = this.getStartValue(), a = this.getEndValue(), i = this.distance, e = c / h, d = Math.pow(e, this.getExponent()), g = b + (d * i); if (c >= h) { this.isEnded = true; return a } return g } }, 0, 0, 0, 0, ["easing.ease-in"], 0, [Ext.fx.easing, "EaseIn"], 0)); (Ext.cmd.derive("Ext.fx.easing.EaseOut", Ext.fx.easing.Linear, { config: { exponent: 4, duration: 1500 }, getValue: function () { var g = Ext.Date.now() - this.getStartTime(), d = this.getDuration(), b = this.getStartValue(), i = this.getEndValue(), a = this.distance, c = g / d, h = 1 - c, e = 1 - Math.pow(h, this.getExponent()), j = b + (e * a); if (g >= d) { this.isEnded = true; return i } return j } }, 0, 0, 0, 0, ["easing.ease-out"], 0, [Ext.fx.easing, "EaseOut"], 0)); (Ext.cmd.derive("Ext.fx.easing.Easing", Ext.Base, { constructor: function (a) { return Ext.factory(a, Ext.fx.easing.Linear, null, "easing") } }, 1, 0, 0, 0, 0, 0, [Ext.fx.easing, "Easing"], 0)); (Ext.cmd.derive("Ext.fx.layout.card.Abstract", Ext.Evented, { isAnimation: true, config: { direction: "left", duration: null, reverse: null, layout: null }, updateLayout: function (a) { if (a) { this.enable() } }, enable: function () { var a = this.getLayout(); if (a) { a.on("beforeactiveitemchange", "onActiveItemChange", this) } }, disable: function () { var a = this.getLayout(); if (this.isAnimating) { this.stopAnimation() } if (a) { a.un("beforeactiveitemchange", "onActiveItemChange", this) } }, onActiveItemChange: Ext.emptyFn, destroy: function () { var b = this, a = b.getLayout(); if (b.isAnimating) { b.stopAnimation() } if (a) { a.un("beforeactiveitemchange", "onActiveItemChange", this) } b.setLayout(null); if (b.observableId) { b.fireEvent("destroy", this) } Ext.Evented.prototype.destroy.call(this) } }, 0, 0, 0, 0, 0, 0, [Ext.fx.layout.card, "Abstract"], 0)); (Ext.cmd.derive("Ext.fx.layout.card.Style", Ext.fx.layout.card.Abstract, { config: { inAnimation: { before: { visibility: null }, preserveEndState: false, replacePrevious: true }, outAnimation: { preserveEndState: false, replacePrevious: true } }, constructor: function (b) { var c, a; Ext.fx.layout.card.Abstract.prototype.constructor.call(this, b); this.endAnimationCounter = 0; c = this.getInAnimation(); a = this.getOutAnimation(); c.on("animationend", "incrementEnd", this); a.on("animationend", "incrementEnd", this) }, updateDirection: function (a) { this.getInAnimation().setDirection(a); this.getOutAnimation().setDirection(a) }, updateDuration: function (a) { this.getInAnimation().setDuration(a); this.getOutAnimation().setDuration(a) }, updateReverse: function (a) { this.getInAnimation().setReverse(a); this.getOutAnimation().setReverse(a) }, incrementEnd: function () { this.endAnimationCounter++; if (this.endAnimationCounter > 1) { this.endAnimationCounter = 0; this.fireEvent("animationend", this) } }, applyInAnimation: function (b, a) { return Ext.factory(b, Ext.fx.Animation, a) }, applyOutAnimation: function (b, a) { return Ext.factory(b, Ext.fx.Animation, a) }, updateInAnimation: function (a) { a.setScope(this) }, updateOutAnimation: function (a) { a.setScope(this) }, onActiveItemChange: function (g, d, i, b) { var h, a, e, c; if (d && i && i.isPainted()) { e = this.getInAnimation(); c = this.getOutAnimation(); h = d.renderElement; a = i.renderElement; e.setElement(h); c.setElement(a); c.setOnEnd(function () { b.resume() }); h.dom.style.setProperty("visibility", "hidden", "important"); d.show(); Ext.Animator.run([c, e]); b.pause() } }, destroy: function () { Ext.destroy(this.getInAnimation(), this.getOutAnimation()); Ext.fx.layout.card.Abstract.prototype.destroy.call(this) } }, 1, 0, 0, 0, 0, 0, [Ext.fx.layout.card, "Style"], 0)); (Ext.cmd.derive("Ext.fx.layout.card.Slide", Ext.fx.layout.card.Style, { config: { inAnimation: { type: "slide", easing: "ease-out" }, outAnimation: { type: "slide", easing: "ease-out", out: true } }, updateReverse: function (a) { this.getInAnimation().setReverse(a); this.getOutAnimation().setReverse(a) } }, 0, 0, 0, 0, ["fx.layout.card.slide"], 0, [Ext.fx.layout.card, "Slide"], 0)); (Ext.cmd.derive("Ext.fx.layout.card.Cover", Ext.fx.layout.card.Style, { config: { reverse: null, inAnimation: { before: { "z-index": 100 }, after: { "z-index": 0 }, type: "slide", easing: "ease-out" }, outAnimation: { easing: "ease-out", from: { opacity: 0.99 }, to: { opacity: 1 }, out: true } }, updateReverse: function (a) { this.getInAnimation().setReverse(a); this.getOutAnimation().setReverse(a) } }, 0, 0, 0, 0, ["fx.layout.card.cover"], 0, [Ext.fx.layout.card, "Cover"], 0)); (Ext.cmd.derive("Ext.fx.layout.card.Reveal", Ext.fx.layout.card.Style, { config: { inAnimation: { easing: "ease-out", from: { opacity: 0.99 }, to: { opacity: 1 } }, outAnimation: { before: { "z-index": 100 }, after: { "z-index": 0 }, type: "slide", easing: "ease-out", out: true } }, updateReverse: function (a) { this.getInAnimation().setReverse(a); this.getOutAnimation().setReverse(a) } }, 0, 0, 0, 0, ["fx.layout.card.reveal"], 0, [Ext.fx.layout.card, "Reveal"], 0)); (Ext.cmd.derive("Ext.fx.layout.card.Fade", Ext.fx.layout.card.Style, { config: { reverse: null, inAnimation: { type: "fade", easing: "ease-out" }, outAnimation: { type: "fade", easing: "ease-out", out: true } } }, 0, 0, 0, 0, ["fx.layout.card.fade"], 0, [Ext.fx.layout.card, "Fade"], 0)); (Ext.cmd.derive("Ext.fx.layout.card.Flip", Ext.fx.layout.card.Style, { config: { duration: 500, inAnimation: { type: "flip", half: true, easing: "ease-out", before: { "backface-visibility": "hidden" }, after: { "backface-visibility": null } }, outAnimation: { type: "flip", half: true, easing: "ease-in", before: { "backface-visibility": "hidden" }, after: { "backface-visibility": null }, out: true } }, onActiveItemChange: function (d, b, e, a) { var c = b.element.getParent(); c.addCls("x-layout-card-perspective"); this.on("animationend", function () { c.removeCls("x-layout-card-perspective") }, this, { single: true }); Ext.fx.layout.card.Style.prototype.onActiveItemChange.apply(this, arguments) }, updateDuration: function (d) { var c = d / 2, b = this.getInAnimation(), a = this.getOutAnimation(); b.setDelay(c); b.setDuration(c); a.setDuration(c) } }, 0, 0, 0, 0, ["fx.layout.card.flip"], 0, [Ext.fx.layout.card, "Flip"], 0)); (Ext.cmd.derive("Ext.fx.layout.card.Pop", Ext.fx.layout.card.Style, { config: { duration: 500, inAnimation: { type: "pop", easing: "ease-out" }, outAnimation: { type: "pop", easing: "ease-in", out: true } }, updateDuration: function (d) { var c = d / 2, b = this.getInAnimation(), a = this.getOutAnimation(); b.setDelay(c); b.setDuration(c); a.setDuration(c) } }, 0, 0, 0, 0, ["fx.layout.card.pop"], 0, [Ext.fx.layout.card, "Pop"], 0)); (Ext.cmd.derive("Ext.fx.layout.card.Scroll", Ext.fx.layout.card.Abstract, { config: { duration: 150 }, constructor: function (a) { this.initConfig(a) }, getEasing: function () { var a = this.easing; if (!a) { this.easing = a = new Ext.fx.easing.Linear() } return a }, updateDuration: function (a) { this.getEasing().setDuration(a) }, onActiveItemChange: function (a, d, m, c) { var j = this.getDirection(), h = this.getEasing(), l, e, b, i, k, g; if (d && m) { if (this.isAnimating) { this.stopAnimation() } d.setWidth("100%"); d.setHeight("100%"); l = this.getLayout().container.innerElement; i = l.getWidth(); k = l.getHeight(); e = d.renderElement; b = m.renderElement; this.oldItem = m; this.newItem = d; this.containerElement = l; this.currentEventController = c; this.isReverse = g = this.getReverse(); d.show(); if (j == "right") { j = "left"; this.isReverse = g = !g } else { if (j == "down") { j = "up"; this.isReverse = g = !g } } if (j == "left") { if (g) { h.setConfig({ startValue: i, endValue: 0 }); l.dom.scrollLeft = i; b.setLeft(i) } else { h.setConfig({ startValue: 0, endValue: i }); e.setLeft(i) } } else { if (g) { h.setConfig({ startValue: k, endValue: 0 }); l.dom.scrollTop = k; b.setTop(k) } else { h.setConfig({ startValue: 0, endValue: k }); e.setTop(k) } } this.startAnimation(); c.pause() } }, startAnimation: function () { this.isAnimating = true; this.getEasing().setStartTime(Date.now()); Ext.AnimationQueue.start(this.doAnimationFrame, this) }, doAnimationFrame: function () { var d = this.getEasing(), c = this.getDirection(), a = "scrollTop", b; if (c == "left" || c == "right") { a = "scrollLeft" } if (d.isEnded) { this.stopAnimation() } else { b = d.getValue(); this.containerElement.dom[a] = b } }, stopAnimation: function () { var c = this, e = c.getDirection(), a = "setTop", d = c.oldItem, b = c.newItem; if (e == "left" || e == "right") { a = "setLeft" } c.currentEventController.resume(); if (c.isReverse && d && d.renderElement && d.renderElement.dom) { d.renderElement[a](null) } else { if (b && b.renderElement && b.renderElement.dom) { b.renderElement[a](null) } } Ext.AnimationQueue.stop(this.doAnimationFrame, this); c.isAnimating = false; c.fireEvent("animationend", c) } }, 1, 0, 0, 0, ["fx.layout.card.scroll"], 0, [Ext.fx.layout.card, "Scroll"], 0)); (Ext.cmd.derive("Ext.fx.layout.Card", Ext.Base, { constructor: function (b) { var a = Ext.fx.layout.card.Abstract, c; if (!b) { return null } if (typeof b == "string") { c = b; b = {} } else { if (b.type) { c = b.type } } b.elementBox = false; if (c) { a = Ext.ClassManager.getByAlias("fx.layout.card." + c) } return Ext.factory(b, a) } }, 1, 0, 0, 0, 0, 0, [Ext.fx.layout, "Card"], 0)); (Ext.cmd.derive("Ext.fx.layout.card.Cube", Ext.fx.layout.card.Style, { config: { reverse: null, inAnimation: { type: "cube" }, outAnimation: { type: "cube", out: true } } }, 0, 0, 0, 0, ["fx.layout.card.cube"], 0, [Ext.fx.layout.card, "Cube"], 0)); (Ext.cmd.derive("Ext.fx.layout.card.ScrollCover", Ext.fx.layout.card.Scroll, { onActiveItemChange: function (c, h, d, e) { var i, a, k, j, b, g; this.currentEventController = e; this.inItem = h; if (h && d) { i = this.getLayout().container.innerElement; a = i.getSize(); k = this.calculateXY(a); j = { easing: this.getEasing(), duration: this.getDuration() }; h.renderElement.dom.style.setProperty("visibility", "hidden", "important"); b = h.setTranslatable(true).getTranslatable(); g = d.setTranslatable(true).getTranslatable(); g.translate({ x: 0, y: 0 }); b.translate({ x: k.left, y: k.top }); b.getWrapper().dom.style.setProperty("z-index", "100", "important"); h.show(); b.on({ animationstart: "onInAnimationStart", animationend: "onInAnimationEnd", scope: this }); b.translateAnimated({ x: 0, y: 0 }, j); e.pause() } }, onInAnimationStart: function () { this.inItem.renderElement.dom.style.removeProperty("visibility") }, onInAnimationEnd: function () { this.inItem.getTranslatable().getWrapper().dom.style.removeProperty("z-index"); this.currentEventController.resume() } }, 0, 0, 0, 0, ["fx.layout.card.scrollcover"], 0, [Ext.fx.layout.card, "ScrollCover"], 0)); (Ext.cmd.derive("Ext.fx.layout.card.ScrollReveal", Ext.fx.layout.card.Scroll, { onActiveItemChange: function (c, h, d, e) { var i, a, k, j, g, b; this.currentEventController = e; this.outItem = d; this.inItem = h; if (h && d) { i = this.getLayout().container.innerElement; a = i.getSize(); k = this.calculateXY(a); j = { easing: this.getEasing(), duration: this.getDuration() }; g = d.setTranslatable(true).getTranslatable(); b = h.setTranslatable(true).getTranslatable(); g.getWrapper().dom.style.setProperty("z-index", "100", "important"); g.translate({ x: 0, y: 0 }); b.translate({ x: 0, y: 0 }); h.show(); g.on({ animationend: "onOutAnimationEnd", scope: this }); g.translateAnimated({ x: k.x, y: k.y }, j); e.pause() } }, onOutAnimationEnd: function () { this.outItem.getTranslatable().getWrapper().dom.style.removeProperty("z-index"); this.currentEventController.resume() } }, 0, 0, 0, 0, ["fx.layout.card.scrollreveal"], 0, [Ext.fx.layout.card, "ScrollReveal"], 0)); (Ext.cmd.derive("Ext.fx.runner.CssAnimation", Ext.fx.runner.Css, { constructor: function () { this.runningAnimationsMap = {}; this.elementEndStates = {}; this.animationElementMap = {}; this.keyframesRulesCache = {}; this.uniqueId = 0; return Ext.fx.runner.Css.prototype.constructor.apply(this, arguments) }, attachListeners: function () { this.listenersAttached = true; Ext.getWin().on({ animationstart: "onAnimationStart", animationend: "onAnimationEnd", scope: this }) }, onAnimationStart: function (h) { var b = h.browserEvent.animationName, a = this.animationElementMap[b], g = this.runningAnimationsMap[a][b], i = this.elementEndStates, c = i[a], d = {}; if (c) { delete i[a]; d[a] = c; this.applyStyles(d) } if (g.before) { d[a] = g.before; this.applyStyles(d) } }, onAnimationEnd: function (j) { var c = j.target, b = j.browserEvent.animationName, d = this.animationElementMap, a = d[b], g = this.runningAnimationsMap, i = g[a], h = i[b]; if (h.onBeforeEnd) { h.onBeforeEnd.call(h.scope || this, c) } if (h.onEnd) { h.onEnd.call(h.scope || this, c) } delete d[b]; delete i[b]; this.removeKeyframesRule(b) }, generateAnimationId: function () { return "animation-" + (++this.uniqueId) }, run: function (g) { var t = {}, u = this.elementEndStates, p = this.animationElementMap, s = this.runningAnimationsMap, b, d, j, l, q, h, r, v, n, m, c, e, a, k, o; if (!this.listenersAttached) { this.attachListeners() } g = Ext.Array.from(g); for (q = 0, h = g.length; q < h; q++) { r = g[q]; r = Ext.factory(r, Ext.fx.Animation); j = r.getElement().getId(); l = r.getName() || this.generateAnimationId(); p[l] = j; r = r.getData(); d = r.states; this.addKeyframesRule(l, d); b = s[j]; if (!b) { b = s[j] = {} } b[l] = r; m = []; c = []; e = []; a = []; k = []; o = []; for (v in b) { if (b.hasOwnProperty(v)) { n = b[v]; m.push(v); c.push(n.duration); e.push(n.easing); a.push(n.delay); k.push(n.direction); o.push(n.iteration) } } t[j] = { "animation-name": m, "animation-duration": c, "animation-timing-function": e, "animation-delay": a, "animation-direction": k, "animation-iteration-count": o }; if (r.preserveEndState) { u[j] = d["100%"] } } this.applyStyles(t) }, addKeyframesRule: function (a, c) { var l, e, b, h, j, k, d, i, g; h = this.getStyleSheet(); j = h.cssRules; d = j.length; h.insertRule("@" + this.vendorPrefix + "keyframes " + a + "{}", d); b = j[d]; for (l in c) { e = c[l]; j = b.cssRules; d = j.length; k = []; for (i in e) { g = this.formatValue(e[i], i); i = this.formatName(i); k.push(i + ":" + g) } b.insertRule(l + "{" + k.join(";") + "}", d) } return this }, removeKeyframesRule: function (a) { var g = this.getStyleSheet(), e = g.cssRules, b, c, d; for (b = 0, c = e.length; b < c; b++) { d = e[b]; if (d.name === a) { g.removeRule(b); break } } return this } }, 1, 0, 0, 0, 0, 0, [Ext.fx.runner, "CssAnimation"], 0)); (Ext.cmd.derive("Ext.list.AbstractTreeItem", Ext.Widget, { isTreeListItem: true, cachedConfig: { expandable: false, expanded: false, iconCls: "", leaf: true, loading: false, selected: false, selectedParent: false }, config: { iconClsProperty: "iconCls", indent: null, owner: null, node: null, over: null, parentItem: null, text: { lazy: true, $value: "" }, textProperty: "text" }, updateNode: function (d) { if (d) { var h = this, a = h.itemMap, j, b, g, e, k, c; h.element.dom.setAttribute("data-recordId", d.internalId); if (!a) { j = d.childNodes; b = h.getOwner(); h.itemMap = a = {}; for (e = 0, g = j.length; e < g; ++e) { c = j[e]; if (c.data.visible) { k = b.createItem(c, h); a[c.internalId] = k; h.insertItem(k, null) } } } h.setExpanded(d.isExpanded()); h.doNodeUpdate(d) } }, updateSelected: function (b) { if (!this.isConfiguring) { var a = this.getParentItem(); while (a && !a.isRootListItem) { a.setSelectedParent(b); a = a.getParentItem() } } }, collapse: function () { this.getNode().collapse() }, expand: function () { this.getNode().expand() }, getToolElement: Ext.emptyFn, insertItem: Ext.emptyFn, isExpanded: function () { return this.getExpanded() }, isSelectionEvent: Ext.emptyFn, isToggleEvent: Ext.emptyFn, nodeCollapse: function (c, e) { var b = this, a = b.getOwner(), d = b.preventAnimation ? null : a.getAnimation(); b.nodeCollapseBegin(d, e); if (!d) { b.nodeCollapseEnd(e) } }, nodeCollapseBegin: function (c, d) { var b = this, a = b.getOwner(); b.setExpanded(false); a.fireEvent("itemcollapse", a, b) }, nodeCollapseEnd: function (a) { if (!a) { this.getOwner().updateLayout() } }, nodeExpand: function (c) { var b = this, a = b.getOwner(), e = b.getFloated(), d = !e && a.getAnimation(); b.nodeExpandBegin(d); if (!d) { b.nodeExpandEnd() } }, nodeExpandBegin: function (c) { var b = this, a = b.getOwner(); b.setExpanded(true); a.fireEvent("itemexpand", a, b) }, nodeExpandEnd: function () { this.getOwner().updateLayout() }, nodeInsert: function (d, g) { var h = this, c = h.getOwner(), a = h.itemMap, b = d.internalId, j = c.getItem(d), e = null, i; if (j) { i = j.getParentItem(); i.removeItem(j); if (i !== h) { i.doUpdateExpandable(); j.setParentItem(h) } } else { j = h.getOwner().createItem(d, h) } a[b] = j; if (g) { e = a[g.internalId] } h.insertItem(j, e); h.doUpdateExpandable(); c.fireEvent("iteminsert", c, h, j, e); c.updateLayout() }, nodeRemove: function (d) { var c = this, e = c.itemMap, a = c.getOwner(), g = d.internalId, b = e[g]; if (b) { delete e[g]; c.removeItem(b); b.destroy(); c.doUpdateExpandable(); a.fireEvent("itemremove", a, c, b); a.updateLayout() } }, nodeUpdate: function (b, a) { this.doNodeUpdate(b) }, removeItem: Ext.emptyFn, destroy: function () { var c = this, d = c.itemMap, a = c.getOwner(), b; if (d) { for (b in d) { d[b].destroy() } c.itemMap = null } if (a) { a.removeItem(c.getNode()) } c.setNode(null); c.setParentItem(null); c.setOwner(null); Ext.Widget.prototype.destroy.call(this) }, privates: { doNodeUpdate: function (d) { var c = this, b = this.getTextProperty(), a = this.getIconClsProperty(); if (b) { c.setText(d.data[b]) } if (a) { c.setIconCls(d.data[a]) } c.setLoading(d.isLoading()); c.setLeaf(d.isLeaf()); c.doUpdateExpandable() }, doUpdateExpandable: function () { var a = this.getNode(); this.setExpandable(a.isExpandable()) }, onClick: function (g) { var c = this, a = c.getOwner(), b = c.getNode(), d = { event: g, item: c, node: b, tree: a, select: b.get("selectable") !== false && c.isSelectionEvent(g), toggle: c.isToggleEvent(g) }; if (a.fireEvent("itemclick", a, d) !== false) { if (d.toggle) { c.toggleExpanded(); g.preventDefault() } if (d.select) { a.setSelection(c.getNode()) } } }, toggleExpanded: function () { if (this.isExpanded()) { this.collapse() } else { this.expand() } }, updateIndent: function (b) { var a = this.itemMap, c; for (c in a) { a[c].setIndent(b) } }, updateOwner: function (a) { this.parent = a } } }, 0, 0, ["widget"], { widget: true }, 0, 0, [Ext.list, "AbstractTreeItem"], 0)); (Ext.cmd.derive("Ext.list.RootTreeItem", Ext.list.AbstractTreeItem, { isRootListItem: true, element: { reference: "element", tag: "ul", cls: "x-treelist-root-container" }, insertItem: function (b, a) { if (a) { b.element.insertBefore(a.element) } else { this.element.appendChild(b.element) } }, isToggleEvent: function (a) { return false } }, 0, 0, ["widget"], { widget: true }, 0, 0, [Ext.list, "RootTreeItem"], 0)); (Ext.cmd.derive("Ext.list.TreeItem", Ext.list.AbstractTreeItem, { collapsedCls: "x-treelist-item-collapsed", expandedCls: "x-treelist-item-expanded", floatedCls: [Ext.Widget.prototype.floatedCls, "x-treelist-item-floated"], floatedToolCls: "x-treelist-item-tool-floated", leafCls: "x-treelist-item-leaf", expandableCls: "x-treelist-item-expandable", hideIconCls: "x-treelist-item-hide-icon", loadingCls: "x-treelist-item-loading", selectedCls: "x-treelist-item-selected", selectedParentCls: "x-treelist-item-selected-parent", withIconCls: "x-treelist-item-with-icon", hoverCls: "x-treelist-item-over", rowHoverCls: "x-treelist-row-over", isTreeListItem: true, config: { rowCls: null }, rowClsProperty: "rowCls", element: { reference: "element", tag: "li", cls: "x-treelist-item", children: [{ reference: "rowElement", cls: "x-treelist-row", children: [{ reference: "wrapElement", cls: "x-treelist-item-wrap", children: [{ reference: "iconElement", cls: "x-treelist-item-icon" }, { reference: "textElement", cls: "x-treelist-item-text" }, { reference: "expanderElement", cls: "x-treelist-item-expander" }] }] }, { reference: "itemContainer", tag: "ul", cls: "x-treelist-container" }, { reference: "toolElement", cls: "x-treelist-item-tool" }] }, constructor: function (a) { Ext.list.AbstractTreeItem.prototype.constructor.call(this, a); var b = this.toolElement.dom; b.parentNode.removeChild(b) }, getToolElement: function () { return this.toolElement }, insertItem: function (b, a) { if (a) { b.element.insertBefore(a.element) } else { this.itemContainer.appendChild(b.element) } }, isSelectionEvent: function (b) { var a = this.getOwner(); return (!this.isToggleEvent(b) || !a.getExpanderOnly() || a.getSelectOnExpander()) }, isToggleEvent: function (b) { var a = false; if (this.getOwner().getExpanderOnly()) { a = b.target === this.expanderElement.dom } else { a = !this.itemContainer.contains(b.target) } return a }, nodeCollapseBegin: function (d, e) { var c = this, b = c.itemContainer, a; if (c.expanding) { c.stopAnimation(c.expanding) } a = d && b.getHeight(); Ext.list.AbstractTreeItem.prototype.nodeCollapseBegin.call(this, d, e); if (d) { b.dom.style.display = "block"; c.collapsingForExpand = e; c.collapsing = this.runAnimation(Ext.merge({ from: { height: a }, to: { height: 0 }, callback: c.nodeCollapseDone, scope: c }, d)) } }, nodeCollapseDone: function (c) { var b = this, a = b.itemContainer; b.collapsing = null; a.dom.style.display = ""; a.setHeight(null); b.nodeCollapseEnd(b.collapsingForExpand) }, nodeExpandBegin: function (d) { var c = this, b = c.itemContainer, a; if (c.collapsing) { c.stopAnimation(c.collapsing) } Ext.list.AbstractTreeItem.prototype.nodeExpandBegin.call(this, d); if (d) { a = b.getHeight(); b.setHeight(0); c.expanding = c.runAnimation(Ext.merge({ to: { height: a }, callback: c.nodeExpandDone, scope: c }, d)) } }, nodeExpandDone: function () { this.expanding = null; this.itemContainer.setHeight(null); this.nodeExpandEnd() }, removeItem: function (a) { this.itemContainer.removeChild(a.element) }, updateNode: function (a, b) { this.syncIndent(); Ext.list.AbstractTreeItem.prototype.updateNode.call(this, a, b) }, updateExpandable: function () { this.updateExpandCls() }, updateExpanded: function () { this.updateExpandCls() }, updateIconCls: function (b, a) { var d = this, c = d.element; d.doIconCls(d.iconElement, b, a); d.doIconCls(d.toolElement, b, a); c.toggleCls(d.withIconCls, !!b); c.toggleCls(d.hideIconCls, b === null) }, updateLeaf: function (a) { this.element.toggleCls(this.leafCls, a) }, updateLoading: function (a) { this.element.toggleCls(this.loadingCls, a) }, updateOver: function (b) { var a = this; a.element.toggleCls(a.hoverCls, !!b); a.rowElement.toggleCls(a.rowHoverCls, b > 1) }, updateRowCls: function (b, a) { this.rowElement.replaceCls(a, b) }, updateSelected: function (c, e) { var d = this, a = d.selectedCls, b = d.getToolElement(); Ext.list.AbstractTreeItem.prototype.updateSelected.call(this, c, e); d.element.toggleCls(a, c); if (b) { b.toggleCls(a, c) } }, updateSelectedParent: function (b) { var c = this; c.element.toggleCls(c.selectedParentCls, b); var a = c.getToolElement(); if (a) { a.toggleCls(c.selectedCls, b) } }, updateText: function (a) { this.textElement.update(a) }, privates: { doNodeUpdate: function (a) { Ext.list.AbstractTreeItem.prototype.doNodeUpdate.call(this, a); this.setRowCls(a && a.data[this.rowClsProperty]) }, doIconCls: function (c, b, a) { if (a) { c.removeCls(a) } if (b) { c.addCls(b) } }, syncIndent: function () { var c = this, a = c.getIndent(), b = c.getNode(), d; if (b) { d = b.data.depth - 1; c.wrapElement.dom.style.marginLeft = (d * a) + "px" } }, updateExpandCls: function () { if (!this.updatingExpandCls) { var e = this, c = e.getExpandable(), d = e.element, b = e.getExpanded(), a = e.expandedCls, g = e.collapsedCls; e.updatingExpandCls = true; d.toggleCls(e.expandableCls, c); if (c) { d.toggleCls(a, b); d.toggleCls(g, !b) } else { d.removeCls([a, g]) } e.updatingExpandCls = false } }, updateIndent: function (b, a) { this.syncIndent(); Ext.list.AbstractTreeItem.prototype.updateIndent.call(this, b, a) } } }, 1, ["treelistitem"], ["widget", "treelistitem"], { widget: true, treelistitem: true }, ["widget.treelistitem"], 0, [Ext.list, "TreeItem"], 0)); Ext.define("Ext.overrides.list.TreeItem", { override: "Ext.list.TreeItem", config: { floated: null }, setFloated: function (e) { var d = this, b = d.element, g = d.placeholder, c, a; if (d.treeItemFloated !== e) { if (e) { g = b.clone(false, true); g.id += "-placeholder"; d.placeholder = Ext.get(g); d.wasExpanded = d.getExpanded(); d.setExpanded(true); b.addCls(d.floatedCls); b.dom.parentNode.insertBefore(g, b.dom); d.floater = d.createFloater() } else { if (g) { a = d.wasExpanded; c = d.getNode(); d.setExpanded(a); if (!a && c.isExpanded()) { d.preventAnimation = true; c.collapse(); d.preventAnimation = false } d.floater.remove(d, false); b.removeCls(d.floatedCls); g.dom.parentNode.insertBefore(b.dom, g.dom); g.destroy(); d.floater.destroy(); d.placeholder = d.floater = null } } d.treeItemFloated = e } }, getFloated: function () { return this.treeItemFloated }, runAnimation: function (a) { return this.itemContainer.addAnimation(a) }, stopAnimation: function (a) { a.jumpToEnd() }, privates: { createFloater: function () { var d = this, a = d.getOwner(), b = d.up("treelist"), c, e = d.getToolElement(); d.floater = c = new Ext.container.Container({ cls: b.self.prototype.element.cls + " " + b.uiPrefix + b.getUi() + " x-treelist-floater", floating: true, width: Ext.isIE8 ? 200 : (b.expandedWidth - e.getWidth()), shadow: false, renderTo: Ext.getBody(), listeners: { element: "el", click: function (g) { return a.onClick(g) } } }); c.add(d); c.show(); c.el.alignTo(e, "tr?"); return c } } }); (Ext.cmd.derive("Ext.list.Tree", Ext.Widget, { expanderFirstCls: "x-treelist-expander-first", expanderOnlyCls: "x-treelist-expander-only", highlightPathCls: "x-treelist-highlight-path", microCls: "x-treelist-micro", uiPrefix: "x-treelist-", element: { reference: "element", cls: "x-treelist x-unselectable", listeners: { click: "onClick", mouseenter: "onMouseEnter", mouseleave: "onMouseLeave", mouseover: "onMouseOver" }, children: [{ reference: "toolsElement", cls: "x-treelist-toolstrip", listeners: { click: "onToolStripClick", mouseover: "onToolStripMouseOver" } }] }, cachedConfig: { animation: { duration: 500, easing: "ease" }, expanderFirst: true, expanderOnly: true }, config: { defaults: { xtype: "treelistitem" }, highlightPath: null, iconSize: null, indent: null, micro: false, overItem: null, selection: null, selectOnExpander: false, singleExpand: null, store: null, ui: null }, twoWayBindable: { selection: 1 }, publishes: { selection: 1 }, defaultBindProperty: "store", constructor: function (a) { var b = this; Ext.Widget.prototype.constructor.call(this, a); b.publishState("selection", b.getSelection()); if (!Ext.isIE8) { b.el.on({ resize: b.onElResize, buffer: 300, scope: b }) } }, beforeLayout: function () { this.syncIconSize() }, destroy: function () { var a = this; a.destroying = true; a.unfloatAll(); a.activeFloater = null; a.setSelection(null); a.setStore(null); Ext.Widget.prototype.destroy.call(this) }, updateOverItem: function (g, a) { var e = {}, d = 2, h, b; for (h = g; h; h = this.getItem(b.parentNode)) { b = h.getNode(); e[b.internalId] = true; h.setOver(d); d = 1 } if (a) { for (h = a; h; h = this.getItem(b.parentNode)) { b = h.getNode(); if (e[b.internalId]) { break } h.setOver(0) } } }, applyMicro: function (a) { return Boolean(a) }, applySelection: function (c, a) { var b = this.getStore(); if (!b) { c = null } if (c && c.get("selectable") === false) { c = a } return c }, updateSelection: function (b, a) { var d = this, c; if (!d.destroying) { c = d.getItem(a); if (c) { c.setSelected(false) } c = d.getItem(b); if (c) { c.setSelected(true) } d.fireEvent("selectionchange", d, b) } }, applyStore: function (a) { return a && Ext.StoreManager.lookup(a, "tree") }, updateStore: function (b, d) { var c = this, a; if (d) { if (!d.destroyed) { if (d.getAutoDestroy()) { d.destroy() } else { c.storeListeners.destroy() } } c.removeRoot(); c.storeListeners = null } if (b) { c.storeListeners = b.on({ destroyable: true, scope: c, filterchange: "onFilterChange", nodeappend: "onNodeAppend", nodecollapse: "onNodeCollapse", nodeexpand: "onNodeExpand", nodeinsert: "onNodeInsert", noderemove: "onNodeRemove", rootchange: "onRootChange", update: "onNodeUpdate" }); a = b.getRoot(); if (a) { c.createRootItem(a) } } if (!c.destroying) { c.updateLayout() } }, updateExpanderFirst: function (a) { this.element.toggleCls(this.expanderFirstCls, a) }, updateExpanderOnly: function (a) { this.element.toggleCls(this.expanderOnlyCls, !a) }, updateHighlightPath: function (a) { this.element.toggleCls(this.highlightPathCls, a) }, onElResize: function (b, a) { if (!this.getMicro()) { this.expandedWidth = a.width } }, updateMicro: function (a) { var b = this; if (!a) { b.unfloatAll(); b.activeFloater = null } b.element.toggleCls(b.microCls, a) }, updateUi: function (d, a) { var c = this.element, b = this.uiPrefix; if (a) { c.removeCls(b + a) } if (d) { c.addCls(b + d) } delete this.iconSize; this.syncIconSize() }, getItem: function (b) { var c = this.itemMap, a; if (b && c) { a = c[b.internalId] } return a || null }, getItemConfig: function (b, a) { return Ext.apply({ parentItem: a.isRootListItem ? null : a, owner: this, node: b, indent: this.getIndent() }, this.getDefaults()) }, privates: { checkForOutsideClick: function (b) { var a = this.activeFloater; if (!a.element.contains(b.target)) { this.unfloatAll() } }, collapsingForExpand: false, createItem: function (g, b) { var e = this, d = Ext.create(e.getItemConfig(g, b)), h = e.toolsElement, a, c; if (b.isRootListItem) { a = d.getToolElement(); if (a) { c = e.findVisiblePreviousSibling(g); if (!c) { h.insertFirst(a) } else { c = e.getItem(c); a.insertAfter(c.getToolElement()) } a.dom.setAttribute("data-recordId", g.internalId); a.isTool = true } } e.itemMap[g.internalId] = d; return d }, createRootItem: function (a) { var c = this, b; c.itemMap = {}; c.rootItem = b = new Ext.list.RootTreeItem({ indent: c.getIndent(), node: a, owner: c }); c.element.appendChild(b.element); c.itemMap[a.internalId] = b }, findVisiblePreviousSibling: function (b) { var a = b.previousSibling; while (a) { if (a.data.visible) { return a } a = a.previousSibling } return null }, floatItem: function (d, b) { var c = this, a; if (d.getFloated()) { return } if (c.toolMouseListeners) { c.toolMouseListeners.destroy(); c.floaterMouseListeners.destroy() } c.unfloatAll(); c.activeFloater = a = d; c.floatedByHover = b; d.setFloated(true); if (b) { c.toolMouseListeners = d.getToolElement().monitorMouseLeave(300, c.checkForMouseLeave, c); c.floaterMouseListeners = (d.floater || d).el.monitorMouseLeave(300, c.checkForMouseLeave, c) } else { Ext.on("mousedown", "checkForOutsideClick", c) } }, onClick: function (b) { var a = b.getTarget("[data-recordId]"), c; if (a) { c = a.getAttribute("data-recordId"); a = this.itemMap[c]; if (a) { a.onClick(b) } } }, onMouseEnter: function (a) { this.onMouseOver(a) }, onMouseLeave: function () { this.setOverItem(null) }, onMouseOver: function (b) { var a = Ext.Component.fromElement(b.getTarget()); this.setOverItem(a && a.isTreeListItem && a) }, checkForMouseLeave: function (c) { var b = this.activeFloater, a = c.getRelatedTarget(); if (b) { if (a !== b.getToolElement().dom && !b.element.contains(a)) { this.unfloatAll() } } }, onFilterChange: function (a) { this.onRootChange(a.getRoot()) }, onNodeAppend: function (a, c) { if (a) { var b = this.itemMap[a.internalId]; if (b) { b.nodeInsert(c, null) } } }, onNodeCollapse: function (b) { var a = this.itemMap[b.internalId]; if (a) { a.nodeCollapse(b, this.collapsingForExpand) } }, onNodeExpand: function (g) { var e = this, d = e.itemMap[g.internalId], h, b, c, a, j; if (d) { if (!d.isRootItem && e.getSingleExpand()) { e.collapsingForExpand = true; a = (d.getParentItem() || e.rootItem).getNode(); h = a.childNodes; for (c = 0, b = h.length; c < b; ++c) { j = h[c]; if (j !== g) { j.collapse() } } e.collapsing = false } d.nodeExpand(g) } }, onNodeInsert: function (a, d, b) { var c = this.itemMap[a.internalId]; if (c) { c.nodeInsert(d, b) } }, onNodeRemove: function (a, d, b) { if (a && !b) { var c = this.itemMap[a.internalId]; if (c) { c.nodeRemove(d) } } }, onNodeUpdate: function (a, e, b, d) { var c = this.itemMap[e.internalId]; if (c) { c.nodeUpdate(e, d) } }, onRootChange: function (a) { var b = this; b.removeRoot(); if (a) { b.createRootItem(a) } b.updateLayout(); b.fireEvent("refresh", b) }, removeItem: function (c) { var d = this.itemMap, e = c.internalId, b, a; if (d) { b = d[e]; if (b.getParentItem() === null) { a = b.getToolElement(); if (a) { this.toolsElement.removeChild(a) } } delete d[e] } }, removeRoot: function () { var b = this, a = b.rootItem; if (a) { b.element.removeChild(a.element); b.rootItem = b.itemMap = Ext.destroy(a) } }, onToolStripClick: function (b) { var a = b.getTarget("[data-recordId]"), c; if (a) { c = a.getAttribute("data-recordId"); a = this.itemMap[c]; if (a) { if (a === this.activeFloater) { this.unfloatAll() } else { this.floatItem(a, false) } } } }, onToolStripMouseOver: function (b) { var a = b.getTarget("[data-recordId]"), c; if (a) { c = a.getAttribute("data-recordId"); a = this.itemMap[c]; if (a) { this.floatItem(a, true) } } }, syncIconSize: function () { var b = this, a = b.iconSize || (b.iconSize = parseInt(b.element.getStyle("background-position"), 10)); b.setIconSize(a) }, unfloatAll: function () { var b = this, a = b.activeFloater; if (a) { a.setFloated(false); b.activeFloater = null; if (b.floatedByHover) { a.getToolElement().un("mouseleave", "checkForMouseLeave", b); a.element.un({ scope: b, mouseleave: "checkForMouseLeave", mouseover: "onMouseOver" }) } else { Ext.un("mousedown", "checkForOutsideClick", b) } } }, defaultIconSize: 22, updateIconSize: function (a) { this.setIndent(a || this.defaultIconSize) }, updateIndent: function (b) { var a = this.rootItem; if (a) { a.setIndent(b) } } } }, 1, ["treelist"], ["widget", "treelist"], { widget: true, treelist: true }, ["widget.treelist"], 0, [Ext.list, "Tree"], 0)); (Ext.cmd.derive("Ext.mixin.ConfigState", Ext.Mixin, { mixinConfig: { id: "configstate" }, alternateStateConfig: "", toggleConfigState: function (a) { var d = this, e = d.capturedConfigState, b = d.getConfig(d.alternateStateConfig), c; if (!b) { return } if (a) { e = {}; for (c in b) { e[c] = d.getConfig(c) } d.capturedConfigState = e; d.setConfig(b) } else { if (!d.isConfiguring && e) { d.setConfig(e); delete d.capturedConfigState } } } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "ConfigState"], 0)); (Ext.cmd.derive("Ext.mixin.Container", Ext.Mixin, { mixinConfig: { id: "container" }, isContainer: true, config: { referenceHolder: false }, getReferences: function () { Ext.ComponentManager.fixReferences(); return this.refs || null }, lookup: function (b) { var a = this.getReferences(); return (a && a[b]) || null }, lookupReference: function (a) { return this.lookup(a) }, privates: { attachReference: function (b) { var d = this, c, a; if (d.destroying || d.destroyed) { return } a = d.refs || (d.refs = {}); c = b.referenceKey; a[c] = b }, clearReference: function (b) { var a = this.refs, c = b.referenceKey; if (a && c) { b.viewModelKey = b.referenceKey = a[c] = null } }, containerOnAdded: function (b, a) { if (a) { Ext.ComponentManager.markReferencesDirty() } }, containerOnRemoved: function (a) { var b; if (!a) { b = this.lookupReferenceHolder(); if (b) { Ext.ComponentManager.markReferencesDirty(); b.clearReferences() } } }, clearReferences: function () { this.refs = null }, initContainerInheritedState: function (e, c) { var h = this, b = h.getController(), i = h.getSession(), d = h.getConfig("viewModel", true), a = h.getReference(), g = h.getReferenceHolder(); if (b) { e.referenceHolder = b; g = true } else { if (g) { e.referenceHolder = h } } if (g) { e.referencePath = "" } else { if (a && h.isParentReference) { e.referencePath = h.referenceKey + "." } } if (i) { e.session = i } if (d) { e.viewModelPath = "" } else { if (a && h.isParentReference) { e.viewModelPath = h.viewModelKey + "." } } }, setupReference: function (b) { var a; if (b && b.charAt(a = b.length - 1) === ">") { this.isParentReference = true; b = b.substring(0, a) } return b } } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "Container"], 0)); (Ext.cmd.derive("Ext.mixin.Hookable", Ext.Mixin, { mixinConfig: { id: "hookable" }, bindHook: function (a, d, i, c, b) { if (!i) { i = d } var g = a[d], e, h; if (g && g.hasOwnProperty("$binding")) { h = g.$binding; if (h.bindingMethod === i && h.bindingScope === this) { return this } } a[d] = e = function () { var l = e.$binding, k = l.bindingScope, j = Array.prototype.slice.call(arguments); j.push(arguments); if (b) { j.push.apply(j, b) } if (!l.preventDefault && k[l.bindingMethod].apply(k, j) !== false) { return l.boundFn.apply(this, arguments) } }; e.$binding = { preventDefault: !!c, boundFn: g, bindingMethod: i, bindingScope: this }; return this }, unbindHook: function (a, b, h) { if (!h) { h = b } var d = a[b], e = d.$binding, c, g; while (e) { c = e.boundFn; if (e.bindingMethod === h && e.bindingScope === this) { if (g) { g.boundFn = c } else { a[b] = c } return this } g = e; e = c.$binding } return this } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "Hookable"], 0)); Ext.define("Ext.mixin.Mashup", function (a) { return { extend: "Ext.Mixin", mixinConfig: { id: "mashup", extended: function (c, b) { a.process(b) } }, statics: { process: function (e) { var c = e.prototype, g = c.requiredScripts, b = e._classHooks, d = b.onCreated; if (g) { delete c.requiredScripts; b.onCreated = function () { var i = this, h = Ext.Array.slice(arguments); Ext.Loader.loadScripts({ url: g, cache: true, onLoad: function () { b.onCreated = d; b.onCreated.call(i, h) } }) } } } }, onClassMixedIn: function (b) { a.process(b) } } }); (Ext.cmd.derive("Ext.mixin.Responsive", Ext.Mixin, function (a) { return { mixinConfig: { id: "responsive", after: { destroy: "destroy" } }, config: { responsiveConfig: { $value: undefined, merge: function (h, c, g, e) { if (!h) { return c } var b = c ? Ext.Object.chain(c) : {}, d; for (d in h) { if (!e || !(d in b)) { b[d] = { fn: null, config: h[d] } } } return b } }, responsiveFormulas: { $value: 0, merge: function (e, b, d, c) { return this.mergeNew(e, b, d, c) } } }, destroy: function () { a.unregister(this) }, privates: { statics: { active: false, all: {}, context: Ext.Object.chain(Ext.platformTags), count: 0, nextId: 0, activate: function () { a.active = true; a.updateContext(); Ext.on("resize", a.onResize, a) }, deactivate: function () { a.active = false; Ext.un("resize", a.onResize, a) }, notify: function () { var d = a.all, c = a.context, b = Ext.GlobalEvents, g = a.timer, e; if (g) { a.timer = null; Ext.asapCancel(g) } a.updateContext(); Ext.suspendLayouts(); b.fireEvent("beforeresponsiveupdate", c); for (e in d) { d[e].setupResponsiveContext() } b.fireEvent("beginresponsiveupdate", c); for (e in d) { d[e].updateResponsiveState() } b.fireEvent("responsiveupdate", c); Ext.resumeLayouts(true) }, onResize: function () { if (!a.timer) { a.timer = Ext.asap(a.onTimer) } }, onTimer: function () { a.timer = null; a.notify() }, processConfig: function (b, i, g) { var h = i && i[g], e = b.config, c, d; if (h) { d = b.self.getConfigurator(); c = d.configs[g]; e[g] = c.merge(h, e[g], b) } }, register: function (b) { var c = b.$responsiveId; if (!c) { b.$responsiveId = c = ++a.nextId; a.all[c] = b; if (++a.count === 1) { a.activate() } } }, unregister: function (b) { var c = b.$responsiveId; if (c in a.all) { b.$responsiveId = null; delete a.all[c]; if (--a.count === 0) { a.deactivate() } } }, updateContext: function () { var e = Ext.Element, d = e.getViewportWidth(), b = e.getViewportHeight(), c = a.context; c.width = d; c.height = b; c.tall = d < b; c.wide = !c.tall; c.landscape = c.portrait = false; if (!c.platform) { c.platform = Ext.platformTags } c[Ext.dom.Element.getOrientation()] = true } }, afterClassMixedIn: function (g) { var e = g.prototype, b = e.responsiveConfig, d = e.responsiveFormulas, c; if (b || d) { c = {}; if (b) { delete e.responsiveConfig; c.responsiveConfig = b } if (d) { delete e.responsiveFormulas; c.responsiveFormulas = d } g.getConfigurator().add(c) } }, applyResponsiveConfig: function (c) { for (var b in c) { c[b].fn = Ext.createRuleFn(b) } return c }, applyResponsiveFormulas: function (d) { var c = {}, e, b; if (d) { for (b in d) { if (Ext.isString(e = d[b])) { e = Ext.createRuleFn(e) } c[b] = e } } return c }, getResponsiveState: function () { var c = a.context, g = this.getResponsiveConfig(), b = {}, d, e; if (g) { for (e in g) { d = g[e]; if (d.fn.call(this, c)) { Ext.merge(b, d.config) } } } return b }, setupResponsiveContext: function () { var c = this.getResponsiveFormulas(), d = a.context, b; if (c) { for (b in c) { d[b] = c[b].call(this, d) } } }, transformInstanceConfig: function (d) { var c = this, b; a.register(c); if (d) { a.processConfig(c, d, "responsiveConfig"); a.processConfig(c, d, "responsiveFormulas") } c.setupResponsiveContext(); b = c.getResponsiveState(); if (d) { b = Ext.merge({}, d, b); delete b.responsiveConfig; delete b.responsiveFormulas } return b }, updateResponsiveState: function () { var b = this.getResponsiveState(); this.setConfig(b) } } } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "Responsive"], 0)); (Ext.cmd.derive("Ext.mixin.Selectable", Ext.Mixin, { mixinConfig: { id: "selectable", after: { updateStore: "updateStore" } }, config: { disableSelection: null, mode: "SINGLE", allowDeselect: false, lastSelected: null, lastFocused: null, deselectOnContainerClick: true, selection: null, twoWayBindable: { selection: 1 }, publishes: { selection: 1 } }, modes: { SINGLE: true, SIMPLE: true, MULTI: true }, selectableEventHooks: { add: "onSelectionStoreAdd", remove: "onSelectionStoreRemove", update: "onSelectionStoreUpdate", clear: { fn: "onSelectionStoreClear", priority: 1000 }, load: "refreshSelection", refresh: "refreshSelection" }, constructor: function () { this.selected = new Ext.util.MixedCollection(); this.callParent(arguments) }, initSelectable: function () { this.publishState("selection", this.getSelection()) }, applyMode: function (a) { a = a ? a.toUpperCase() : "SINGLE"; return this.modes[a] ? a : "SINGLE" }, updateStore: function (a, c) { var b = this, d = Ext.apply({}, b.selectableEventHooks, { scope: b }); if (c && Ext.isObject(c) && c.isStore) { if (c.autoDestroy) { c.destroy() } else { c.un(d) } } if (a) { a.on(d); b.refreshSelection() } }, selectAll: function (a) { var c = this, b = c.getStore().getRange(); c.select(b, true, a) }, deselectAll: function (c) { var b = this, a = b.getStore().getRange(); b.deselect(a, c); b.selected.clear(); b.setLastSelected(null); b.setLastFocused(null) }, updateSelection: function (a) { if (this.changingSelection) { return } if (a) { this.select(a) } else { this.deselectAll() } }, selectWithEvent: function (a) { var c = this, b = c.isSelected(a); switch (c.getMode()) { case "MULTI": case "SIMPLE": if (b) { c.deselect(a) } else { c.select(a, true) } break; case "SINGLE": if (c.getAllowDeselect() && b) { c.deselect(a) } else { c.select(a, false) } break } }, selectRange: function (c, h, j) { var g = this, b = g.getStore(), a = [], e, d; if (g.getDisableSelection()) { return } if (c > h) { e = h; h = c; c = e } for (d = c; d <= h; d++) { a.push(b.getAt(d)) } this.doMultiSelect(a, j) }, select: function (c, e, b) { var d = this, a; if (d.getDisableSelection()) { return } if (typeof c === "number") { c = [d.getStore().getAt(c)] } if (!c) { return } if (d.getMode() == "SINGLE" && c) { a = c.length ? c[0] : c; d.doSingleSelect(a, b) } else { d.doMultiSelect(c, e, b) } }, doSingleSelect: function (a, b) { var d = this, c = d.selected; if (d.getDisableSelection()) { return } if (d.isSelected(a)) { return } if (c.getCount() > 0) { d.deselect(d.getLastSelected(), b) } c.add(a); d.setLastSelected(a); d.onItemSelect(a, b); d.setLastFocused(a); if (!b) { d.fireSelectionChange([a]) } }, doMultiSelect: function (a, k, j) { if (a === null || this.getDisableSelection()) { return } a = !Ext.isArray(a) ? [a] : a; var g = this, b = g.selected, e = a.length, h = false, c = 0, d; if (!k && b.getCount() > 0) { h = true; g.deselect(g.getSelections(), true) } for (; c < e; c++) { d = a[c]; if (k && g.isSelected(d)) { continue } h = true; g.setLastSelected(d); b.add(d); if (!j) { g.setLastFocused(d) } g.onItemSelect(d, j) } if (h && !j) { this.fireSelectionChange(a) } }, deselect: function (a, k) { var g = this; if (g.getDisableSelection()) { return } a = Ext.isArray(a) ? a : [a]; var b = g.selected, h = false, c = 0, j = g.getStore(), e = a.length, d; for (; c < e; c++) { d = a[c]; if (typeof d === "number") { d = j.getAt(d) } if (b.remove(d)) { if (g.getLastSelected() == d) { g.setLastSelected(b.last()) } h = true } if (d) { g.onItemDeselect(d, k) } } if (h && !k) { g.fireSelectionChange(a) } }, updateLastFocused: function (b, a) { this.onLastFocusChanged(a, b) }, fireSelectionChange: function (a) { var b = this; b.changingSelection = true; b.setSelection(b.getLastSelected() || null); b.changingSelection = false; b.fireAction("selectionchange", [b, a], "getSelections") }, getSelections: function () { return this.selected.getRange() }, isSelected: function (a) { a = Ext.isNumber(a) ? this.getStore().getAt(a) : a; return this.selected.indexOf(a) !== -1 }, hasSelection: function () { return this.selected.getCount() > 0 }, refreshSelection: function () { var b = this, a = b.getSelections(); b.deselectAll(true); if (a.length) { b.select(a, false, true) } }, onSelectionStoreRemove: function (c, b) { var h = this, e = h.selected, g = b.length, j, a, d; if (h.getDisableSelection()) { return } for (d = 0; d < g; d++) { a = b[d]; if (e.remove(a)) { if (h.getLastSelected() == a) { h.setLastSelected(null) } if (h.getLastFocused() == a) { h.setLastFocused(null) } j = j || []; j.push(a) } } if (j) { h.fireSelectionChange([j]) } }, onSelectionStoreClear: function (b) { var a = b.getData().items; this.onSelectionStoreRemove(b, a) }, getSelectionCount: function () { return this.selected.getCount() }, onSelectionStoreAdd: Ext.emptyFn, onSelectionStoreUpdate: Ext.emptyFn, onItemSelect: Ext.emptyFn, onItemDeselect: Ext.emptyFn, onLastFocusChanged: Ext.emptyFn, onEditorKey: Ext.emptyFn }, 1, 0, 0, 0, 0, 0, [Ext.mixin, "Selectable"], function () { })); (Ext.cmd.derive("Ext.mixin.StyleCacher", Ext.Mixin, { mixinConfig: { id: "stylecacher" }, getCachedStyle: function (c, b) { var a = this.$styleCache; if (!a) { a = this.$styleCache = {} } if (!(b in a)) { a[b] = Ext.fly(c).getStyle(b) } return a[b] } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "StyleCacher"], 0)); (Ext.cmd.derive("Ext.mixin.Traversable", Ext.Mixin, { mixinConfig: { id: "traversable" }, setParent: function (a) { this.parent = a; return this }, hasParent: function () { return Boolean(this.parent || this.$initParent) }, getParent: function () { return this.parent || this.$initParent }, getAncestors: function () { var b = [], a = this.getParent(); while (a) { b.push(a); a = a.getParent() } return b }, getAncestorIds: function () { var b = [], a = this.getParent(); while (a) { b.push(a.getId()); a = a.getParent() } return b } }, 0, 0, 0, 0, 0, 0, [Ext.mixin, "Traversable"], 0)); (Ext.cmd.derive("Ext.perf.Accumulator", Ext.Base, function () { var c = null, h = Ext.global.chrome, d, b = function () { b = Ext.now; var k, l; if (Ext.isChrome && h && h.Interval) { k = new h.Interval(); k.start(); b = function () { return k.microseconds() / 1000 } } else { if (window.ActiveXObject) { try { l = new ActiveXObject("SenchaToolbox.Toolbox"); Ext.senchaToolbox = l; b = function () { return l.milliseconds } } catch (m) { } } } Ext.perf.getTimestamp = Ext.perf.Accumulator.getTimestamp = b; return b() }; function i(l, k) { l.sum += k; l.min = Math.min(l.min, k); l.max = Math.max(l.max, k) } function e(n) { var l = n ? n : (b() - this.time), m = this, k = m.accum; ++k.count; if (!--k.depth) { i(k.total, l) } i(k.pure, l - m.childTime); c = m.parent; if (c) { ++c.accum.childCount; c.childTime += l } } function a() { return { min: Number.MAX_VALUE, max: 0, sum: 0 } } function j(l, k) { return function () { var n = l.enter(), m = k.apply(this, arguments); n.leave(); return m } } function g(m, l, k, o) { var n = { avg: 0, min: o.min, max: o.max, sum: 0 }; if (m) { k = k || 0; n.sum = o.sum - l * k; n.avg = n.sum / m } return n } return { constructor: function (k) { var l = this; l.count = l.childCount = l.depth = l.maxDepth = 0; l.pure = a(); l.total = a(); l.name = k }, statics: { getTimestamp: b }, format: function (k) { if (!d) { d = new Ext.XTemplate(["{name} - {count} call(s)", '<tpl if="count">', '<tpl if="childCount">', " ({childCount} children)", "</tpl>", '<tpl if="depth - 1">', " ({depth} deep)", "</tpl>", '<tpl for="times">', ", {type}: {[this.time(values.sum)]} msec (", "avg={[this.time(values.sum / parent.count)]}", ")", "</tpl>", "</tpl>"].join(""), { time: function (m) { return Math.round(m * 100) / 100 } }) } var l = this.getData(k); l.name = this.name; l.pure.type = "Pure"; l.total.type = "Total"; l.times = [l.pure, l.total]; return d.apply(l) }, getData: function (k) { var l = this; return { count: l.count, childCount: l.childCount, depth: l.maxDepth, pure: g(l.count, l.childCount, k, l.pure), total: g(l.count, l.childCount, k, l.total) } }, enter: function () { var k = this, l = { accum: k, leave: e, childTime: 0, parent: c }; ++k.depth; if (k.maxDepth < k.depth) { k.maxDepth = k.depth } c = l; l.time = b(); return l }, monitor: function (m, l, k) { var n = this.enter(); if (k) { m.apply(l, k) } else { m.call(l) } n.leave() }, report: function () { Ext.log(this.format()) }, tap: function (s, u) { var t = this, n = typeof u === "string" ? [u] : u, r, v, p, o, m, l, k, q; q = function () { if (typeof s === "string") { r = Ext.global; o = s.split("."); for (p = 0, m = o.length; p < m; ++p) { r = r[o[p]] } } else { r = s } for (p = 0, m = n.length; p < m; ++p) { l = n[p]; v = l.charAt(0) === "!"; if (v) { l = l.substring(1) } else { v = !(l in r.prototype) } k = v ? r : r.prototype; k[l] = j(t, k[l]) } }; Ext.ClassManager.onCreated(q, t, s); return t } } }, 1, 0, 0, 0, 0, 0, [Ext.perf, "Accumulator"], function () { Ext.perf.getTimestamp = this.getTimestamp })); (Ext.cmd.derive("Ext.perf.Monitor", Ext.Base, { singleton: true, alternateClassName: "Ext.Perf", constructor: function () { this.accumulators = []; this.accumulatorsByName = {} }, calibrate: function () { var b = new Ext.perf.Accumulator("$"), g = b.total, c = Ext.perf.Accumulator.getTimestamp, e = 0, h, a, d; d = c(); do { h = b.enter(); h.leave(); ++e } while (g.sum < 100); a = c(); return (a - d) / e }, get: function (b) { var c = this, a = c.accumulatorsByName[b]; if (!a) { c.accumulatorsByName[b] = a = new Ext.perf.Accumulator(b); c.accumulators.push(a) } return a }, enter: function (a) { return this.get(a).enter() }, monitor: function (a, c, b) { this.get(a).monitor(c, b) }, report: function () { var c = this, b = c.accumulators, a = c.calibrate(); b.sort(function (e, d) { return (e.name < d.name) ? -1 : ((d.name < e.name) ? 1 : 0) }); c.updateGC(); Ext.log("Calibration: " + Math.round(a * 100) / 100 + " msec/sample"); Ext.each(b, function (d) { Ext.log(d.format(a)) }) }, getData: function (c) { var b = {}, a = this.accumulators; Ext.each(a, function (d) { if (c || d.count) { b[d.name] = d.getData() } }); return b }, reset: function () { Ext.each(this.accumulators, function (a) { var b = a; b.count = b.childCount = b.depth = b.maxDepth = 0; b.pure = { min: Number.MAX_VALUE, max: 0, sum: 0 }; b.total = { min: Number.MAX_VALUE, max: 0, sum: 0 } }) }, updateGC: function () { var a = this.accumulatorsByName.GC, b = Ext.senchaToolbox, c; if (a) { a.count = b.garbageCollectionCounter || 0; if (a.count) { c = a.pure; a.total.sum = c.sum = b.garbageCollectionMilliseconds; c.min = c.max = c.sum / a.count; c = a.total; c.min = c.max = c.sum / a.count } } }, watchGC: function () { Ext.perf.getTimestamp(); var a = Ext.senchaToolbox; if (a) { this.get("GC"); a.watchGarbageCollector(false) } }, setup: function (c) { if (!c) { c = { render: { "Ext.Component": "render" }, layout: { "Ext.layout.Context": "run" } } } this.currentConfig = c; var d, g, b, e, a; for (d in c) { if (c.hasOwnProperty(d)) { g = c[d]; b = Ext.Perf.get(d); for (e in g) { if (g.hasOwnProperty(e)) { a = g[e]; b.tap(e, a) } } } } this.watchGC() }, setupLog: function (c) { var e, a, b, g, d; for (e in c) { if (c.hasOwnProperty(e)) { a = Ext.ClassManager.get(e); if (a) { b = c[e]; d = {}; for (g in b) { d[g] = (function (h, i) { return function () { var l, m, n, k, j; l = +Date.now(); j = this.callParent(arguments); m = +Date.now() - l; if (window.console && m > 0) { k = i === "this" ? this : typeof i === "string" ? this[i] : typeof i === "number" ? arguments[i] : null; if (k) { n = k.id } if (n != null) { console.log(h + " for " + n + ": " + m + "ms") } else { console.log(h + " for unknown: " + m + "ms") } if (console.trace) { console.trace() } } return j } })(g, b[g]) } Ext.override(a, d) } } } } }, 1, 0, 0, 0, 0, 0, [Ext.perf, "Monitor", Ext, "Perf"], 0)); (Ext.cmd.derive("Ext.plugin.Abstract", Ext.Base, { alternateClassName: "Ext.AbstractPlugin", isPlugin: true, constructor: function (a) { if (a) { this.pluginConfig = a; this.initConfig(a) } }, clonePlugin: function (a) { return new this.self(Ext.apply({}, a, this.pluginConfig)) }, getCmp: function () { return this.cmp }, setCmp: function (a) { this.cmp = a }, init: Ext.emptyFn, destroy: function () { this.cmp = this.pluginConfig = null; this.callParent() }, onClassExtended: function (b, e, a) { var d = e.alias, c = b.prototype; if (d && !e.ptype) { if (Ext.isArray(d)) { d = d[0] } c.ptype = d.split("plugin.")[1] } }, resolveListenerScope: function (d) { var c = this, b = c.getCmp(), a; if (b) { a = b.resolveSatelliteListenerScope(c, d) } return a || c.mixins.observable.resolveListenerScope.call(c, d) } }, 1, 0, 0, 0, 0, 0, [Ext.plugin, "Abstract", Ext, "AbstractPlugin"], 0)); Ext.define("Ext.overrides.plugin.Abstract", { override: "Ext.plugin.Abstract", $configStrict: false, $configPrefixed: false, disabled: false, getState: null, applyState: null, enable: function () { this.disabled = false }, disable: function () { this.disabled = true } }); (Ext.cmd.derive("Ext.plugin.LazyItems", Ext.plugin.Abstract, { init: function (a) { Ext.plugin.Abstract.prototype.init.apply(this, arguments); if (this.items) { if (this.eagerInstantiation) { this.items = a.prepareItems(this.items) } } a.beforeRender = Ext.Function.createInterceptor(a.beforeRender, this.beforeComponentRender, this) }, beforeComponentRender: function () { this.cmp.add(this.items); this.cmp.beforeComponentRender = null } }, 0, 0, 0, 0, ["plugin.lazyitems"], 0, [Ext.plugin, "LazyItems"], 0)); (Ext.cmd.derive("Ext.plugin.MouseEnter", Ext.plugin.Abstract, { element: "el", init: function (a) { var c = this, b = { mouseover: c.onMouseOver, scope: c, destroyable: true }; if (c.leaveHandler) { b.mouseout = c.onMouseOut } if (typeof c.element === "string") { b.element = c.element; c.mouseListener = a.on(b) } else { c.mouseListener = c.element.on(b) } }, onMouseOver: function (c) { var b = this, a = c.getTarget(b.delegate); if (a && a !== c.getRelatedTarget(b.delegate)) { Ext.callback(b.handler, null, [c, a], 0, b.cmp, b.scope) } }, onMouseOut: function (c) { var b = this, a = c.getRelatedTarget(b.delegate); if (a && a !== c.getTarget(b.delegate)) { Ext.callback(b.leaveHandler, null, [c, a], 0, b.cmp, b.scope) } }, destroy: function () { Ext.plugin.Abstract.prototype.destroy.call(this); Ext.destroy(this.mouseListener) } }, 0, 0, 0, 0, ["plugin.mouseenter"], 0, [Ext.plugin, "MouseEnter"], 0)); (Ext.cmd.derive("Ext.sparkline.Shape", Ext.Base, { constructor: function (d, e, b, a) { var c = this; c.target = d; c.id = e; c.type = b; c.args = a }, append: function () { this.target.appendShape(this); return this } }, 1, 0, 0, 0, 0, 0, [Ext.sparkline, "Shape"], 0)); (Ext.cmd.derive("Ext.sparkline.CanvasBase", Ext.Base, { shapeCount: 0, _pxregex: /(\d+)(px)?\s*$/i, constructor: function (a) { this.owner = a; this.rtl = this.owner.getInherited().rtl }, setWidth: function (a) { this.pixelWidth = a }, setHeight: function (a) { this.pixelHeight = a }, drawLine: function (c, e, b, d, g, a) { return this.drawShape([[c, e], [b, d]], g, a) }, drawShape: function (c, b, d, a) { return this._genShape("Shape", [c, b, d, a]) }, drawCircle: function (c, g, b, d, e, a) { return this._genShape("Circle", [c, g, b, d, e, a]) }, drawPieSlice: function (b, h, a, d, c, e, g) { return this._genShape("PieSlice", [b, h, a, d, c, e, g]) }, drawRect: function (b, g, c, a, d, e) { return this._genShape("Rect", [b, g, c, a, d, e]) }, getElement: function () { return this.el }, getLastShapeId: function () { return this.lastShapeId }, reset: function () { }, _genShape: function (b, a) { var c = this.shapeCount++; a.unshift(c); return new Ext.sparkline.Shape(this, c, b, a) }, appendShape: function (a) { }, replaceWithShape: function (b, a) { }, insertAfterShape: function (b, a) { }, removeShapeId: function (a) { }, getShapeAt: function (a, b) { }, render: function () { } }, 1, 0, 0, 0, 0, 0, [Ext.sparkline, "CanvasBase"], 0)); (Ext.cmd.derive("Ext.sparkline.CanvasCanvas", Ext.sparkline.CanvasBase, { statics: { contextOverrides: (function () { var a = window.devicePixelRatio || 1; return { moveTo: function (b, c) { if (this.rtl) { b = this.canvas.width - b - 1 } this.$moveTo(b * a, c * a) }, lineTo: function (b, c) { if (this.rtl) { b = this.canvas.width - b - 1 } this.$lineTo(b * a, c * a) }, arc: function (c, h, b, g, d, e) { if (this.rtl) { c = this.canvas.width - c - 1 } this.$arc(c * a, h * a, b * a, g, d, e) }, clearRect: function (c, e, d, b) { if (this.rtl) { c = this.canvas.width - c - d } this.$clearRect(c * a, e * a, d * a, b * a) } } })() }, setWidth: function (a) { Ext.sparkline.CanvasBase.prototype.setWidth.apply(this, arguments); this.owner.element.dom.width = a * (window.devicePixelRatio || 1) }, setHeight: function (a) { Ext.sparkline.CanvasBase.prototype.setHeight.apply(this, arguments); this.owner.element.dom.height = a * (window.devicePixelRatio || 1) }, onOwnerUpdate: function () { var a = this; a.el = a.owner.element; a.interact = !a.owner.initialConfig.disableInteraction; a.shapes = {}; a.shapeseq = []; a.currentTargetShapeId = a.lastShapeId = null }, _getContext: function (d, g, a) { var c = this.el.dom.getContext("2d"), e = Ext.sparkline.CanvasCanvas.contextOverrides, b; if (!this.context) { for (b in e) { c["$" + b] = c[b] } Ext.apply(c, e); c.rtl = this.rtl; this.context = c } if (d != null) { c.strokeStyle = d } c.lineWidth = a || 1; if (g != null) { c.fillStyle = g } return c }, reset: function () { var a = this._getContext(); a.clearRect(0, 0, this.pixelWidth, this.pixelHeight); this.shapes = {}; this.shapeseq = []; this.currentTargetShapeId = this.lastShapeId = null }, _drawShape: function (h, k, j, b, g) { var c = this._getContext(j, b, g), a = this.rtl ? -0.5 : 0.5, e, d; c.beginPath(); c.moveTo(k[0][0] + a, k[0][1] + 0.5); for (e = 1, d = k.length; e < d; e++) { c.lineTo(k[e][0] + a, k[e][1] + 0.5) } if (j != null) { c.stroke() } if (b != null) { c.fill() } if (this.targetX != null && this.targetY != null && c.isPointInPath(this.targetX, this.targetY)) { this.currentTargetShapeId = h } }, _drawCircle: function (g, c, i, b, e, h, a) { var d = this._getContext(e, h, a); d.beginPath(); d.arc(c, i, b, 0, 2 * Math.PI, false); if (this.targetX != null && this.targetY != null && d.isPointInPath(this.targetX, this.targetY)) { this.currentTargetShapeId = g } if (e != null) { d.stroke() } if (h != null) { d.fill() } }, _drawPieSlice: function (e, j, h, d, g, c, i, b) { var a = this._getContext(i, b); a.beginPath(); a.moveTo(j, h); a.arc(j, h, d, g, c, false); a.lineTo(j, h); a.closePath(); if (i != null) { a.stroke() } if (b) { a.fill() } if (this.targetX !== undefined && this.targetY !== undefined && a.isPointInPath(this.targetX, this.targetY)) { this.currentTargetShapeId = e } }, _drawRect: function (e, b, h, c, a, d, g) { return this._drawShape(e, [[b, h], [b + c, h], [b + c, h + a], [b, h + a], [b, h]], d, g) }, appendShape: function (a) { this.shapes[a.id] = a; this.shapeseq.push(a.id); this.lastShapeId = a.id; return a.id }, replaceWithShape: function (c, a) { var d = this.shapeseq, b; this.shapes[a.id] = a; for (b = d.length; b--;) { if (d[b] === c) { d[b] = a.id } } delete this.shapes[c] }, replaceWithShapes: function (c, b) { var h = this.shapeseq, e = {}, a, d, g; for (d = c.length; d--;) { e[c[d]] = true } for (d = h.length; d--;) { a = h[d]; if (e[a]) { h.splice(d, 1); delete this.shapes[a]; g = d } } for (d = b.length; d--;) { h.splice(g, 0, b[d].id); this.shapes[b[d].id] = b[d] } }, insertAfterShape: function (c, a) { var d = this.shapeseq, b; for (b = d.length; b--;) { if (d[b] === c) { d.splice(b + 1, 0, a.id); this.shapes[a.id] = a; return } } }, removeShapeId: function (b) { var c = this.shapeseq, a; for (a = c.length; a--;) { if (c[a] === b) { c.splice(a, 1); break } } delete this.shapes[b] }, getShapeAt: function (a, b) { if (this.rtl) { a = this.el.dom.width - a - 1 } this.targetX = a; this.targetY = b; this.render(); return this.currentTargetShapeId }, render: function () { var h = this.shapeseq, a = this.shapes, e = h.length, d = this._getContext(), g, b, c; d.clearRect(0, 0, this.pixelWidth, this.pixelHeight); for (c = 0; c < e; c++) { g = h[c]; b = a[g]; this["_draw" + b.type].apply(this, b.args) } if (!this.interact) { this.shapes = {}; this.shapeseq = [] } } }, 0, 0, 0, 0, 0, 0, [Ext.sparkline, "CanvasCanvas"], 0)); (Ext.cmd.derive("Ext.sparkline.VmlCanvas", Ext.sparkline.CanvasBase, { setWidth: function (a) { var b = this; Ext.sparkline.CanvasBase.prototype.setWidth.apply(this, arguments); b.owner.groupEl.dom.coordsize = b.width + " " + (b.height || 0); b.owner.groupEl.dom.style.width = a + "px" }, setHeight: function (a) { var b = this; Ext.sparkline.CanvasBase.prototype.setHeight.apply(this, arguments); b.owner.groupEl.dom.coordsize = (b.width || 0) + " " + b.height; b.owner.groupEl.dom.style.height = a + "px" }, onOwnerUpdate: function () { var a = this; a.group = a.owner.groupEl; a.el = a.owner.element; a.prerender = [] }, _drawShape: function (g, n, j, a, d) { var k = [], h, m, l, e, b, c; for (c = 0, b = n.length; c < b; c++) { k[c] = (n[c][0]) + "," + (n[c][1]) } h = k.splice(0, 1); d = d == null ? 1 : d; m = j == null ? ' stroked="false" ' : ' strokeWeight="' + d + 'px" strokeColor="' + j + '" '; l = a == null ? ' filled="false"' : ' fillColor="' + a + '" filled="true" '; e = k[0] === k[k.length - 1] ? "x " : ""; return ['<svml:shape coordorigin="0 0" coordsize="', this.pixelWidth, " ", this.pixelHeight, '" id="jqsshape', g, '" ', m, l, ' style="position:absolute;height:', this.pixelHeight, "px;width:", this.pixelWidth, 'px" ', ' path="m ', h, " l ", k.join(", "), " ", e, 'e"></svml:shape>'].join("") }, _drawCircle: function (d, i, g, c, h, a, b) { var e = c * 2, k, j; i -= c; g -= c; k = h == null ? ' stroked="false" ' : ' strokeWeight="' + b + 'px" strokeColor="' + h + '" '; j = a == null ? ' filled="false"' : ' fillColor="' + a + '" filled="true" '; return ['<svml:oval id="jqsshape', d, '" ', k, j, ' style="position:absolute;top:', g, "px; left:", i, "px;width:", e, "px;height:", e, 'px"></svml:oval>'].join("") }, _drawPieSlice: function (j, o, m, i, k, e, n, d) { var l, c = this.pixelWidth, p = this.pixelHeight, b, a, h, g, r = n == null ? ' stroked="false" ' : ' strokeWeight="1px" strokeColor="' + n + '" ', q = d == null ? ' filled="false"' : ' fillColor="' + d + '" filled="true" '; if (k === e) { return "" } if ((e - k) === (2 * Math.PI)) { k = 0; e = (2 * Math.PI) } b = o + Math.round(Math.cos(k) * i); a = m + Math.round(Math.sin(k) * i); h = o + Math.round(Math.cos(e) * i); g = m + Math.round(Math.sin(e) * i); if (b === h && a === g) { if ((e - k) < Math.PI) { return "" } b = h = o + i; a = g = m } if (b === h && a === g && (e - k) < Math.PI) { return "" } l = [o - i, m - i, o + i, m + i, b, a, h, g]; return ['<svml:shape coordorigin="0 0" coordsize="', c, " ", p, '" id="jqsshape', j, '" ', r, q, ' style="position:absolute;height:', p, "px;width:", c, 'px" path="m ', o, ",", m, " wa ", l.join(", "), ' x e"></svml:shape>'].join("") }, _drawRect: function (e, b, h, c, a, d, g) { return this._drawShape(e, [[b, h], [b, h + a], [b + c, h + a], [b + c, h], [b, h]], d, g) }, reset: function () { Ext.fly(this.group).empty() }, appendShape: function (a) { this.prerender.push(this["_draw" + a.type].apply(this, a.args)); this.lastShapeId = a.id; return a.id }, replaceWithShape: function (d, a) { var c = this.el.getById("jqsshape" + d, true), b = this["_draw" + a.type].apply(this, a.args); c.outerHTML = b }, replaceWithShapes: function (b, a) { var e = this.el.getById("jqsshape" + b[0], true), d = "", g = a.length, c; for (c = 0; c < g; c++) { d += this["_draw" + a[c].type].apply(this, a[c].args) } e.outerHTML = d; for (c = 1; c < b.length; c++) { this.el.getById("jqsshape" + b[c]).destroy() } }, insertAfterShape: function (d, a) { var c = this.el.getById("jqsshape" + d, true), b = this["_draw" + a.type].apply(this, a.args); c.insertAdjacentHTML("afterEnd", b) }, removeShapeId: function (b) { var a = this.el.getById("jqsshape" + b, true); this.group.removeChild(a) }, getShapeAt: function (a, c) { var b = this.el.id.substr(8); return b }, render: function () { this.group.dom.innerHTML = this.prerender.join("") } }, 0, 0, 0, 0, 0, 0, [Ext.sparkline, "VmlCanvas"], function () { Ext.onInternalReady(function () { var a = document; if (a.namespaces && !a.namespaces.svml) { a.namespaces.add("svml", "urn:schemas-microsoft-com:vml", "#default#VML") } }) })); (Ext.cmd.derive("Ext.util.Color", Ext.Base, { alternateClassName: "Ext.draw.Color", statics: { colorToHexRe: /(.*?)rgb\((\d+),\s*(\d+),\s*(\d+)\)/, rgbToHexRe: /\s*rgb\((\d+),\s*(\d+),\s*(\d+)\)/, rgbaToHexRe: /\s*rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\.\d]+)\)/, hexRe: /\s*#([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)\s*/, NONE: "none", RGBA_NONE: "rgba(0, 0, 0, 0)" }, isColor: true, lightnessFactor: 0.2, constructor: function (d, b, a, c) { this.setRGB(d, b, a, c) }, clone: function () { var a = this; return new this.self(a.r, a.g, a.b, a.a) }, setRGB: function (e, c, a, d) { var b = this; b.r = Math.min(255, Math.max(0, e)); b.g = Math.min(255, Math.max(0, c)); b.b = Math.min(255, Math.max(0, a)); if (d === undefined) { b.a = 1 } else { b.a = Math.min(1, Math.max(0, d)) } }, getBrightness: function () { var d = this.r / 255 * 100, c = this.g / 255 * 100, a = this.b / 255 * 100; return ((d * 299) + (c * 587) + (a * 114)) / 1000 }, getGrayscale: function () { return this.r * 0.3 + this.g * 0.59 + this.b * 0.11 }, getHSL: function () { var j = this, a = j.r / 255, i = j.g / 255, k = j.b / 255, m = Math.max(a, i, k), d = Math.min(a, i, k), n = m - d, e, o = 0, c = 0.5 * (m + d); if (d !== m) { o = (c <= 0.5) ? n / (m + d) : n / (2 - m - d); if (a === m) { e = 60 * (i - k) / n } else { if (i === m) { e = 120 + 60 * (k - a) / n } else { e = 240 + 60 * (a - i) / n } } if (e < 0) { e += 360 } if (e >= 360) { e -= 360 } } return [e, o, c] }, getHSV: function () { var j = this, a = j.r / 255, i = j.g / 255, k = j.b / 255, l = Math.max(a, i, k), d = Math.min(a, i, k), c = l - d, e, n = 0, m = l; if (d != l) { n = m ? c / m : 0; if (a === l) { e = 60 * (i - k) / c } else { if (i === l) { e = 60 * (k - a) / c + 120 } else { e = 60 * (a - i) / c + 240 } } if (e < 0) { e += 360 } if (e >= 360) { e -= 360 } } return [e, n, m] }, setHSL: function (i, g, e) { var j = this, d = Math.abs, k, b, a; i = (i % 360 + 360) % 360; g = g > 1 ? 1 : g < 0 ? 0 : g; e = e > 1 ? 1 : e < 0 ? 0 : e; if (g === 0 || i === null) { e *= 255; j.setRGB(e, e, e) } else { i /= 60; k = g * (1 - d(2 * e - 1)); b = k * (1 - d(i % 2 - 1)); a = e - k / 2; a *= 255; k *= 255; b *= 255; switch (Math.floor(i)) { case 0: j.setRGB(k + a, b + a, a); break; case 1: j.setRGB(b + a, k + a, a); break; case 2: j.setRGB(a, k + a, b + a); break; case 3: j.setRGB(a, b + a, k + a); break; case 4: j.setRGB(b + a, a, k + a); break; case 5: j.setRGB(k + a, a, b + a); break } } return j }, setHSV: function (g, e, d) { var i = this, j, b, a; g = (g % 360 + 360) % 360; e = e > 1 ? 1 : e < 0 ? 0 : e; d = d > 1 ? 1 : d < 0 ? 0 : d; if (e === 0 || g === null) { d *= 255; i.setRGB(d, d, d) } else { g /= 60; j = d * e; b = j * (1 - Math.abs(g % 2 - 1)); a = d - j; a *= 255; j *= 255; b *= 255; switch (Math.floor(g)) { case 0: i.setRGB(j + a, b + a, a); break; case 1: i.setRGB(b + a, j + a, a); break; case 2: i.setRGB(a, j + a, b + a); break; case 3: i.setRGB(a, b + a, j + a); break; case 4: i.setRGB(b + a, a, j + a); break; case 5: i.setRGB(j + a, a, b + a); break } } return i }, createLighter: function (b) { var a = this.clone(); a.lighten(b); return a }, lighten: function (b) { if (!b && b !== 0) { b = this.lightnessFactor } var a = this.getHSL(); this.setHSL(a[0], a[1], Ext.Number.constrain(a[2] + b, 0, 1)) }, createDarker: function (b) { var a = this.clone(); a.darken(b); return a }, darken: function (a) { if (!a && a !== 0) { a = this.lightnessFactor } return this.lighten(-a) }, toString: function () { var h = this, c = Math.round; if (h.a === 1) { var e = c(h.r).toString(16), d = c(h.g).toString(16), a = c(h.b).toString(16); e = (e.length === 1) ? "0" + e : e; d = (d.length === 1) ? "0" + d : d; a = (a.length === 1) ? "0" + a : a; return ["#", e, d, a].join("") } else { return "rgba(" + [c(h.r), c(h.g), c(h.b), h.a === 0 ? 0 : h.a.toFixed(15)].join(", ") + ")" } }, toHex: function (c) { var h = this.r, e = this.g, a = this.b, d = a | (e << 8) | (h << 16); return "#" + ("000000" + d.toString(16)).slice(-6) }, setFromString: function (k) { var e, i, h, c, d = 1, j = parseInt; if (k === Ext.util.Color.NONE) { this.r = this.g = this.b = this.a = 0; return this } if ((k.length === 4 || k.length === 7) && k.substr(0, 1) === "#") { e = k.match(Ext.util.Color.hexRe); if (e) { i = j(e[1], 16) >> 0; h = j(e[2], 16) >> 0; c = j(e[3], 16) >> 0; if (k.length === 4) { i += (i * 16); h += (h * 16); c += (c * 16) } } } else { if ((e = k.match(Ext.util.Color.rgbToHexRe))) { i = +e[1]; h = +e[2]; c = +e[3] } else { if ((e = k.match(Ext.util.Color.rgbaToHexRe))) { i = +e[1]; h = +e[2]; c = +e[3]; d = +e[4] } else { if (Ext.util.Color.ColorList.hasOwnProperty(k.toLowerCase())) { return this.setFromString(Ext.util.Color.ColorList[k.toLowerCase()]) } } } } if (typeof i === "undefined") { return this } this.r = i; this.g = h; this.b = c; this.a = d; return this } }, 3, 0, 0, 0, 0, 0, [Ext.util, "Color", Ext.draw, "Color"], function () { var a = new this(); this.addStatics({ fly: function (e, c, b, d) { switch (arguments.length) { case 1: a.setFromString(e); break; case 3: case 4: a.setRGB(e, c, b, d); break; default: return null }return a }, ColorList: { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", green: "#008000", greenyellow: "#adff2f", honeydew: "#f0fff0", hotpink: "#ff69b4", indianred: "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgray: "#d3d3d3", lightgrey: "#d3d3d3", lightgreen: "#90ee90", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370d8", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#d87093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" }, fromHSL: function (d, c, b) { return (new this(0, 0, 0, 0)).setHSL(d, c, b) }, fromHSV: function (d, c, b) { return (new this(0, 0, 0, 0)).setHSL(d, c, b) }, fromString: function (b) { return (new this(0, 0, 0, 0)).setFromString(b) }, create: function (b) { if (b instanceof this) { return b } else { if (Ext.isArray(b)) { return new Ext.util.Color(b[0], b[1], b[2], b[3]) } else { if (Ext.isString(b)) { return Ext.util.Color.fromString(b) } else { if (arguments.length > 2) { return new Ext.util.Color(arguments[0], arguments[1], arguments[2], arguments[3]) } else { return new Ext.util.Color(0, 0, 0, 0) } } } } } }) })); (Ext.cmd.derive("Ext.sparkline.Base", Ext.Gadget, { cachedConfig: { baseCls: "x-sparkline", lineColor: "#157fcc", defaultPixelsPerValue: 3, tagValuesAttribute: "values", enableTagOptions: false, enableHighlight: true, highlightColor: null, highlightLighten: 0.1, tooltipSkipNull: true, tooltipPrefix: "", tooltipSuffix: "", disableTooltips: false, disableInteraction: false, tipTpl: null }, config: { values: null }, element: { tag: "canvas", reference: "element", style: { display: "inline-block", verticalAlign: "top" }, listeners: { mouseenter: "onMouseEnter", mouseleave: "onMouseLeave", mousemove: "onMouseMove" }, width: 0, height: 0 }, defaultBindProperty: "values", redrawQueue: {}, inheritableStatics: { sparkLineTipClass: "x-sparkline-tip-target", onClassCreated: function (c) { var a = c.prototype.applyConfigChange, e = c.prototype, g = c.getConfigurator().configs, d, b; for (d in g) { if (d !== "tipTpl") { b = Ext.Config.get(d).names.apply; if (e[b]) { e[b] = Ext.Function.createSequence(e[b], a) } else { e[b] = a } } } } }, constructor: function (a) { var b = this; b.canvas = Ext.supports.Canvas ? new Ext.sparkline.CanvasCanvas(b) : new Ext.sparkline.VmlCanvas(b); if (!b.getDisableTooltips()) { b.element.cls = Ext.sparkline.Base.sparkLineTipClass } Ext.apply(b, a); Ext.Widget.prototype.constructor.call(this, a) }, all: function (d, b, a) { var c; for (c = b.length; c--;) { if (a && b[c] === null) { continue } if (b[c] !== d) { return false } } return true }, applyConfigChange: function (b) { var a = this; a.redrawQueue[a.getId()] = a; if (!a.redrawTimer) { Ext.sparkline.Base.prototype.redrawTimer = Ext.Function.requestAnimationFrame(a.processRedrawQueue) } return b }, applyTipTpl: function (a) { if (a && !a.isTemplate) { a = new Ext.XTemplate(a) } return a }, normalizeValue: function (b) { var a; switch (b) { case "undefined": b = undefined; break; case "null": b = null; break; case "true": b = true; break; case "false": b = false; break; default: a = parseFloat(b); if (b == a) { b = a } }return b }, normalizeValues: function (c) { var b, a = []; for (b = c.length; b--;) { a[b] = this.normalizeValue(c[b]) } return a }, updateWidth: function (b, a) { var c = this, e = c.element.dom, d = c.measurer; Ext.Widget.prototype.updateWidth.call(this, b, a); c.canvas.setWidth(b); c.width = b; if (c.height == null && d) { c.setHeight(parseInt(d.getCachedStyle(e.parentNode, "line-height"), 10)) } }, updateHeight: function (a, c) { var b = this; Ext.Widget.prototype.updateHeight.call(this, a, c); b.canvas.setHeight(a); b.height = a }, applyValues: function (b, a) { if (b && a && Ext.Array.equals(b, a)) { b = undefined } return b }, updateValues: function (a) { this.values = a }, redraw: function () { var a = this; if (!a.destroyed && a.getValues()) { a.onUpdate(); a.canvas.onOwnerUpdate(); a.renderGraph() } }, onUpdate: Ext.emptyFn, renderGraph: function () { var a = true; if (this.disabled) { this.canvas.reset(); a = false } return a }, onMouseEnter: function (a) { this.onMouseMove(a) }, onMouseMove: function (a) { this.currentPageXY = a.getPoint(); this.redraw() }, onMouseLeave: function () { var a = this; a.currentPageXY = a.targetX = a.targetY = null; a.redraw(); a.hideTip() }, updateDisplay: function () { var b = this, a = b.getValues(), e, c, d; if (a && a.length && b.currentPageXY && b.el.getRegion().contains(b.currentPageXY)) { e = b.canvas.el.getXY(); d = b.getRegion(b.currentPageXY[0] - e[0], b.currentPageXY[1] - e[1]); if (d != null && b.isValidRegion(d, a)) { if (!b.disableHighlight) { b.renderHighlight(d) } c = b.getRegionTooltip(d) } b.fireEvent("sparklineregionchange", b); if (c) { b.tooltip.setHtml(c); b.showTip() } } if (!c) { b.hideTip() } }, getRegion: Ext.emptyFn, getRegionTooltip: function (n) { var m = this, e = [], p = m.getTipTpl(), g, h, d, k, b, o, l, c, a; g = m.getRegionFields(n); o = m.tooltipFormatter; if (o) { return o(m, m, g) } if (!p) { return "" } if (!Ext.isArray(g)) { g = [g] } h = m.tooltipFormatFieldlist; d = m.tooltipFormatFieldlistKey; if (h && d) { k = []; for (c = g.length; c--;) { b = g[c][d]; if ((a = Ext.Array.indexOf(b, h)) !== -1) { k[a] = g[c] } } g = k } l = g.length; for (a = 0; a < l; a++) { if (!g[a].isNull || !m.getTooltipSkipNull()) { Ext.apply(g[a], { prefix: m.getTooltipPrefix(), suffix: m.getTooltipSuffix() }); e.push(p.apply(g[a])) } } if (e.length) { return e.join("<br>") } return "" }, getRegionFields: Ext.emptyFn, calcHighlightColor: function (a) { var c = this, e = c.getHighlightColor(), b = c.getHighlightLighten(), d; if (e) { return e } if (b) { d = Ext.util.Color.fromString(a); if (d) { d.lighten(b); a = d.toHex() } } return a }, destroy: function () { delete this.redrawQueue[this.getId()]; Ext.Widget.prototype.destroy.call(this) }, privates: { hideTip: Ext.privateFn, isValidRegion: function (b, a) { return b < a.length }, showTip: Ext.privateFn } }, 1, ["sparkline"], ["widget", "sparkline"], { widget: true, sparkline: true }, ["widget.sparkline"], 0, [Ext.sparkline, "Base"], function (b) { var a = b.prototype; Ext.onInternalReady(function () { a.tooltip = b.constructTip() }); b.onClassCreated(b); a.processRedrawQueue = function () { var c = a.redrawQueue, d; for (d in c) { c[d].redraw() } a.redrawQueue = {}; a.redrawTimer = 0 }; if (!Ext.supports.Canvas) { b.prototype.element = { tag: "span", reference: "element", listeners: { mouseenter: "onMouseEnter", mouseleave: "onMouseLeave", mousemove: "onMouseMove" }, style: { display: "inline-block", position: "relative", overflow: "hidden", margin: "0px", padding: "0px", verticalAlign: "top", cursor: "default" }, children: [{ tag: "svml:group", reference: "groupEl", coordorigin: "0 0", coordsize: "0 0", style: "position:absolute;width:0;height:0;pointer-events:none" }] } } })); Ext.define("Ext.override.sparkline.Base", { override: "Ext.sparkline.Base", statics: { constructTip: function () { return new Ext.tip.ToolTip({ id: "sparklines-tooltip", showDelay: 0, dismissDelay: 0, hideDelay: 400 }) } }, onMouseMove: function (a) { this.tooltip.triggerEvent = a; arguments.callee.$previous.call(this, a) }, onMouseLeave: function (a) { arguments.callee.$previous.call(this, a); this.tooltip.target = null }, privates: { hideTip: function () { var a = this.tooltip; a.target = null; a.hide() }, showTip: function () { var a = this.tooltip; a.target = this.el; a.onTargetOver(a.triggerEvent) } } }); (Ext.cmd.derive("Ext.sparkline.BarBase", Ext.sparkline.Base, { renderHighlight: function (a) { this.renderRegion(a, true) }, renderGraph: function () { var h = this, b = h.values, d = h.canvas, k = h.regionShapes || (h.regionShapes = {}), a, g, e, c; if (!Ext.sparkline.Base.prototype.renderGraph.call(this)) { return } for (e = b.length; e--;) { a = h.renderRegion(e); if (a) { if (Ext.isArray(a)) { g = []; for (c = a.length; c--;) { a[c].append(); g.push(a[c].id) } k[e] = g } else { a.append(); k[e] = a.id } } else { k[e] = null } } if (h.currentPageXY) { h.currentRegion = null; h.updateDisplay() } d.render() } }, 0, 0, ["widget", "sparkline"], { widget: true, sparkline: true }, 0, 0, [Ext.sparkline, "BarBase"], 0)); (Ext.cmd.derive("Ext.sparkline.RangeMap", Ext.Base, { constructor: function (d) { var c, a, b = []; for (c in d) { if (d.hasOwnProperty(c) && typeof c === "string" && c.indexOf(":") > -1) { a = c.split(":"); a[0] = a[0].length === 0 ? -Infinity : parseFloat(a[0]); a[1] = a[1].length === 0 ? Infinity : parseFloat(a[1]); a[2] = d[c]; b.push(a) } } this.map = d; this.rangelist = b || false }, get: function (e) { var d = this.rangelist, c, b, a; if ((a = this.map[e]) !== undefined) { return a } if (d) { for (c = d.length; c--;) { b = d[c]; if (b[0] <= e && b[1] >= e) { return b[2] } } } } }, 1, 0, 0, 0, 0, 0, [Ext.sparkline, "RangeMap"], 0)); (Ext.cmd.derive("Ext.sparkline.Bar", Ext.sparkline.BarBase, { config: { barColor: "#3366cc", negBarColor: "#f44", stackedBarColor: ["#3366cc", "#dc3912", "#ff9900", "#109618", "#66aa00", "#dd4477", "#0099c6", "#990099"], zeroColor: null, nullColor: null, zeroAxis: true, barWidth: 4, barSpacing: 1, chartRangeMin: null, chartRangeMax: null, chartRangeClip: false, colorMap: null }, tipTpl: "&#9679; {prefix}{value}{suffix}", remove: function (e, c) { var b, d, a = []; for (b = 0, d = e.length; b < d; b++) { if (e[b] !== c) { a.push(e[b]) } } return a }, all: function (b, d, a) { var c; for (c = b.length; c--;) { if (a && b[c] === null) { continue } if (b[c] !== d) { return false } } return true }, applyColorMap: function (a) { var b = this; if (Ext.isArray(a)) { b.colorMapByIndex = a; b.colorMapByValue = null } else { b.colorMapByIndex = null; b.colorMapByValue = a; if (b.colorMapByValue && b.colorMapByValue.get == null) { b.colorMapByValue = new Ext.sparkline.RangeMap(a) } } b.applyConfigChange(); return a }, onUpdate: function () { var I = this, c = I.values, t = I.getBarWidth(), q = I.getBarSpacing(), k = I.getChartRangeMin(), l = I.getChartRangeMax(), m = I.getChartRangeClip(), D = Infinity, G = -Infinity, v, r, u, e, g, B, h, s, z = I.getZeroAxis(), o, x, A, C, F, E, w, y, H, p, J, n, d, b = [], a = []; for (B = 0, h = c.length; B < h; B++) { J = c[B]; v = typeof (J) === "string" && J.indexOf(":") > -1; if (v || Ext.isArray(J)) { E = true; if (v) { J = c[B] = I.normalizeValues(J.split(":")) } J = I.remove(J, null); r = Math.min.apply(Math, J); u = Math.max.apply(Math, J); if (r < D) { D = r } if (u > G) { G = u } } } I.stacked = E; I.regionShapes = {}; I.totalBarWidth = t + q; I.width = (c.length * t) + ((c.length - 1) * q); if (m) { C = k == null ? -Infinity : k; F = l == null ? Infinity : l } g = []; e = E ? [] : g; for (B = 0, h = c.length; B < h; B++) { if (E) { w = c[B]; c[B] = p = []; b[B] = 0; e[B] = a[B] = 0; for (y = 0, H = w.length; y < H; y++) { J = p[y] = m ? Ext.Number.constrain(w[y], C, F) : w[y]; if (J !== null) { if (J > 0) { b[B] += J } if (D < 0 && G > 0) { if (J < 0) { a[B] += Math.abs(J) } else { e[B] += J } } else { e[B] += Math.abs(J - (J < 0 ? G : D)) } g.push(J) } } } else { J = m ? Ext.Number.constrain(c[B], C, F) : c[B]; J = c[B] = I.normalizeValue(J); if (J !== null) { g.push(J) } } } I.max = A = Math.max.apply(Math, g); I.min = x = Math.min.apply(Math, g); I.stackMax = G = E ? Math.max.apply(Math, b) : A; I.stackMin = D = E ? Math.min.apply(Math, g) : x; if (k != null && (m || k < x)) { x = k } if (l != null && (m || l > A)) { A = l } if (x <= 0 && A >= 0 && z) { o = 0 } else { if (!z) { o = x } else { if (x > 0) { o = x } else { o = A } } } I.xAxisOffset = o; s = E ? (Math.max.apply(Math, e) + Math.max.apply(Math, a)) : A - x; I.canvasHeightEf = (z && x < 0) ? I.getHeight() - 2 : I.getHeight() - 1; if (x < o) { d = (E && A >= 0) ? G : A; n = (d - o) / s * I.getHeight(); if (n !== Math.ceil(n)) { I.canvasHeightEf -= 2; n = Math.ceil(n) } } else { n = I.getHeight() } I.yoffset = n; I.range = s }, getRegion: function (b, c) { var a = Math.floor(b / this.totalBarWidth); return (a < 0 || a >= this.values.length) ? undefined : a }, getRegionFields: function (e) { var b = Ext.Array.from(this.values[e]), a = [], d, c; for (c = b.length; c--;) { d = b[c]; a.push({ isNull: d === null, value: d, color: this.calcColor(c, d, e), offset: e }) } return a }, calcColor: function (j, i, d) { var g = this, b = g.colorMapByIndex, h = g.colorMapByValue, a, e, c = g.getZeroColor(); if (this.stacked) { a = g.getStackedBarColor() } else { a = (i < 0) ? g.getNegBarColor() : g.getBarColor() } if (i === 0 && c != null) { a = c } if (h && (e = h.get(i))) { a = e } else { if (b && b.length > d) { a = b[d] } } return Ext.isArray(a) ? a[j % a.length] : a }, renderRegion: function (l, e) { var z = this, n = z.values[l], a = z.xAxisOffset, o = z.range, w = z.stacked, c = z.canvas, q = z.getBarWidth(), j = l * z.totalBarWidth, b = z.canvasHeightEf, k = z.yoffset, h, r, t, s, g, u, d, A, v, m, p = z.getNullColor(); n = Ext.isArray(n) ? n : [n]; d = n.length; A = n[0]; s = z.all(n, null); m = z.all(n, a, true); if (s) { if (p) { t = e ? p : z.calcHighlightColor(p, z); h = (k > 0) ? k - 1 : k; c.drawRect(j, h, q - 1, 0, t, t).append() } return } g = k; for (u = 0; u < d; u++) { A = n[u]; if (w && A === a) { if (!m || v) { continue } v = true } if (o > 0) { r = Math.floor(b * ((Math.abs(A - a) / o))) + 1 } else { r = 1 } if (A < a || (A === a && k === 0)) { h = g; g += r } else { h = k - r; k -= r } t = z.calcColor(u, A, l); if (e) { t = z.calcHighlightColor(t, z) } c.drawRect(j, h, q - 1, r - 1, t, t).append() } } }, 0, ["sparklinebar"], ["widget", "sparkline", "sparklinebar"], { widget: true, sparkline: true, sparklinebar: true }, ["widget.sparklinebar"], 0, [Ext.sparkline, "Bar"], function (a) { a.onClassCreated(a) })); (Ext.cmd.derive("Ext.sparkline.Box", Ext.sparkline.Base, { config: { raw: false, boxLineColor: "#000", boxFillColor: "#cdf", whiskerColor: "#000", outlierLineColor: "#333", outlierFillColor: "#fff", medianColor: "#f00", showOutliers: true, outlierIQR: 1.5, spotRadius: 1.5, target: null, targetColor: "#4a2", chartRangeMin: null, chartRangeMax: null }, tipTpl: ["{field:this.fields}: {value}", { fields: function (b) { var a = { lq: "Lower Quartile", med: "Median", uq: "Upper Quartile", lo: "Left Outlier", ro: "Right Outlier", lw: "Left Whisker", rw: "Right Whisker" }; return a[b] } }], tooltipFormatFieldlistKey: "field", quartile: function (a, c) { var b; if (c === 2) { b = Math.floor(a.length / 2); return a.length % 2 ? a[b] : (a[b - 1] + a[b]) / 2 } else { if (a.length % 2) { b = (a.length * c + c) / 4; return b % 1 ? (a[Math.floor(b)] + a[Math.floor(b) - 1]) / 2 : a[b - 1] } else { b = (a.length * c + 2) / 4; return b % 1 ? (a[Math.floor(b)] + a[Math.floor(b) - 1]) / 2 : a[b - 1] } } }, applyValues: function (a) { a = Ext.Array.map(Ext.Array.from(a), Number); this.disabled = !(a && a.length); this.applyConfigChange(); return a }, getRegion: function () { return 1 }, getRegionFields: function () { var a = [{ field: "lq", value: this.quartiles[0] }, { field: "med", value: this.quartiles[1] }, { field: "uq", value: this.quartiles[2] }]; if (this.loutlier !== undefined) { a.push({ field: "lo", value: this.loutlier }) } if (this.routlier !== undefined) { a.push({ field: "ro", value: this.routlier }) } if (this.lwhisker !== undefined) { a.push({ field: "lw", value: this.lwhisker }) } if (this.rwhisker !== undefined) { a.push({ field: "rw", value: this.rwhisker }) } return a }, renderHighlight: Ext.emptyFn, renderGraph: function () { var E = this, l = E.canvas, h = E.values, o = h.length, D = E.getWidth(), e = E.getHeight(), q = E.getChartRangeMin(), t = E.getChartRangeMax(), x = q == null ? Math.min.apply(Math, h) : q, C = t == null ? Math.max.apply(Math, h) : t, z = 0, w, B, j, s, r, p, b, m, A, y, g, F = E.getSpotRadius(), a = E.getOutlierLineColor(), k = E.getOutlierFillColor(), v = E.getShowOutliers(), u = E.getOutlierIQR(), d = E.getLineColor(), c = E.getWhiskerColor(), n = E.getTargetColor(); if (!Ext.sparkline.Base.prototype.renderGraph.call(this)) { return } if (E.raw) { if (v && h.length > 5) { B = h[0]; w = h[1]; s = h[2]; r = h[3]; p = h[4]; b = h[5]; m = h[6] } else { w = h[0]; s = h[1]; r = h[2]; p = h[3]; b = h[4] } } else { h.sort(function (G, i) { return G - i }); s = E.quartile(h, 1); r = E.quartile(h, 2); p = E.quartile(h, 3); j = p - s; if (v) { w = b = null; for (A = 0; A < o; A++) { if (w == null && h[A] > s - (j * u)) { w = h[A] } if (h[A] < p + (j * u)) { b = h[A] } } B = h[0]; m = h[o - 1] } else { w = h[0]; b = h[o - 1] } } E.quartiles = [s, r, p]; E.lwhisker = w; E.rwhisker = b; E.loutlier = B; E.routlier = m; g = D / (C - x + 1); if (v) { z = Math.ceil(F); D -= 2 * Math.ceil(F); g = D / (C - x + 1); if (B < w) { l.drawCircle((B - x) * g + z, e / 2, F, a, k).append() } if (m > b) { l.drawCircle((m - x) * g + z, e / 2, F, a, k).append() } } l.drawRect(Math.round((s - x) * g + z), Math.round(e * 0.1), Math.round((p - s) * g), Math.round(e * 0.8), E.getBoxLineColor(), E.getBoxFillColor()).append(); l.drawLine(Math.round((w - x) * g + z), Math.round(e / 2), Math.round((s - x) * g + z), Math.round(e / 2), d).append(); l.drawLine(Math.round((w - x) * g + z), Math.round(e / 4), Math.round((w - x) * g + z), Math.round(e - e / 4), c).append(); l.drawLine(Math.round((b - x) * g + z), Math.round(e / 2), Math.round((p - x) * g + z), Math.round(e / 2), d).append(); l.drawLine(Math.round((b - x) * g + z), Math.round(e / 4), Math.round((b - x) * g + z), Math.round(e - e / 4), c).append(); l.drawLine(Math.round((r - x) * g + z), Math.round(e * 0.1), Math.round((r - x) * g + z), Math.round(e * 0.9), E.getMedianColor()).append(); if (E.target) { y = Math.ceil(E.spotRadius); l.drawLine(Math.round((E.target - x) * g + z), Math.round((e / 2) - y), Math.round((E.target - x) * g + z), Math.round((e / 2) + y), n).append(); l.drawLine(Math.round((E.target - x) * g + z - y), Math.round(e / 2), Math.round((E.target - x) * g + z + y), Math.round(e / 2), n).append() } if (E.currentPageXY && E.el.getRegion().contains(E.currentPageXY)) { E.currentRegion = null; E.updateDisplay() } l.render() } }, 0, ["sparklinebox"], ["widget", "sparkline", "sparklinebox"], { widget: true, sparkline: true, sparklinebox: true }, ["widget.sparklinebox"], 0, [Ext.sparkline, "Box"], 0)); (Ext.cmd.derive("Ext.sparkline.Bullet", Ext.sparkline.Base, { config: { targetColor: "#f33", targetWidth: 3, performanceColor: "#33f", rangeColors: ["#d3dafe", "#a8b6ff", "#7f94ff"], base: null }, tipTpl: ["{fieldkey:this.fields} - {value}", { fields: function (a) { if (a === "r") { return "Range" } if (a === "p") { return "Performance" } if (a === "t") { return "Target" } } }], applyValues: function (a) { a = Ext.Array.map(Ext.Array.from(a), this.normalizeValue); this.disabled = !(a && a.length); this.applyConfigChange(); return a }, onUpdate: function () { var d = this, b = d.values, c, a, g, e = d.getBase(); Ext.sparkline.Base.prototype.onUpdate.apply(this, arguments); g = b.slice(); g[0] = g[0] === null ? g[2] : g[0]; g[1] = b[1] === null ? g[2] : g[1]; c = Math.min.apply(Math, b); a = Math.max.apply(Math, b); if (e == null) { c = c < 0 ? c : 0 } else { c = e } d.min = c; d.max = a; d.range = a - c; d.shapes = {}; d.valueShapes = {}; d.regiondata = {}; if (!b.length) { d.disabled = true } }, getRegion: function (a, c) { var b = this.canvas.getShapeAt(a, c); return (b !== undefined && this.shapes[b] !== undefined) ? this.shapes[b] : undefined }, getRegionFields: function (a) { return { fieldkey: a.substr(0, 1), value: this.values[a.substr(1)], region: a } }, renderHighlight: function (e) { var d = this, b = d.valueShapes, a = d.shapes, g = b[e], c; delete a[g]; switch (e.substr(0, 1)) { case "r": c = d.renderRange(e.substr(1), true); break; case "p": c = d.renderPerformance(true); break; case "t": c = d.renderTarget(true); break }b[e] = c.id; a[c.id] = e; d.canvas.replaceWithShape(g, c) }, renderRange: function (e, b) { var d = this.values[e], c = Math.round(this.getWidth() * ((d - this.min) / this.range)), a = this.getRangeColors()[e - 2]; if (b) { a = this.calcHighlightColor(a) } return this.canvas.drawRect(0, 0, c - 1, this.getHeight() - 1, a, a) }, renderPerformance: function (b) { var d = this.values[1], c = Math.round(this.getWidth() * ((d - this.min) / this.range)), a = this.getPerformanceColor(); if (b) { a = this.calcHighlightColor(a) } return this.canvas.drawRect(0, Math.round(this.getHeight() * 0.3), c - 1, Math.round(this.getHeight() * 0.4) - 1, a, a) }, renderTarget: function (c) { var h = this.values[0], e = this.getTargetWidth(), a = Math.round(this.getWidth() * ((h - this.min) / this.range) - (e / 2)), g = Math.round(this.getHeight() * 0.1), d = this.getHeight() - (g * 2), b = this.getTargetColor(); if (c) { b = this.calcHighlightColor(b) } return this.canvas.drawRect(a, g, e - 1, d - 1, b, b) }, renderGraph: function () { var g = this, h = g.values.length, d = g.canvas, e, c, b = g.shapes || (g.shapes = {}), a = g.valueShapes || (g.valueShapes = {}); if (!Ext.sparkline.Base.prototype.renderGraph.call(this)) { return } for (e = 2; e < h; e++) { c = g.renderRange(e).append(); b[c.id] = "r" + e; a["r" + e] = c.id } if (g.values[1] !== null) { c = g.renderPerformance().append(); b[c.id] = "p1"; a.p1 = c.id } if (g.values[0] !== null) { c = this.renderTarget().append(); b[c.id] = "t0"; a.t0 = c.id } if (g.currentPageXY && g.el.getRegion().contains(g.currentPageXY)) { g.updateDisplay() } d.render() }, privates: { isValidRegion: function (b, a) { return true } } }, 0, ["sparklinebullet"], ["widget", "sparkline", "sparklinebullet"], { widget: true, sparkline: true, sparklinebullet: true }, ["widget.sparklinebullet"], 0, [Ext.sparkline, "Bullet"], 0)); (Ext.cmd.derive("Ext.sparkline.Discrete", Ext.sparkline.BarBase, { config: { lineHeight: "auto", thresholdColor: null, thresholdValue: 0, chartRangeMax: null, chartRangeMin: null, chartRangeClip: false }, tipTpl: "{prefix}{value}{suffix}", applyValues: function (a) { a = Ext.Array.map(Ext.Array.from(a), Number); this.disabled = !(a && a.length); this.applyConfigChange(); return a }, onUpdate: function () { var c = this, b = c.values, a = c.getChartRangeMin(), d = c.getChartRangeMax(), e = c.getChartRangeClip(); Ext.sparkline.BarBase.prototype.onUpdate.apply(this, arguments); c.regionShapes = {}; c.min = Math.min.apply(Math, b); c.max = Math.max.apply(Math, b); c.range = c.max - c.min; c.width = c.getWidth(); c.interval = Math.floor(c.width / b.length); c.itemWidth = c.width / b.length; if (a != null && (e || a < c.min)) { c.min = a } if (d != null && (e || d > c.max)) { c.max = d } if (c.canvas) { if (c.getLineHeight() === "auto") { c.setLineHeight(Math.round(c.getHeight() * 0.3)) } } }, getRegion: function (a, b) { return Math.floor(a / this.itemWidth) }, getRegionFields: function (a) { return { isNull: this.values[a] === undefined, value: this.values[a], offset: a } }, renderRegion: function (k, e) { var m = this, r = m.values, h = m.min, n = m.max, j = m.range, c = m.interval, b = m.canvas, i = m.getHeight(), q = m.getLineHeight(), l = i - q, a, d, g, p, o = m.getThresholdColor(); d = Ext.Number.constrain(r[k], h, n); p = k * c; a = Math.round(l - l * ((d - h) / j)); g = (o && d < m.getThresholdValue()) ? o : m.getLineColor(); if (e) { g = m.calcHighlightColor(g) } b.drawLine(p, a, p, a + q, g).append() } }, 0, ["sparklinediscrete"], ["widget", "sparkline", "sparklinediscrete"], { widget: true, sparkline: true, sparklinediscrete: true }, ["widget.sparklinediscrete"], 0, [Ext.sparkline, "Discrete"], 0)); (Ext.cmd.derive("Ext.sparkline.Line", Ext.sparkline.Base, { config: { fillColor: "#def", spotColor: "#f80", highlightSpotColor: "#5f5", highlightLineColor: "#f22", spotRadius: 1.5, minSpotColor: "#f80", maxSpotColor: "#f80", lineWidth: 1, normalRangeMin: null, normalRangeMax: null, normalRangeColor: "#ccc", drawNormalOnTop: false, chartRangeMin: null, chartRangeMax: null, chartRangeMinX: null, chartRangeMaxX: null, valueSpots: null }, tipTpl: "&#9679; {prefix}{y}{suffix}", applyValueSpots: function (a) { if (a && !a.get) { a = new Ext.sparkline.RangeMap(a) } this.applyConfigChange(); return a }, onUpdate: function () { this.vertices = []; this.regionMap = []; this.xvalues = []; this.yvalues = []; this.yminmax = [] }, getRegion: function (a, d) { var b, c = this.regionMap; for (b = c.length; b--;) { if (c[b] !== null && a >= c[b][0] && a <= c[b][1]) { return c[b][2] } } return undefined }, getRegionFields: function (a) { return { isNull: this.yvalues[a] === null, x: this.xvalues[a], y: this.yvalues[a], color: this.getLineColor(), fillColor: this.getFillColor(), offset: a } }, renderHighlight: function (g) { var c = this, a = c.canvas, e = c.vertices[g], b = c.getSpotRadius(), h = c.getHighlightSpotColor(), d = c.getHighlightLineColor(); if (!e) { return } if (b && h) { a.drawCircle(e[0], e[1], b, null, h).append() } if (d) { a.drawLine(e[0], c.canvasTop, e[0], c.canvasTop + c.getHeight(), d).append() } }, scanValues: function () { var k = this, l = k.values, c = l.length, a = k.xvalues, h = k.yvalues, m = k.yminmax, e, d, j, g, b; for (e = 0; e < c; e++) { d = l[e]; j = typeof (l[e]) === "string"; g = typeof (l[e]) === "object" && l[e] instanceof Array; b = j && l[e].split(":"); if (j && b.length === 2) { a.push(Number(b[0])); h.push(Number(b[1])); m.push(Number(b[1])) } else { if (g) { a.push(d[0]); h.push(d[1]); m.push(d[1]) } else { a.push(e); if (l[e] === null || l[e] === "null") { h.push(null) } else { h.push(Number(d)); m.push(Number(d)) } } } } if (k.xvalues) { a = k.xvalues } k.maxy = k.maxyorg = Math.max.apply(Math, m); k.miny = k.minyorg = Math.min.apply(Math, m); k.maxx = Math.max.apply(Math, a); k.minx = Math.min.apply(Math, a); k.xvalues = a; k.yvalues = h; k.yminmax = m }, processRangeOptions: function () { var d = this, c = d.getNormalRangeMin(), g = d.getNormalRangeMax(), a = d.getChartRangeMin(), b = d.getChartRangeMinX(), e = d.getChartRangeMax(), h = d.getChartRangeMaxX(); if (c != null) { if (c < d.miny) { d.miny = c } if (g > d.maxy) { d.maxy = g } } if (a != null && (d.chartRangeClip || a < d.miny)) { d.miny = a } if (e != null && (d.chartRangeClip || e > d.maxy)) { this.maxy = e } if (b != null && (d.chartRangeClipX || b < d.minx)) { d.minx = b } if (h != null && (d.chartRangeClipX || h > d.maxx)) { d.maxx = h } }, drawNormalRange: function (c, h, g, d, i) { var a = this.getNormalRangeMin(), e = this.getNormalRangeMax(), b = h + Math.round(g - (g * ((e - this.miny) / i))), j = Math.round((g * (e - a)) / i); this.canvas.drawRect(c, b, d, j, undefined, this.normalRangeColor).append() }, renderGraph: function () { var q = this, k = q.canvas, M = q.getWidth(), m = q.getHeight(), d = q.vertices, L = q.getSpotRadius(), O = q.regionMap, B, g, C, t, r, s, J, A, F, E, j, w, n, p, h, K, e, D, o, c = q.getValueSpots(), H, u, G, I, N, l = q.getSpotColor(), b = q.getMinSpotColor(), z = q.getMaxSpotColor(), v = q.getNormalRangeMin(), a = q.getDrawNormalOnTop(); if (!Ext.sparkline.Base.prototype.renderGraph.call(this)) { return } q.scanValues(); q.processRangeOptions(); G = q.xvalues; I = q.yvalues; if (!q.yminmax.length || q.yvalues.length < 2) { return } t = r = 0; B = q.maxx - q.minx === 0 ? 1 : q.maxx - q.minx; g = q.maxy - q.miny === 0 ? 1 : q.maxy - q.miny; C = q.yvalues.length - 1; if (L && (M < (L * 4) || m < (L * 4))) { L = 0 } if (L) { H = q.getHighlightSpotColor() && !q.disableInteraction; if (H || b || (l && I[C] === q.miny)) { m -= Math.ceil(L) } if (H || z || (l && I[C] === q.maxy)) { m -= Math.ceil(L); t += Math.ceil(L) } if (H || ((b || z) && (I[0] === q.miny || I[0] === q.maxy))) { r += Math.ceil(L); M -= Math.ceil(L) } if (H || l || (b || z && (I[C] === q.miny || I[C] === q.maxy))) { M -= Math.ceil(L) } } m--; if (v != null && !a) { q.drawNormalRange(r, t, m, M, g) } J = []; A = [J]; p = h = null; K = I.length; for (N = 0; N < K; N++) { F = G[N]; j = G[N + 1]; E = I[N]; w = r + Math.round((F - q.minx) * (M / B)); n = N < K - 1 ? r + Math.round((j - q.minx) * (M / B)) : M; h = w + ((n - w) / 2); O[N] = [p || 0, h, N]; p = h; if (E === null) { if (N) { if (I[N - 1] !== null) { J = []; A.push(J) } d.push(null) } } else { if (E < q.miny) { E = q.miny } if (E > q.maxy) { E = q.maxy } if (!J.length) { J.push([w, t + m]) } s = [w, t + Math.round(m - (m * ((E - this.miny) / g)))]; J.push(s); d.push(s) } } e = []; D = []; o = A.length; for (N = 0; N < o; N++) { J = A[N]; if (J.length) { if (q.fillColor) { J.push([J[J.length - 1][0], (t + m)]); D.push(J.slice(0)); J.pop() } if (J.length > 2) { J[0] = [J[0][0], J[1][1]] } e.push(J) } } o = D.length; for (N = 0; N < o; N++) { k.drawShape(D[N], q.fillColor, q.fillColor).append() } if (v != null && a) { q.drawNormalRange(r, t, m, M, g) } o = e.length; for (N = 0; N < o; N++) { k.drawShape(e[N], q.getLineColor(), null, q.getLineWidth()).append() } if (L && c) { if (c.get == null) { c = new Ext.sparkline.RangeMap(c) } for (N = 0; N < K; N++) { u = c.get(I[N]); if (u) { k.drawCircle(r + Math.round((G[N] - q.minx) * (M / B)), t + Math.round(m - (m * ((I[N] - q.miny) / g))), L, null, u).append() } } } if (L && l && I[C] != null) { k.drawCircle(r + Math.round((G[G.length - 1] - q.minx) * (M / B)), t + Math.round(m - (m * ((I[C] - q.miny) / g))), L, null, l).append() } if (q.maxy !== q.minyorg) { if (L && b) { F = G[Ext.Array.indexOf(I, q.minyorg)]; k.drawCircle(r + Math.round((F - q.minx) * (M / B)), t + Math.round(m - (m * ((q.minyorg - q.miny) / g))), L, null, b).append() } if (L && z) { F = G[Ext.Array.indexOf(I, q.maxyorg)]; k.drawCircle(r + Math.round((F - q.minx) * (M / B)), t + Math.round(m - (m * ((q.maxyorg - q.miny) / g))), L, null, z).append() } } q.canvasTop = t; if (q.currentPageXY && q.el.getRegion().contains(q.currentPageXY)) { q.updateDisplay() } k.render() } }, 0, ["sparklineline"], ["widget", "sparkline", "sparklineline"], { widget: true, sparkline: true, sparklineline: true }, ["widget.sparklineline"], 0, [Ext.sparkline, "Line"], 0)); (Ext.cmd.derive("Ext.sparkline.Pie", Ext.sparkline.Base, { config: { offset: 0, sliceColors: ["#3366cc", "#dc3912", "#ff9900", "#109618", "#66aa00", "#dd4477", "#0099c6", "#990099"], borderWidth: 0, borderColor: "#000" }, tipTpl: '&#9679; {value} ({percent:number("0.0")}%)', applyValues: function (a) { a = Ext.Array.map(Ext.Array.from(a), Number); this.disabled = !(a && a.length); this.applyConfigChange(); return a }, onUpdate: function () { var d = this, a = d.values, c = 0, b; Ext.sparkline.Base.prototype.onUpdate.apply(this, arguments); d.shapes = {}; d.valueShapes = {}; if (a.length > 0) { for (b = a.length; b--;) { c += a[b] } } d.total = c; d.radius = Math.floor(Math.min(d.getWidth(), d.getHeight()) / 2) }, getRegion: function (a, d) { var b = window.devicePixelRatio || 1, c = this.canvas.getShapeAt(a * b, d * b); return (c != null && this.shapes[c] != null) ? this.shapes[c] : null }, getRegionFields: function (b) { var a = this.getSliceColors(); return { isNull: this.values[b] == null, value: this.values[b], percent: this.values[b] / this.total * 100, color: a[b % a.length], offset: b } }, renderHighlight: function (a) { this.renderSlice(a, true).append() }, renderSlice: function (m, e) { var o = this, d = o.canvas, n = o.radius, a = o.getBorderWidth(), j = o.getOffset(), b = 2 * Math.PI, s = o.values, p = o.total, l = j ? (2 * Math.PI) * (j / 360) : 0, c, h, k, q, g, r = this.getSliceColors(); q = s.length; for (k = 0; k < q; k++) { c = l; h = l; if (p > 0) { h = l + (b * (s[k] / p)) } if (m === k) { g = r[k % r.length]; if (e) { g = o.calcHighlightColor(g) } return d.drawPieSlice(n, n, n - a, c, h, null, g) } l = h } }, renderGraph: function () { var h = this, c = h.canvas, k = h.values, e = h.radius, a = h.getBorderWidth(), g, d, b = h.shapes || (h.shapes = {}), j = h.valueShapes || (h.valueShapes = {}); if (!Ext.sparkline.Base.prototype.renderGraph.call(this)) { return } if (a) { c.drawCircle(e, e, Math.floor(e - (a / 2)), h.getBorderColor(), null, a).append() } for (d = k.length; d--;) { if (k[d]) { g = h.renderSlice(d).append(); j[d] = g.id; b[g.id] = d } } if (h.currentPageXY && h.el.getRegion().contains(h.currentPageXY)) { h.currentRegion = null; h.updateDisplay() } c.render() } }, 0, ["sparklinepie"], ["widget", "sparkline", "sparklinepie"], { widget: true, sparkline: true, sparklinepie: true }, ["widget.sparklinepie"], 0, [Ext.sparkline, "Pie"], 0)); (Ext.cmd.derive("Ext.sparkline.TriState", Ext.sparkline.BarBase, { config: { barWidth: 4, barSpacing: 1, posBarColor: "#6f6", negBarColor: "#f44", zeroBarColor: "#999", colorMap: {} }, tipTpl: ["&#9679; {value:this.states}", { states: function (a) { var b = Number(a); if (b === -1) { return "Loss" } if (b === 0) { return "Draw" } if (b === 1) { return "Win" } return a } }], applyColorMap: function (a) { var b = this; if (Ext.isArray(a)) { b.colorMapByIndex = a; b.colorMapByValue = null } else { b.colorMapByIndex = null; b.colorMapByValue = a; if (b.colorMapByValue && b.colorMapByValue.get == null) { b.colorMapByValue = new Ext.sparkline.RangeMap(a) } } b.applyConfigChange(); return a }, applyValues: function (a) { a = Ext.Array.map(Ext.Array.from(a), Number); this.disabled = !(a && a.length); this.applyConfigChange(); return a }, onUpdate: function () { this.totalBarWidth = this.getBarWidth() + this.getBarSpacing() }, getBarWidth: function () { var a = this.values; return this._barWidth || (this.getWidth() - (a.length - 1) * this.getBarSpacing()) / a.length }, getRegion: function (a, b) { return Math.floor(a / this.totalBarWidth) }, getRegionFields: function (a) { return { isNull: this.values[a] == null, value: this.values[a], color: this.calcColor(this.values[a], a), offset: a } }, calcColor: function (g, h) { var e = this, b = e.values, i = e.colorMapByIndex, d = e.colorMapByValue, a, c; if (d && (c = d.get(g))) { a = c } else { if (i && i.length > h) { a = i[h] } else { if (b[h] < 0) { a = e.getNegBarColor() } else { if (b[h] > 0) { a = e.getPosBarColor() } else { a = e.getZeroBarColor() } } } } return a }, renderRegion: function (e, b) { var h = this, k = h.values, a = h.canvas, d, l, g, j, i, c; d = a.pixelHeight; g = Math.round(d / 2); j = e * h.totalBarWidth; if (k[e] < 0) { i = g; l = g - 1 } else { if (k[e] > 0) { i = 0; l = g - 1 } else { i = g - 1; l = 2 } } c = h.calcColor(k[e], e); if (c == null) { return } if (b) { c = h.calcHighlightColor(c) } a.drawRect(j, i, h.getBarWidth() - 1, l - 1, c, c).append() } }, 0, ["sparklinetristate"], ["widget", "sparkline", "sparklinetristate"], { widget: true, sparkline: true, sparklinetristate: true }, ["widget.sparklinetristate"], 0, [Ext.sparkline, "TriState"], 0)); (Ext.cmd.derive("Ext.util.Base64", Ext.Base, { singleton: true, _str: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", encode: function (e) { var d = this; var a = "", n, l, j, m, k, h, g, b = 0; e = d._utf8_encode(e); var c = e.length; while (b < c) { n = e.charCodeAt(b++); l = e.charCodeAt(b++); j = e.charCodeAt(b++); m = n >> 2; k = ((n & 3) << 4) | (l >> 4); h = ((l & 15) << 2) | (j >> 6); g = j & 63; if (isNaN(l)) { h = g = 64 } else { if (isNaN(j)) { g = 64 } } a = a + d._str.charAt(m) + d._str.charAt(k) + d._str.charAt(h) + d._str.charAt(g) } return a }, decode: function (e) { var d = this; var a = "", n, l, j, m, k, h, g, b = 0; e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""); var c = e.length; while (b < c) { m = d._str.indexOf(e.charAt(b++)); k = d._str.indexOf(e.charAt(b++)); h = d._str.indexOf(e.charAt(b++)); g = d._str.indexOf(e.charAt(b++)); n = (m << 2) | (k >> 4); l = ((k & 15) << 4) | (h >> 2); j = ((h & 3) << 6) | g; a = a + String.fromCharCode(n); if (h !== 64) { a = a + String.fromCharCode(l) } if (g !== 64) { a = a + String.fromCharCode(j) } } a = d._utf8_decode(a); return a }, _utf8_encode: function (d) { d = d.replace(/\r\n/g, "\n"); var b = "", g = 0, a = d.length; for (; g < a; g++) { var e = d.charCodeAt(g); if (e < 128) { b += String.fromCharCode(e) } else { if ((e > 127) && (e < 2048)) { b += String.fromCharCode((e >> 6) | 192); b += String.fromCharCode((e & 63) | 128) } else { b += String.fromCharCode((e >> 12) | 224); b += String.fromCharCode(((e >> 6) & 63) | 128); b += String.fromCharCode((e & 63) | 128) } } } return b }, _utf8_decode: function (b) { var e = "", h = 0, j = 0, d = 0, g = 0, a = b.length; while (h < a) { j = b.charCodeAt(h); if (j < 128) { e += String.fromCharCode(j); h++ } else { if ((j > 191) && (j < 224)) { g = b.charCodeAt(h + 1); e += String.fromCharCode(((j & 31) << 6) | (g & 63)); h += 2 } else { g = b.charCodeAt(h + 1); d = b.charCodeAt(h + 2); e += String.fromCharCode(((j & 15) << 12) | ((g & 63) << 6) | (d & 63)); h += 3 } } } return e } }, 0, 0, 0, 0, 0, 0, [Ext.util, "Base64"], 0)); (Ext.cmd.derive("Ext.util.DelimitedValue", Ext.Base, { dateFormat: "C", delimiter: "\t", lineBreak: "\n", quote: '"', parseREs: {}, quoteREs: {}, lineBreakRe: /\r?\n/g, lastLineBreakRe: /(\r?\n|\r)$/, constructor: function (a) { if (a) { Ext.apply(this, a) } }, decode: function (k, b) { if (!k) { return [] } var i = this, c = b || i.delimiter, n = [], o = [n], a = i.quote, g = i.quoteREs, l = i.parseREs, k = k.replace(i.lastLineBreakRe, ""), m = l[c] || (l[c] = new RegExp("(\\" + c + "|\\r?\\n|\\r|^)(?:\\" + a + "([^\\" + a + "]*(?:\\" + a + "\\" + a + "[^\\" + a + "]*)*)\\" + a + '|([^"\\' + c + "\\r\\n]*))", "gi")), e = g[a] || (g[a] = new RegExp("\\" + a + "\\" + a, "g")), h, d, j; while (h = m.exec(k)) { d = h[1]; if (d.length && d !== c) { o.push(n = []) } if (h[2]) { j = h[2].replace(e, '"') } else { j = h[3] } n.push(j) } return o }, encode: function (m, c) { var j = this, e = c || j.delimiter, d = j.dateFormat, b = j.quote, k = b + b, l = m.length, h = j.lineBreakRe, o = [], a = [], g, i, n; while (l-- > 0) { n = m[l]; a.length = i = n.length; while (i-- > 0) { g = n[i]; if (g == null) { g = "" } else { if (typeof g === "string") { if (g) { if (g.indexOf(b) > -1) { g = b + g.split(b).join(k) + b } else { if (g.indexOf(e) > -1 || h.test(g)) { g = b + g + b } } } } else { if (Ext.isDate(g)) { g = Ext.Date.format(g, d) } } } a[i] = g } o[l] = a.join(e) } return o.join(j.lineBreak) } }, 1, 0, 0, 0, 0, 0, [Ext.util, "DelimitedValue"], 0)); (Ext.cmd.derive("Ext.util.CSV", Ext.util.DelimitedValue, { singleton: true, delimiter: "," }, 0, 0, 0, 0, 0, 0, [Ext.util, "CSV"], 0)); (Ext.cmd.derive("Ext.util.ItemCollection", Ext.util.MixedCollection, { alternateClassName: "Ext.ItemCollection", getKey: function (a) { return a.getItemId && a.getItemId() }, has: function (a) { return this.map.hasOwnProperty(a.getId()) } }, 0, 0, 0, 0, 0, 0, [Ext.util, "ItemCollection", Ext, "ItemCollection"], 0)); (Ext.cmd.derive("Ext.util.LocalStorage", Ext.Base, { id: null, destroyed: false, lazyKeys: true, prefix: "", session: false, _keys: null, _store: null, _users: 0, statics: { cache: {}, get: function (e) { var d = this, b = d.cache, c = { _users: 1 }, a; if (Ext.isString(e)) { c.id = e } else { Ext.apply(c, e) } if (!(a = b[c.id])) { a = new d(c) } else { ++a._users } return a }, supported: true }, constructor: function (a) { var b = this; Ext.apply(b, a); if (b._users) { Ext.util.LocalStorage.cache[b.id] = b } b.init() }, init: function () { var a = this, b = a.id; if (!a.prefix && b) { a.prefix = b + "-" } a._store = (a.session ? window.sessionStorage : window.localStorage) }, destroy: function () { var a = this; delete Ext.util.LocalStorage.cache[a.id]; a._store = a._keys = null; a.callParent() }, getKeys: function () { var e = this, a = e._store, g = e.prefix, d = e._keys, h = g.length, c, b; if (!d) { e._keys = d = []; for (c = a.length; c--;) { b = a.key(c); if (b.length > h) { if (g === b.substring(0, h)) { d.push(b.substring(h)) } } } } return d }, release: function () { if (!--this._users) { this.destroy() } }, save: Ext.emptyFn, clear: function () { var d = this, a = d._store, e = d.prefix, c = d._keys || d.getKeys(), b; for (b = c.length; b--;) { a.removeItem(e + c[b]) } c.length = 0 }, key: function (a) { var b = this._keys || this.getKeys(); return (0 <= a && a < b.length) ? b[a] : null }, getItem: function (b) { var a = this.prefix + b; return this._store.getItem(a) }, removeItem: function (c) { var g = this, b = g.prefix + c, a = g._store, e = g._keys, d = a.length; a.removeItem(b); if (e && d !== a.length) { if (g.lazyKeys) { g._keys = null } else { Ext.Array.remove(e, c) } } }, setItem: function (c, h) { var g = this, b = g.prefix + c, a = g._store, e = a.length, d = g._keys; a.setItem(b, h); if (d && e !== a.length) { d.push(c) } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "LocalStorage"], function () { var a = this; if ("localStorage" in window) { return } if (!Ext.isIE) { a.supported = false; return } a.override({ data: null, flushDelay: 1, init: function () { var c = this, d = c.data, b; c.el = b = document.createElement("div"); b.id = (c.id || (c.id = "extjs-localstore")); b.addBehavior("#default#userdata"); Ext.getHead().dom.appendChild(b); b.load(c.id); d = b.getAttribute("xdata"); c.data = d = (d ? Ext.decode(d) : {}); c._flushFn = function () { c._timer = null; c.save(0) } }, destroy: function () { var c = this, b = c.el; if (b) { if (c._timer) { c.save() } b.parentNode.removeChild(b); c.data = c.el = null; c.callParent() } }, getKeys: function () { var c = this, b = c._keys; if (!b) { c._keys = b = Ext.Object.getKeys(c.data) } return b }, save: function (b) { var c = this; if (!b) { if (c._timer) { clearTimeout(c._timer); c._timer = null } c.el.setAttribute("xdata", Ext.encode(c.data)); c.el.save(c.id) } else { if (!c._timer) { c._timer = Ext.defer(c._flushFn, b) } } }, clear: function () { var b = this; b.data = {}; b._keys = null; b.save(b.flushDelay) }, getItem: function (b) { var c = this.data; return (b in c) ? c[b] : null }, removeItem: function (b) { var d = this, c = d._keys, e = d.data; if (b in e) { delete e[b]; if (c) { if (d.lazyKeys) { d._keys = null } else { Ext.Array.remove(c, b) } } d.save(d.flushDelay) } }, setItem: function (b, g) { var d = this, e = d.data, c = d._keys; if (c && !(b in e)) { c.push(b) } e[b] = g; d.save(d.flushDelay) } }) })); (Ext.cmd.derive("Ext.util.TSV", Ext.util.DelimitedValue, { singleton: true, delimiter: "\t" }, 0, 0, 0, 0, 0, 0, [Ext.util, "TSV"], 0)); (Ext.cmd.derive("Ext.util.TaskManager", Ext.util.TaskRunner, { alternateClassName: ["Ext.TaskManager"], singleton: true }, 0, 0, 0, 0, 0, 0, [Ext.util, "TaskManager", Ext, "TaskManager"], 0)); (Ext.cmd.derive("Ext.util.TextMetrics", Ext.Base, { statics: { shared: null, measure: function (a, d, e) { var b = this, c = b.shared; if (!c) { c = b.shared = new b(a, e) } c.bind(a); c.setFixedWidth(e || "auto"); return c.getSize(d) }, destroy: function () { var a = this; Ext.destroy(a.shared); a.shared = null } }, constructor: function (a, d) { var c = this, b = Ext.getBody().createChild({ role: "presentation", cls: "x-textmetrics" }); b.setVisibilityMode(1); c.measure = b; if (a) { c.bind(a) } b.position("absolute"); b.setLocalXY(-1000, -1000); b.hide(); if (d) { b.setWidth(d) } }, getSize: function (c) { var b = this.measure, a; b.setHtml(c); a = b.getSize(); b.setHtml(""); return a }, bind: function (a) { var b = this; b.el = Ext.get(a); b.measure.setStyle(b.el.getStyle(["font-size", "font-style", "font-weight", "font-family", "line-height", "text-transform", "letter-spacing", "word-break"])) }, setFixedWidth: function (a) { this.measure.setWidth(a) }, getWidth: function (a) { this.measure.dom.style.width = "auto"; return this.getSize(a).width }, getHeight: function (a) { return this.getSize(a).height }, destroy: function () { var a = this; a.el = a.measure = Ext.destroy(a.measure); a.callParent() } }, 1, 0, 0, 0, 0, 0, [Ext.util, "TextMetrics"], function () { Ext.Element.override({ getTextWidth: function (c, b, a) { return Ext.Number.constrain(Ext.util.TextMetrics.measure(this.dom, Ext.valueFrom(c, this.dom.innerHTML, true)).width, b || 0, a || 1000000) } }) })); (Ext.cmd.derive("Ext.util.translatable.CssTransform", Ext.util.translatable.Dom, { isCssTransform: true, doTranslate: function (a, d) { var c = this, b = c.getElement(); if (!c.destroyed && !b.destroyed) { b.translate(a, d) } Ext.util.translatable.Dom.prototype.doTranslate.call(this, a, d) }, destroy: function () { var a = this.getElement(); if (a && !a.destroyed) { a.dom.style.webkitTransform = null } Ext.util.translatable.Dom.prototype.destroy.call(this) } }, 0, 0, 0, 0, 0, 0, [Ext.util.translatable, "CssTransform"], 0)); (Ext.cmd.derive("Ext.util.translatable.ScrollParent", Ext.util.translatable.Dom, { isScrollParent: true, applyElement: function (a) { var b = Ext.get(a); if (b) { this.parent = b.parent() } return b }, doTranslate: function (a, c) { var b = this.parent; b.setScrollLeft(Math.round(-a)); b.setScrollTop(Math.round(-c)); Ext.util.translatable.Dom.prototype.doTranslate.call(this, a, c) }, getPosition: function () { var c = this, a = c.position, b = c.parent; a.x = b.getScrollLeft(); a.y = b.getScrollTop(); return a } }, 0, 0, 0, 0, 0, 0, [Ext.util.translatable, "ScrollParent"], 0)); (Ext.cmd.derive("Ext.util.translatable.CssPosition", Ext.util.translatable.Dom, { doTranslate: function (a, c) { var b = this.getElement().dom.style; if (typeof a == "number") { b.left = a + "px" } if (typeof c == "number") { b.top = c + "px" } Ext.util.translatable.Dom.prototype.doTranslate.call(this, a, c) }, destroy: function () { var a = this.getElement().dom.style; a.left = null; a.top = null; Ext.util.translatable.Dom.prototype.destroy.call(this) } }, 0, 0, 0, 0, 0, 0, [Ext.util.translatable, "CssPosition"], 0)); (Ext.cmd.derive("Ext.util.Translatable", Ext.Base, { constructor: function (a) { var b = Ext.util.translatable; switch (Ext.browser.getPreferredTranslationMethod(a)) { case "scrollposition": return new b.ScrollPosition(a); case "scrollparent": return new b.ScrollParent(a); case "csstransform": return new b.CssTransform(a); case "cssposition": return new b.CssPosition(a) } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "Translatable"], 0)); (Ext.cmd.derive("Ext.util.paintmonitor.OverflowChange", Ext.util.paintmonitor.Abstract, { eventName: Ext.browser.is.Firefox ? "overflow" : "overflowchanged", monitorClass: "overflowchange", onElementPainted: function (a) { this.getCallback().apply(this.getScope(), this.getArgs()) } }, 0, 0, 0, 0, 0, 0, [Ext.util.paintmonitor, "OverflowChange"], 0)); Ext.define(null, { override: "Ext.event.publisher.Focus", compatibility: Ext.isIE10m, publishDelegatedDomEvent: function (c) { var a = document.body, b = Ext.synchronouslyFocusing; if (b && ((c.type === "focusout" && (c.srcElement === b || c.srcElement === window) && c.toElement === a) || (c.type === "focusin" && (c.srcElement === a || c.srcElement === window) && c.fromElement === b && c.toElement === null))) { return } this.callParent([c]) } }); Ext.define(null, { override: "Ext.form.field.Checkbox", compatibility: Ext.isIE8, changeEventName: "propertychange", onChangeEvent: function (a) { if (this.duringSetRawValue || a.browserEvent.propertyName !== "checked") { return } this.callParent([a]) }, updateCheckedCls: function (b) { var a = this, c = a.displayEl; a.callParent([b]); if (c && b !== a.lastValue) { c.repaint() } } }); Ext.define(null, { override: "Ext.form.field.Radio", compatibility: Ext.isIE8, getSubTplData: function (a) { var b = this.callParent([a]); delete b.checked; return b }, afterRender: function () { this.callParent(); if (this.checked) { this.inputEl.dom.checked = true } }, onChange: function (b, a) { this.callSuper([b, a]) } }); Ext.define(null, { override: "Ext.scroll.Scroller", compatibility: Ext.isIE8, privates: { doScrollTo: function (i, h, a) { var g = this, c = g.getElement(), d, b, j, k, e; if (c && !c.destroyed) { b = this.getElement().dom; k = (i === Infinity); e = (h === Infinity); if (k || e) { d = g.getMaxPosition(); if (k) { i = d.x } if (e) { h = d.y } } i = g.convertX(i); if (a) { j = {}; if (h != null) { j.scrollTop = h } if (i != null) { j.scrollLeft = i } c.animate(Ext.mergeIf({ to: { scrollTop: h, scrollLeft: i } }, a)) } else { if (i != null && h != null) { g.deferDomScroll = true } if (h != null) { b.scrollTop = h } if (i != null) { b.scrollLeft = i } if (g.deferDomScroll) { g.deferDomScroll = false; +b.scrollLeft; b.scrollLeft = i } } g.positionDirty = true } }, onDomScroll: function () { var a = this; if (a.deferDomScroll) { return } a.callParent() } } }); (Ext.cmd.derive("Ext.Action", Ext.Base, { constructor: function (a) { this.initialConfig = a; this.itemId = a.itemId = (a.itemId || a.id || Ext.id()); this.items = [] }, isAction: true, setText: function (a) { this.initialConfig.text = a; this.callEach("setText", [a]) }, getText: function () { return this.initialConfig.text }, setIconCls: function (a) { this.initialConfig.iconCls = a; this.callEach("setIconCls", [a]) }, setGlyph: function (a) { this.initialConfig.glyph = a; this.callEach("setGlyph", [a]) }, getIconCls: function () { return this.initialConfig.iconCls }, setDisabled: function (a) { this.initialConfig.disabled = a; this.callEach("setDisabled", [a]) }, enable: function () { this.setDisabled(false) }, disable: function () { this.setDisabled(true) }, isDisabled: function () { return this.initialConfig.disabled }, setHidden: function (a) { this.initialConfig.hidden = a; this.callEach("setVisible", [!a]) }, show: function () { this.setHidden(false) }, hide: function () { this.setHidden(true) }, isHidden: function () { return this.initialConfig.hidden }, setHandler: function (b, a) { this.initialConfig.handler = b; this.initialConfig.scope = a; this.callEach("setHandler", [b, a]) }, each: function (b, a) { Ext.each(this.items, b, a) }, callEach: function (g, c) { var b = this.items, d = 0, a = b.length, e; Ext.suspendLayouts(); for (; d < a; d++) { e = b[d]; e[g].apply(e, c) } Ext.resumeLayouts(true) }, addComponent: function (a) { this.items.push(a); a.on("destroy", this.removeComponent, this) }, removeComponent: function (a) { Ext.Array.remove(this.items, a) }, execute: function () { this.initialConfig.handler.apply(this.initialConfig.scope || Ext.global, arguments) } }, 1, 0, 0, 0, 0, 0, [Ext, "Action"], 0)); (Ext.cmd.derive("Ext.ElementLoader", Ext.Base, { statics: { Renderer: { Html: function (a, b, c) { a.getTarget().setHtml(b.responseText, c.scripts === true, c.rendererScope); return true } } }, url: null, params: null, baseParams: null, autoLoad: false, target: null, loadMask: false, ajaxOptions: null, scripts: false, isLoader: true, constructor: function (b) { var c = this, a; c.mixins.observable.constructor.call(c, b); c.setTarget(c.target); if (c.autoLoad) { a = c.autoLoad; if (a === true) { a = null } c.load(a) } }, setTarget: function (b) { var a = this; b = Ext.get(b); if (a.target && a.target !== b) { a.abort() } a.target = b }, getTarget: function () { return this.target || null }, abort: function () { var a = this.active; if (a !== undefined) { Ext.Ajax.abort(a.request); if (a.mask) { this.removeMask() } delete this.active } }, removeMask: function () { this.target.unmask() }, addMask: function (a) { this.target.mask(a === true ? null : a) }, load: function (c) { c = Ext.apply({}, c); var e = this, a = Ext.isDefined(c.loadMask) ? c.loadMask : e.loadMask, g = Ext.apply({}, c.params), b = Ext.apply({}, c.ajaxOptions), h = c.callback || e.callback, d = c.scope || e.scope || e; Ext.applyIf(b, e.ajaxOptions); Ext.applyIf(c, b); Ext.applyIf(g, e.params); Ext.apply(g, e.baseParams); Ext.applyIf(c, { url: e.url }); Ext.apply(c, { scope: e, params: g, callback: e.onComplete }); if (e.fireEvent("beforeload", e, c) === false) { return } if (a) { e.addMask(a) } e.active = { options: c, mask: a, scope: d, callback: h, success: c.success || e.success, failure: c.failure || e.failure, renderer: c.renderer || e.renderer, scripts: Ext.isDefined(c.scripts) ? c.scripts : e.scripts }; e.active.request = Ext.Ajax.request(c); e.setOptions(e.active, c) }, setOptions: function (b, a) { b.rendererScope = a.rendererScope || this.rendererScope || this }, onComplete: function (b, g, a) { var d = this, e = d.active, h, c; if (e) { c = e.scope; h = e.rendererScope; if (g) { g = d.getRenderer(e.renderer).call(h, d, a, e) !== false } if (g) { Ext.callback(e.success, c, [d, a, b]); d.fireEvent("load", d, a, b) } else { Ext.callback(e.failure, c, [d, a, b]); d.fireEvent("exception", d, a, b) } Ext.callback(e.callback, c, [d, g, a, b]); if (e.mask) { d.removeMask() } } delete d.active }, getRenderer: function (a) { if (Ext.isFunction(a)) { return a } return this.statics().Renderer.Html }, startAutoRefresh: function (a, b) { var c = this; c.stopAutoRefresh(); c.autoRefresh = Ext.interval(function () { c.load(b) }, a) }, stopAutoRefresh: function () { clearInterval(this.autoRefresh); this.autoRefresh = null }, isAutoRefreshing: function () { return !!this.autoRefresh }, destroy: function () { var a = this; a.stopAutoRefresh(); a.abort(); a.callParent() } }, 1, 0, 0, 0, 0, [[Ext.util.Observable.prototype.mixinId || Ext.util.Observable.$className, Ext.util.Observable]], [Ext, "ElementLoader"], 0)); (Ext.cmd.derive("Ext.ComponentLoader", Ext.ElementLoader, { statics: { Renderer: { Data: function (a, b, d) { var g = true; try { a.getTarget().update(Ext.decode(b.responseText)) } catch (c) { g = false } return g }, Component: function (a, c, h) { var i = true, g = a.getTarget(), b = []; try { b = Ext.decode(c.responseText) } catch (d) { i = false } if (i) { g.suspendLayouts(); if (h.removeAll) { g.removeAll() } g.add(b); g.resumeLayouts(true) } return i } } }, target: null, loadOnRender: false, loadMask: false, renderer: "html", setTarget: function (b) { var a = this; if (Ext.isString(b)) { b = Ext.getCmp(b) } if (a.target && a.target !== b) { a.abort() } a.target = b; if (b && a.loadOnRender) { if (b.rendered) { a.doLoadOnRender() } else { a.mon(b, "render", a.doLoadOnRender, a) } } }, doLoadOnRender: function () { var a = this.loadOnRender; this.load(Ext.isObject(a) ? a : null) }, removeMask: function () { this.target.setLoading(false) }, addMask: function (a) { this.target.setLoading(a) }, setOptions: function (b, a) { b.removeAll = Ext.isDefined(a.removeAll) ? a.removeAll : this.removeAll; b.rendererScope = a.rendererScope || this.rendererScope || this.target }, getRenderer: function (b) { if (Ext.isFunction(b)) { return b } var a = this.statics().Renderer; switch (b) { case "component": return a.Component; case "data": return a.Data; default: return Ext.ElementLoader.Renderer.Html } } }, 0, 0, 0, 0, 0, 0, [Ext, "ComponentLoader"], 0)); (Ext.cmd.derive("Ext.layout.SizeModel", Ext.Base, { constructor: function (c) { var e = this, d = e.self, a = d.sizeModelsArray, b; Ext.apply(e, c); e[b = e.name] = true; e.fixed = !(e.auto = e.natural || e.shrinkWrap); a[e.ordinal = a.length] = d[b] = d.sizeModels[b] = e }, statics: { sizeModelsArray: [], sizeModels: {} }, calculated: false, configured: false, constrainedMax: false, constrainedMin: false, natural: false, shrinkWrap: false, calculatedFromConfigured: false, calculatedFromNatural: false, calculatedFromShrinkWrap: false, names: null }, 1, 0, 0, 0, 0, 0, [Ext.layout, "SizeModel"], function () { var e = this, a = e.sizeModelsArray, c, b, h, g, d; new e({ name: "calculated" }); new e({ name: "configured", names: { width: "width", height: "height" } }); new e({ name: "natural" }); new e({ name: "shrinkWrap" }); new e({ name: "calculatedFromConfigured", configured: true, calculatedFrom: true, names: { width: "width", height: "height" } }); new e({ name: "calculatedFromNatural", natural: true, calculatedFrom: true }); new e({ name: "calculatedFromShrinkWrap", shrinkWrap: true, calculatedFrom: true }); new e({ name: "constrainedMax", configured: true, constrained: true, names: { width: "maxWidth", height: "maxHeight" } }); new e({ name: "constrainedMin", configured: true, constrained: true, names: { width: "minWidth", height: "minHeight" } }); new e({ name: "constrainedDock", configured: true, constrained: true, constrainedByMin: true, names: { width: "dockConstrainedWidth", height: "dockConstrainedHeight" } }); for (c = 0, h = a.length; c < h; ++c) { d = a[c]; d.pairsByHeightOrdinal = g = []; for (b = 0; b < h; ++b) { g.push({ width: d, height: a[b] }) } } })); (Ext.cmd.derive("Ext.layout.Layout", Ext.Base, { factoryConfig: { type: "layout" }, isLayout: true, initialized: false, running: false, needsItemSize: true, setsItemSize: true, autoSizePolicy: { readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0 }, $configPrefixed: false, $configStrict: false, constructor: function (a) { var b = this; b.id = Ext.id(null, b.type + "-"); b.initConfig(a); delete b.type; b.layoutCount = 0 }, beginLayout: Ext.emptyFn, beginLayoutCycle: function (c) { var b = this, a = b.context, d; if (b.lastWidthModel !== c.widthModel) { if (b.lastWidthModel) { d = true } b.lastWidthModel = c.widthModel } if (b.lastHeightModel !== c.heightModel) { if (b.lastWidthModel) { d = true } b.lastHeightModel = c.heightModel } if (d) { (a = c.context).clearTriggers(b, false); a.clearTriggers(b, true); b.triggerCount = 0 } }, finishedLayout: function (a) { this.lastWidthModel = a.widthModel; this.lastHeightModel = a.heightModel; this.ownerContext = null }, redoLayout: Ext.emptyFn, undoLayout: Ext.emptyFn, getAnimatePolicy: function () { return this.animatePolicy }, getItemSizePolicy: function (a) { return this.autoSizePolicy }, isItemBoxParent: function (a) { return false }, isItemLayoutRoot: function (d) { var c = d.getSizeModel(), b = c.width, a = c.height; if (!d.componentLayout.lastComponentSize && (b.calculated || a.calculated)) { return false } return !b.shrinkWrap && !a.shrinkWrap }, isItemShrinkWrap: function (a) { return a.shrinkWrap }, isRunning: function () { return !!this.ownerContext }, getItemsRenderTree: function (d, b) { var h = d.length, e, g, c, a; if (h) { a = []; for (e = 0; e < h; ++e) { g = d[e]; if (!g.rendered) { if (b && (b[g.id] !== undefined)) { c = b[g.id] } else { this.configureItem(g); c = g.getRenderTree(); if (b) { b[g.id] = c } } if (c) { a.push(c) } } } } return a }, finishRender: Ext.emptyFn, finishRenderItems: function (e, a) { var d = a.length, b, c; for (b = 0; b < d; b++) { c = a[b]; if (c.rendering) { c.finishRender(b) } } }, renderChildren: function () { var b = this, a = b.getLayoutItems(), c = b.getRenderTarget(); b.renderItems(a, c) }, renderItems: function (a, g) { var e = this, d = a.length, b = 0, h = 0, c; if (d) { Ext.suspendLayouts(); for (; b < d; b++ , h++) { c = a[b]; if (c && !c.rendered) { e.renderItem(c, g, h) } else { if (c.ignoreDomPosition) { --h } else { if (!e.isValidParent(c, g, h)) { e.moveItem(c, g, h) } else { e.configureItem(c) } } } } Ext.resumeLayouts(true) } }, isValidParent: function (d, e, a) { var c = (e && e.dom) || e, b = this.getItemLayoutEl(d); if (b && c) { if (typeof a === "number") { a = this.getPositionOffset(a); return b === c.childNodes[a] } return b.parentNode === c } return false }, getItemLayoutEl: function (c) { var d = c.el ? c.el.dom : Ext.getDom(c), a = d.parentNode, b; if (a) { b = a.className; if (b && b.indexOf("x-resizable-wrap") !== -1) { d = d.parentNode } } return d }, getPositionOffset: function (a) { return a }, configureItem: function (a) { a.ownerLayout = this }, renderItem: function (c, d, a) { var b = this; if (!c.rendered) { b.configureItem(c); c.render(d, a) } }, moveItem: function (b, c, a) { var d = Ext.Element.getActiveElement(true); c = c.dom || c; if (typeof a === "number") { a = c.childNodes[a] } if (b.el.contains(d)) { d.suspendFocusEvents() } else { d = null } c.insertBefore(b.el.dom, a || null); b.container = Ext.get(c); this.configureItem(b); if (d) { d.focus(); d.resumeFocusEvents() } }, onContentChange: function () { this.owner.updateLayout(); return true }, initLayout: function () { this.initialized = true }, setOwner: function (a) { this.owner = a }, getLayoutItems: function () { return [] }, onAdd: function (a) { a.ownerLayout = this }, onRemove: Ext.emptyFn, onDestroy: Ext.emptyFn, afterRemove: function (e) { var d = this, c = e.el, b = d.owner, a; if (e.rendered) { a = [].concat(d.itemCls || []); if (b.itemCls) { a = Ext.Array.push(a, b.itemCls) } if (a.length) { c.removeCls(a) } } delete e.ownerLayout }, afterCollapse: function (a, b) { if (b) { this.onContentChange(a) } }, afterExpand: function (a, b) { if (b) { this.onContentChange(a) } }, destroy: function () { var a = this, b; if (a.targetCls) { b = a.getTarget(); if (b) { b.removeCls(a.targetCls) } } if (!a.onDestroy.$emptyFn) { a.onDestroy() } a.callParent() }, sortWeightedItems: function (a, d) { for (var b = 0, c = a.length; b < c; ++b) { a[b].$i = b } Ext.Array.sort(a, function (g, e) { var h = e.weight - g.weight; if (!h) { h = g.$i - e.$i; if (g[d]) { h = -h } } return h }); for (b = 0; b < c; ++b) { delete a[b].$i } } }, 1, 0, 0, 0, 0, [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.layout, "Layout"], function () { var a = this; a.prototype.sizeModels = a.sizeModels = Ext.layout.SizeModel.sizeModels })); (Ext.cmd.derive("Ext.layout.container.Container", Ext.layout.Layout, { alternateClassName: "Ext.layout.ContainerLayout", type: "container", beginCollapse: Ext.emptyFn, beginExpand: Ext.emptyFn, animatePolicy: null, activeItemCount: 0, renderTpl: ["{%this.renderBody(out,values)%}"], usesContainerHeight: true, usesContainerWidth: true, usesHeight: true, usesWidth: true, constructor: function () { Ext.layout.Layout.prototype.constructor.apply(this, arguments); this.mixins.elementCt.constructor.call(this) }, destroy: function () { this.mixins.elementCt.destroy.call(this); Ext.layout.Layout.prototype.destroy.call(this) }, beginLayout: function (a) { Ext.layout.Layout.prototype.beginLayout.apply(this, arguments); a.targetContext = a.paddingContext = a.getEl("getTarget", this); this.cacheChildItems(a) }, beginLayoutCycle: function (c, a) { var b = this; Ext.layout.Layout.prototype.beginLayoutCycle.apply(this, arguments); if (a) { if (b.usesContainerHeight) { ++c.consumersContainerHeight } if (b.usesContainerWidth) { ++c.consumersContainerWidth } } }, cacheChildItems: function (g) { var e = this, c, h, a, d, b; if (e.needsItemSize || e.setsItemSize) { c = g.context; h = g.childItems = []; a = g.visibleItems = e.getVisibleItems(); d = a.length; for (b = 0; b < d; ++b) { h.push(c.getCmp(a[b])) } } }, cacheElements: function () { var a = this.owner; this.attachChildEls(a.el, a) }, calculate: function (c) { var b = c.props, a = c.el; if (c.widthModel.shrinkWrap && isNaN(b.width)) { c.setContentWidth(a.getWidth()) } if (c.heightModel.shrinkWrap && isNaN(b.height)) { c.setContentHeight(a.getHeight()) } }, configureItem: function (d) { var c = this, e = c.itemCls, b = c.owner.itemCls, a, g; d.ownerLayout = c; if (e) { if (typeof e === "string") { g = [e] } else { g = e; a = !!g } } if (b) { if (a) { g = Ext.Array.clone(g) } g = Ext.Array.push(g || [], b) } if (g) { d.addCls(g) } }, doRenderBody: function (a, b) { this.renderItems(a, b); this.renderContent(a, b) }, doRenderContainer: function (b, e) { var c = e.$comp.layout, a = c.getRenderTpl(), d = c.getRenderData(); a.applyOut(d, b) }, doRenderItems: function (b, d) { var c = d.$layout, a = c.getRenderTree(); if (a) { Ext.DomHelper.generateMarkup(a, b) } }, doRenderTabGuard: function (b, d, a) { var c = d.$comp, e; if (c.tabGuard && !d.$skipTabGuards) { e = c.lookupTpl("tabGuardTpl"); if (e) { d.tabGuard = a; d.tabGuardEl = c.tabGuardElements[a]; c.addChildEl(d.tabGuardEl); e.applyOut(d, b); delete d.tabGuard; delete d.tabGuardEl } } }, finishRender: function () { var c = this, a = c.owner, d, b; Ext.layout.Layout.prototype.finishRender.call(this); c.cacheElements(); d = c.getRenderTarget(); b = c.getLayoutItems(); c.finishRenderItems(d, b) }, notifyOwner: function () { this.owner.afterLayout(this) }, getContainerSize: function (b, g) { var c = b.targetContext, e = c.getFrameInfo(), j = b.paddingContext.getPaddingInfo(), i = 0, k = 0, d, h, a, l; if (!b.widthModel.shrinkWrap) { ++k; a = g ? c.getDomProp("width") : c.getProp("width"); d = (typeof a === "number"); if (d) { ++i; a -= e.width + j.width; if (a < 0) { a = 0 } } } if (!b.heightModel.shrinkWrap) { ++k; l = g ? c.getDomProp("height") : c.getProp("height"); h = (typeof l === "number"); if (h) { ++i; l -= e.height + j.height; if (l < 0) { l = 0 } } } return { width: a, height: l, needed: k, got: i, gotAll: i === k, gotWidth: d, gotHeight: h } }, getPositionOffset: function (a) { if (!this.createsInnerCt) { var b = this.owner.itemNodeOffset; if (b) { a += b } } return a }, getLayoutItems: function () { var a = this.owner, b = a && a.items; return (b && b.items) || [] }, getRenderData: function () { var a = this.owner; return { $comp: a, $layout: this, ownerId: a.id } }, getRenderedItems: function () { var e = this, h = e.getRenderTarget(), a = e.getLayoutItems(), d = a.length, g = [], b, j, c; for (b = 0, j = 0; b < d; b++ , j++) { c = a[b]; if (c.rendered) { if (c.ignoreDomPosition) { --j } else { if (!this.isValidParent(c, h, j)) { continue } } g.push(c) } } return g }, getRenderTarget: function () { return this.owner.getTargetEl() }, getElementTarget: function () { return this.getRenderTarget() }, getRenderTpl: function () { var a = this, b = Ext.XTemplate.getTpl(this, "renderTpl"); if (!b.renderContent) { a.owner.setupRenderTpl(b) } return b }, getRenderTree: function () { var a, c = this.owner.items, d, b = {}; do { d = c.generation; a = this.getItemsRenderTree(this.getLayoutItems(), b) } while (c.generation !== d); return a }, renderChildren: function () { var b = this, c = b.owner.items, e = b.getRenderTarget(), d, a; do { d = c.generation; a = b.getLayoutItems(); b.renderItems(a, e) } while (c.generation !== d) }, getScrollbarsNeeded: function (c, i, b, h) { var a = Ext.getScrollbarSize(), e = typeof c === "number", j = typeof i === "number", g = 0, d = 0; if (!a.width) { return 0 } if (j && i < h) { d = 2; c -= a.width } if (e && c < b) { g = 1; if (!d && j) { i -= a.height; if (i < h) { d = 2 } } } return d + g }, getTarget: function () { return this.owner.getTargetEl() }, getVisibleItems: function () { var g = this.getRenderTarget(), b = this.getLayoutItems(), e = b.length, a = [], c, h, d; for (c = 0, h = 0; c < e; c++ , h++) { d = b[c]; if (d.rendered && d.hidden !== true && !d.floated) { if (d.ignoreDomPosition) { --h } else { if (!this.isValidParent(d, g, h)) { continue } } a.push(d) } } return a }, getMoveAfterIndex: function (a) { return this.owner.items.indexOf(a) + 1 }, moveItemBefore: function (d, e) { var a = this.owner, b = a.items, c = b.indexOf(d), g; if (d === e) { return d } if (e) { g = b.indexOf(e); if (c > -1 && c < g) { --g } } else { g = b.length } return a.insert(g, d) }, setupRenderTpl: function (a) { a.renderBody = this.doRenderBody; a.renderContainer = this.doRenderContainer; a.renderItems = this.doRenderItems; a.renderTabGuard = this.doRenderTabGuard }, getContentTarget: function () { return this.owner.getDefaultContentTarget() }, onAdd: function (a) { if (!a.liquidLayout) { ++this.activeItemCount } Ext.layout.Layout.prototype.onAdd.call(this, a) }, onRemove: function (b, a) { if (!b.liquidLayout) { --this.activeItemCount } Ext.layout.Layout.prototype.onRemove.call(this, b, a) } }, 1, 0, 0, 0, ["layout.container"], [[Ext.util.ElementContainer.prototype.mixinId || Ext.util.ElementContainer.$className, Ext.util.ElementContainer]], [Ext.layout.container, "Container", Ext.layout, "ContainerLayout"], 0)); (Ext.cmd.derive("Ext.layout.container.Auto", Ext.layout.container.Container, { type: "autocontainer", childEls: ["outerCt", "innerCt"], reserveScrollbar: false, managePadding: true, manageOverflow: false, needsItemSize: false, setsItemSize: false, lastOverflowAdjust: { width: 0, height: 0 }, outerCtCls: "x-autocontainer-outerCt", innerCtCls: "x-autocontainer-innerCt", renderTpl: ['<div id="{ownerId}-outerCt" data-ref="outerCt" class="{outerCtCls}" role="presentation">', '<div id="{ownerId}-innerCt" data-ref="innerCt" style="{%this.renderPadding(out, values)%}" ', '<tpl if="!$comp.html">role="presentation"</tpl>', 'class="{innerCtCls}">', "{%this.renderBody(out,values)%}", "</div>", "</div>"], beginLayout: function (a) { Ext.layout.container.Container.prototype.beginLayout.apply(this, arguments); this.initContextItems(a) }, beforeLayoutCycle: function (d) { var b = this.owner, c = b.inheritedState, a = b.inheritedStateInner; if (!c || c.invalid) { c = b.getInherited(); a = b.inheritedStateInner } if (d.widthModel.shrinkWrap) { a.inShrinkWrapTable = true } else { delete a.inShrinkWrapTable } }, beginLayoutCycle: function (d) { var j = this, b = j.outerCt, h = j.lastOuterCtWidth || "", g = j.lastOuterCtHeight || "", k = j.lastOuterCtTableLayout || "", a = d.state, l, e, m, c, i; Ext.layout.container.Container.prototype.beginLayoutCycle.apply(this, arguments); e = m = c = ""; if (!d.widthModel.shrinkWrap) { e = "100%"; i = j.owner.inheritedStateInner; l = j.getOverflowXStyle(d); c = (i.inShrinkWrapTable || l === "auto" || l === "scroll") ? "" : "fixed" } if (!d.heightModel.shrinkWrap && !Ext.supports.PercentageHeightOverflowBug) { m = "100%" } if ((e !== h) || j.hasOuterCtPxWidth) { b.setStyle("width", e); j.lastOuterCtWidth = e; j.hasOuterCtPxWidth = false } if (c !== k) { b.setStyle("table-layout", c); j.lastOuterCtTableLayout = c } if ((m !== g) || j.hasOuterCtPxHeight) { b.setStyle("height", m); j.lastOuterCtHeight = m; j.hasOuterCtPxHeight = false } if (j.hasInnerCtPxHeight) { j.innerCt.setStyle("height", ""); j.hasInnerCtPxHeight = false } a.overflowAdjust = a.overflowAdjust || j.lastOverflowAdjust }, calculate: function (c) { var a = this, b = c.state, e = a.getContainerSize(c, true), d = b.calculatedItems || (b.calculatedItems = a.calculateItems ? a.calculateItems(c, e) : true); a.setCtSizeIfNeeded(c, e); if (d && c.hasDomProp("containerChildrenSizeDone")) { a.calculateContentSize(c); if (e.gotAll) { if (a.manageOverflow && !c.state.secondPass && !a.reserveScrollbar) { a.calculateOverflow(c, e) } return } } a.done = false }, calculateContentSize: function (g) { var e = this, a = ((g.widthModel.shrinkWrap ? 1 : 0) | (g.heightModel.shrinkWrap ? 2 : 0)), c = (a & 1) || undefined, h = (a & 2) || undefined, d = 0, b = g.props; if (c) { if (isNaN(b.contentWidth)) { ++d } else { c = undefined } } if (h) { if (isNaN(b.contentHeight)) { ++d } else { h = undefined } } if (d) { if (c && !g.setContentWidth(e.measureContentWidth(g))) { e.done = false } if (h && !g.setContentHeight(e.measureContentHeight(g))) { e.done = false } } }, calculateOverflow: function (c) { var h = this, b, j, a, g, e, d, i; e = (h.getOverflowXStyle(c) === "auto"); d = (h.getOverflowYStyle(c) === "auto"); if (e || d) { a = Ext.getScrollbarSize(); i = c.overflowContext.el.dom; g = 0; if (i.scrollWidth > i.clientWidth) { g |= 1 } if (i.scrollHeight > i.clientHeight) { g |= 2 } b = (d && (g & 2)) ? a.width : 0; j = (e && (g & 1)) ? a.height : 0; if (b !== h.lastOverflowAdjust.width || j !== h.lastOverflowAdjust.height) { h.done = false; c.invalidate({ state: { overflowAdjust: { width: b, height: j }, overflowState: g, secondPass: true } }) } } }, completeLayout: function (a) { this.lastOverflowAdjust = a.state.overflowAdjust }, doRenderBody: function (c, e) { var d = e.$layout, a = Ext.XTemplate, g = d.beforeBodyTpl, b = d.afterBodyTpl; if (g) { a.getTpl(d, "beforeBodyTpl").applyOut(e, c) } this.renderItems(c, e); this.renderContent(c, e); if (b) { a.getTpl(d, "afterBodyTpl").applyOut(e, c) } }, doRenderPadding: function (b, d) { var c = d.$layout, a = d.$layout.owner, e = a[a.contentPaddingProperty]; if (c.managePadding && e) { b.push("padding:", a.unitizeBox(e)) } }, finishedLayout: function (b) { var a = this.innerCt; Ext.layout.container.Container.prototype.finishedLayout.apply(this, arguments); if (Ext.isIE8) { a.repaint() } if (Ext.isOpera) { a.setStyle("position", "relative"); a.dom.scrollWidth; a.setStyle("position", "") } }, getContainerSize: function (b, c) { var a = Ext.layout.container.Container.prototype.getContainerSize.apply(this, arguments), d = b.state.overflowAdjust; if (d) { a.width -= d.width; a.height -= d.height } return a }, getRenderData: function () { var a = this, b = Ext.layout.container.Container.prototype.getRenderData.call(this); b.innerCtCls = a.innerCtCls; b.outerCtCls = a.outerCtCls; return b }, getRenderTarget: function () { return this.innerCt }, getElementTarget: function () { return this.innerCt }, getOverflowXStyle: function (a) { return a.overflowXStyle || (a.overflowXStyle = this.owner.scrollFlags.overflowX || a.overflowContext.getStyle("overflow-x")) }, getOverflowYStyle: function (a) { return a.overflowYStyle || (a.overflowYStyle = this.owner.scrollFlags.overflowY || a.overflowContext.getStyle("overflow-y")) }, initContextItems: function (b) { var a = this, d = b.target, c = a.owner.getOverflowEl(); b.outerCtContext = b.getEl("outerCt", a); b.innerCtContext = b.getEl("innerCt", a); b.overflowContext = (c === b.el) ? b : b.getEl(c); if (d[d.contentPaddingProperty] !== undefined) { b.paddingContext = b.innerCtContext } }, initLayout: function () { var c = this, b = Ext.getScrollbarSize().width, a = c.owner; Ext.layout.container.Container.prototype.initLayout.call(this); if (b && c.manageOverflow && !c.hasOwnProperty("lastOverflowAdjust")) { if (a.scrollable || c.reserveScrollbar) { c.lastOverflowAdjust = { width: b, height: 0 } } } }, measureContentHeight: function (b) { var a = this.outerCt.getHeight(), c = b.target; if (this.managePadding && (c[c.contentPaddingProperty] === undefined)) { a += b.targetContext.getPaddingInfo().height } return a }, measureContentWidth: function (d) { var g, c, b, a, e; if (this.chromeCellMeasureBug) { g = this.innerCt.dom; c = g.style; b = c.display; if (b === "table-cell") { c.display = ""; g.offsetWidth; c.display = b } } if (Ext.isSafari) { g = this.outerCt.dom; c = g.style; c.display = "table-cell"; g.offsetWidth; g.style.display = "" } a = this.outerCt.getWidth(); e = d.target; if (this.managePadding && (e[e.contentPaddingProperty] === undefined)) { a += d.targetContext.getPaddingInfo().width } return a }, setCtSizeIfNeeded: function (d, b) { var e = this, l = b.height, h = d.paddingContext.getPaddingInfo(), j = e.getTarget(), k = e.getOverflowXStyle(d), c = (k === "auto" || k === "scroll"), a = Ext.getScrollbarSize(), g, i; if (l && !d.heightModel.shrinkWrap) { if (Ext.supports.PercentageHeightOverflowBug) { g = true } if (Ext.isIE8) { i = true } if ((g || i) && c && (j.dom.scrollWidth > j.dom.clientWidth)) { l = Math.max(l - a.height, 0) } if (g) { d.outerCtContext.setProp("height", l + h.height); e.hasOuterCtPxHeight = true } if (i) { d.innerCtContext.setProp("height", l); e.hasInnerCtPxHeight = true } } }, setupRenderTpl: function (a) { Ext.layout.container.Container.prototype.setupRenderTpl.apply(this, arguments); a.renderPadding = this.doRenderPadding }, getContentTarget: function () { return this.innerCt } }, 0, 0, 0, 0, ["layout.auto", "layout.autocontainer"], 0, [Ext.layout.container, "Auto"], function (b) { var a = Ext.chromeVersion; b.prototype.chromeCellMeasureBug = Ext.isChrome && a >= 26 && a <= 34 })); (Ext.cmd.derive("Ext.ZIndexManager", Ext.Base, { alternateClassName: "Ext.WindowGroup", statics: { zBase: 9000, activeCounter: 0 }, constructor: function (a) { var b = this; b.id = Ext.id(null, "zindex-mgr-"); b.zIndexStack = new Ext.util.Collection({ sorters: { sorterFn: function (e, d) { var c = (e.alwaysOnTop || 0) - (d.alwaysOnTop || 0); if (!c) { c = e.getActiveCounter() - d.getActiveCounter() } return c } }, filters: { filterFn: function (c) { return c.isVisible() } } }); b.zIndexStack.addObserver(b); b.front = null; b.sortCount = 0; b.globalListeners = Ext.GlobalEvents.on({ beforehide: b.onComponentShowHide, show: b.onComponentShowHide, scope: b, destroyable: true }); if (a) { if (a.isContainer) { b.resizeListeners = a.on({ resize: b.onContainerResize, scope: b, destroyable: true }); b.zseed = Ext.Number.from(b.rendered ? a.getEl().getStyle("zIndex") : undefined, b.getNextZSeed()); b.targetEl = a.getTargetEl(); b.container = a } else { b.resizeListeners = Ext.on({ resize: b.onContainerResize, scope: b, destroyable: true }); b.zseed = b.getNextZSeed(); b.targetEl = Ext.get(a) } } else { b.zseed = b.getNextZSeed(); Ext.onInternalReady(function () { b.resizeListeners = Ext.on({ resize: b.scheduleContainerResize, scope: b, destroyable: true, priority: -10000 }); b.targetEl = Ext.getBody() }) } }, getId: function () { return this.id }, getNextZSeed: function () { return (Ext.ZIndexManager.zBase += 10000) }, setBase: function (a) { this.zseed = a; return this.onCollectionSort() }, onCollectionSort: function () { var j = this, e = j.front, k = j.zseed, l = j.zIndexStack.getRange(), h = l.length, d, g, c, b, m = !e || e.isVisible(); j.sortCount++; for (d = 0; d < h; d++) { g = l[d]; if (g.destroying || g.destroyed) { continue } k = g.setZIndex(k); if (!g.hidden) { b = g; if (g.modal) { c = g } } } if (b !== e) { if (e && !e.destroying) { e.setActive(false) } if (b) { m = m && (b.isFocusable(true) && (b.modal || (b.focusOnToFront && !b.preventFocusOnActivate))); b.setActive(true, m) } } j.front = b || null; if (c) { if (c === e) { j.syncModalMask(c) } else { j.showModalMask(c) } } else { j.hideModalMask() } return k }, onComponentUpdate: function (a) { if (this.zIndexStack.contains(a)) { this.zIndexStack.sort() } }, onAfterComponentRender: function (a) { if (a.isVisible() && a.toFrontOnShow) { this.zIndexStack.itemChanged(a, "hidden"); this.zIndexStack.sort() } }, onComponentShowHide: function (b) { var c = this, d = c.zIndexStack, a = c.sortCount; if (b.isFloating() && !c.hidingAll && (d.getSource() || d).contains(b)) { if (c.tempHidden) { Ext.Array.remove(c.tempHidden, b) } d.beginUpdate(); if (b.isVisible()) { if (b.toFrontOnShow) { d.itemChanged(b, "hidden"); b.setActiveCounter(++Ext.ZIndexManager.activeCounter) } } else { d.itemChanged(b, "hidden") } d.endUpdate(); if (c.sortCount === a) { c.onCollectionSort() } } }, register: function (a) { var b = this; if (a.zIndexManager) { a.zIndexManager.unregister(a) } a.zIndexManager = b; if (!a.rendered) { a.on("afterrender", b.onAfterComponentRender, b, { single: true }) } b.zIndexStack.add(a) }, unregister: function (a) { var b = this; delete a.zIndexManager; a.un("afterrender", b.onAfterComponentRender, b); b.zIndexStack.remove(a); b.onCollectionSort() }, get: function (a) { return a.isComponent ? a : this.zIndexStack.get(a) }, bringToFront: function (b, e) { var c = this, h = c.zIndexStack, a = h.last(), d, g; b = c.get(b); if (!b) { return false } g = b.preventFocusOnActivate; b.preventFocusOnActivate = e; b.setActiveCounter(++Ext.ZIndexManager.activeCounter); b.preventFocusOnActivate = g; d = h.last(); return (d === b && d !== a) }, sendToBack: function (a) { a = this.get(a); if (a) { a.setActiveCounter(0) } return a || null }, hideAll: function () { var d = this, c = d.zIndexStack.getRange(), a = c.length, b; d.hidingAll = true; for (b = 0; b < a; b++) { c[b].hide() } d.hidingAll = false; d.hideModalMask(); d.front = null }, hide: function () { var g = this, e = Ext.Element.getActiveElement(), d = g.zIndexStack.getRange(), a = d.length, c, b; g.focusRestoreElement = null; (g.tempHidden || (g.tempHidden = [])).length = 0; for (c = 0; c < a; c++) { b = d[c]; if (b.isVisible()) { if (b.el.contains(e)) { g.focusRestoreElement = e } b.el.hide(); b.pendingShow = b.hidden = true; g.tempHidden.push(b) } } }, show: function () { var d = this, c, e = d.tempHidden, a = e ? e.length : 0, b; for (c = 0; c < a; c++) { b = e[c]; b.hidden = false; if (b.pendingShow) { b.el.show(); b.pendingShow = false; b.setPosition(b.x, b.y); b.onFloatShow() } else { b.hide() } } d.tempHidden = null; if (d.focusRestoreElement) { d.focusRestoreElement.focus() } }, getActive: function () { return this.zIndexStack.last() }, getBy: function (b, a) { return this.zIndexStack.filterBy(b, a).getRange() }, each: function (b, a) { this.zIndexStack.each(b, a) }, eachBottomUp: function (g, e) { var b = this.zIndexStack.getRange(), d, a = b.length, c; for (d = 0; d < a; d++) { c = b[d]; if (c.isComponent && g.call(e || c, c) === false) { return } } }, eachTopDown: function (e, d) { var a = this.zIndexStack.getRange(), c, b; for (c = a.length; c-- > 0;) { b = a[c]; if (b.isComponent && e.call(d || b, b) === false) { return } } }, destroy: function () { var d = this, b = d.zIndexStack.getRange(), a = b.length, c; for (c = 0; c < a; c++) { Ext.destroy(b[c]) } Ext.destroy(d.mask, d.maskShim, d.zIndexStack, d.globalListeners, d.resizeListeners); d.callParent() }, privates: { getMaskBox: function () { var a = this.mask.maskTarget; if (a.dom === document.body) { return { height: Math.max(document.body.scrollHeight, Ext.dom.Element.getDocumentHeight()), width: Math.max(document.body.scrollWidth, document.documentElement.clientWidth), x: 0, y: 0 } } else { return a.getBox() } }, scheduleContainerResize: function () { if (!this.containerResizeTimer) { this.containerResizeTimer = Ext.Function.requestAnimationFrame(this.onContainerResize, this) } }, onContainerResize: function () { var c = this, b = c.mask, a = c.maskShim, d; c.containerResizeTimer = null; if (b && b.isVisible()) { b.hide(); if (a) { a.hide() } d = c.getMaskBox(); if (a) { a.setSize(d); a.show() } b.setSize(d); b.show() } }, onMaskMousedown: function (a) { if (this.front) { this.front.focus(); a.preventDefault() } }, onMaskClick: function () { var b = this.front, a; if (b) { if (!b.hasListeners.maskclick || b.fireEvent("maskclick", b) !== false) { a = b.maskClickAction || "focus"; b[a]() } } }, showModalMask: function (b) { var d = this, e = b.el, c = b.floatParent ? b.floatParent.getEl() : b.container, a = d.mask; if (!a) { d.mask = a = Ext.getBody().createChild({ role: "presentation", cls: "x-mask x-border-box", style: "height:0;width:0" }); a.setVisibilityMode(Ext.Element.DISPLAY); a.on({ mousedown: d.onMaskMousedown, click: d.onMaskClick, scope: d }) } else { d.hideModalMask() } a.maskTarget = c; c.saveTabbableState({ excludeRoot: e }); d.syncModalMask(b) }, syncModalMask: function (b) { var c = this, g = b.el.getZIndex() - 4, a = c.mask, e = c.maskShim, d = c.getMaskBox(); if (e) { e.setZIndex(g); e.show(); e.setBox(d) } a.setZIndex(g); a.show(); a.setBox(d) }, hideModalMask: function () { var b = this.mask, a = this.maskShim; if (b && b.isVisible()) { b.maskTarget.restoreTabbableState(); b.maskTarget = undefined; b.hide(); if (a) { a.hide() } } } } }, 1, 0, 0, 0, 0, 0, [Ext, "ZIndexManager", Ext, "WindowGroup"], function () { Ext.WindowManager = Ext.WindowMgr = new this() })); (Ext.cmd.derive("Ext.container.Container", Ext.Component, { alternateClassName: ["Ext.Container", "Ext.AbstractContainer"], renderTpl: "<tpl if=\"hasTabGuard\">{% this.renderTabGuard(out, values, 'before'); %}</tpl>{% this.renderContainer(out,values) %}<tpl if=\"hasTabGuard\">{% this.renderTabGuard(out, values, 'after'); %}</tpl>", config: { actions: null }, autoDestroy: true, defaultType: "panel", detachOnRemove: true, items: undefined, layout: "auto", suspendLayout: false, tabGuardTpl: '<span id="{id}-{tabGuardEl}" data-ref="{tabGuardEl}" aria-hidden="true" class="x-tab-guard x-tab-guard-{tabGuardPosition}" style="width:0px;height:0px;"></span>', tabGuardElements: { before: "tabGuardBeforeEl", after: "tabGuardAfterEl" }, _applyDefaultsOptions: { defaults: true, strict: false }, ariaRole: "presentation", baseCls: "x-container", layoutCounter: 0, add: function () { var l = this, h = Ext.Array.slice(arguments), e = (typeof h[0] === "number") ? h.shift() : -1, c = l.getLayout(), d = false, n, j, b, a, o, m, g, k; if (h.length === 1 && Ext.isArray(h[0])) { j = h[0]; n = true } else { j = h } if (l.rendered) { Ext.suspendLayouts() } g = j = l.prepareItems(j, true); a = j.length; if (!n && a === 1) { g = j[0] } for (b = 0; b < a; b++) { o = j[b]; m = (e < 0) ? l.items.length : (e + b); k = !!o.instancedCmp; delete o.instancedCmp; if (o.floating) { (l.floatingItems || (l.floatingItems = new Ext.util.ItemCollection())).add(o); o.onAdded(l, m, k); delete o.$initParent; if (l.hasListeners.add) { l.fireEvent("add", l, o, m) } } else { if ((!l.hasListeners.beforeadd || l.fireEvent("beforeadd", l, o, m) !== false) && l.onBeforeAdd(o) !== false) { l.items.insert(m, o); o.onAdded(l, m, k); delete o.$initParent; l.onAdd(o, m); c.onAdd(o, m); d = true; if (l.hasListeners.add) { l.fireEvent("add", l, o, m) } } } } if (d) { l.updateLayout() } if (l.rendered) { Ext.resumeLayouts(true) } return g }, onAdded: function (b, c, a) { Ext.Component.prototype.onAdded.call(this, b, c, a); this.containerOnAdded(b, a) }, onRemoved: function (a) { this.containerOnRemoved(a); Ext.Component.prototype.onRemoved.apply(this, arguments) }, afterComponentLayout: function () { var b = this.floatingItems, a, d, c; Ext.Component.prototype.afterComponentLayout.apply(this, arguments); if (b) { b = b.items; a = b.length; for (d = 0; d < a; d++) { c = b[d]; if (!c.rendered && c.autoShow) { c.show() } } } }, afterLayout: function (b) { var a = this; ++a.layoutCounter; if (a.hasListeners.afterlayout) { a.fireEvent("afterlayout", a, b) } }, doDestroy: function () { var b = this, a = b.items, d = b.floatingItems, e; if (a) { while ((e = a.first())) { b.doRemove(e, true) } a.destroy(); b.items = null } if (d) { while ((e = d.first())) { b.doRemove(e, true) } d.destroy(); b.floatingItems = null } Ext.destroy(b.layout); Ext.Component.prototype.doDestroy.call(this) }, beforeRender: function () { var b = this, a = b.getLayout(), c; b.preventChildDisable = true; Ext.Component.prototype.beforeRender.call(this); b.preventChildDisable = false; if (!a.initialized) { a.initLayout() } c = a.targetCls; if (c) { b.applyTargetCls(c) } }, cascade: function (l, m, a) { var k = this, e = k.items ? k.items.items : [], g = e.length, d = 0, j, h = a ? a.concat(k) : [k], b = h.length - 1; if (l.apply(m || k, h) !== false) { for (; d < g; d++) { j = e[d]; if (j.cascade) { j.cascade(l, m, a) } else { h[b] = j; l.apply(m || j, h) } } } return this }, contains: function (c, b) { var a = false; if (b) { this.cascade(function (d) { if (d.contains && d.contains(c)) { a = true; return false } }); return a } else { return this.items.contains(c) || (this.floatingItems && this.floatingItems.contains(c)) } }, disable: function (b, h) { var e = this, d = e.disabled, g, a, c; Ext.Component.prototype.disable.call(this, b, h); if (!h && !e.preventChildDisable && !d) { g = e.getChildItemsToDisable(); a = g.length; for (c = 0; c < a; c++) { g[c].disable(b, true) } } return e }, enable: function (b, h) { var e = this, d = e.disabled, g, a, c; Ext.Component.prototype.enable.call(this, b, h); if (d) { g = e.getChildItemsToDisable(); a = g.length; for (c = 0; c < a; c++) { g[c].enable(b, true) } } return e }, getChildByElement: function (e, a) { var h, c, b = 0, d = this.getRefItems(), g = d.length; e = Ext.getDom(e); for (; b < g; b++) { h = d[b]; c = h.getEl(); if (c && ((c.dom === e) || c.contains(e))) { return (a && h.getChildByElement) ? h.getChildByElement(e, a) : h } } return null }, getComponent: function (b) { if (Ext.isObject(b)) { b = b.getItemId() } var d = this.items.get(b), a = this.floatingItems; if (!d && a && typeof b !== "number") { d = a.get(b) } return d }, getFocusEl: function () { var a = this.getDefaultFocus(); if (a) { return a } else { if (this.focusable) { return this.getTargetEl() } } return undefined }, getLayout: function () { var b = this, a = b.layout; if (!a || !a.isLayout) { b.setLayout(a) } return b.layout }, getRefItems: function (c) { var h = this, d = h.items.items, b = d.length, e = 0, g, a = []; for (; e < b; e++) { g = d[e]; a[a.length] = g; if (c && g.getRefItems) { a.push.apply(a, g.getRefItems(true)) } } if (h.floatingItems) { d = h.floatingItems.items; b = d.length; for (e = 0; e < b; e++) { g = d[e]; a[a.length] = g; if (c && g.getRefItems) { a.push.apply(a, g.getRefItems(true)) } } } return a }, getDefaultFocus: function () { var b = this.defaultFocus, a; if (b) { a = this.down(b) } return a }, initComponent: function () { var a = this; Ext.Component.prototype.initComponent.call(this); a.getLayout(); a.constructing = true; a.initItems(); if (a.disabled) { a.disabled = false; a.disable(true) } delete a.constructing }, initItems: function () { var b = this, a = b.items; if (!a || !a.isMixedCollection) { b.items = new Ext.util.ItemCollection(); if (a) { if (!Ext.isArray(a)) { a = [a] } b.$initingItems = true; b.add(a); delete b.$initingItems } } }, initInheritedState: function (i, c) { var h = this, d = h.controller, e = h.layout, g = h.session, j = h.viewModel, b = h.reference, a = h.referenceHolder; Ext.Component.prototype.initInheritedState.call(this, i, c); if (h.collapsed) { i.collapsed = true } h.initContainerInheritedState(i, c); if (e && e.initInheritedState) { e.initInheritedState(i, c) } }, insert: function (c, b) { var a; if (b && b.isComponent) { a = this.items.indexOf(b); if (a !== -1) { return this.move(a, c) } } return this.add(c, b) }, lookupComponent: function (a) { var c = this, d = c.defaultType, b; if (!a.isComponent) { if (typeof a === "string") { if (!(b = (a[0] === "@"))) { return Ext.ComponentManager.get(a) } a = c.getAction(a.substr(1)); d = c.defaultActionType || d } a = Ext.ComponentManager.create(a, d); if (b) { a.instancedCmp = true } } return a }, move: function (b, e) { var d = this, a = d.items, c; if (b.isComponent) { b = a.indexOf(b) } c = a.getAt(b); if (b !== e) { c = a.removeAt(b); if (c === false) { return false } e = Math.min(e, a.getCount()); a.insert(e, c); d.onMove(c, b, e); if (d.hasListeners.childmove) { d.fireEvent("childmove", d, c, b, e) } d.updateLayout() } return c }, moveBefore: function (a, c) { var d, b; if (a !== c) { d = Ext.Element.getActiveElement(true); if (a.el && a.el.contains(d)) { b = d; b.suspendFocusEvents(); a.isLayoutMoving = true } a = this.layout.moveItemBefore(a, c); if (b) { a.isLayoutMoving = false; b.focus(); b.resumeFocusEvents() } } return a }, moveAfter: function (c, d) { var b = this.layout, a; if (c !== d) { a = d ? b.getMoveAfterIndex(d) : 0; c = this.moveBefore(c, this.items.getAt(a)) } return c }, nextChild: function (j, c) { var g = this, d = g.items, h = d.indexOf(j), e = 0, b = d.length, a; if (h !== -1) { if (c) { for (; e < b; e++) { a = d.getAt(h + e); if (!a || Ext.ComponentQuery.is(a, c)) { break } } } else { a = d.getAt(h + 1) } } return a || null }, onAdd: Ext.emptyFn, onBeforeAdd: function (b) { var a = b.ownerCt; if (a && a !== this) { a.remove(b, false) } }, onMove: Ext.emptyFn, onRemove: Ext.emptyFn, onPosition: function () { Ext.Component.prototype.onPosition.apply(this, arguments); this.repositionFloatingItems() }, onResize: function () { Ext.Component.prototype.onResize.apply(this, arguments); this.repositionFloatingItems() }, prevChild: function (j, c) { var g = this, d = g.items, h = d.indexOf(j), e = 0, b = d.length, a; if (h !== -1) { if (c) { for (; e < b; e++) { a = d.getAt(h - e); if (!a || Ext.ComponentQuery.is(a, c)) { break } } } else { a = d.getAt(h - 1) } } return a || null }, remove: function (b, a) { var d = this, e; if (d.destroyed || d.destroying) { return } e = d.getComponent(b); if (e && (!d.hasListeners.beforeremove || d.fireEvent("beforeremove", d, e) !== false)) { d.doRemove(e, a); if (d.hasListeners.remove) { d.fireEvent("remove", d, e) } if (!d.destroying && !d.destroyAfterRemoving && !e.floating) { d.updateLayout() } if (d.destroyAfterRemoving) { d.destroy() } } return e }, removeAll: function (d) { var j = this, g, b = j.floatingItems, c = [], e = 0, a, h; if (b) { g = j.items.items.concat(b.items) } else { g = j.items.items.slice() } a = g.length; Ext.suspendLayouts(); j.removingAll = true; for (; e < a; e++) { h = g[e]; j.remove(h, d); if (h.ownerCt !== j) { c.push(h) } } j.removingAll = false; Ext.resumeLayouts(!!a); return c }, setLayout: function (e) { var d = this, b = d.layout, g = b && b.isLayout, a, c; if (typeof e === "string") { e = { type: e } } c = e.type; if (g && (!c || (c === b.type))) { delete e.type; b.setConfig(e) } else { if (g) { b.setOwner(null) } a = d.self.prototype.layout; if (typeof a === "string") { e.type = c || a } else { Ext.merge(Ext.merge({}, a), e) } e = this.layout = Ext.Factory.layout(e); e.setOwner(this) } if (d.rendered) { d.updateLayout() } }, setActiveItem: function (a) { return this.getLayout().setActiveItem(a) }, updateActions: function (d) { var b = this, a, c; for (a in d) { if (!d[a].isAction) { d[a] = new Ext.Action(d[a]) } } }, getAction: function (b) { var a = this; for (var a = this; a; a = a.getRefOwner()) { if (a.actions && a.actions[b]) { return a.actions[b] } } }, privates: { applyDefaults: function (a) { var b = this, c = b.defaults; if (c) { if (Ext.isFunction(c)) { c = c.call(b, a) } if (Ext.isString(a)) { a = Ext.ComponentManager.get(a) } if (a.isComponent) { a.setConfig(c, null, b._applyDefaultsOptions) } else { a = b.self.getConfigurator().merge(b, Ext.Object.fork(c), a) } } return a }, applyReference: function (a) { return this.setupReference(a) }, applyTargetCls: function (a) { this.layoutTargetCls = a }, detachComponent: function (a) { Ext.getDetachedBody().appendChild(a.getEl()) }, doRemove: function (i, b) { var h = this, j, a = h.detachOnRemove, c = h.layout, e = c && h.rendered, d, g = i.floating; if (b === undefined) { j = h.autoDestroy } else { if (typeof b === "boolean") { j = b } else { j = ("destroy" in b) && b.destroy; a = ("detach" in b) && b.detach } } d = i.destroying || j; if (g) { h.floatingItems.remove(i) } else { h.items.remove(i) } if (e && !g) { if (c.running) { Ext.Component.cancelLayout(i, d) } c.onRemove(i, d) } if (!i.destroyed) { i.onRemoved(d) } h.onRemove(i, d); if (j) { i.destroy() } else { if (!h.destroyed) { if (e && !g) { c.afterRemove(i) } if (a && i.rendered) { h.detachComponent(i) } } } }, finishRenderChildren: function () { Ext.Component.prototype.finishRenderChildren.call(this); var a = this.getLayout(); if (a) { a.finishRender() } }, getChildItemsToDisable: function () { return this.query("[isFormField],[isFocusableContainer],button") }, getContentTarget: function () { return this.getLayout().getContentTarget() }, getDefaultContentTarget: function () { return this.el }, prepareItems: function (b, d) { if (Ext.isArray(b)) { b = b.slice() } else { b = [b] } var g = this, c = 0, a = b.length, e; for (; c < a; c++) { e = b[c]; if (e == null) { Ext.Array.erase(b, c, 1); --c; --a } else { if (d) { e = this.applyDefaults(e) } e.$initParent = g; if (e.isComponent) { e.instancedCmp = true } b[c] = g.lookupComponent(e); delete e.$initParent } } return b }, repositionFloatingItems: function () { var b = this.floatingItems, a, d, c; if (b) { b = b.items; a = b.length; for (d = 0; d < a; d++) { c = b[d]; if (c.el && !c.hidden) { c.setPosition(c.x, c.y) } } } }, initTabGuards: function (h) { var k = this, g = k.tabGuardBeforeEl, e = k.tabGuardAfterEl, d = k.tabGuardBeforeIndex || 0, b = k.tabGuardAfterIndex || 0, j, c, a; if (!k.rendered || !k.tabGuard) { return } a = k.el.findTabbableElements({ skipSelf: true }); if (a[0] === g.dom) { a.shift() } if (a[a.length - 1] === e.dom) { a.pop() } if (a && a.length) { if (d == null || b == null) { for (j = 0; j < a.length; j++) { c = +a[j].getAttribute("tabIndex"); if (c > 0) { d = Math.min(d, c); b = Math.max(b, c) } } } g.dom.setAttribute("tabIndex", d); e.dom.setAttribute("tabIndex", b) } else { g.dom.removeAttribute("tabIndex"); e.dom.removeAttribute("tabIndex") } if (k.onTabGuardFocusEnter) { if (!g.hasListeners.focusenter) { g.on("focusenter", k.onTabGuardFocusEnter, k) } if (!e.hasListeners.focusenter) { e.on("focusenter", k.onTabGuardFocusEnter, k) } } }, _noMargin: { "margin-top": "", "margin-right": "", "margin-bottom": "", "margin-left": "" }, resetItemMargins: function () { var a = this.items.items, c = a.length, b = this._noMargin, d; while (c--) { d = a[c]; d.margin$ = null; d.el.setStyle(b) } }, setupRenderTpl: function (a) { Ext.Component.prototype.setupRenderTpl.apply(this, arguments); this.getLayout().setupRenderTpl(a) } } }, 0, ["container"], ["component", "box", "container"], { component: true, box: true, container: true }, ["widget.container"], [[Ext.mixin.Queryable.prototype.mixinId || Ext.mixin.Queryable.$className, Ext.mixin.Queryable], [Ext.mixin.Container.prototype.mixinId || Ext.mixin.Container.$className, Ext.mixin.Container]], [Ext.container, "Container", Ext, "Container", Ext, "AbstractContainer"], 0)); (Ext.cmd.derive("Ext.layout.container.Editor", Ext.layout.container.Container, { autoSizeDefault: { width: "field", height: "field" }, sizePolicies: { $: { $: { readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0 }, boundEl: { readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1 } }, boundEl: { $: { readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0 }, boundEl: { readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1 } } }, getItemSizePolicy: function (d) { var c = this, a = c.owner.autoSize, b = a && a.width, e = c.sizePolicies; e = e[b] || e.$; b = a && a.height; e = e[b] || e.$; return e }, calculate: function (g) { var e = this, b = e.owner, a = b.autoSize, d, c; if (a === true) { a = e.autoSizeDefault } if (a) { d = e.getDimension(b, a.width, "getWidth", b.width); c = e.getDimension(b, a.height, "getHeight", b.height) } g.childItems[0].setSize(d, c); g.setWidth(d); g.setHeight(c); g.setContentSize(d || b.field.getWidth(), c || b.field.getHeight()) }, getDimension: function (a, b, d, c) { switch (b) { case "boundEl": return a.boundEl[d](); case "field": return undefined; default: return c } } }, 0, 0, 0, 0, ["layout.editor"], 0, [Ext.layout.container, "Editor"], 0)); (Ext.cmd.derive("Ext.Editor", Ext.container.Container, { layout: "editor", allowBlur: true, revertInvalid: true, value: "", alignment: "c-c?", offsets: [0, 0], shadow: "frame", constrain: false, swallowKeys: true, completeOnEnter: true, cancelOnEsc: true, updateEl: false, focusOnToFront: false, baseCls: "x-editor", editing: false, preventDefaultAlign: true, useBoundValue: true, specialKeyDelay: 1, initComponent: function () { var a = this, b = a.field = Ext.ComponentManager.create(a.field || {}, "textfield"); b.msgTarget = b.msgTarget || "qtip"; a.mon(b, { scope: a, specialkey: a.onSpecialKey }); if (b.grow) { a.mon(b, "autosize", a.onFieldAutosize, a, { delay: 1 }) } a.floating = { constrain: a.constrain }; a.items = b; Ext.container.Container.prototype.initComponent.call(this) }, onAdded: function (a) { this.ownerCmp = a }, onFieldAutosize: function () { this.updateLayout() }, afterRender: function (b, a) { var c = this, e = c.field, d = e.inputEl; Ext.container.Container.prototype.afterRender.apply(this, arguments); if (d) { d.dom.name = ""; if (c.swallowKeys) { d.swallowEvent(["keypress", "keydown"]) } } }, onSpecialKey: function (h, g) { var e = this, c = g.getKey(), a = e.completeOnEnter && c === g.ENTER, d = e.cancelOnEsc && c === g.ESC, b = e.specialKeyTask; if (a || d) { g.stopEvent(); if (!b) { e.specialKeyTask = b = new Ext.util.DelayedTask() } b.delay(e.specialKeyDelay, a ? e.completeEdit : e.cancelEdit, e) } e.fireEvent("specialkey", e, h, g) }, startEdit: function (c, e, a) { var d = this, g = d.field, i, b, h; d.completeEdit(true); d.boundEl = Ext.get(c); i = d.boundEl.dom; if (d.useBoundValue && !Ext.isDefined(e)) { e = Ext.String.trim(i.textContent || i.innerText || i.innerHTML) } if (d.fireEvent("beforestartedit", d, d.boundEl, e) !== false) { if (d.context) { e = d.context.value } Ext.suspendLayouts(); if (!d.rendered) { b = d.ownerCt; h = d.renderTo || (b && b.getEl()) || Ext.getBody(); Ext.fly(h).position(); d.renderTo = h } d.startValue = e; d.show(); d.realign(true); g.suspendEvents(); g.setValue(e); g.resetOriginalValue(); g.resumeEvents(); if (a !== false) { g.focus(g.selectOnFocus ? true : [Number.MAX_VALUE]) } if (g.autoSize) { g.autoSize() } Ext.resumeLayouts(true); d.toggleBoundEl(false); d.editing = true } }, realign: function (a) { var b = this; if (a === true) { b.updateLayout() } b.alignTo(b.boundEl, b.alignment, b.offsets) }, completeEdit: function (a) { var d = this, g = d.field, b = d.startValue, c = d.context && d.context.cancel, e; if (!d.editing) { return } if (g.assertValue) { g.assertValue() } e = d.getValue(); if (!g.isValid()) { if (d.revertInvalid !== false) { d.cancelEdit(a) } return } if (d.ignoreNoChange && !g.didValueChange(e, b)) { d.onEditComplete(a); return } if (d.fireEvent("beforecomplete", d, e, b) !== false) { e = d.getValue(); if (d.updateEl && d.boundEl) { d.boundEl.setHtml(e) } d.onEditComplete(a, c); d.fireEvent("complete", d, e, b) } }, onShow: function () { var a = this; Ext.container.Container.prototype.onShow.apply(this, arguments); a.fireEvent("startedit", a, a.boundEl, a.startValue) }, cancelEdit: function (a) { var c = this, b = c.startValue, e = c.field, d; if (c.editing) { if (e) { d = c.editedValue = c.getValue(); e.suspendEvents(); c.setValue(b); e.resumeEvents() } c.onEditComplete(a, true); c.fireEvent("canceledit", c, d, b); delete c.editedValue } }, onEditComplete: function (b, a) { this.editing = false; if (b !== true) { this.hide(); this.toggleBoundEl(true) } }, onFocusLeave: function (b) { var a = this; if (a.allowBlur === true && a.editing) { a.completeEdit() } Ext.container.Container.prototype.onFocusLeave.call(this, b) }, onHide: function () { var a = this, b = a.field; if (a.editing) { a.completeEdit() } else { if (b.collapse) { b.collapse() } } Ext.container.Container.prototype.onHide.apply(this, arguments) }, getValue: function () { return this.field.getValue() }, setValue: function (a) { this.field.setValue(a) }, toggleBoundEl: function (a) { if (this.hideEl !== false) { this.boundEl.setVisible(a) } }, doDestroy: function () { var b = this, a = b.specialKeyTask; if (a) { a.cancel() } Ext.destroy(b.field); Ext.container.Container.prototype.doDestroy.call(this) } }, 0, ["editor"], ["component", "box", "container", "editor"], { component: true, box: true, container: true, editor: true }, ["widget.editor"], 0, [Ext, "Editor"], 0)); (Ext.cmd.derive("Ext.EventManager", Ext.Base, { singleton: true, mouseLeaveRe: /(mouseout|mouseleave)/, mouseEnterRe: /(mouseover|mouseenter)/, addListener: function (c, a, e, d, b) { Ext.get(c).addListener(a, e, d, b) }, onWindowResize: function (c, b, a) { Ext.GlobalEvents.on("resize", c, b, a) }, onWindowUnload: function (c, b, a) { Ext.getWin().on("unload", c, b, a) }, purgeElement: function (b, a) { Ext.get(b).clearListeners() }, removeAll: function (a) { Ext.get(a).clearListeners() }, removeListener: function (c, a, e, d, b) { Ext.get(c).removeListener(a, e, d, b) }, removeResizeListener: function (b, a) { Ext.GlobalEvents.un("resize", b, a) }, removeUnloadListener: function (b, a) { Ext.getWin().un("unload", b, a) }, stopEvent: function (a) { this.stopPropagation(a); this.preventDefault(a) }, stopPropagation: function (a) { a = a.browserEvent || a; if (a.stopPropagation) { a.stopPropagation() } else { a.cancelBubble = true } }, preventDefault: function (a) { a = a.browserEvent || a; if (a.preventDefault) { a.preventDefault() } else { a.returnValue = false; try { if (a.ctrlKey || a.keyCode > 111 && a.keyCode < 124) { a.keyCode = -1 } } catch (b) { } } }, getId: function (a) { a = Ext.get(a); return a.id }, getRelatedTarget: function (a) { a = a.browserEvent || a; var b = a.relatedTarget; if (!b) { if (this.mouseLeaveRe.test(a.type)) { b = a.toElement } else { if (this.mouseEnterRe.test(a.type)) { b = a.fromElement } } } return this.resolveTextNode(b) }, getPageX: function (a) { return this.getPageXY(a)[0] }, getPageXY: function (c) { c = c.browserEvent || c; var b = c.pageX, e = c.pageY, d = document.documentElement, a = document.body; if (!b && b !== 0) { b = c.clientX + (d && d.scrollLeft || a && a.scrollLeft || 0) - (d && d.clientLeft || a && a.clientLeft || 0); e = c.clientY + (d && d.scrollTop || a && a.scrollTop || 0) - (d && d.clientTop || a && a.clientTop || 0) } return [b, e] }, getPageY: function (a) { return this.getPageXY(a)[1] }, getTarget: function (a) { a = a.browserEvent || a; return Ext.EventManager.resolveTextNode(a.target || a.srcElement) }, resolveTextNode: Ext.isGecko ? function (b) { if (b) { var a = HTMLElement.prototype.toString.call(b); if (a !== "[xpconnect wrapped native prototype]" && a !== "[object XULElement]") { return b.nodeType === 3 ? b.parentNode : b } } } : function (a) { return a && a.nodeType === 3 ? a.parentNode : a } }, 0, 0, 0, 0, 0, 0, [Ext, "EventManager"], function (a) { a.on = a.addListener; a.un = a.removeListener })); (Ext.cmd.derive("Ext.Img", Ext.Component, { autoEl: "img", baseCls: "x-img", config: { src: null, glyph: null }, alt: "", title: "", imgCls: "", maskOnDisable: false, applySrc: function (a) { return a && Ext.resolveResource(a) }, getElConfig: function () { var d = this, e = d.autoEl, b = Ext.Component.prototype.getElConfig.call(this), c = d.glyph, a; if (c) { b.tag = "div"; b.html = c.character; b.style = b.style || {}; b.style.fontFamily = c.fontFamily; b.role = "img" } else { if (e === "img" || (Ext.isObject(e) && e.tag === "img")) { a = b } else { b.cn = [a = { tag: "img", id: d.id + "-img" }] } } if (a) { if (d.imgCls) { a.cls = (a.cls ? a.cls + " " : "") + d.imgCls } a.src = d.src || Ext.BLANK_IMAGE_URL } if (d.alt) { (a || b).alt = d.alt } else { (a || b).alt = "" } if (d.title) { (a || b).title = d.title } return b }, onRender: function () { var b = this, c = b.autoEl, a; Ext.Component.prototype.onRender.apply(this, arguments); a = b.el; if (c === "img" || (Ext.isObject(c) && c.tag === "img")) { b.imgEl = a } else { b.imgEl = a.getById(b.id + "-img") } }, doDestroy: function () { var a = this, b = a.imgEl; if (b && a.el !== b) { b.destroy() } a.imgEl = null; Ext.Component.prototype.doDestroy.call(this) }, getTitle: function () { return this.title }, setTitle: function (c) { var a = this, b = a.imgEl; a.title = c || ""; if (b) { b.dom.title = c || "" } }, afterComponentLayout: function (e, a, c, g) { var b = this.getSizeModel().height, d; if ((b.calculated || b.configured) && a && this.glyph) { d = a + "px"; this.setStyle({ "line-height": d, "font-size": d }) } Ext.Component.prototype.afterComponentLayout.call(this, e, a, c, g) }, getAlt: function () { return this.alt }, setAlt: function (c) { var a = this, b = a.imgEl; a.alt = c || ""; if (b) { b.dom.alt = c || "" } }, _naturalSize: null, getNaturalSize: function () { var e = this, b = e.imgEl, g = e._naturalSize, d, a, c; if (b && !g) { b = b.dom; e._naturalSize = g = { width: a = b.naturalWidth, height: b.naturalHeight }; if (!a) { d = b.style; a = d.width; c = d.height; d.width = d.height = "auto"; g.width = b.width; g.height = b.height; d.width = a; d.height = c } g.aspect = g.width / g.height } return g }, updateSrc: function (b) { var a = this.imgEl; if (a) { a.dom.src = b || Ext.BLANK_IMAGE_URL } }, applyGlyph: function (b, a) { if (b) { if (!b.isGlyph) { b = new Ext.Glyph(b) } if (b.isEqual(a)) { b = undefined } } return b }, updateGlyph: function (c, a) { var b = this.el; if (b) { b.dom.innerHTML = c.character; b.setStyle(c.getStyle()) } } }, 0, ["image", "imagecomponent"], ["component", "box", "image", "imagecomponent"], { component: true, box: true, image: true, imagecomponent: true }, ["widget.image", "widget.imagecomponent"], 0, [Ext, "Img"], 0)); (Ext.cmd.derive("Ext.util.StoreHolder", Ext.Base, { mixinId: "storeholder", autoDestroyBoundStore: false, bindStore: function (b, c, a) { a = a || "store"; var d = this, e = c ? null : d[a]; if (b !== e) { if (e) { if (!d.onUnbindStore.$emptyFn) { d.onUnbindStore(e, c, a) } if (!e.destroyed) { if (d.autoDestroyBoundStore && a === "store" && e.autoDestroy) { e.destroy() } else { d.unbindStoreListeners(e) } } } if (b) { d[a] = b = Ext.data.StoreManager.lookup(b); d.bindStoreListeners(b); if (!d.onBindStore.$emptyFn) { d.onBindStore(b, e, c) } } else { d[a] = null } if (d.fireEvent) { d.fireEvent("storechange", d, b, e) } } return d }, getStore: function () { return this.store }, setStore: function (a) { this.bindStore(a) }, unbindStoreListeners: function (a) { var b = this.storeListeners; if (b) { a.un(b) } }, bindStoreListeners: function (a) { var b = this.getStoreListeners(a); if (b) { b = Ext.apply({}, b); if (!b.scope) { b.scope = this } this.storeListeners = b; a.on(b) } }, getStoreListeners: Ext.emptyFn, onUnbindStore: Ext.emptyFn, onBindStore: Ext.emptyFn }, 0, 0, 0, 0, 0, 0, [Ext.util, "StoreHolder"], 0)); (Ext.cmd.derive("Ext.LoadMask", Ext.Component, { isLoadMask: true, msg: "Loading...", msgCls: "x-mask-loading", msgWrapCls: "x-mask-msg", useMsg: true, useTargetEl: false, cls: "x-mask", componentCls: "x-border-box", ariaRole: "progressbar", focusable: true, tabIndex: 0, childEls: ["msgWrapEl", "msgEl", "msgTextEl"], renderTpl: ['<div id="{id}-msgWrapEl" data-ref="msgWrapEl" class="{[values.$comp.msgWrapCls]}" role="presentation">', '<div id="{id}-msgEl" data-ref="msgEl" class="{[values.$comp.msgCls]} ', "x-", 'mask-msg-inner {childElCls}" role="presentation">', '<div id="{id}-msgTextEl" data-ref="msgTextEl" class="', "x-", "mask-msg-text", '{childElCls}" role="presentation">{msg}</div>', "</div>", "</div>"], maskOnDisable: false, skipLayout: true, constructor: function (b) { var c = this, a; if (arguments.length === 2) { a = c.target = b; b = arguments[1] } else { a = b.target } Ext.Component.prototype.constructor.call(this, b); if (a.isComponent) { c.ownerCt = a; c.hidden = true; c.renderTo = c.getMaskTarget(); c.external = c.renderTo === Ext.getBody(); c.bindComponent(a) } else { a = Ext.get(a); c.isElement = true; c.renderTo = c.target } c.render(c.renderTo); if (c.store) { c.bindStore(c.store, true) } }, initRenderData: function () { var a = Ext.Component.prototype.initRenderData.apply(this, arguments); a.msg = this.msg || ""; return a }, onRender: function () { Ext.Component.prototype.onRender.apply(this, arguments); this.maskEl = this.el }, bindComponent: function (a) { var c = this, b = { scope: this, resize: c.sizeMask }; if (c.external) { b.added = c.onComponentAdded; b.removed = c.onComponentRemoved; if (a.floating) { b.move = c.sizeMask; c.activeOwner = a } else { if (a.ownerCt) { c.onComponentAdded(a.ownerCt) } } } c.mon(a, b); if (c.external) { c.mon(Ext.GlobalEvents, { show: c.onContainerShow, hide: c.onContainerHide, expand: c.onContainerExpand, collapse: c.onContainerCollapse, scope: c }) } }, onComponentAdded: function (a) { var b = this; delete b.activeOwner; b.floatParent = a; if (!a.floating) { a = a.up("[floating]") } if (a) { b.activeOwner = a; b.mon(a, "move", b.sizeMask, b); b.mon(a, "tofront", b.onOwnerToFront, b) } else { b.preventBringToFront = true } a = b.floatParent.ownerCt; if (b.rendered && b.isVisible() && a) { b.floatOwner = a; b.mon(a, "afterlayout", b.sizeMask, b, { single: true }) } }, onComponentRemoved: function (a) { var c = this, d = c.activeOwner, b = c.floatOwner; if (d) { c.mun(d, "move", c.sizeMask, c); c.mun(d, "tofront", c.onOwnerToFront, c) } if (b) { c.mun(b, "afterlayout", c.sizeMask, c) } delete c.activeOwner; delete c.floatOwner }, afterRender: function () { var a = this; Ext.Component.prototype.afterRender.apply(this, arguments); if (Ext.isIE) { a.el.on("mousedown", a.onMouseDown, a) } this.el.skipGarbageCollection = true }, onMouseDown: function (b) { var a = this.el; if (b.within(a)) { b.preventDefault(); a.focus() } }, onOwnerToFront: function (a, b) { this.el.setStyle("zIndex", b + 1) }, onContainerShow: function (a) { if (!this.isHierarchicallyHidden()) { this.onComponentShow() } }, onContainerHide: function (a) { if (this.isHierarchicallyHidden()) { this.onComponentHide() } }, onContainerExpand: function (a) { if (!this.isHierarchicallyHidden()) { this.onComponentShow() } }, onContainerCollapse: function (a) { if (this.isHierarchicallyHidden()) { this.onComponentHide() } }, onComponentHide: function () { var a = this; if (a.rendered && a.isVisible()) { a.hide(); a.showNext = true } }, onComponentShow: function () { if (this.showNext) { this.show() } delete this.showNext }, sizeMask: function () { var b = this, c = b.activeOwner || b.target, a = b.external ? b.getOwner().el : b.getMaskTarget(), d; if (b.rendered && b.isVisible()) { if (b.external) { if (!b.isElement && c.floating) { d = c.el.getZIndex(); if (!isNaN(d)) { b.onOwnerToFront(c, d) } } b.el.setSize(a.getSize()).alignTo(a, "tl-tl") } b.msgWrapEl.center(b.el) } }, bindStore: function (a, b) { var c = this; Ext.destroy(c.proxyListeners); c.mixins.storeholder.bindStore.apply(c, arguments); a = c.store; if (a) { while (a.getSource) { a = a.getSource() } if (!a.loadsSynchronously()) { c.proxyListeners = a.getProxy().on({ exception: c.onLoad, scope: c, destroyable: true }) } if (a.isLoading()) { c.onBeforeLoad() } } }, getStoreListeners: function (b) { var d = this.onLoad, c = this.onBeforeLoad, a = { cachemiss: c, cachefilled: { fn: d, buffer: 100 } }; if (!b.loadsSynchronously()) { a.beforeload = c; a.load = d } return a }, onDisable: function () { Ext.Component.prototype.onDisable.apply(this, arguments); if (this.loading) { this.onLoad() } }, getOwner: function () { return this.ownerCt || this.ownerCmp || this.floatParent }, getMaskTarget: function () { var a = this.getOwner(); if (this.isElement) { return this.target } return this.useTargetEl ? a.getTargetEl() : (a.getMaskTarget() || Ext.getBody()) }, onBeforeLoad: function () { var c = this, a = c.getOwner(), b; if (!c.disabled) { c.loading = true; if (a.componentLayoutCounter) { c.maybeShow() } else { b = a.afterComponentLayout; a.afterComponentLayout = function () { a.afterComponentLayout = b; b.apply(a, arguments); c.maybeShow() } } } }, maybeShow: function () { var c = this, a = c.getOwner(), b; b = a.isVisible(true) && (!c.isComponent || a.el.isVisible(true)); if (!b) { c.showNext = true } else { if (c.loading && a.rendered) { c.show() } } }, hide: function () { var b = this, a = b.ownerCt; if (b.isElement) { a.unmask(); b.fireEvent("hide", this); return } if (a) { a.updateMaskState(false, b) } delete b.showNext; return Ext.Component.prototype.hide.apply(this, arguments) }, show: function () { var a = this; if (a.isElement) { a.ownerCt.mask(this.useMsg ? this.msg : "", this.msgCls); a.fireEvent("show", this); return } return Ext.Component.prototype.show.apply(this, arguments) }, afterShow: function () { var b = this, a = b.ownerCt; b.loading = true; Ext.Component.prototype.afterShow.apply(this, arguments); a.updateMaskState(true, b); b.el.restoreTabbableState(); b.syncMaskState() }, syncMaskState: function () { var c = this, b = c.ownerCt, a = c.el; if (c.isVisible()) { if (c.hasOwnProperty("msgWrapCls")) { a.dom.className = c.msgWrapCls } if (c.useMsg) { c.msgTextEl.setHtml(c.msg); c.ariaEl.dom.setAttribute("aria-valuetext", c.msg) } else { c.msgWrapEl.hide() } if (c.shim || Ext.useShims) { a.enableShim(null, true) } else { a.disableShim() } if (b.el.contains(Ext.Element.getActiveElement())) { c.focus() } c.sizeMask() } }, onLoad: function () { this.loading = false; this.hide() }, doDestroy: function () { var a = this; a.ownerCt = null; a.bindStore(null); if (a.isElement) { a.ownerCt.unmask() } Ext.Component.prototype.doDestroy.call(this) } }, 1, ["loadmask"], ["component", "box", "loadmask"], { component: true, box: true, loadmask: true }, ["widget.loadmask"], [[Ext.util.StoreHolder.prototype.mixinId || Ext.util.StoreHolder.$className, Ext.util.StoreHolder]], [Ext, "LoadMask"], 0)); (Ext.cmd.derive("Ext.layout.component.Component", Ext.layout.Layout, { type: "component", isComponentLayout: true, nullBox: {}, usesContentHeight: true, usesContentWidth: true, usesHeight: true, usesWidth: true, widthCache: {}, heightCache: {}, beginLayoutCycle: function (d, q) { var l = this, c = l.owner, h = d.ownerCtContext, i = d.heightModel, j = d.widthModel, k = c.el.dom === document.body, g = c.lastBox || l.nullBox, n = c.el.lastBox || l.nullBox, a = !k, e = d.isTopLevel, m, o, b, p; Ext.layout.Layout.prototype.beginLayoutCycle.call(this, d, q); if (q) { if (l.usesContentWidth) { ++d.consumersContentWidth } if (l.usesContentHeight) { ++d.consumersContentHeight } if (l.usesWidth) { ++d.consumersWidth } if (l.usesHeight) { ++d.consumersHeight } if (h && !h.hasRawContent) { m = c.ownerLayout; if (m) { if (m.usesWidth) { ++d.consumersWidth } if (m.usesHeight) { ++d.consumersHeight } } } } if (j.configured) { b = c[j.names.width]; if (e && j.calculatedFrom) { b = g.width } if (!k) { a = l.setWidthInDom || (q ? b !== n.width : j.constrained) } d.setWidth(b, a) } else { if (e) { if (j.calculated) { o = g.width; d.setWidth(o, o !== n.width) } o = g.x; d.setProp("x", o, o !== n.x) } } if (i.configured) { p = c[i.names.height]; if (e && i.calculatedFrom) { p = g.height } if (!k) { a = q ? p !== n.height : i.constrained } d.setHeight(p, a) } else { if (e) { if (i.calculated) { o = g.height; d.setHeight(o, o !== n.height) } o = g.y; d.setProp("y", o, o !== n.y) } } }, finishedLayout: function (b) { var h = this, k = b.children, a = h.owner, e, c, j, d, g; if (k) { e = k.length; for (c = 0; c < e; c++) { j = k[c]; j.el.lastBox = j.props } } b.previousSize = h.lastComponentSize; h.lastComponentSize = a.el.lastBox = g = b.props; d = a.lastBox || (a.lastBox = {}); d.x = g.x; d.y = g.y; d.width = g.width; d.height = g.height; d.invalid = false; Ext.layout.Layout.prototype.finishedLayout.call(this, b) }, notifyOwner: function (c) { var b = this, a = b.lastComponentSize, d = c.previousSize; b.owner.afterComponentLayout(a.width, a.height, d ? d.width : undefined, d ? d.height : undefined) }, getTarget: function () { return this.owner.el }, getRenderTarget: function () { return this.owner.el }, cacheTargetInfo: function (b) { var a = this, d = a.targetInfo, c; if (!d) { c = b.getEl("getTarget", a); a.targetInfo = d = { padding: c.getPaddingInfo(), border: c.getBorderInfo() } } return d }, measureAutoDimensions: function (m, i) { var u = this, a = u.owner, r = a.layout, d = m.heightModel, h = m.widthModel, c = m.boxParent, o = m.isBoxParent, v = m.target, b = m.props, j, w = { gotWidth: false, gotHeight: false, isContainer: (j = !m.hasRawContent) }, t = i || 3, q, e, k = 0, g = 0, l, p, s, x, n; if (h.shrinkWrap && m.consumersContentWidth) { ++k; q = !(t & 1); if (j) { if (q) { w.contentWidth = 0; w.gotWidth = true; ++g } else { if ((w.contentWidth = m.getProp("contentWidth")) !== undefined) { w.gotWidth = true; ++g } } } else { p = b.contentWidth; if (typeof p === "number") { w.contentWidth = p; w.gotWidth = true; ++g } else { if (q) { l = true } else { if (!m.hasDomProp("containerChildrenSizeDone")) { l = false } else { if (o || !c || c.widthModel.shrinkWrap) { l = true } else { l = c.hasDomProp("width") } } } if (l) { if (q) { s = 0 } else { if (r && r.measureContentWidth) { s = r.measureContentWidth(m) } else { if (v.cacheWidth) { x = v.xtype + "-" + v.ui; n = u.widthCache; s = n[x] || (n[x] = u.measureContentWidth(m)) } else { s = u.measureContentWidth(m) } } } if (!isNaN(w.contentWidth = s)) { m.setContentWidth(s, true); w.gotWidth = true; ++g } } } } } else { if (h.natural && m.consumersWidth) { ++k; p = b.width; if (typeof p === "number") { w.width = p; w.gotWidth = true; ++g } else { if (o || !c) { l = true } else { l = c.hasDomProp("width") } if (l) { if (!isNaN(w.width = u.measureOwnerWidth(m))) { m.setWidth(w.width, false); w.gotWidth = true; ++g } } } } } if (d.shrinkWrap && m.consumersContentHeight) { ++k; e = !(t & 2); if (j) { if (e) { w.contentHeight = 0; w.gotHeight = true; ++g } else { if ((w.contentHeight = m.getProp("contentHeight")) !== undefined) { w.gotHeight = true; ++g } } } else { p = b.contentHeight; if (typeof p === "number") { w.contentHeight = p; w.gotHeight = true; ++g } else { if (e) { l = true } else { if (!m.hasDomProp("containerChildrenSizeDone")) { l = false } else { if (a.noWrap) { l = true } else { if (!h.shrinkWrap) { l = (m.bodyContext || m).hasDomProp("width") } else { if (o || !c || c.widthModel.shrinkWrap) { l = true } else { l = c.hasDomProp("width") } } } } } if (l) { if (e) { s = 0 } else { if (r && r.measureContentHeight) { s = r.measureContentHeight(m) } else { if (v.cacheHeight) { x = v.xtype + "-" + v.ui; n = u.heightCache; s = n[x] || (n[x] = u.measureContentHeight(m)) } else { s = u.measureContentHeight(m) } } } if (!isNaN(w.contentHeight = s)) { m.setContentHeight(s, true); w.gotHeight = true; ++g } } } } } else { if (d.natural && m.consumersHeight) { ++k; p = b.height; if (typeof p === "number") { w.height = p; w.gotHeight = true; ++g } else { if (o || !c) { l = true } else { l = c.hasDomProp("width") } if (l) { if (!isNaN(w.height = u.measureOwnerHeight(m))) { m.setHeight(w.height, false); w.gotHeight = true; ++g } } } } } if (c) { m.onBoxMeasured() } w.gotAll = g === k; return w }, measureContentWidth: function (a) { return a.el.getWidth() - a.getFrameInfo().width }, measureContentHeight: function (a) { return a.el.getHeight() - a.getFrameInfo().height }, measureOwnerHeight: function (a) { return a.el.getHeight() }, measureOwnerWidth: function (a) { return a.el.getWidth() } }, 0, 0, 0, 0, 0, 0, [Ext.layout.component, "Component"], 0)); (Ext.cmd.derive("Ext.layout.component.Auto", Ext.layout.component.Component, { type: "autocomponent", setHeightInDom: false, setWidthInDom: false, waitForOuterHeightInDom: false, waitForOuterWidthInDom: false, beginLayoutCycle: function (d, a) { var c = this, g = c.lastWidthModel, e = c.lastHeightModel, b = c.owner.el; Ext.layout.component.Component.prototype.beginLayoutCycle.apply(this, arguments); if (g && g.fixed && d.widthModel.shrinkWrap) { b.setWidth(null) } if (e && e.fixed && d.heightModel.shrinkWrap) { b.setHeight(null) } }, calculate: function (h) { var g = this, e = g.measureAutoDimensions(h), b = h.heightModel, c = h.widthModel, d, a; if (e.gotWidth) { if (c.shrinkWrap) { g.publishOwnerWidth(h, e.contentWidth) } else { if (g.publishInnerWidth) { g.publishInnerWidth(h, e.width) } } } else { if (!c.auto && g.publishInnerWidth) { d = g.waitForOuterWidthInDom ? h.getDomProp("width") : h.getProp("width"); if (d === undefined) { g.done = false } else { g.publishInnerWidth(h, d) } } } if (e.gotHeight) { if (b.shrinkWrap) { g.publishOwnerHeight(h, e.contentHeight) } else { if (g.publishInnerHeight) { g.publishInnerHeight(h, e.height) } } } else { if (!b.auto && g.publishInnerHeight) { a = g.waitForOuterHeightInDom ? h.getDomProp("height") : h.getProp("height"); if (a === undefined) { g.done = false } else { g.publishInnerHeight(h, a) } } } if (!e.gotAll) { g.done = false } }, calculateOwnerHeightFromContentHeight: function (b, a) { return a + b.getFrameInfo().height }, calculateOwnerWidthFromContentWidth: function (b, a) { return a + b.getFrameInfo().width }, publishOwnerHeight: function (i, g) { var e = this, b = e.owner, a = e.calculateOwnerHeightFromContentHeight(i, g), h, d, c; if (isNaN(a)) { e.done = false } else { h = Ext.Number.constrain(a, b.minHeight, b.maxHeight); if (h === a) { d = e.setHeightInDom } else { c = e.sizeModels[(h < a) ? "constrainedMax" : "constrainedMin"]; a = h; if (i.heightModel.calculatedFromShrinkWrap) { i.heightModel = c } else { i.invalidate({ heightModel: c }) } } i.setHeight(a, d) } }, publishOwnerWidth: function (h, b) { var g = this, a = g.owner, e = g.calculateOwnerWidthFromContentWidth(h, b), i, d, c; if (isNaN(e)) { g.done = false } else { i = Ext.Number.constrain(e, a.minWidth, a.maxWidth); if (i === e) { d = g.setWidthInDom } else { c = g.sizeModels[(i < e) ? "constrainedMax" : "constrainedMin"]; e = i; if (h.widthModel.calculatedFromShrinkWrap) { h.widthModel = c } else { h.invalidate({ widthModel: c }) } } h.setWidth(e, d) } } }, 0, 0, 0, 0, ["layout.autocomponent"], 0, [Ext.layout.component, "Auto"], 0)); (Ext.cmd.derive("Ext.layout.component.ProgressBar", Ext.layout.component.Auto, { type: "progressbar", beginLayout: function (d) { var b = this, a, c; Ext.layout.component.Auto.prototype.beginLayout.apply(this, arguments); if (!d.textEls) { c = b.owner.textEl; if (c.isComposite) { d.textEls = []; c = c.elements; for (a = c.length; a--;) { d.textEls[a] = d.getEl(Ext.get(c[a])) } } else { d.textEls = [d.getEl("textEl")] } } }, calculate: function (e) { var c = this, a, d, b; Ext.layout.component.Auto.prototype.calculate.apply(this, arguments); if (Ext.isNumber(b = e.getProp("width"))) { b -= e.getBorderInfo().width; d = e.textEls; for (a = d.length; a--;) { d[a].setWidth(b) } } else { c.done = false } } }, 0, 0, 0, 0, ["layout.progressbar"], 0, [Ext.layout.component, "ProgressBar"], 0)); (Ext.cmd.derive("Ext.ProgressBar", Ext.Component, { baseCls: "x-progress", animate: false, text: "", waitTimer: null, childEls: ["bar"], defaultBindProperty: "value", renderTpl: ['<tpl if="internalText">', '<div class="{baseCls}-text {baseCls}-text-back" role="presentation">{text}</div>', "</tpl>", '<div id="{id}-bar" data-ref="bar" class="{baseCls}-bar {baseCls}-bar-{ui}" role="presentation" style="width:{percentage}%">', '<tpl if="internalText">', '<div class="{baseCls}-text" role="presentation">', '<div role="presentation">{text}</div>', "</div>", "</tpl>", "</div>"], componentLayout: "progressbar", ariaRole: "progressbar", focusable: true, tabIndex: 0, autoEl: { "aria-valuemin": "0", "aria-valuenow": "0", "aria-valuemax": "100" }, initRenderData: function () { var a = this, c = a.value || 0, b; b = Ext.Component.prototype.initRenderData.call(this); return Ext.apply(b, { internalText: !a.hasOwnProperty("textEl"), text: a.text || Math.round(c * 100) + "%", percentage: c * 100 }) }, onRender: function () { var a = this; Ext.Component.prototype.onRender.apply(this, arguments); if (a.textEl) { a.textEl = Ext.get(a.textEl); a.updateText(a.text) } else { a.textEl = a.el.select("." + a.baseCls + "-text") } }, afterRender: function () { var a = this; Ext.Component.prototype.afterRender.apply(this, arguments); if (a.text) { a.ariaEl.dom.setAttribute("aria-valuetext", a.text) } }, updateValue: function (a) { this.updateProgress(a) }, updateProgress: function (e, g, a) { e = e || 0; var d = this, b = d.value, c = d.getTextTpl(); d.value = e || (e = 0); if (g != null) { d.autoText = false; d.updateText(g) } else { if (c) { d.autoText = false; d.updateText(c.apply({ value: e, percent: e * 100 })) } else { if (!d.text && d.autoText !== false) { d.autoText = true; d.updateText(Math.round(e * 100) + "%") } else { if (d.text && d.ariaEl.dom) { d.ariaEl.dom.removeAttribute("aria-valuetext") } } } } if (d.rendered && !d.destroyed) { if (a === true || (a !== false && d.animate)) { d.bar.stopAnimation(); d.bar.animate(Ext.apply({ from: { width: (b * 100) + "%" }, to: { width: (e * 100) + "%" } }, d.animate)) } else { d.bar.setStyle("width", (e * 100) + "%") } d.ariaEl.dom.setAttribute("aria-valuenow", Math.round(e * 100)) } d.fireEvent("update", d, e, g); return d }, updateText: function (b) { var a = this; if (!a.autoText) { a.text = b } if (a.rendered) { a.textEl.setHtml(b); if (!a.autoText) { a.ariaEl.dom.setAttribute("aria-valuetext", b) } else { a.ariaEl.dom.removeAttribute("aria-valuetext") } } return a }, applyText: function (a) { this.updateText(a) }, getText: function () { return this.text }, wait: function (c) { var b = this, a; if (!b.waitTimer) { a = b; c = c || {}; if (c.text != null) { b.autoText = false } b.updateText(c.text); b.waitTimer = Ext.TaskManager.start({ run: function (d) { var e = c.increment || 10; d -= 1; b.updateProgress(((((d + e) % e) + 1) * (100 / e)) * 0.01, null, c.animate) }, interval: c.interval || 1000, duration: c.duration, onStop: function () { if (c.fn) { c.fn.apply(c.scope || b) } b.reset() }, scope: a }) } return b }, isWaiting: function () { return this.waitTimer !== null }, reset: function (a) { var b = this; b.updateProgress(0); b.clearTimer(); if (a === true) { b.hide() } if (b.rendered) { b.ariaEl.dom.removeAttribute("aria-valuetext") } return b }, clearTimer: function () { var a = this; if (a.waitTimer) { a.waitTimer.onStop = null; Ext.TaskManager.stop(a.waitTimer); a.waitTimer = null } }, doDestroy: function () { var b = this, a = b.bar; b.clearTimer(); if (b.rendered) { if (b.textEl.isComposite) { b.textEl.clear() } Ext.destroyMembers(b, "textEl", "progressBar"); if (a && b.animate) { a.stopAnimation() } } Ext.Component.prototype.doDestroy.call(this) } }, 0, ["progressbar"], ["component", "box", "progressbar"], { component: true, box: true, progressbar: true }, ["widget.progressbar"], [[Ext.ProgressBase.prototype.mixinId || Ext.ProgressBase.$className, Ext.ProgressBase]], [Ext, "ProgressBar"], 0)); (Ext.cmd.derive("Ext.dom.ButtonElement", Ext.dom.Element, { setSize: function (d, a, b) { var e = this, c = e.component; Ext.dom.Element.prototype.setSize.call(this, d, a, b); c.btnWrap.setStyle("table-layout", (!d || d === "auto") ? "" : "fixed"); c.btnEl.setStyle("height", (!a || a === "auto") ? "" : "auto"); return e }, setStyle: function (g, e) { var d = this, b = d.component, c, a; Ext.dom.Element.prototype.setStyle.call(this, g, e); if (g) { if (g === "width" || (typeof g !== "string" && "width" in g)) { c = e || g.width; b.btnWrap.setStyle("table-layout", (!c || c === "auto") ? "" : "fixed") } if (g === "height" || (typeof g !== "string" && "height" in g)) { a = e || g.height; b.btnEl.setStyle("height", (!a || a === "auto") ? "" : "auto") } } return d }, setHeight: function (a, b) { Ext.dom.Element.prototype.setHeight.call(this, a, b); this.component.btnEl.setStyle("height", (!a || a === "auto") ? "" : "auto"); return this }, setWidth: function (b, a) { Ext.dom.Element.prototype.setWidth.call(this, b, a); this.component.btnWrap.setStyle("table-layout", (!b || b === "auto") ? "" : "fixed"); return this } }, 0, 0, 0, 0, 0, 0, [Ext.dom, "ButtonElement"], 0)); (Ext.cmd.derive("Ext.button.Manager", Ext.Base, { singleton: true, alternateClassName: "Ext.ButtonToggleManager", groups: {}, pressedButton: null, init: function () { var a = this; if (!a.initialized) { Ext.getDoc().on({ mouseup: a.onDocumentMouseUp, scope: a }); a.initialized = true } }, onButtonMousedown: function (a, c) { var b = this.pressedButton; if (b && !b.destroying && !b.destroyed) { b.onMouseUp(c) } this.pressedButton = a }, onDocumentMouseUp: function (b) { var a = this.pressedButton; if (a && !a.destroying && !a.destroyed) { a.onMouseUp(b); this.pressedButton = null } }, toggleGroup: function (b, e) { if (e) { var d = this.groups[b.toggleGroup], c = d.length, a; for (a = 0; a < c; a++) { if (d[a] !== b) { d[a].toggle(false) } } } }, register: function (b) { var c = this, a = this.groups, d = a[b.toggleGroup]; c.init(); if (!b.toggleGroup) { return } if (!d) { d = a[b.toggleGroup] = [] } d.push(b); b.on("toggle", c.toggleGroup, c) }, unregister: function (a) { if (!a.toggleGroup) { return } var b = this, c = b.groups[a.toggleGroup]; if (c) { Ext.Array.remove(c, a); a.un("toggle", b.toggleGroup, b) } }, getPressed: function (d) { var c = this.groups[d], b = 0, a; if (c) { for (a = c.length; b < a; b++) { if (c[b].pressed === true) { return c[b] } } } return null } }, 0, 0, 0, 0, 0, 0, [Ext.button, "Manager", Ext, "ButtonToggleManager"], 0)); (Ext.cmd.derive("Ext.menu.Manager", Ext.Base, { singleton: true, alternateClassName: "Ext.menu.MenuMgr", groups: {}, visible: [], constructor: function () { var a = this; a.onShow = function () { a.registerGlobalListeners(); return a.onShow.apply(a, arguments) } }, onGlobalScroll: function (c) { var g = this.visible, b = g.length, d, e, a = c.getElement(); if (b && c !== Ext.scroll.Scroller.viewport) { g = g.slice(); for (d = 0; d < b; ++d) { e = g[d]; if (!e.alignOnScroll && e.hideOnScroll !== false && !e.owns(a)) { e.hide() } } } }, checkActiveMenus: function (d) { var h = this.visible, a = h.length, b, g, c = Ext.Component.fromElement(d.target); if (a) { h = h.slice(); for (b = 0; b < a; ++b) { g = h[b]; if (!(g.owns(d) || (c && c.isMenuItem && c.menu === g))) { g.hide() } } } }, onShow: function (a) { if (a.floating) { Ext.Array.include(this.visible, a) } }, onHide: function (a) { if (a.floating) { Ext.Array.remove(this.visible, a) } }, hideAll: function () { var d = this.visible, b = d.length, a = false, c; if (b) { d = d.slice(); for (c = 0; c < b; c++) { d[c].hide(); a = true } } return a }, get: function (c, b) { var a; if (typeof c === "string") { a = Ext.getCmp(c); if (a instanceof Ext.menu.Menu) { c = a } } else { if (Ext.isArray(c)) { b = Ext.apply({ items: c }, b); c = new Ext.menu.Menu(b) } else { if (!c.isComponent) { b = Ext.apply({}, c, b); c = Ext.ComponentManager.create(b, "menu") } } } return c }, registerCheckable: function (c) { var a = this.groups, b = c.group; if (b) { if (!a[b]) { a[b] = [] } a[b].push(c) } }, unregisterCheckable: function (c) { var a = this.groups, b = c.group; if (b) { Ext.Array.remove(a[b], c) } }, onCheckChange: function (d, g) { var a = this.groups, c = d.group, b = 0, j, e, h; if (c && g) { j = a[c]; e = j.length; for (; b < e; b++) { h = j[b]; if (h !== d) { h.setChecked(false) } } } }, registerGlobalListeners: function () { var a = this; delete a.onShow; Ext.on({ mousedown: a.checkActiveMenus, scroll: a.onGlobalScroll, scope: a }) } }, 1, 0, 0, 0, 0, 0, [Ext.menu, "Manager", Ext.menu, "MenuMgr"], 0)); (Ext.cmd.derive("Ext.util.ClickRepeater", Ext.util.Observable, { constructor: function (b, a) { var c = this; c.el = Ext.get(b); c.el.unselectable(); Ext.apply(c, a); Ext.util.Observable.prototype.constructor.call(this); if (!c.disabled) { c.disabled = true; c.enable() } if (c.handler) { c.on("click", c.handler, c.scope || c) } }, interval: 20, delay: 250, preventDefault: true, stopDefault: false, timer: 0, enable: function () { if (this.disabled) { this.el.on("mousedown", this.handleMouseDown, this); if (Ext.isIE8) { this.el.on("dblclick", this.handleDblClick, this) } if (this.preventDefault || this.stopDefault) { this.el.on("click", this.eventOptions, this) } } this.disabled = false }, disable: function (a) { if (a || !this.disabled) { clearTimeout(this.timer); if (this.pressedCls) { this.el.removeCls(this.pressedCls) } Ext.getDoc().un("mouseup", this.handleMouseUp, this); this.el.clearListeners() } this.disabled = true }, setDisabled: function (a) { this[a ? "disable" : "enable"]() }, eventOptions: function (a) { if (this.preventDefault) { a.preventDefault() } if (this.stopDefault) { a.stopEvent() } }, destroy: function () { this.disable(true); Ext.util.Observable.prototype.destroy.call(this) }, handleDblClick: function (a) { clearTimeout(this.timer); this.fireEvent("mousedown", this, a); this.fireEvent("click", this, a) }, handleMouseDown: function (a) { clearTimeout(this.timer); if (this.pressedCls) { this.el.addCls(this.pressedCls) } this.mousedownTime = new Date(); Ext.getDoc().on("mouseup", this.handleMouseUp, this); this.el.on("mouseout", this.handleMouseOut, this); this.fireEvent("mousedown", this, a); this.fireEvent("click", this, a); if (this.accelerate) { this.delay = 400 } this.timer = Ext.defer(this.click, this.delay || this.interval, this, [a]); if (this.mousedownPreventDefault) { a.preventDefault() } if (this.mousedownStopEvent) { a.stopEvent() } }, click: function (a) { this.fireEvent("click", this, a); this.timer = Ext.defer(this.click, this.accelerate ? this.easeOutExpo(Ext.Date.getElapsed(this.mousedownTime), 400, -390, 12000) : this.interval, this, [a]) }, easeOutExpo: function (e, a, h, g) { return (e === g) ? a + h : h * (-Math.pow(2, -10 * e / g) + 1) + a }, handleMouseOut: function () { clearTimeout(this.timer); if (this.pressedCls) { this.el.removeCls(this.pressedCls) } this.el.on("mouseover", this.handleMouseReturn, this) }, handleMouseReturn: function (a) { this.el.un("mouseover", this.handleMouseReturn, this); if (this.pressedCls) { this.el.addCls(this.pressedCls) } this.click(a) }, handleMouseUp: function (a) { clearTimeout(this.timer); this.el.un("mouseover", this.handleMouseReturn, this); this.el.un("mouseout", this.handleMouseOut, this); Ext.getDoc().un("mouseup", this.handleMouseUp, this); if (this.pressedCls) { this.el.removeCls(this.pressedCls) } this.fireEvent("mouseup", this, a) } }, 1, 0, 0, 0, 0, 0, [Ext.util, "ClickRepeater"], 0)); (Ext.cmd.derive("Ext.button.Button", Ext.Component, { alternateClassName: "Ext.Button", config: { iconAlign: "left", text: null, textAlign: "center", arrowVisible: true, glyph: null }, isButton: true, _syncFrameHeight: true, liquidLayout: true, hidden: false, disabled: false, pressed: false, tabIndex: 0, enableToggle: false, menuAlign: "tl-bl?", showEmptyMenu: false, clickEvent: "click", preventDefault: true, handleMouseEvents: true, tooltipType: "qtip", baseCls: "x-btn", hrefTarget: "_blank", destroyMenu: true, focusable: true, ariaRole: "button", keyMap: { scope: "this", SPACE: "onEnterKey", ENTER: "onEnterKey", DOWN: "onDownKey" }, defaultBindProperty: "text", childEls: ["btnEl", "btnWrap", "btnInnerEl", "btnIconEl", "arrowEl"], publishes: { pressed: 1 }, _btnWrapCls: "x-btn-wrap", _btnCls: "x-btn-button", _baseIconCls: "x-btn-icon-el", _glyphCls: "x-btn-glyph", _innerCls: "x-btn-inner", _textCls: "x-btn-text", _noTextCls: "x-btn-no-text", _hasIconCls: "x-btn-icon", _pressedCls: "x-btn-pressed", overCls: "x-btn-over", _disabledCls: "x-btn-disabled", _menuActiveCls: "x-btn-menu-active", _arrowElCls: "x-btn-arrow-el", _focusCls: "x-btn-focus", _arrowFocusCls: "x-arrow-focus", renderTpl: '<span id="{id}-btnWrap" data-ref="btnWrap" role="presentation" unselectable="on" style="{btnWrapStyle}" class="{btnWrapCls} {btnWrapCls}-{ui} {splitCls}{childElCls}"><span id="{id}-btnEl" data-ref="btnEl" role="presentation" unselectable="on" style="{btnElStyle}" class="{btnCls} {btnCls}-{ui} {textCls} {noTextCls} {hasIconCls} {iconAlignCls} {textAlignCls} {btnElAutoHeightCls}{childElCls}"><tpl if="iconBeforeText">{[values.$comp.renderIcon(values)]}</tpl><span id="{id}-btnInnerEl" data-ref="btnInnerEl" unselectable="on" class="{innerCls} {innerCls}-{ui}{childElCls}">{text}</span><tpl if="!iconBeforeText">{[values.$comp.renderIcon(values)]}</tpl></span></span>{[values.$comp.getAfterMarkup ? values.$comp.getAfterMarkup(values) : ""]}<tpl if="closable"><span id="{id}-closeEl" data-ref="closeEl" class="{baseCls}-close-btn"><tpl if="closeText"> {closeText}</tpl></span></tpl><tpl if="split"><span id="{id}-arrowEl" class="{arrowElCls}" data-ref="arrowEl" role="button" hidefocus="on" unselectable="on"<tpl if="tabIndex != null"> tabindex="{tabIndex}"</tpl><tpl foreach="arrowElAttributes"> {$}="{.}"</tpl> style="{arrowElStyle}">{arrowElText}</span></tpl>', iconTpl: '<span id="{id}-btnIconEl" data-ref="btnIconEl" role="presentation" unselectable="on" class="{baseIconCls} {baseIconCls}-{ui} {iconCls} {glyphCls}{childElCls}" style="<tpl if="iconUrl">background-image:url({iconUrl});</tpl><tpl if="glyph"><tpl if="glyphFontFamily">font-family:{glyphFontFamily};</tpl>">{glyph}<tpl else>"></tpl></span>', scale: "small", allowedScales: ["small", "medium", "large"], arrowAlign: "right", arrowCls: "arrow", maskOnDisable: false, shrinkWrap: 3, frame: true, autoEl: { tag: "a", hidefocus: "on", unselectable: "on" }, hasFrameTable: function () { return this.href && this.frameTable }, frameTableListener: function () { if (!this.disabled) { this.doNavigate() } }, doNavigate: function () { if (this.hrefTarget === "_blank") { window.open(this.getHref(), this.hrefTarget) } else { location.href = this.getHref() } }, _triggerRegion: {}, initComponent: function () { var a = this; a.addCls("x-unselectable"); Ext.Component.prototype.initComponent.call(this); if (a.menu) { a.split = true; a.setMenu(a.menu, false, true) } if (a.url) { a.href = a.url } a.configuredWithPreventDefault = a.hasOwnProperty("preventDefault"); if (a.href && !a.configuredWithPreventDefault) { a.preventDefault = false } if (Ext.isString(a.toggleGroup) && a.toggleGroup !== "") { a.enableToggle = true } if (a.html && !a.text) { a.text = a.html; delete a.html } }, getElConfig: function () { var c = this, b = Ext.Component.prototype.getElConfig.call(this), a = c.getHref(), d = c.hrefTarget; if (b.tag === "a") { if (!c.disabled) { b.tabIndex = c.tabIndex } if (a) { if (!c.disabled) { b.href = a; if (d) { b.target = d } } } } if (!c.ariaStaticRoles[c.ariaRole]) { if (c.menu && !c.isSplitButton) { b["aria-haspopup"] = true } if (c.enableToggle) { b["aria-pressed"] = !!c.pressed } } return b }, beforeRender: function () { Ext.Component.prototype.beforeRender.call(this); if (this.pressed) { this.addCls(this._pressedCls) } }, initRenderData: function () { return Ext.apply(Ext.Component.prototype.initRenderData.call(this), this.getTemplateArgs()) }, getMenu: function () { return this.menu || null }, setMenu: function (i, h, e) { var g = this, b = g.menu, a = g.isSplitButton ? g.arrowEl && g.arrowEl.dom : g.ariaEl.dom, c, d; if (b && !e) { if (h !== false && g.destroyMenu) { b.destroy() } b.ownerCmp = null } if (i) { c = i.isMenu; i = Ext.menu.Manager.get(i, { ownerCmp: g }); i.setOwnerCmp(g, c); i.menuClickBuffer = 250; g.mon(i, { scope: g, show: g.onMenuShow, hide: g.onMenuHide }); if (!b && g.getArrowVisible()) { g.split = true; if (g.rendered) { g._addSplitCls(); g.updateLayout() } } g.menu = i; if (a) { a.setAttribute("aria-haspopup", true); a.setAttribute("aria-owns", i.id) } else { d = g.isSplitButton ? (g.ariaArrowElAttributes || (g.ariaArrowElAttributes = {})) : (g.ariaRenderAttributes || (g.ariaRenderAttributes = {})); d["aria-haspopup"] = true; d["aria-owns"] = i.id } } else { if (g.rendered) { a.removeAttribute("aria-haspopup"); a.removeAttribute("aria-owns"); g._removeSplitCls(); g.updateLayout() } else { d = g.isSplitButton ? g.ariaArrowElAttributes : g.ariaRenderAttributes; if (d) { delete d["aria-haspopup"]; delete d["aria-owns"] } } g.split = false; g.menu = null } }, onRender: function () { var c = this, d, a, b; Ext.Component.prototype.onRender.apply(this, arguments); a = c.el; if (c.tooltip) { c.setTooltip(c.tooltip, true) } if (c.handleMouseEvents) { b = { scope: c, mouseover: c.onMouseOver, mouseout: c.onMouseOut, mousedown: c.onMouseDown }; if (c.split) { b.mousemove = c.onMouseMove } } else { b = { scope: c } } if (Ext.supports.Touch) { b.touchstart = c.onTouchStart } if (c.repeat) { c.mon(new Ext.util.ClickRepeater(a, Ext.isObject(c.repeat) ? c.repeat : {}), "click", c.onRepeatClick, c) } else { if (b[c.clickEvent]) { d = true } else { b[c.clickEvent] = c.onClick } } c.mon(a, b); if (c.hasFrameTable()) { c.mon(c.frameTable, "click", c.frameTableListener, c) } if (d) { c.mon(a, c.clickEvent, c.onClick, c) } Ext.button.Manager.register(c) }, onFocusLeave: function (a) { Ext.Component.prototype.onFocusLeave.call(this, a); if (this.menu) { this.menu.hide() } }, getTemplateArgs: function () { var h = this, b = h._btnCls, d = h._baseIconCls, a = h.getIconAlign(), i = h.glyph, g, j = h.text, c = h._hasIcon(), e = h._hasIconCls; if (i) { g = i.fontFamily; i = i.character } return { split: h.isSplitButton, innerCls: h._innerCls, splitCls: h.getArrowVisible() ? h.getSplitCls() : "", iconUrl: h.icon, iconCls: h.iconCls, glyph: i, glyphCls: i ? h._glyphCls : "", glyphFontFamily: g, text: j || "&#160;", closeText: h.closeText, textCls: j ? h._textCls : "", noTextCls: j ? "" : h._noTextCls, hasIconCls: c ? e : "", btnWrapCls: h._btnWrapCls, btnWrapStyle: h.width ? "table-layout:fixed;" : "", btnElStyle: h.height ? "height:auto;" : "", btnCls: b, baseIconCls: d, iconBeforeText: a === "left" || a === "top", iconAlignCls: c ? (e + "-" + a) : "", textAlignCls: b + "-" + h.getTextAlign(), arrowElCls: h._arrowElCls, arrowElStyle: h.arrowVisible ? "" : "display:none", tabIndex: h.tabIndex } }, renderIcon: function (a) { return this.lookupTpl("iconTpl").apply(a) }, setHref: function (a) { var b = this, d = b.hrefTarget, c; b.href = a; if (!b.configuredWithPreventDefault) { b.preventDefault = !a } if (b.rendered) { c = b.el.dom; if (!a || b.disabled) { c.removeAttribute("href"); c.removeAttribute("hrefTarget") } else { c.href = b.getHref(); if (d) { c.target = d } } } }, getHref: function () { var b = this, a = b.href; return a ? Ext.urlAppend(a, Ext.Object.toQueryString(Ext.apply({}, b.params, b.baseParams))) : false }, setParams: function (c) { var a = this, b; a.params = c; if (a.rendered) { b = a.el.dom; if (a.disabled) { b.removeAttribute("href") } else { b.href = a.getHref() || "" } } }, getSplitCls: function () { var a = this; return a.split ? (a.baseCls + "-" + a.arrowCls) + " " + (a.baseCls + "-" + a.arrowCls + "-" + a.arrowAlign) : "" }, setIcon: function (b) { b = b || ""; var c = this, a = c.btnIconEl, d = c.icon || ""; if (c.glyph) { c.setGlyph(null) } c.icon = b; if (b !== d) { if (a) { a.removeCls(c.iconCls); a.setStyle("background-image", b ? "url(" + b + ")" : ""); c._syncHasIconCls(); if (c.didIconStateChange(d, b)) { c.updateLayout() } } c.fireEvent("iconchange", c, d, b) } return c }, setIconCls: function (b) { b = b || ""; var d = this, a = d.btnIconEl, c = d.iconCls || ""; if (d.glyph) { d.setGlyph(null) } d.iconCls = b; if (c !== b) { if (a) { a.setStyle("background-image", ""); a.removeCls(c); a.addCls(b); d._syncHasIconCls(); if (d.didIconStateChange(c, b)) { d.updateLayout() } } d.fireEvent("iconchange", d, c, b) } return d }, applyGlyph: function (b, a) { if (b) { if (!b.isGlyph) { b = new Ext.Glyph(b) } if (b.isEqual(a)) { b = undefined } } return b }, updateGlyph: function (d, b) { var c = this, a = c.btnIconEl, e = c._glyphCls; if (a) { c.icon = null; a.setStyle("background-image", ""); if (d) { a.dom.innerHTML = d.character; a.addCls(e); a.setStyle(d.getStyle()) } else { a.dom.innerHTML = ""; a.removeCls(e) } c._syncHasIconCls(); if (c.didIconStateChange(b, d)) { c.updateLayout() } } c.fireEvent("glyphchange", c, d && d.glyphConfig, b && b.glyphConfig); return c }, setTooltip: function (c, a) { var b = this; if (b.rendered) { if (!a || !c) { b.clearTip() } if (c) { if (Ext.quickTipsActive && Ext.isObject(c)) { Ext.tip.QuickTipManager.register(Ext.apply({ target: b.el.id }, c)); b.tooltip = c } else { b.el.dom.setAttribute(b.getTipAttr(), c) } } } else { b.tooltip = c } return b }, updateIconAlign: function (g, d) { var c = this, b, a, e; if (c.rendered) { b = c.btnEl; a = c.btnIconEl; e = c._hasIconCls; if (d) { b.removeCls(e + "-" + d) } b.addCls(e + "-" + g); if (g === "top" || g === "left") { b.insertFirst(a) } else { b.appendChild(a) } c.updateLayout() } }, updateTextAlign: function (e, d) { var c = this, b = c.btnEl, a = c._btnCls; if (c.rendered) { b.removeCls(a + "-" + d); b.addCls(a + "-" + e) } }, getTipAttr: function () { return this.tooltipType === "qtip" ? "data-qtip" : "title" }, getRefItems: function (a) { var c = this.menu, b = []; if (c) { if (a) { b = c.getRefItems(a) } b.unshift(c) } return b }, clearTip: function () { var b = this, a = b.el; if (Ext.quickTipsActive && Ext.isObject(b.tooltip)) { Ext.tip.QuickTipManager.unregister(a) } else { a.dom.removeAttribute(b.getTipAttr()) } }, doDestroy: function () { var a = this, b = a.menu; if (a.rendered) { a.clearTip() } Ext.destroy(a.repeater); if (b && a.destroyMenu) { a.menu = Ext.destroy(b) } Ext.button.Manager.unregister(a); Ext.Component.prototype.doDestroy.call(this) }, setHandler: function (b, a) { this.handler = b; if (arguments.length > 1) { this.scope = a } return this }, updateText: function (d, a) { d = d == null ? "" : String(d); a = a || ""; var c = this, e = c.btnInnerEl, b = c.btnEl; if (c.rendered) { e.setHtml(d || "&#160;"); b[d ? "addCls" : "removeCls"](c._textCls); b[d ? "removeCls" : "addCls"](c._noTextCls); c.updateLayout() } c.fireEvent("textchange", c, a, d) }, didIconStateChange: function (a, c) { var b = Ext.isEmpty(c); return Ext.isEmpty(a) ? !b : b }, click: function (a) { return this.onClick(a) }, setPressed: function (a) { return this.toggle(a !== false) }, toggle: function (d, b) { var c = this, a = c.ariaEl.dom; if (!c.enableToggle) { return c } d = d === undefined ? !c.pressed : !!d; if (c.fireEvent("beforetoggle", c, d) !== false) { if (d !== c.pressed) { c[d ? "addCls" : "removeCls"](c._pressedCls); c.pressed = d; if (a) { a.setAttribute("aria-pressed", d) } if (!b) { c.fireEvent("toggle", c, d); Ext.callback(c.toggleHandler, c.scope, [c, d], 0, c); if (c.publishState) { c.publishState("pressed", d) } } } } return c }, maybeShowMenu: function (a) { if (this.menu) { this.showMenu(a) } }, showMenu: function (a) { var c = this, d = c.menu, b = !a || a.pointerType; if (d && c.rendered) { if (c.tooltip && Ext.quickTipsActive && c.getTipAttr() !== "title") { Ext.tip.QuickTipManager.getQuickTip().cancelShow(c.el) } if (d.isVisible()) { if (b) { d.hide() } else { d.focus() } } else { if (!a || c.showEmptyMenu || d.items.getCount() > 0) { d.autoFocus = !b; d.showBy(c.el, c.menuAlign) } } } return c }, hideMenu: function () { if (this.hasVisibleMenu()) { this.menu.hide() } return this }, hasVisibleMenu: function () { var a = this.menu; return a && a.rendered && a.isVisible() }, onRepeatClick: function (a, b) { this.onClick(b) }, onTouchStart: function (a) { this.doPreventDefault(a) }, onEnterKey: function (a) { if (!this.href) { this.onClick(a); a.stopEvent(); return false } }, onClick: function (b) { var a = this; if (b) { a.doPreventDefault(b) } if (b && b.type !== "keydown" && b.button) { return } if (!a.disabled) { a.doToggle(); a.maybeShowMenu(b); a.fireHandler(b) } }, doToggle: function () { var a = this; if (a.allowDepress !== false || !a.pressed) { a.toggle() } }, doPreventDefault: function (a) { if (a && (this.preventDefault || (this.disabled && this.getHref()))) { a.preventDefault() } }, fireHandler: function (b) { var a = this; if (a.fireEvent("click", a, b) !== false && !a.destroyed) { Ext.callback(a.handler, a.scope, [a, b], 0, a) } }, onMouseOver: function (b) { var a = this; if (!a.disabled && !b.within(a.el, true, true)) { a.onMouseEnter(b) } }, onMouseOut: function (b) { var a = this; if (!b.within(a.el, true, true)) { if (a.overMenuTrigger) { a.onMenuTriggerOut(b) } a.onMouseLeave(b) } }, onMouseMove: function (c) { var a = this, b = a.overMenuTrigger; if (a.split) { if (a.isWithinTrigger(c)) { if (!b) { a.onMenuTriggerOver(c) } } else { if (b) { a.onMenuTriggerOut(c) } } } }, isWithinTrigger: function (d) { var c = this, b = c.el, g, a; g = (c.arrowAlign === "right") ? d.getX() - c.getX() : d.getY() - b.getY(); a = c.getTriggerRegion(); return g > a.begin && g < a.end }, getTriggerRegion: function () { var d = this, e = d._triggerRegion, c = d.arrowAlign === "right", b = c ? "getRight" : "getBottom", a = c ? d.getWidth() : d.getHeight(); e.begin = a - (d.el[b]() - d.btnEl[b]()); e.end = a; return e }, onMouseEnter: function (a) { this.fireEvent("mouseover", this, a) }, onMouseLeave: function (a) { this.fireEvent("mouseout", this, a) }, onMenuTriggerOver: function (c) { var b = this, a = b.arrowTooltip; b.overMenuTrigger = true; if (b.split && a) { b.btnWrap.dom.setAttribute(b.getTipAttr(), a) } b.fireEvent("menutriggerover", b, b.menu, c) }, onMenuTriggerOut: function (b) { var a = this; delete a.overMenuTrigger; if (a.split && a.arrowTooltip) { a.btnWrap.dom.setAttribute(a.getTipAttr(), "") } a.fireEvent("menutriggerout", a, a.menu, b) }, onEnable: function () { var b = this, a = b.href, d = b.hrefTarget, c = b.el.dom; Ext.Component.prototype.onEnable.call(this); b.removeCls(b._disabledCls); c.setAttribute("tabIndex", b.tabIndex); if (a) { c.href = a } if (d) { c.target = d } }, onDisable: function () { var a = this, b = a.el.dom; Ext.Component.prototype.onDisable.call(this); a.addCls(a._disabledCls); a.removeCls(a.overCls); b.removeAttribute("tabIndex"); if (a.href) { b.removeAttribute("href") } if (a.hrefTarget) { b.removeAttribute("target") } }, setScale: function (c) { var a = this, b = a.ui.replace("-" + a.scale, ""); if (!Ext.Array.contains(a.allowedScales, c)) { throw ("#setScale: scale must be an allowed scale (" + a.allowedScales.join(", ") + ")") } a.scale = c; a.setUI(b) }, setUI: function (b) { var a = this; if (a.scale && !b.match(a.scale)) { b = b + "-" + a.scale } Ext.Component.prototype.setUI.call(this, b) }, onMouseDown: function (b) { var a = this; if (Ext.isIE || b.pointerType === "touch") { Ext.defer(function () { var c = a.getFocusEl(); if (c && !b.defaultPrevented) { c.focus() } }, 1) } if (!a.disabled && b.button === 0) { Ext.button.Manager.onButtonMousedown(a, b); a.addCls(a._pressedCls) } }, onMouseUp: function (b) { var a = this; if (!a.destroyed && b.button === 0) { if (!a.pressed) { a.removeCls(a._pressedCls) } } }, onMenuShow: function () { var a = this; a.addCls(a._menuActiveCls); a.fireEvent("menushow", a, a.menu) }, onMenuHide: function (b) { var a = this; a.removeCls(a._menuActiveCls); a.fireEvent("menuhide", a, a.menu) }, onDownKey: function (b) { var a = this; if (a.menu && !a.disabled) { a.showMenu(b); b.stopEvent(); return false } }, updateArrowVisible: function (b) { var a = this; if (a.rendered) { if (b) { if (a.menu || a.isSplitButton) { a.split = true; a._addSplitCls() } } else { a._removeSplitCls(); a.split = false } } return b }, privates: { elClsMap: { btnWrap: "_btnWrapCls", btnEl: "_btnCls", btnIconEl: "_baseIconCls", btnInnerEl: "_innerCls" }, addUIToElement: function () { Ext.Component.prototype.addUIToElement.call(this); this.updateChildElsUICls(true) }, addOverCls: function () { if (!this.disabled) { this.addCls(this.overCls) } }, _addSplitCls: function () { var a = this; a.btnWrap.addCls(a.getSplitCls()) }, getTdCls: function () { return "x-button-" + this.ui + "-" + this.scale + "-cell" }, getValue: function () { return this.value }, removeUIFromElement: function () { Ext.Component.prototype.removeUIFromElement.call(this); this.updateChildElsUICls(false) }, removeOverCls: function () { this.removeCls(this.overCls) }, _removeSplitCls: function () { var a = this; a.btnWrap.removeCls(a.getSplitCls()) }, _syncHasIconCls: function () { var b = this, a = b.btnEl, c = b._hasIconCls; if (a) { a[b._hasIcon() ? "addCls" : "removeCls"]([c, c + "-" + b.iconAlign]) } }, _hasIcon: function () { return !!(this.icon || this.iconCls || this.glyph) }, updateChildElsUICls: function (j) { var c = this, e = c.ui, a = j ? "addCls" : "removeCls", d = c.elClsMap, h, b, g, i; for (h in d) { b = c[h]; g = d[h]; i = c[g]; if (b && i) { b[a](i + "-" + e) } } }, wrapPrimaryEl: function (a) { this.el = new Ext.dom.ButtonElement(a); Ext.Component.prototype.wrapPrimaryEl.call(this, a) } } }, 0, ["button"], ["component", "box", "button"], { component: true, box: true, button: true }, ["widget.button"], [[Ext.mixin.Queryable.prototype.mixinId || Ext.mixin.Queryable.$className, Ext.mixin.Queryable]], [Ext.button, "Button", Ext, "Button"], 0)); (Ext.cmd.derive("Ext.button.Split", Ext.button.Button, { alternateClassName: "Ext.SplitButton", isSplitButton: true, arrowCls: "split", split: true, getTemplateArgs: function () { var b = this, a, c; c = Ext.button.Button.prototype.getTemplateArgs.call(this); if (b.disabled) { c.tabIndex = null } a = b.ariaArrowElAttributes || {}; a["aria-hidden"] = !!b.hidden; a["aria-disabled"] = !!b.disabled; if (b.arrowTooltip) { a["aria-label"] = b.arrowTooltip } else { a["aria-labelledby"] = b.id } c.arrowElAttributes = a; return c }, onRender: function () { var b = this, a; Ext.button.Button.prototype.onRender.call(this); a = b.getFocusEl(); if (a) { a.on({ scope: b, focus: b.onMainElFocus, blur: b.onMainElBlur }) } a = b.arrowEl; if (a) { a.dom.setAttribute("data-componentid", b.id); a.setVisibilityMode(Ext.dom.Element.DISPLAY); a.on({ scope: b, focus: b.onArrowElFocus, blur: b.onArrowElBlur }) } }, setArrowHandler: function (b, a) { this.arrowHandler = b; this.scope = a }, onClick: function (c) { var b = this, a = c.type === "keydown" && c.target === b.arrowEl.dom; b.doPreventDefault(c); if (!b.disabled) { if (a || b.isWithinTrigger(c)) { c.preventDefault(); b.maybeShowMenu(c); b.fireEvent("arrowclick", b, c); if (b.arrowHandler) { b.arrowHandler.call(b.scope || b, b, c) } } else { b.doToggle(); b.fireHandler(c) } } }, enable: function (b) { var c = this, a = c.arrowEl; Ext.button.Button.prototype.enable.call(this, b); if (a) { a.dom.setAttribute("tabIndex", c.tabIndex); a.dom.setAttribute("aria-disabled", "false") } }, disable: function (b) { var c = this, a = c.arrowEl; Ext.button.Button.prototype.disable.call(this, b); if (a) { a.dom.removeAttribute("tabIndex"); a.dom.setAttribute("aria-disabled", "true") } }, afterHide: function (a, b) { Ext.button.Button.prototype.afterHide.call(this, a, b); this.arrowEl.dom.setAttribute("aria-hidden", "true") }, afterShow: function (c, a, b) { Ext.button.Button.prototype.afterShow.call(this, c, a, b); this.arrowEl.dom.setAttribute("aria-hidden", "false") }, privates: { isFocusing: function (d) { var c = this, h = d.fromElement, g = d.toElement, b = c.focusEl && c.focusEl.dom, a = c.arrowEl && c.arrowEl.dom; if (c.focusable) { if (g === b) { return h === a ? false : true } else { if (g === a) { return h === b ? false : true } } return true } return false }, isBlurring: function (d) { var c = this, h = d.fromElement, g = d.toElement, b = c.focusEl && c.focusEl.dom, a = c.arrowEl && c.arrowEl.dom; if (c.focusable) { if (h === b) { return g === a ? false : true } else { if (h === a) { return g === b ? false : true } } return true } return false }, getFocusClsEl: Ext.privateFn, onMainElFocus: function (a) { this.el.addCls(this._focusCls) }, onMainElBlur: function (a) { this.el.removeCls(this._focusCls) }, onArrowElFocus: function (a) { this.el.addCls(this._arrowFocusCls) }, onArrowElBlur: function () { this.el.removeCls(this._arrowFocusCls) }, setTabIndex: function (a) { Ext.button.Button.prototype.setTabIndex.call(this, a); if (this.arrowEl) { this.arrowEl.set({ tabIndex: a }) } }, _addSplitCls: function () { var a = this.arrowEl; Ext.button.Button.prototype._addSplitCls.call(this); a.dom.setAttribute("tabIndex", this.tabIndex); a.setVisible(true) }, _removeSplitCls: function () { var a = this.arrowEl; Ext.button.Button.prototype._removeSplitCls.call(this); a.dom.removeAttribute("tabIndex"); a.setVisible(false) } } }, 0, ["splitbutton"], ["component", "box", "button", "splitbutton"], { component: true, box: true, button: true, splitbutton: true }, ["widget.splitbutton"], 0, [Ext.button, "Split", Ext, "SplitButton"], 0)); (Ext.cmd.derive("Ext.button.Cycle", Ext.button.Split, { alternateClassName: "Ext.CycleButton", getButtonText: function (b) { var a = this, c = ""; if (b && a.showText === true) { if (a.prependText) { c += a.prependText } c += b.text; return c } return a.text }, setActiveItem: function (g, a) { var e = this, b = e.changeHandler, d = e.forceIcon, c = e.forceGlyph; e.settingActive = true; if (!Ext.isObject(g)) { g = e.menu.getComponent(g) } if (g) { e.setText(e.getButtonText(g)); e.setIconCls(d ? d : g.iconCls); e.setGlyph(c ? c : g.glyph); e.activeItem = g; if (!g.checked) { g.setChecked(true, false) } if (!a) { if (b) { Ext.callback(b, e.scope, [e, g], 0, e) } e.fireEvent("change", e, g) } } e.settingActive = false }, getActiveItem: function () { return this.activeItem }, initComponent: function () { var g = this, e = 0, b, c, a, d; b = (g.menu.items || []).concat(g.items || []); g.menu = Ext.applyIf({ cls: "x-cycle-menu", items: [] }, g.menu); a = b.length; for (c = 0; c < a; c++) { d = b[c]; d = Ext.applyIf({ group: g.id, itemIndex: c, checkHandler: g.checkHandler, scope: g, checked: d.checked || false }, d); g.menu.items.push(d); if (d.checked) { e = c } } g.itemCount = g.menu.items.length; Ext.button.Split.prototype.initComponent.apply(this, arguments); g.on("click", g.toggleSelected, g); g.setActiveItem(e, true) }, checkHandler: function (a, b) { if (b && !this.settingActive) { this.setActiveItem(a) } }, toggleSelected: function () { var c = this, a = c.menu, b; b = c.activeItem.next(":not([disabled])") || a.items.getAt(0); b.setChecked(true) } }, 0, ["cycle"], ["component", "box", "button", "splitbutton", "cycle"], { component: true, box: true, button: true, splitbutton: true, cycle: true }, ["widget.cycle"], 0, [Ext.button, "Cycle", Ext, "CycleButton"], 0)); (Ext.cmd.derive("Ext.layout.container.SegmentedButton", Ext.layout.container.Container, { needsItemSize: false, setsItemSize: false, _btnRowCls: "x-segmented-button-row", getRenderTree: function () { var d = this, a = Ext.layout.container.Container.prototype.getRenderTree.call(this), b, c; if (d.owner.getVertical()) { for (b = 0, c = a.length; b < c; b++) { a[b] = { cls: d._btnRowCls, cn: a[b] } } } return a }, getItemLayoutEl: function (a) { var b = a.el.dom; return this.owner.getVertical() ? b.parentNode : b }, onDestroy: function () { if (this.rendered) { var b = this.getRenderTarget(), a; while ((a = b.last())) { a.destroy() } } } }, 0, 0, 0, 0, ["layout.segmentedbutton"], 0, [Ext.layout.container, "SegmentedButton"], 0)); (Ext.cmd.derive("Ext.button.Segmented", Ext.container.Container, { config: { allowDepress: false, allowMultiple: false, forceSelection: false, allowToggle: true, vertical: false, defaultUI: "default" }, beforeRenderConfig: { value: undefined }, defaultBindProperty: "value", publishes: ["value"], twoWayBindable: ["value"], layout: "segmentedbutton", defaultType: "button", maskOnDisable: false, isSegmentedButton: true, baseCls: "x-segmented-button", itemCls: "x-segmented-button-item", _firstCls: "x-segmented-button-first", _lastCls: "x-segmented-button-last", _middleCls: "x-segmented-button-middle", applyValue: function (k, a) { var j = this, n = j.getAllowMultiple(), d, e, l, m, h, c, g, b; l = (k instanceof Array) ? k : (k == null) ? [] : [k]; m = (a instanceof Array) ? a : (a == null) ? [] : [a]; j._isApplyingValue = true; if (!j.rendered) { h = j.items.items; for (c = h.length - 1; c >= 0; c--) { e = h[c]; if (j.forceSelection && !c && !b) { e.pressed = true } if (e.pressed) { b = true; d = e.value; if (d == null) { d = j.items.indexOf(e) } if (!Ext.Array.contains(l, d)) { l.unshift(d) } } } } g = l.length; for (c = 0; c < g; c++) { k = l[c]; e = j._lookupButtonByValue(k); if (e) { d = e.value; if ((d != null) && d !== k) { l[c] = d } if (!e.pressed) { e.setPressed(true) } } } k = n ? l : g ? l[0] : null; for (c = 0, g = m.length; c < g; c++) { a = m[c]; if (!Ext.Array.contains(l, a)) { j._lookupButtonByValue(a).setPressed(false) } } j._isApplyingValue = false; return k }, updateValue: function (c, a) { var b = this, d; if (b.hasListeners.change) { if (c && a && b.getAllowMultiple()) { d = Ext.Array.equals(c, a) } if (!d) { b.fireEvent("change", b, c, a) } } }, beforeRender: function () { var a = this; a.addCls(a.baseCls + a._getClsSuffix()); a._syncItemClasses(true); Ext.container.Container.prototype.beforeRender.call(this) }, onAdd: function (c) { var b = this, a = "_syncItemClasses"; b.mon(c, { hide: a, show: a, beforetoggle: "_onBeforeItemToggle", toggle: "_onItemToggle", scope: b }); if (b.getAllowToggle()) { c.enableToggle = true; if (!b.getAllowMultiple()) { c.toggleGroup = b.getId(); c.allowDepress = b.getAllowDepress() } } c.addCls(b.itemCls + b._getClsSuffix()); b._syncItemClasses(); Ext.container.Container.prototype.onAdd.call(this, c) }, onRemove: function (b) { var a = this; b.removeCls(a.itemCls + a._getClsSuffix()); a._syncItemClasses(); Ext.container.Container.prototype.onRemove.call(this, b) }, beforeLayout: function () { if (Ext.isChrome) { this.el.dom.offsetWidth } Ext.container.Container.prototype.beforeLayout.call(this) }, updateDefaultUI: function (e) { var a = this.items, d, b, c; if (this.rendered) { Ext.raise("Changing the ui config of a segmented button after render is not supported.") } else { if (a) { if (a.items) { a = a.items } for (b = 0, c = a.length; b < c; b++) { d = a[b]; if (d.ui === "default" && e !== "default" && !d.hasOwnProperty("ui")) { a[b].ui = e } } } } }, privates: { _getClsSuffix: function () { return this.getVertical() ? "-vertical" : "-horizontal" }, _getFirstCls: function () { return this._firstCls }, _getLastCls: function () { return this._lastCls }, _lookupButtonByValue: function (h) { var b = this.items.items, g = b.length, e = 0, d = null, a, c; for (; e < g; e++) { c = b[e]; a = c.value; if ((a != null) && a === h) { d = c; break } } if (!d && typeof h === "number") { d = b[h] } return d }, _onBeforeItemToggle: function (a, b) { if (this.allowMultiple && this.forceSelection && !b && this.getValue().length === 1) { return false } }, _onItemToggle: function (c, h) { if (this._isApplyingValue) { return } var e = this, d = Ext.Array, b = e.allowMultiple, a = (c.value != null) ? c.value : e.items.indexOf(c), g = e.getValue(), i; if (b) { i = d.indexOf(g, a) } if (h) { if (b) { if (i === -1) { g = d.slice(g); g.push(a) } } else { g = a } } else { if (b) { if (i > -1) { g = d.slice(g); g.splice(i, 1) } } else { if (g === a) { g = null } } } e.setValue(g); e.fireEvent("toggle", e, c, h) }, _syncItemClasses: function (a) { var h = this, b, d, k, g, e, l, j, c; if (!a && !h.rendered) { return } b = h._getFirstCls(); d = h._middleCls; k = h._getLastCls(); g = h.items.items; e = g.length; l = []; for (c = 0; c < e; c++) { j = g[c]; if (!j.hidden) { l.push(j) } } e = l.length; for (c = 0; c < e; c++) { l[c].removeCls([b, d, k]) } if (e > 1) { l[0].addCls(b); for (c = 1; c < e - 1; c++) { l[c].addCls(d) } l[e - 1].addCls(k) } } } }, 0, ["segmentedbutton"], ["component", "box", "container", "segmentedbutton"], { component: true, box: true, container: true, segmentedbutton: true }, ["widget.segmentedbutton"], 0, [Ext.button, "Segmented"], 0)); (Ext.cmd.derive("Ext.panel.Bar", Ext.container.Container, { vertical: false, _verticalSides: { left: 1, right: 1 }, initComponent: function () { var b = this, a = b.vertical; b.dock = b.dock || (a ? "left" : "top"); b.layout = Ext.apply(a ? { type: "vbox", align: "middle", alignRoundingMethod: "ceil" } : { type: "hbox", align: "middle", alignRoundingMethod: "floor" }, b.layout); Ext.container.Container.prototype.initComponent.call(this) }, onAdded: function (b, c, a) { this.initOrientation(); Ext.container.Container.prototype.onAdded.call(this, b, c, a) }, onRemoved: function (a) { this.removeClsWithUI(this.uiCls); Ext.container.Container.prototype.onRemoved.call(this, a) }, beforeRender: function () { var a = this; if (a.forceOrientation || !a.ownerCt) { a.initOrientation() } Ext.container.Container.prototype.beforeRender.call(this) }, setDock: function (d) { var c = this, b, a; if (d !== c.dock) { Ext.suspendLayouts(); c.clearOrientation(); Ext.container.Container.prototype.setDock.call(this, d); c.initOrientation(); a = c.vertical; b = c.layout; b.setVertical(a); b.setAlignRoundingMethod(a ? "ceil" : "floor"); Ext.resumeLayouts(true) } }, privates: { clearOrientation: function () { this.removeClsWithUI([this.vertical ? "vertical" : "horizontal", this.getDockName()]) }, getDockName: function () { return this.dock }, initOrientation: function () { var c = this, b = c.dock, a = (c.vertical = (b ? b in c._verticalSides : c.vertical)); c.addClsWithUI([a ? "vertical" : "horizontal", c.getDockName()]) } } }, 0, 0, ["component", "box", "container"], { component: true, box: true, container: true }, 0, 0, [Ext.panel, "Bar"], 0)); (Ext.cmd.derive("Ext.panel.Title", Ext.Component, { isTitle: true, noWrap: true, textAlign: "left", iconAlign: "left", rotation: 0, text: "&#160;", beforeRenderConfig: { textAlign: null, text: null, glyph: null, icon: null, iconAlign: null, iconCls: null, rotation: null }, autoEl: { role: "presentation", unselectable: "on" }, textElRole: "presentation", tabIndex: 0, childEls: ["textEl", "iconEl", "iconWrapEl"], renderTpl: '<tpl if="iconMarkup && iconBeforeTitle">{iconMarkup}</tpl><div id="{id}-textEl" data-ref="textEl" class="{textCls} {textCls}-{ui} {itemCls}{childElCls}" unselectable="on"<tpl if="textElRole"> role="{textElRole}"</tpl>>{text}</div><tpl if="iconMarkup && !iconBeforeTitle">{iconMarkup}</tpl>', iconTpl: '<div id="{id}-iconWrapEl" data-ref="iconWrapEl" role="presentation" class="{iconWrapCls} {iconWrapCls}-{ui} {iconAlignCls} {itemCls}{childElCls}"<tpl if="iconWrapStyle"> style="{iconWrapStyle}"</tpl>><div id="{id}-iconEl" data-ref="iconEl" role="presentation" unselectable="on" class="{baseIconCls} {baseIconCls}-{ui} {iconCls} {glyphCls}" style="<tpl if="iconUrl">background-image:url({iconUrl});</tpl><tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>"><tpl if="glyph">{glyph}</tpl></div></div>', _textAlignClasses: { left: "x-title-align-left", center: "x-title-align-center", right: "x-title-align-right" }, _iconAlignClasses: { top: "x-title-icon-top", right: "x-title-icon-right", bottom: "x-title-icon-bottom", left: "x-title-icon-left" }, _rotationClasses: { 0: "x-title-rotate-none", 1: "x-title-rotate-right", 2: "x-title-rotate-left" }, _rotationAngles: { 1: 90, 2: 270 }, baseCls: "x-title", _titleSuffix: "-title", _glyphCls: "x-title-glyph", _iconWrapCls: "x-title-icon-wrap", _baseIconCls: "x-title-icon", _itemCls: "x-title-item", _textCls: "x-title-text", afterComponentLayout: function () { var d = this, b = d.getRotation(), a, e, c; if (b && !Ext.isIE8) { c = d.el; a = d.lastBox; e = a.x; c.setStyle(d._getVerticalAdjustDirection(), (e + ((b === 1) ? a.width : -a.height)) + "px") } Ext.Component.prototype.afterComponentLayout.call(this) }, onRender: function () { var c = this, a = c.getRotation(), b = c.el; Ext.Component.prototype.onRender.call(this); if (a) { b.setVertical(c._rotationAngles[a]) } if (Ext.supports.FixedTableWidthBug) { b._needsTableWidthFix = true } }, applyText: function (a) { if (!a) { a = "&#160;" } return a }, beforeRender: function () { var a = this; Ext.Component.prototype.beforeRender.call(this); a.addCls(a._rotationClasses[a.getRotation()]); a.addCls(a._textAlignClasses[a.getTextAlign()]) }, getIconMarkup: function () { return this.lookupTpl("iconTpl").apply(this.getIconRenderData()) }, getIconRenderData: function () { var e = this, c = e.getIcon(), b = e.getIconCls(), d = e.getGlyph(), g, a = e.getIconAlign(); if (d) { g = d.fontFamily; d = d.character } return { id: e.id, ui: e.ui, itemCls: e._itemCls, iconUrl: c, iconCls: b, iconWrapCls: e._iconWrapCls, baseIconCls: e._baseIconCls, iconAlignCls: e._iconAlignClasses[a], glyph: d, glyphCls: d ? e._glyphCls : "", glyphFontFamily: g } }, initRenderData: function () { var b = this, a, c; c = Ext.apply({ text: b.getText(), textElRole: b.textElRole, id: b.id, ui: b.ui, itemCls: b._itemCls, textCls: b._textCls, iconMarkup: null, iconBeforeTitle: null }, Ext.Component.prototype.initRenderData.call(this)); if (b._hasIcon()) { a = b.getIconAlign(); c.iconMarkup = b.getIconMarkup(); c.iconBeforeTitle = (a === "top" || a === "left") } return c }, onAdded: function (b, g, a) { var d = this, e = d._titleSuffix, c = b.baseCls; d.addCls([c + e, c + e + "-" + b.ui]); Ext.Component.prototype.onAdded.call(this, b, g, a) }, applyGlyph: function (b, a) { if (b) { if (!b.isGlyph) { b = new Ext.Glyph(b) } if (b.isEqual(a)) { b = undefined } } return b }, updateGlyph: function (d, b) { var c = this, e = c._glyphCls, a; if (c.rendered) { c._syncIconVisibility(); a = c.iconEl; if (d) { a.dom.innerHTML = d.character; a.addCls(e); a.setStyle("font-family", d.fontFamily) } else { if (b !== d) { a.dom.innerHTML = ""; a.removeCls(e) } } if (c._didIconStateChange(b, d)) { c.updateLayout() } } }, updateIcon: function (b, d) { b = b || ""; var c = this, a; if (c.rendered && b !== d) { c._syncIconVisibility(); a = c.iconEl; a.setStyle("background-image", b ? "url(" + b + ")" : ""); if (c._didIconStateChange(d, b)) { c.updateLayout() } } }, updateIconAlign: function (g, c) { var b = this, e = b.iconWrapEl, a, d; if (b.iconWrapEl) { a = b.el; d = b._iconAlignClasses; if (c) { e.removeCls(d[c]) } e.addCls(d[g]); if (g === "top" || g === "left") { a.insertFirst(e) } else { a.appendChild(e) } b.updateLayout() } }, updateIconCls: function (b, c) { b = b || ""; var d = this, a; if (d.rendered && c !== b) { d._syncIconVisibility(); a = d.iconEl; if (c) { a.removeCls(c) } a.addCls(b); if (d._didIconStateChange(c, b)) { d.updateLayout() } } }, updateRotation: function (b, a) { var d = this, c, e; if (d.rendered) { c = d.el; e = d._rotationClasses; d.removeCls(e[a]); d.addCls(e[b]); c.setHorizontal(); if (b) { c.setVertical(d._rotationAngles[b]) } c.setStyle({ right: "", left: "", top: "", height: "", width: "" }); d.lastBox = null; d.updateLayout() } }, updateText: function (a) { if (this.rendered) { this.textEl.setHtml(a); this.updateLayout() } }, updateTextAlign: function (d, b) { var a = this, c = a._textAlignClasses; if (a.rendered) { if (b) { a.removeCls(c[b]) } a.addCls(c[d]); a.updateLayout() } }, privates: { _getVerticalAdjustDirection: function () { return "left" }, _didIconStateChange: function (a, c) { var b = Ext.isEmpty(c); return Ext.isEmpty(a) ? !b : b }, _hasIcon: function () { return !!(this.getIcon() || this.getIconCls() || this.getGlyph()) }, _syncIconVisibility: function () { var e = this, d = e.el, a = e._hasIcon(), g = e.iconWrapEl, c, b; if (a && !g) { b = e.iconAlign; c = (b === "left" || b === "top"); d.dom.insertAdjacentHTML(c ? "afterbegin" : "beforeend", e.getIconMarkup()); g = e.iconWrapEl = d[c ? "first" : "last"](); e.iconEl = g.first() } if (g) { g.setDisplayed(a) } } } }, 0, ["title"], ["component", "box", "title"], { component: true, box: true, title: true }, ["widget.title"], 0, [Ext.panel, "Title"], 0)); (Ext.cmd.derive("Ext.panel.Tool", Ext.Component, { config: { glyph: null }, isTool: true, baseCls: "x-tool", disabledCls: "x-tool-disabled", toolPressedCls: "x-tool-pressed", toolOverCls: "x-tool-over", childEls: ["toolEl"], renderTpl: ['<div id="{id}-toolEl" data-ref="toolEl" class="{className} {childElCls}" role="presentation"<tpl if="glyph"><tpl if="glyphFontFamily"> style="font-family:{glyphFontFamily};"></tpl>{glyph}<tpl else>></tpl></div>'], toolOwner: null, tooltipType: "qtip", stopEvent: true, ariaRole: "button", focusable: true, tabIndex: 0, keyMap: { scope: "this", SPACE: "onClick", ENTER: "onClick" }, cacheHeight: true, cacheWidth: true, initComponent: function () { var a = this; a.tooltip = a.tooltip || a.qtip; Ext.Component.prototype.initComponent.call(this) }, initRenderData: function () { var b = this, c = Ext.Component.prototype.initRenderData.call(this), a = b.getGlyph(), d; if (a) { d = a.fontFamily; a = a.character } Ext.applyIf(c, { className: b.calculateClassName(), glyph: a, glyphFontFamily: d }); return c }, calculateClassName: function () { var b = this, a = b.baseCls + "-tool-el "; if (b.type) { a += b.baseCls + "-img " + b.baseCls + "-" + b.type } else { if (b.iconCls) { a += b.iconCls } } return a }, afterRender: function () { var a = this, b; Ext.Component.prototype.afterRender.call(this); if (a.setTypeAfterRender) { a.setTypeAfterRender = false; a.setType(a.type) } a.el.on({ click: a.onClick, mousedown: a.onMouseDown, mouseover: a.onMouseOver, mouseout: a.onMouseOut, scope: a }); b = a.tooltip; if (b) { a.setTooltip(b) } }, tipAttrs: { qtip: "data-qtip" }, setTooltip: function (h, d) { var e = this, b = e.tooltip, g = e.tooltipType, i = e.id, c = e.el, a; if (b && Ext.quickTipsActive && Ext.isObject(b)) { Ext.tip.QuickTipManager.unregister(i) } e.tooltip = h; if (d) { e.tooltipType = d } if (h) { if (Ext.quickTipsActive && Ext.isObject(h)) { Ext.tip.QuickTipManager.register(Ext.apply({ target: i }, h)) } else { if (c) { if (d && g && d !== g) { a = e.tipAttrs[g] || "title"; c.dom.removeAttribute(a) } a = e.tipAttrs[d || g] || "title"; c.dom.setAttribute(a, h) } } if (a !== "title" && e.ariaRole && e.ariaRole !== "presentation") { if (c) { c.dom.setAttribute("aria-label", h) } else { e.ariaRenderAttributes = e.ariaRenderAttributes || {}; e.ariaRenderAttributes["aria-label"] = h } } } }, setType: function (g) { var h = this, d = h.toolEl, e = h.updating, b = h.rendering, c, a; if (!e) { c = h.calculateClassName(); if (!b) { h.updating = a = true } h.setIconCls(null); h.setGlyph(null) } h.type = g; if (a) { h.updateToolCls(c); h.updating = false } else { if (b) { h.setTypeAfterRender = true } } return h }, setIconCls: function (d) { var g = this, c = g.toolEl, e = g.updating, b, a; if (!e) { b = g.calculateClassName(); g.updating = a = true; g.setType(null); g.setGlyph(null) } g.iconCls = d; if (a) { g.updateToolCls(b); g.updating = false } return g }, doDestroy: function () { var a = this; a.setTooltip(null); delete a.toolOwner; Ext.Component.prototype.doDestroy.call(this) }, applyGlyph: function (b, a) { if (b) { if (!b.isGlyph) { b = new Ext.Glyph(b) } if (b.isEqual(a)) { b = undefined } } return b }, updateGlyph: function (h, b) { var g = this, d = g.toolEl, e = g.updating, c, a; if (!e) { c = g.calculateClassName(); g.updating = a = true; g.setType(null); g.setIconCls(null) } if (d) { if (h) { d.dom.innerHTML = h.character; d.setStyle(h.getStyle()) } else { d.dom.innerHTML = "" } } if (a) { g.updateToolCls(c); g.updating = false } }, privates: { onClick: function (c, b) { var a = this; if (a.disabled) { return false } if (c.type !== "keydown") { a.el.removeCls(a.toolPressedCls + " " + a.toolOverCls) } if (a.stopEvent !== false) { c.stopEvent() } if (a.handler) { Ext.callback(a.handler, a.scope, [c, b, a.ownerCt, a], 0, a) } else { if (a.callback) { Ext.callback(a.callback, a.scope, [a.toolOwner || a.ownerCt, a, c], 0, a) } } if (a.destroyed) { return } a.fireEvent("click", a, c, a.toolOwner || a.ownerCt); return true }, onMouseDown: function (a) { a.preventDefault(); if (this.disabled) { return false } this.el.addCls(this.toolPressedCls) }, onMouseOver: function () { if (this.disabled) { return false } this.el.addCls(this.toolOverCls) }, onMouseOut: function () { this.el.removeCls(this.toolOverCls) }, updateToolCls: function (b) { var c = this, a = this.toolEl; if (a) { a.removeCls(b); a.addCls(this.calculateClassName()) } } } }, 0, ["tool"], ["component", "box", "tool"], { component: true, box: true, tool: true }, ["widget.tool"], 0, [Ext.panel, "Tool"], 0)); (Ext.cmd.derive("Ext.util.KeyMap", Ext.Base, { alternateClassName: "Ext.KeyMap", eventName: "keydown", constructor: function (a) { var b = this; if ((arguments.length !== 1) || (typeof a === "string") || a.dom || a.tagName || a === document || a.isComponent) { b.legacyConstructor.apply(b, arguments); return } Ext.apply(b, a); b.bindings = []; if (!b.target.isComponent) { b.target = Ext.get(b.target) } if (b.binding) { b.addBinding(b.binding) } else { if (a.key) { b.addBinding(a) } } b.enable() }, legacyConstructor: function (b, d, a) { var c = this; Ext.apply(c, { target: Ext.get(b), eventName: a || c.eventName, bindings: [] }); if (d) { c.addBinding(d) } c.enable() }, addBinding: function (e) { var c = this, d = e.key, b, a; if (c.processing) { c.bindings = c.bindings.slice(0) } if (Ext.isArray(e)) { for (b = 0, a = e.length; b < a; b++) { c.addBinding(e[b]) } return } c.bindings.push(Ext.apply({ keyCode: c.processKeys(d) }, e)) }, removeBinding: function (g) { var e = this, h = e.bindings, a = h.length, b, d, c; if (e.processing) { e.bindings = h.slice(0) } c = e.processKeys(g.key); for (b = 0; b < a; ++b) { d = h[b]; if ((d.fn || d.handler) === (g.fn || g.handler) && d.scope === g.scope) { if (g.alt === d.alt && g.ctrl === d.ctrl && g.shift === d.shift) { if (Ext.Array.equals(d.keyCode, c)) { Ext.Array.erase(e.bindings, b, 1); return } } } } }, processKeys: function (g) { var h = false, d, e, b, a, c; if (g.test) { return g } if (Ext.isString(g)) { e = []; b = g.toUpperCase(); for (c = 0, a = b.length; c < a; ++c) { e.push(b.charCodeAt(c)) } g = e; h = true } if (!Ext.isArray(g)) { g = [g] } if (!h) { for (c = 0, a = g.length; c < a; ++c) { d = g[c]; if (Ext.isString(d)) { g[c] = d.toUpperCase().charCodeAt(0) } } } return g }, handleTargetEvent: function (e) { var d = this, g, c, b, a; if (d.enabled) { g = d.bindings; c = 0; b = g.length; e = d.processEvent.apply(d.processEventScope || d, arguments); if (e) { d.lastKeyEvent = e; if (d.ignoreInputFields && Ext.fly(e.target).isInputField()) { return } if (!e.getKey) { return e } d.processing = true; for (; c < b; ++c) { a = d.processBinding(g[c], e); if (a === false) { d.processing = false; return a } } d.processing = false } } }, processEvent: Ext.identityFn, processBinding: function (e, a) { if (this.checkModifiers(e, a)) { var g = a.getKey(), j = e.fn || e.handler, k = e.scope || this, h = e.keyCode, b = e.defaultEventAction, c, d, l; if (h.test) { if (h.test(String.fromCharCode(a.getCharCode()))) { l = j.call(k, g, a); if (l !== true && b) { a[b]() } if (l === false) { return l } } } else { if (h.length) { for (c = 0, d = h.length; c < d; ++c) { if (g === h[c]) { l = j.call(k, g, a); if (l !== true && b) { a[b]() } if (l === false) { return l } break } } } } } }, checkModifiers: function (h, e) { var d = ["shift", "ctrl", "alt"], c = 0, a = d.length, g, b; for (; c < a; ++c) { b = d[c]; g = h[b]; if (!(g === undefined || (g === e[b + "Key"]))) { return false } } return true }, on: function (b, d, c) { var h, a, e, g; if (Ext.isObject(b) && !Ext.isArray(b)) { h = b.key; a = b.shift; e = b.ctrl; g = b.alt } else { h = b } this.addBinding({ key: h, shift: a, ctrl: e, alt: g, fn: d, scope: c }) }, un: function (b, d, c) { var h, a, e, g; if (Ext.isObject(b) && !Ext.isArray(b)) { h = b.key; a = b.shift; e = b.ctrl; g = b.alt } else { h = b } this.removeBinding({ key: h, shift: a, ctrl: e, alt: g, fn: d, scope: c }) }, isEnabled: function () { return this.enabled }, enable: function () { var a = this; if (!a.enabled) { a.target.on(a.eventName, a.handleTargetEvent, a, { capture: a.capture, priority: a.priority }); a.enabled = true } }, disable: function () { var a = this; if (a.enabled) { a.target.removeListener(a.eventName, a.handleTargetEvent, a); a.enabled = false } }, setDisabled: function (a) { if (a) { this.disable() } else { this.enable() } }, destroy: function (c) { var a = this, b = a.target; a.bindings = []; a.disable(); if (c) { b.destroy() } delete a.target; a.callParent() } }, 1, 0, 0, 0, 0, 0, [Ext.util, "KeyMap", Ext, "KeyMap"], 0)); (Ext.cmd.derive("Ext.util.KeyNav", Ext.Base, { alternateClassName: "Ext.KeyNav", disabled: false, defaultEventAction: false, forceKeyDown: false, eventName: "keypress", statics: { keyOptions: { left: 37, right: 39, up: 38, down: 40, space: 32, pageUp: 33, pageDown: 34, del: 46, backspace: 8, home: 36, end: 35, enter: 13, esc: 27, tab: 9 } }, constructor: function (a) { var b = this; if (arguments.length === 2) { b.legacyConstructor.apply(b, arguments); return } b.doConstruction(a) }, legacyConstructor: function (b, a) { this.doConstruction(Ext.apply({ target: b }, a)) }, doConstruction: function (a) { var c = this, b = { target: a.target, ignoreInputFields: a.ignoreInputFields, eventName: c.getKeyEvent("forceKeyDown" in a ? a.forceKeyDown : c.forceKeyDown, a.eventName), capture: a.capture }, d; if (c.map) { c.map.destroy() } c.initConfig(a); if (a.processEvent) { b.processEvent = a.processEvent; b.processEventScope = a.processEventScope || c } if (a.priority) { b.priority = a.priority } if (a.keyMap) { d = c.map = a.keyMap } else { d = c.map = new Ext.util.KeyMap(b); c.destroyKeyMap = true } this.addBindings(a); d.disable(); if (!a.disabled) { d.enable() } }, addBindings: function (i) { var c = this, b, g, e = c.map, a = Ext.util.KeyNav.keyOptions, d, h = i.scope || c; for (b in i) { g = i[b]; d = a[b]; if (d != null) { b = d } if (g && (b.length === 1 || !isNaN(b = parseInt(b, 10)))) { if (typeof g === "function") { g = { handler: g, defaultEventAction: (i.defaultEventAction !== undefined) ? i.defaultEventAction : c.defaultEventAction } } e.addBinding({ key: b, ctrl: g.ctrl, shift: g.shift, alt: g.alt, handler: Ext.Function.bind(c.handleEvent, g.scope || h, [g.handler || g.fn, c], true), defaultEventAction: (g.defaultEventAction !== undefined) ? g.defaultEventAction : c.defaultEventAction }) } } }, handleEvent: function (d, c, b, a) { a.lastKeyEvent = c; return b.call(this, c) }, destroy: function (b) { var a = this; if (a.destroyKeyMap) { a.map.destroy(b) } delete a.map; a.callParent() }, enable: function () { if (this.map) { this.map.enable(); this.disabled = false } }, disable: function () { if (this.map) { this.map.disable() } this.disabled = true }, setDisabled: function (a) { this.map.setDisabled(a); this.disabled = a }, getKeyEvent: function (b, a) { if (b || (Ext.supports.SpecialKeyDownRepeat && !a)) { return "keydown" } else { return a || this.eventName } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "KeyNav", Ext, "KeyNav"], 0)); (Ext.cmd.derive("Ext.util.FocusableContainer", Ext.Mixin, { mixinConfig: { id: "focusablecontainer", before: { onAdd: "onFocusableChildAdd", onRemove: "onFocusableChildRemove", doDestroy: "destroyFocusableContainer", onFocusEnter: "onFocusEnter" }, after: { afterRender: "initFocusableContainer", onFocusLeave: "onFocusLeave", afterShow: "activateFocusableContainer" } }, isFocusableContainer: true, enableFocusableContainer: true, activeChildTabIndex: 0, inactiveChildTabIndex: -1, focusableContainerEl: "el", tabGuard: true, privates: { initFocusableContainer: function (c) { var b, d, a; if (this.enableFocusableContainer) { c = c != null ? c : true; this.doInitFocusableContainer(c) } else { b = this.getFocusables(); for (d = 0, a = b.length; d < a; d++) { b[d].focusableContainer = null } } }, doInitFocusableContainer: function (a) { var c = this, b = c.focusableContainerEl, d; if (a) { c.clearFocusables() } d = c.findNextFocusableChild({ step: 1, beforeRender: true }); if (d) { c.activateFocusableContainer(true) } else { if (c.isFocusableContainerActive()) { c.activateFocusableContainer(false) } } if (!b.isElement) { b = c.focusableContainerEl = c[b] } c.focusableKeyNav = c.createFocusableContainerKeyNav(b) }, createFocusableContainerKeyNav: function (a) { var b = this; return new Ext.util.KeyNav(a, { eventName: "keydown", ignoreInputFields: true, scope: b, tab: b.onFocusableContainerTabKey, enter: b.onFocusableContainerEnterKey, space: b.onFocusableContainerSpaceKey, up: b.onFocusableContainerUpKey, down: b.onFocusableContainerDownKey, left: b.onFocusableContainerLeftKey, right: b.onFocusableContainerRightKey }) }, destroyFocusableContainer: function () { if (this.enableFocusableContainer) { this.doDestroyFocusableContainer() } }, doDestroyFocusableContainer: function () { this.focusableKeyNav = Ext.destroy(this.focusableKeyNav) }, getFocusables: function () { return this.items.items }, initDefaultFocusable: function () { var j = this, c = j.activeChildTabIndex, b = false, d, h, e, a, g; d = j.getFocusables(); a = d.length; if (!a) { return } for (e = 0; e < a; e++) { h = d[e]; if (!h.disabled && h.isFocusable && h.isFocusable()) { b = true; break } } if (!b) { return } h = j.findNextFocusableChild({ items: d, step: true }); if (h) { j.activateFocusable(h) } return h }, clearFocusables: function () { var e = this, b = e.getFocusables(), a = b.length, d, c; for (c = 0; c < a; c++) { d = b[c]; if (d.focusable && !d.disabled) { e.deactivateFocusable(d) } } }, activateFocusable: function (c, b) { var a = b != null ? b : this.activeChildTabIndex; c.setTabIndex(a) }, deactivateFocusable: function (c, b) { var a = b != null ? b : this.inactiveChildTabIndex; c.setTabIndex(a) }, activateFocusableContainer: function (b) { var c = this, a = c.tabGuardBeforeEl, d = c.tabGuardAfterEl; if (!c.rendered || c.destroying || c.destroyed || !a || !d) { return } b = b != null ? b : true; if (b) { a.dom.setAttribute("tabIndex", c.activeChildTabIndex); d.dom.setAttribute("tabIndex", c.activeChildTabIndex) } else { a.dom.removeAttribute("tabIndex"); d.dom.removeAttribute("tabIndex") } }, onFocusableContainerTabKey: function () { return true }, onFocusableContainerEnterKey: function () { return true }, onFocusableContainerSpaceKey: function () { return true }, onFocusableContainerUpKey: function (a) { a.preventDefault(); return this.moveChildFocus(a, false) }, onFocusableContainerDownKey: function (a) { a.preventDefault(); return this.moveChildFocus(a, true) }, onFocusableContainerLeftKey: function (a) { a.preventDefault(); return this.moveChildFocus(a, false) }, onFocusableContainerRightKey: function (a) { a.preventDefault(); return this.moveChildFocus(a, true) }, getFocusableFromEvent: function (a) { var b = Ext.Component.fromElement(a.getTarget()); return b }, moveChildFocus: function (b, a) { var c = this.getFocusableFromEvent(b); return this.focusChild(c, a, b) }, focusChild: function (c, a) { var b = this.findNextFocusableChild({ child: c, step: a }); if (b) { b.focus() } return b }, findNextFocusableChild: function (l) { var k = l.beforeRender, g, j, a, b, h, d, e, c; g = l.items || this.getFocusables(); b = l.step != null ? l.step : 1; a = l.child; c = !!this.allowFocusingDisabledChildren; h = Ext.Array.indexOf(g, a); b = b === true ? 1 : b === false ? -1 : b; e = g.length; d = b > 0 ? (h < e ? h + b : 0) : (h > 0 ? h + b : e - 1); for (; ; d += b) { if (h < 0 && (d >= e || d < 0)) { return null } else { if (d >= e) { d = -1; continue } else { if (d < 0) { d = e; continue } else { if (d === h) { return null } } } } j = g[d]; if (!j || !j.focusable || (j.disabled && !c)) { continue } if (k || (j.isFocusable && j.isFocusable())) { return j } } return null }, isFocusableContainerActive: function () { var e = this, d = false, b = e.tabGuardBeforeEl, c = e.focusableContainerEl, g, a; if (b && b.isTabbable && b.isTabbable()) { d = true } else { if (c.isTabbable && c.isTabbable()) { d = true } else { g = e.lastFocusedChild; a = g && g.getFocusEl && g.getFocusEl(); if (a && a.isTabbable && a.isTabbable()) { d = true } } } return d }, onFocusEnter: function (c) { var a = this, b = c.toComponent, d; if (!a.enableFocusableContainer || a.destroying || a.destroyed) { return null } if (b === a) { d = a.initDefaultFocusable(); if (d) { d.focus(); a.activateFocusableContainer(false) } } else { a.activateFocusableContainer(false) } return b }, onFocusLeave: function (c) { var b = this, a = b.lastFocusedChild; if (!b.enableFocusableContainer || b.destroying || b.destroyed) { return } b.clearFocusables(); if (a && !a.disabled) { b.activateFocusable(a) } else { b.activateFocusableContainer(true) } }, beforeFocusableChildBlur: Ext.privateFn, afterFocusableChildBlur: Ext.privateFn, beforeFocusableChildFocus: function (b) { var a = this; if (!a.enableFocusableContainer || a.destroying || a.destroyed) { return } a.clearFocusables(); a.activateFocusable(b); if (b.needArrowKeys) { a.guardFocusableChild(b) } }, guardFocusableChild: function (d) { var c = this, a = c.activeChildTabIndex, b; b = c.findNextFocusableChild({ child: d, step: -1 }); if (b) { b.setTabIndex(a) } b = c.findNextFocusableChild({ child: d, step: 1 }); if (b) { b.setTabIndex(a) } }, afterFocusableChildFocus: function (b) { var a = this; if (!a.enableFocusableContainer || a.destroying || a.destroyed) { return } a.lastFocusedChild = b }, onFocusableChildAdd: function (a) { if (this.enableFocusableContainer) { return this.doFocusableChildAdd(a) } }, doFocusableChildAdd: function (b) { var a = this; if (b.focusable) { b.focusableContainer = a; if (!a.$initingItems && !a.isFocusableContainerActive()) { a.activateFocusableContainer(true) } } }, onFocusableChildRemove: function (a) { if (this.enableFocusableContainer) { return this.doFocusableChildRemove(a) } a.focusableContainer = null }, doFocusableChildRemove: function (b) { var a = this; if (b === a.lastFocusedChild) { a.lastFocusedChild = null; a.activateFocusableContainer(true) } b = a.findNextFocusableChild({ step: 1, beforeRender: true }); if (!b) { a.activateFocusableContainer(false) } }, beforeFocusableChildEnable: Ext.privateFn, onFocusableChildEnable: function (b) { var a = this; if (!a.enableFocusableContainer || a.destroying || a.destroyed) { return } if (b !== a.lastFocusedChild) { a.deactivateFocusable(b); if (!a.isFocusableContainerActive()) { a.activateFocusableContainer(true) } } }, beforeFocusableChildDisable: function (c) { var b = this, a; if (!b.enableFocusableContainer || b.destroying || b.destroyed) { return } if (c.hasFocus) { a = b.findNextFocusableChild({ child: c }) || c.findFocusTarget(); if (a) { a.focus() } } }, onFocusableChildDisable: function (d) { var c = this, a = c.lastFocusedChild, b; if (!c.enableFocusableContainer || c.destroying || c.destroyed) { return } if (d === a) { c.activateFocusableContainer(true) } b = c.findNextFocusableChild({ step: 1 }); if (!b) { c.activateFocusableContainer(false) } }, beforeFocusableChildHide: function (a) { return this.beforeFocusableChildDisable(a) }, onFocusableChildHide: function (a) { return this.onFocusableChildDisable(a) }, beforeFocusableChildShow: function (a) { return this.beforeFocusableChildEnable(a) }, onFocusableChildShow: function (a) { return this.onFocusableChildEnable(a) }, onFocusableChildMasked: Ext.privateFn, onFocusableChildDestroy: Ext.privateFn, onFocusableChildUpdate: Ext.privateFn } }, 0, 0, 0, 0, 0, 0, [Ext.util, "FocusableContainer"], 0)); (Ext.cmd.derive("Ext.panel.Header", Ext.panel.Bar, { isHeader: true, defaultType: "tool", indicateDrag: false, weight: -1, shrinkWrap: 3, iconAlign: "left", titleAlign: "left", titlePosition: 0, titleRotation: "default", autoEl: { role: "presentation" }, beforeRenderConfig: { glyph: null, icon: null, iconCls: null, iconAlign: null, title: { $value: { xtype: "title", flex: 1 }, merge: function (b, a) { if (typeof b !== "object") { b = { text: b } } return Ext.merge(a ? Ext.Object.chain(a) : {}, b) } }, titleAlign: null, titlePosition: null, titleRotation: null }, headerCls: "x-header", initComponent: function () { var d = this, c = d.items, b = d.itemPosition, a = [d.headerCls]; d.tools = d.tools || []; d.items = c = (c ? c.slice() : []); if (b !== undefined) { d._userItems = c.slice(); d.items = c = [] } d.indicateDragCls = d.headerCls + "-draggable"; if (d.indicateDrag) { a.push(d.indicateDragCls) } d.addCls(a); d.syncNoBorderCls(); Ext.Array.push(c, d.tools); d.tools.length = 0; Ext.panel.Bar.prototype.initComponent.call(this); d.on({ dblclick: d.onDblClick, click: d.onClick, element: "el", scope: d }) }, addTool: function (a) { var b = this; b.add(Ext.ComponentManager.create(a, "tool")); b.checkFocusableTools() }, afterLayout: function () { var b = this, e, a, c, d; if (b.vertical) { a = b.frameTR; if (a) { e = b.frameBR; c = b.frameTL; d = (b.getWidth() - a.getPadding("r") - ((c) ? c.getPadding("l") : b.el.getBorderWidth("l"))) + "px"; e.setStyle("background-position-x", d); a.setStyle("background-position-x", d) } } Ext.panel.Bar.prototype.afterLayout.call(this) }, applyTitle: function (e, c) { var d = this, a, b; e = e || ""; a = Ext.isString(e); if (!Ext.isObject(e)) { e = { text: e.toString() } } if (c) { Ext.suspendLayouts(); c.setConfig(e); Ext.resumeLayouts(true); e = c } else { if (a) { e.xtype = "title" } e.ui = d.ui; b = ("rotation" in e); e.id = d.id + "-title"; if (d.isAccordionHeader) { e.ariaRole = "tab"; e.textElRole = null; e.focusable = true } e = Ext.create(e); if (!b && d.vertical && d.titleRotation === "default") { e.rotation = 1 } } return e }, applyTitlePosition: function (b) { var a = this.items.getCount(); if (this._titleInItems) { --a } return Math.max(Math.min(b, a), 0) }, beforeLayout: function () { Ext.panel.Bar.prototype.beforeLayout.call(this); this.syncBeforeAfterTitleClasses() }, beforeRender: function () { var b = this, a = b.itemPosition; b.protoEl.unselectable(); Ext.panel.Bar.prototype.beforeRender.call(this); if (a !== undefined) { b.insert(a, b._userItems) } b.checkFocusableTools() }, checkFocusableTools: function () { var c = this, d = c.tools, e, b, a; if (c.isAccordionHeader) { c.enableFocusableContainer = false; return } for (b = 0, a = d.length; b < a; b++) { if (d[b].focusable) { e = true; break } } if (e) { if (!c.initialConfig.hasOwnProperty("enableFocusableContainer") || c.enableFocusableContainer) { c.ariaRole = "toolbar"; c.enableFocusableContainer = true; if (c.rendered) { c.ariaEl.dom.setAttribute("role", "toolbar"); c.initFocusableContainer(true) } } } else { c.ariaRole = "presentation"; c.enableFocusableContainer = false; if (c.rendered) { c.ariaEl.dom.setAttribute("role", "presentation"); c.initFocusableContainer(true) } } }, getTools: function () { return this.tools.slice() }, onAdd: function (b, a) { var c = this.tools; Ext.panel.Bar.prototype.onAdd.call(this, b, a); if (b.isTool) { c.push(b); c[b.type] = b } }, onAdded: function (b, c, a) { this.syncNoBorderCls(); Ext.panel.Bar.prototype.onAdded.call(this, b, c, a) }, onRemoved: function (b, c, a) { this.syncNoBorderCls(); Ext.panel.Bar.prototype.onRemoved.call(this, b, c, a) }, setDock: function (c) { var b = this, e = b.getTitle(), a = b.getTitleRotation(), d = e.getRotation(); Ext.suspendLayouts(); Ext.panel.Bar.prototype.setDock.call(this, c); if (a === "default") { a = (b.vertical ? 1 : 0); if (a !== d) { e.setRotation(a) } if (b.rendered) { b.resetItemMargins() } } Ext.resumeLayouts(true) }, updateGlyph: function (a) { this.getTitle().setGlyph(a) }, updateIcon: function (a) { this.getTitle().setIcon(a) }, updateIconAlign: function (b, a) { this.getTitle().setIconAlign(b) }, updateIconCls: function (a) { this.getTitle().setIconCls(a) }, updateTitle: function (b, a) { if (!a) { this.insert(this.getTitlePosition(), b); this._titleInItems = true } this.titleCmp = b }, updateTitleAlign: function (b, a) { this.getTitle().setTextAlign(b) }, updateTitlePosition: function (a) { this.insert(a, this.getTitle()) }, updateTitleRotation: function (a) { if (a === "default") { a = (this.vertical ? 1 : 0) } this.getTitle().setRotation(a) }, privates: { fireClickEvent: function (a, c) { var b = "." + Ext.panel.Tool.prototype.baseCls; if (!c.getTarget(b)) { this.fireEvent(a, this, c) } }, getFramingInfoCls: function () { var c = this, b = Ext.panel.Bar.prototype.getFramingInfoCls.call(this), a = c.ownerCt; if (!c.expanding && a && (a.collapsed || c.isCollapsedExpander)) { b += "-" + a.collapsedCls } return b + "-" + c.dock }, onClick: function (a) { this.fireClickEvent("click", a) }, onDblClick: function (a) { this.fireClickEvent("dblclick", a) }, syncBeforeAfterTitleClasses: function (c) { var k = this, j = k.items, g = j.items, b = k.getTitlePosition(), a = g.length, h = j.generation, l = k.syncBeforeAfterGen, n, e, d, m; if (!c && (l === h)) { return } k.syncBeforeAfterGen = h; for (d = 0; d < a; ++d) { m = g[d]; n = m.afterTitleCls || (m.afterTitleCls = m.baseCls + "-after-title"); e = m.beforeTitleCls || (m.beforeTitleCls = m.baseCls + "-before-title"); if (!k.title || d < b) { if (l) { m.removeCls(n) } m.addCls(e) } else { if (d > b) { if (l) { m.removeCls(e) } m.addCls(n) } } } }, syncNoBorderCls: function () { var b = this, a = this.ownerCt, c = b.headerCls + "-noborder"; if (a ? (a.border === false && !a.frame) : b.border === false) { b.addCls(c) } else { b.removeCls(c) } } } }, 0, ["header"], ["component", "box", "container", "header"], { component: true, box: true, container: true, header: true }, ["widget.header"], [[Ext.util.FocusableContainer.prototype.mixinId || Ext.util.FocusableContainer.$className, Ext.util.FocusableContainer]], [Ext.panel, "Header"], 0)); (Ext.cmd.derive("Ext.layout.container.boxOverflow.None", Ext.Base, { alternateClassName: "Ext.layout.boxOverflow.None", factoryConfig: { defaultType: "none" }, isBoxOverflowHandler: true, $configPrefixed: false, $configStrict: false, constructor: function (a) { this.initConfig(a) }, handleOverflow: Ext.emptyFn, clearOverflow: Ext.emptyFn, beginLayout: Ext.emptyFn, beginLayoutCycle: Ext.emptyFn, calculate: function (b) { var a = this, c = b.state.boxPlan, d; if (c && c.tooNarrow) { d = a.handleOverflow(b); if (d) { if (d.reservedSpace) { a.layout.publishInnerCtSize(b, d.reservedSpace) } } } else { a.clearOverflow() } }, completeLayout: Ext.emptyFn, finishedLayout: function (d) { var c = this, a = c.layout.owner, b, e; if (a.hasListeners.overflowchange) { b = a.query(">[hidden]"); e = b.length; if (e !== c.lastHiddenCount) { a.fireEvent("overflowchange", c.lastHiddenCount, e, b); c.lastHiddenCount = e } } }, onRemove: Ext.emptyFn, getItem: function (a) { return this.layout.owner.getComponent(a) }, getOwnerType: function (a) { var b; if (a.isToolbar) { b = "toolbar" } else { if (a.isTabBar) { b = "tab-bar" } else { if (a.isMenu) { b = "menu" } else { if (a.isBreadcrumb) { b = "breadcrumb" } else { b = a.getXType() } } } } return b }, getPrefixConfig: Ext.emptyFn, getSuffixConfig: Ext.emptyFn, getOverflowCls: function () { return "" }, setVertical: function () { var b = this, a = b.layout, c = a.innerCt; c.removeCls(b.getOverflowCls(a.oppositeDirection)); c.addCls(b.getOverflowCls(a.direction)) } }, 1, 0, 0, 0, ["box.overflow.None", "box.overflow.none"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.layout.container.boxOverflow, "None", Ext.layout.boxOverflow, "None"], 0)); (Ext.cmd.derive("Ext.layout.container.boxOverflow.Scroller", Ext.layout.container.boxOverflow.None, { alternateClassName: "Ext.layout.boxOverflow.Scroller", animateScroll: false, scrollIncrement: 20, wheelIncrement: 10, scrollRepeatInterval: 60, scrollDuration: 400, scrollerCls: "x-box-scroller", beforeSuffix: "-before-scroller", afterSuffix: "-after-scroller", constructor: function (a) { var b = this; b.mixins.observable.constructor.call(b, a); b.scrollPosition = 0; b.scrollSize = 0 }, getPrefixConfig: function () { return { role: "presentation", id: this.layout.owner.id + this.beforeSuffix, cls: this.createScrollerCls("beforeX"), style: "display:none" } }, getSuffixConfig: function () { return { role: "presentation", id: this.layout.owner.id + this.afterSuffix, cls: this.createScrollerCls("afterX"), style: "display:none" } }, createScrollerCls: function (e) { var h = this, g = h.layout, b = g.owner, d = h.getOwnerType(b), a = h.scrollerCls, c = a + " " + a + "-" + g.names[e] + " " + a + "-" + d + " " + a + "-" + d + "-" + b.ui; if (b.plain) { c += " " + a + "-plain" } return c }, getOverflowCls: function (a) { return this.scrollerCls + "-body-" + a }, beginLayout: function (a) { a.innerCtScrollPos = this.getScrollPosition(); Ext.layout.container.boxOverflow.None.prototype.beginLayout.apply(this, arguments) }, finishedLayout: function (d) { var c = this, g = d.state.boxPlan, b = c.layout, e = b.names, h = Math.min(c.getMaxScrollPosition(), d.innerCtScrollPos), a; if (g && g.tooNarrow) { a = d.childItems[d.childItems.length - 1].props; c.scrollSize = a[e.x] + a[e.width]; c.updateScrollButtons(); b.innerCt[e.setScrollLeft](h) } Ext.layout.container.boxOverflow.None.prototype.finishedLayout.call(this, d) }, handleOverflow: function (b) { var h = this, g = h.layout.names, i = g.getWidth, j = g.parallelMargins, c, e, d, a; h.showScrollers(); d = h.getBeforeScroller(); a = h.getAfterScroller(); c = d[i]() + a[i]() + d.getMargin(j) + a.getMargin(j); e = b.targetContext.getPaddingInfo()[g.width]; return { reservedSpace: Math.max(c - e, 0) } }, getBeforeScroller: function () { var a = this; return a._beforeScroller || (a._beforeScroller = a.createScroller(a.beforeSuffix, "beforeRepeater", "scrollLeft")) }, getAfterScroller: function () { var a = this; return a._afterScroller || (a._afterScroller = a.createScroller(a.afterSuffix, "afterRepeater", "scrollRight")) }, createScroller: function (g, d, h) { var e = this, c = e.layout.owner, b = e.scrollerCls, a; a = c.el.getById(c.id + g); a.addClsOnOver(b + "-hover"); a.addClsOnClick(b + "-pressed"); a.setVisibilityMode(Ext.Element.DISPLAY); e[d] = new Ext.util.ClickRepeater(a, { interval: e.scrollRepeatInterval, handler: h, scope: e }); return a }, createWheelListener: function () { var a = this; a.wheelListener = a.layout.innerCt.on("mousewheel", a.onMouseWheel, a, { destroyable: true }) }, onMouseWheel: function (a) { a.stopEvent(); this.scrollBy(this.getWheelDelta(a) * this.wheelIncrement * -1, false) }, getWheelDelta: function (a) { return a.getWheelDelta() }, clearOverflow: function () { this.hideScrollers() }, showScrollers: function () { var a = this; if (!a.wheelListener) { a.createWheelListener() } a.getBeforeScroller().show(); a.getAfterScroller().show(); a.layout.owner.addClsWithUI(a.layout.direction === "vertical" ? "vertical-scroller" : "scroller") }, hideScrollers: function () { var b = this, c = b.getBeforeScroller(), a = b.getAfterScroller(); if (c) { c.hide(); a.hide(); b.layout.owner.removeClsWithUI(b.layout.direction === "vertical" ? "vertical-scroller" : "scroller") } }, destroy: function () { Ext.destroyMembers(this, "beforeRepeater", "afterRepeater", "_beforeScroller", "_afterScroller", "wheelListener"); this.callParent() }, scrollBy: function (b, a) { this.scrollTo(this.getScrollPosition() + b, a) }, getScrollAnim: function () { return { duration: this.scrollDuration, callback: this.updateScrollButtons, scope: this } }, updateScrollButtons: function () { var b = this, d = b.getBeforeScroller(), a = b.getAfterScroller(), c; if (!d || !a) { return } c = b.scrollerCls + "-disabled"; d[b.atExtremeBefore() ? "addCls" : "removeCls"](c); a[b.atExtremeAfter() ? "addCls" : "removeCls"](c); b.scrolling = false }, scrollLeft: function () { this.scrollBy(-this.scrollIncrement, false) }, scrollRight: function () { this.scrollBy(this.scrollIncrement, false) }, getScrollPosition: function () { var c = this, b = c.layout, a; if (isNaN(c.scrollPosition)) { a = b.innerCt[b.names.getScrollLeft]() } else { a = c.scrollPosition } return a }, getMaxScrollPosition: function () { var b = this, a = b.layout, c = b.scrollSize - a.innerCt.lastBox[a.names.width]; return (c < 0) ? 0 : c }, atExtremeBefore: function () { return !this.getScrollPosition() }, atExtremeAfter: function () { return this.getScrollPosition() >= this.getMaxScrollPosition() }, setVertical: function () { var c = this, d = c.getBeforeScroller(), b = c.getAfterScroller(), e = c.layout.names, a = c.scrollerCls; d.removeCls(a + "-" + e.beforeY); b.removeCls(a + "-" + e.afterY); d.addCls(a + "-" + e.beforeX); b.addCls(a + "-" + e.afterX); Ext.layout.container.boxOverflow.None.prototype.setVertical.call(this) }, scrollTo: function (a, b) { var g = this, e = g.layout, h = e.names, d = g.getScrollPosition(), c = Ext.Number.constrain(a, 0, g.getMaxScrollPosition()); if (c !== d && !g.scrolling) { g.scrollPosition = NaN; if (b === undefined) { b = g.animateScroll } e.innerCt[h.scrollTo](h.beforeScrollX, c, b ? g.getScrollAnim() : false); if (b) { g.scrolling = true } else { g.updateScrollButtons() } g.fireEvent("scroll", g, c, b ? g.getScrollAnim() : false) } }, scrollToItem: function (k, c) { var j = this, g = j.layout, d = g.owner, i = g.names, b = g.innerCt, a, e, h; k = j.getItem(k); if (k !== undefined) { if (k === d.items.first()) { h = 0 } else { if (k === d.items.last()) { h = j.getMaxScrollPosition() } else { a = j.getItemVisibility(k); if (!a.fullyVisible) { e = k.getBox(false, true); h = e[i.x]; if (a.hiddenEnd) { h -= (b[i.getWidth]() - e[i.width]) } } } } if (h !== undefined) { j.scrollTo(h, c) } } }, getItemVisibility: function (j) { var h = this, b = h.getItem(j).getBox(true, true), c = h.layout, g = c.names, e = b[g.x], d = e + b[g.width], a = h.getScrollPosition(), i = a + c.innerCt[g.getWidth](); return { hiddenStart: e < a, hiddenEnd: d > i, fullyVisible: e >= a && d <= i } } }, 1, 0, 0, 0, ["box.overflow.Scroller", "box.overflow.scroller"], [["observable", Ext.mixin.Observable]], [Ext.layout.container.boxOverflow, "Scroller", Ext.layout.boxOverflow, "Scroller"], 0)); (Ext.cmd.derive("Ext.dd.DragDropManager", Ext.Base, { singleton: true, alternateClassName: ["Ext.dd.DragDropMgr", "Ext.dd.DDM"], ids: {}, handleIds: {}, dragCurrent: null, dragOvers: {}, deltaX: 0, deltaY: 0, preventDefault: true, stopPropagation: false, initialized: false, locked: false, init: function () { this.initialized = true }, POINT: 0, INTERSECT: 1, mode: 0, notifyOccluded: false, dragCls: "x-dd-drag-current", currentPoint: new Ext.util.Point(), _execOnAll: function (c, b) { var e = this.ids, d, a, h, g; for (d in e) { if (e.hasOwnProperty(d)) { g = e[d]; for (a in g) { if (g.hasOwnProperty(a)) { h = g[a]; if (!this.isTypeOfDD(h)) { continue } h[c].apply(h, b) } } } } }, addListeners: function () { var a = this; a.init(); Ext.getWin().on({ unload: a._onUnload, resize: a._onResize, scope: a }) }, _onResize: function (a) { this._execOnAll("resetConstraints", []) }, lock: function () { this.locked = true }, unlock: function () { this.locked = false }, isLocked: function () { return this.locked }, locationCache: {}, useCache: true, clickPixelThresh: 8, dragThreshMet: false, clickTimeout: null, startX: 0, startY: 0, regDragDrop: function (b, a) { if (!this.initialized) { this.init() } if (!this.ids[a]) { this.ids[a] = {} } this.ids[a][b.id] = b }, removeDDFromGroup: function (c, a) { if (!this.ids[a]) { this.ids[a] = {} } var b = this.ids[a]; if (b && b[c.id]) { delete b[c.id] } }, _remove: function (h, b) { var e = this, c = e.ids, a = h.groups, d; if (e.clearingAll) { return } if (e.dragCurrent === h) { e.dragCurrent = null } for (d in a) { if (a.hasOwnProperty(d)) { if (b) { delete c[d] } else { if (c[d]) { delete c[d][h.id] } } } } delete e.handleIds[h.id]; delete e.locationCache[h.id] }, regHandle: function (b, a) { if (!this.handleIds[b]) { this.handleIds[b] = {} } this.handleIds[b][a] = a }, isDragDrop: function (a) { return (this.getDDById(a)) ? true : false }, getRelated: function (g, b) { var e = [], d, c, a; for (d in g.groups) { for (c in this.ids[d]) { a = this.ids[d][c]; if (!this.isTypeOfDD(a)) { continue } if (!b || a.isTarget) { e[e.length] = a } } } return e }, isLegalTarget: function (e, d) { var b = this.getRelated(e, true), c, a; for (c = 0, a = b.length; c < a; ++c) { if (b[c].id === d.id) { return true } } return false }, isTypeOfDD: function (a) { return (a && a.__ygDragDrop) }, isHandle: function (b, a) { return (this.handleIds[b] && this.handleIds[b][a]) }, getDDById: function (d, c) { var b, a; for (b in this.ids) { a = this.ids[b][d]; if (a instanceof Ext.dd.DDTarget || c) { return a } } return null }, handleMouseDown: function (d, c) { var g = this, k = d.getXY(), a = c.getEl(), i = { translate: false, fn: g.handleMouseUp, capture: false, priority: -1000 }, b = { translate: false, fn: g.handleMouseMove, capture: false }, h = { capture: true, destroyable: true, scope: g }, j = Ext.supports; h.touchstart = g.handleMouseUp; if (j.PointerEvents) { h.pointerup = i; h.pointermove = b } else { if (j.MSPointerEvents) { h.mouseup = i; h.mousemove = b } else { if (d.pointerType === "mouse") { h.mouseup = i; h.mousemove = b } else { h.touchend = i; h.touchmove = b } } } g.pointerMoveListeners = Ext.getDoc().on(h); g.isMouseDown = true; if (Ext.quickTipsActive) { Ext.tip.QuickTipManager.ddDisable() } g.currentPoint.setPosition(k); if (g.dragCurrent) { g.handleMouseUp(d) } g.mousedownEvent = d; g.currentTarget = d.getTarget(); g.dragCurrent = c; Ext.fly(a).setCapture(); g.startX = k[0]; g.startY = k[1]; g.offsetX = g.offsetY = 0; g.deltaX = g.startX - a.offsetLeft; g.deltaY = g.startY - a.offsetTop; g.dragThreshMet = false }, startDrag: function (b, e) { var c = this, d = c.dragCurrent, a; clearTimeout(c.clickTimeout); if (d) { d.b4StartDrag(b, e); d.startDrag(b, e); a = Ext.fly(d.getDragEl()); if (a) { a.addCls(c.dragCls); if (a.shim && a.shim.el) { a.shim.el.addCls(c.dragCls) } } } c.dragThreshMet = true }, handleMouseUp: function (b) { var a = this; a.pointerMoveListeners.destroy(); a.isMouseDown = false; if (Ext.quickTipsActive) { Ext.tip.QuickTipManager.ddEnable() } if (!a.dragCurrent) { return } if (Ext.isIE && document.releaseCapture) { document.releaseCapture() } clearTimeout(a.clickTimeout); if (a.dragThreshMet) { a.fireEvents(b, true) } a.stopDrag(b); if (a.dragThreshMet) { a.stopEvent(b) } a.mousedownEvent = a.currentTarget = null }, stopEvent: function (a) { if (this.stopPropagation) { a.stopPropagation() } if (this.preventDefault && a.pointerType === "touch") { a.preventDefault() } }, stopDrag: function (d) { var b = this, c = b.dragCurrent, a; if (c) { if (b.dragThreshMet) { a = Ext.fly(c.getDragEl()); if (a) { a.removeCls(b.dragCls); if (a.shim && a.shim.el) { a.shim.el.removeCls(b.dragCls) } } c.b4EndDrag(d); c.endDrag(d) } b.dragCurrent.onMouseUp(d) } b.dragCurrent = null; b.dragOvers = {} }, handleMouseMove: function (j) { var h = this, i = h.dragCurrent, a = j.getXY(), d = a[0], b = a[1], g, c; h.offsetX = d - h.startX; h.offsetY = b - h.startY; h.currentPoint.setPosition(a); if (!i) { return true } if (!h.dragThreshMet) { g = Math.abs(h.offsetX); c = Math.abs(h.offsetY); if (g > h.clickPixelThresh || c > h.clickPixelThresh) { j.claimGesture(); h.startDrag(h.startX, h.startY) } } if (h.dragThreshMet) { i.b4Drag(j); i.onDrag(j); if (!i.moveOnly) { h.fireEvents(j, false) } } h.stopEvent(j); return true }, fireEvents: function (u, m) { var w = this, n = Ext.supports.Touch, g = w.dragCurrent, s = w.currentPoint, o = [], h = [], k = [], a = [], v = [], t = [], c, d, l, b, q, r, p, j; if (!g || g.isLocked()) { return } j = !(g.deltaX < 0 || g.deltaY < 0); if (n || (!w.notifyOccluded && (!Ext.supports.CSSPointerEvents || Ext.isIE10m || Ext.isOpera) && j)) { c = g.getDragEl(); if (j) { c.style.visibility = "hidden" } u = u.chain({ target: w.elementFromPoint(u.clientX, u.clientY) || document.documentElement }); if (j) { c.style.visibility = "visible" } } for (q in w.dragOvers) { d = w.dragOvers[q]; delete w.dragOvers[q]; if (!w.isTypeOfDD(d) || d.destroyed) { continue } if (m) { k.push(d) } else { if (w.notifyOccluded) { if (!this.isOverTarget(s, d, w.mode)) { k.push(d) } } else { if (!u.within(d.getEl())) { k.push(d) } } } h[q] = true } for (p in g.groups) { if ("string" !== typeof p) { continue } for (q in w.ids[p]) { d = w.ids[p][q]; if (w.isTypeOfDD(d) && (l = d.getEl()) && (d.isTarget) && (!d.isLocked()) && (Ext.fly(l).isVisible(true)) && ((d !== g) || (g.ignoreSelf === false))) { if (w.notifyOccluded) { if ((d.zIndex = w.getZIndex(l)) !== -1) { b = true } o.push(d) } else { if (u.within(d.getEl())) { o.push(d); break } } } } } if (b) { Ext.Array.sort(o, w.byZIndex) } for (q = 0, r = o.length; q < r; q++) { d = o[q]; if (w.isOverTarget(s, d, w.mode)) { if (m) { v.push(d) } else { if (!h[d.id]) { t.push(d) } else { a.push(d) } w.dragOvers[d.id] = d } if (!w.notifyOccluded) { break } } } if (w.mode) { if (t.length) { g.onDragEnter(u, t) } if (a.length) { g.b4DragOver(u, a); g.onDragOver(u, a) } if (v.length) { g.b4DragDrop(u, v); g.onDragDrop(u, v) } if (k.length) { g.b4DragOut(u, k); g.onDragOut(u, k) } } else { for (q = 0, r = t.length; q < r; ++q) { g.onDragEnter(u, t[q].id) } for (q = 0, r = a.length; q < r; ++q) { g.b4DragOver(u, a[q].id); g.onDragOver(u, a[q].id) } for (q = 0, r = v.length; q < r; ++q) { g.b4DragDrop(u, v[q].id); g.onDragDrop(u, v[q].id) } for (q = 0, r = k.length; q < r; ++q) { g.b4DragOut(u, k[q].id); g.onDragOut(u, k[q].id) } } if (m && !v.length) { g.onInvalidDrop(u) } }, elementFromPoint: function (a, b) { if (Ext.rootInheritedState.rtl) { a = Ext.Element.getViewportWidth() - a } return Ext.Element.fromPoint(a, b, true) }, getZIndex: function (b) { var a = document.body, c, d = -1; b = Ext.getDom(b); while (b !== a) { if (!isNaN(c = Number(Ext.fly(b).getStyle("zIndex")))) { d = c } b = b.parentNode } return d }, byZIndex: function (b, a) { return b.zIndex < a.zIndex }, getBestMatch: function (c) { var e = null, b = c.length, d, a; if (b === 1) { e = c[0] } else { for (d = 0; d < b; ++d) { a = c[d]; if (a.cursorIsOver) { e = a; break } else { if (!e || e.overlap.getArea() < a.overlap.getArea()) { e = a } } } } return e }, refreshCache: function (b) { var a, c, d, e; for (a in b) { if ("string" !== typeof a) { continue } for (c in this.ids[a]) { d = this.ids[a][c]; if (this.isTypeOfDD(d)) { e = this.getLocation(d); if (e) { this.locationCache[d.id] = e } else { delete this.locationCache[d.id] } } } } }, verifyEl: function (a) { return Ext.getBody().contains(a) }, getLocation: function (i) { if (!this.isTypeOfDD(i)) { return null } if (i.getRegion) { return i.getRegion() } var g = i.getEl(), m, d, c, o, n, p, a, k, h; try { m = Ext.fly(g).getXY() } catch (j) { } if (!m) { return null } d = m[0]; c = d + g.offsetWidth; o = m[1]; n = o + g.offsetHeight; p = o - i.padding[0]; a = c + i.padding[1]; k = n + i.padding[2]; h = d - i.padding[3]; return new Ext.util.Region(p, a, k, h) }, isOverTarget: function (j, a, c) { var e = this.locationCache[a.id], i, g, b, d, h; if (!e || !this.useCache) { e = this.getLocation(a); this.locationCache[a.id] = e } if (!e) { return false } a.cursorIsOver = e.contains(j); i = this.dragCurrent; if (!i || !i.getTargetCoord || (!c && !i.constrainX && !i.constrainY)) { return a.cursorIsOver } a.overlap = null; g = i.getTargetCoord(j.x, j.y); b = i.getDragEl(); d = new Ext.util.Region(g.y, g.x + b.offsetWidth, g.y + b.offsetHeight, g.x); h = d.intersect(e); if (h) { a.overlap = h; return (c) ? true : a.cursorIsOver } else { return false } }, _onUnload: function (b, a) { Ext.dd.DragDropManager.unregAll() }, unregAll: function () { var c = this, a = c.elementCache, b; if (c.dragCurrent) { c.stopDrag(); c.dragCurrent = null } c.clearingAll = true; c._execOnAll("unreg", []); delete c.clearingAll; for (b in a) { delete a[b] } c.elementCache = {}; c.ids = {}; c.handleIds = {} }, elementCache: {}, getElWrapper: function (b) { var a = this.elementCache[b]; if (!a || !a.el) { a = this.elementCache[b] = new this.ElementWrapper(Ext.getDom(b)) } return a }, getElement: function (a) { return Ext.getDom(a) }, getCss: function (b) { var a = Ext.getDom(b); return (a) ? a.style : null }, ElementWrapper: function (a) { this.el = a || null; this.id = this.el && a.id; this.css = this.el && a.style }, getPosX: function (a) { return Ext.fly(a).getX() }, getPosY: function (a) { return Ext.fly(a).getY() }, swapNode: function (c, a) { if (c.swapNode) { c.swapNode(a) } else { var d = a.parentNode, b = a.nextSibling; if (b === c) { d.insertBefore(c, a) } else { if (a === c.nextSibling) { d.insertBefore(a, c) } else { c.parentNode.replaceChild(a, c); d.insertBefore(c, b) } } } }, getScroll: function () { var d = window.document, e = d.documentElement, a = d.body, c = 0, b = 0; if (e && (e.scrollTop || e.scrollLeft)) { c = e.scrollTop; b = e.scrollLeft } else { if (a) { c = a.scrollTop; b = a.scrollLeft } } return { top: c, left: b } }, getStyle: function (b, a) { return Ext.fly(b).getStyle(a) }, getScrollTop: function () { return this.getScroll().top }, getScrollLeft: function () { return this.getScroll().left }, moveToEl: function (a, c) { var b = Ext.fly(c).getXY(); Ext.fly(a).setXY(b) }, numericSort: function (d, c) { return (d - c) }, handleWasClicked: function (a, c) { if (this.isHandle(c, a.id)) { return true } else { var b = a.parentNode; while (b) { if (this.isHandle(c, b.id)) { return true } else { b = b.parentNode } } } return false } }, 0, 0, 0, 0, 0, 0, [Ext.dd, "DragDropManager", Ext.dd, "DragDropMgr", Ext.dd, "DDM"], function (a) { Ext.onInternalReady(function () { a.addListeners() }) })); (Ext.cmd.derive("Ext.resizer.Splitter", Ext.Component, { childEls: ["collapseEl"], renderTpl: ['<tpl if="collapsible===true">', '<div id="{id}-collapseEl" data-ref="collapseEl" role="presentation" class="', "x-", "collapse-el ", "x-", 'layout-split-{collapseDir}{childElCls}">', "</div>", "</tpl>"], isSplitter: true, baseCls: "x-splitter", collapsedClsInternal: "x-splitter-collapsed", canResize: true, collapsible: null, collapseOnDblClick: true, defaultSplitMin: 40, defaultSplitMax: 1000, collapseTarget: "next", horizontal: false, vertical: false, touchAction: undefined, size: 5, tracker: null, ariaRole: "separator", focusable: true, tabIndex: 0, applyTouchAction: function (a, b) { if (a === undefined) { a = this.vertical ? { panX: false } : { panY: false } } return Ext.Component.prototype.applyTouchAction.call(this, a, b) }, getTrackerConfig: function () { return Ext.apply({ xclass: "Ext.resizer.SplitterTracker", el: this.el, splitter: this }, this.tracker) }, beforeRender: function () { var c = this, d = c.getCollapseTarget(), b = c.collapsible, a; Ext.Component.prototype.beforeRender.call(this); if (d.collapsed) { c.addCls(c.collapsedClsInternal) } if (!c.canResize) { c.addCls(c.baseCls + "-noresize") } Ext.applyIf(c.renderData, { collapseDir: c.getCollapseDirection(), collapsible: (b !== null) ? b : d.collapsible }); c.ariaRenderAttributes = c.ariaRenderAttributes || {}; c.ariaRenderAttributes["aria-orientation"] = c.orientation; c.protoEl.unselectable() }, onRender: function () { var b = this, c, a; Ext.Component.prototype.onRender.apply(this, arguments); if (b.performCollapse !== false) { if (b.renderData.collapsible) { b.mon(b.collapseEl, "click", b.toggleTargetCmp, b) } if (b.collapseOnDblClick) { b.mon(b.el, "dblclick", b.toggleTargetCmp, b) } } c = b.getCollapseTarget(); if (c && c.isPanel) { c.on({ collapse: b.onTargetCollapse, expand: b.onTargetExpand, beforeexpand: b.onBeforeTargetExpand, beforecollapse: b.onBeforeTargetCollapse, scope: b }) } if (b.canResize) { b.tracker = Ext.create(b.getTrackerConfig()); b.relayEvents(b.tracker, ["beforedragstart", "dragstart", "dragend"]) } a = b.collapseEl; if (a) { a.lastCollapseDirCls = b.collapseDirProps[b.collapseDirection].cls } }, getCollapseDirection: function () { var g = this, c = g.collapseDirection, e, a, b, d; if (!c) { e = g.collapseTarget; if (e.isComponent) { c = e.collapseDirection } if (!c) { d = g.ownerCt.layout.type; if (e.isComponent) { b = g.ownerCt.items; a = Number(b.indexOf(e) === b.indexOf(g) - 1) << 1 | Number(d === "hbox") } else { a = Number(g.collapseTarget === "prev") << 1 | Number(d === "hbox") } c = ["bottom", "right", "top", "left"][a] } g.collapseDirection = c } g.setOrientation((c === "top" || c === "bottom") ? "horizontal" : "vertical"); return c }, getCollapseTarget: function () { var a = this; return a.collapseTarget.isComponent ? a.collapseTarget : a.collapseTarget === "prev" ? a.previousSibling() : a.nextSibling() }, setCollapseEl: function (b) { var a = this.collapseEl; if (a) { a.setDisplayed(b) } }, onBeforeTargetExpand: function (a) { this.setCollapseEl("none") }, onBeforeTargetCollapse: function () { this.setCollapseEl("none") }, onTargetCollapse: function (b) { var a = this; if (b === a.getCollapseTarget() && b[a.orientation === "vertical" ? "collapsedHorizontal" : "collapsedVertical"]()) { a.el.addCls(a.collapsedClsInternal + " " + (a.collapsedCls || "")) } a.setCollapseEl("") }, onTargetExpand: function (b) { var a = this; a.el.removeCls(a.collapsedClsInternal + " " + (a.collapsedCls || "")); a.setCollapseEl("") }, collapseDirProps: { top: { cls: "x-layout-split-top" }, right: { cls: "x-layout-split-right" }, bottom: { cls: "x-layout-split-bottom" }, left: { cls: "x-layout-split-left" } }, orientationProps: { horizontal: { opposite: "vertical", fixedAxis: "height", stretchedAxis: "width" }, vertical: { opposite: "horizontal", fixedAxis: "width", stretchedAxis: "height" } }, applyCollapseDirection: function () { var c = this, b = c.collapseEl, d = c.collapseDirProps[c.collapseDirection], a; if (b) { a = b.lastCollapseDirCls; if (a) { b.removeCls(a) } b.addCls(b.lastCollapseDirCls = d.cls) } }, applyOrientation: function () { var e = this, c = e.orientation, d = e.orientationProps[c], g = e.size, b = d.fixedAxis, h = d.stretchedAxis, a = e.baseCls + "-"; e[c] = true; e[d.opposite] = false; if (!e.hasOwnProperty(b) || e[b] === "100%") { e[b] = g } if (!e.hasOwnProperty(h) || e[h] === g) { e[h] = "100%" } e.removeCls(a + d.opposite); e.addCls(a + c) }, setOrientation: function (a) { var b = this; if (b.orientation !== a) { b.orientation = a; b.applyOrientation() } }, updateOrientation: function () { delete this.collapseDirection; this.getCollapseDirection(); this.applyCollapseDirection() }, toggleTargetCmp: function (d, b) { var c = this.getCollapseTarget(), g = c.placeholder, a; if (Ext.isFunction(c.expand) && Ext.isFunction(c.collapse)) { if (g && !g.hidden) { a = true } else { a = !c.hidden } if (a) { if (c.collapsed || c.floatedFromCollapse) { c.expand() } else { if (c.collapseDirection) { c.collapse() } else { c.collapse(this.renderData.collapseDir) } } } } }, setSize: function () { var a = this; Ext.Component.prototype.setSize.apply(this, arguments); if (Ext.isIE && a.el) { a.el.repaint() } }, doDestroy: function () { Ext.destroy(this.tracker); Ext.Component.prototype.doDestroy.call(this) } }, 0, ["splitter"], ["component", "box", "splitter"], { component: true, box: true, splitter: true }, ["widget.splitter"], 0, [Ext.resizer, "Splitter"], 0)); (Ext.cmd.derive("Ext.layout.container.Box", Ext.layout.container.Container, { alternateClassName: "Ext.layout.BoxLayout", type: "box", config: { align: "begin", constrainAlign: false, enableSplitters: true, overflowHandler: { $value: null, merge: function (b, a) { if (typeof b === "string") { b = { type: b } } return Ext.merge(a ? Ext.Object.chain(a) : {}, b) } }, padding: 0, pack: "start", stretchMaxPartner: undefined, vertical: false, alignRoundingMethod: "round" }, itemCls: "x-box-item", targetCls: "x-box-layout-ct", targetElCls: "x-box-target", innerCls: "x-box-inner", manageMargins: true, createsInnerCt: true, childEls: ["innerCt", "targetEl"], renderTpl: ['{%var oc,l=values.$comp.layout,oh=l.overflowHandler;if (oh && oh.getPrefixConfig!==Ext.emptyFn) {if(oc=oh.getPrefixConfig())dh.generateMarkup(oc, out)}%}<div id="{ownerId}-innerCt" data-ref="innerCt" role="presentation" class="{[l.innerCls]}{[oh ? (" " + oh.getOverflowCls(l.direction)) : ""]}"><div id="{ownerId}-targetEl" data-ref="targetEl" class="{targetElCls}" role="presentation">{%this.renderBody(out, values)%}</div></div>{%if (oh && oh.getSuffixConfig!==Ext.emptyFn) {if(oc=oh.getSuffixConfig())dh.generateMarkup(oc, out)}%}', { disableFormats: true, definitions: "var dh=Ext.DomHelper;" }], constructor: function (a) { var c = this, b; Ext.layout.container.Container.prototype.constructor.call(this, a); c.setVertical(c.vertical); c.flexSortFn = c.flexSort.bind(c); b = typeof c.padding; if (b === "string" || b === "number") { c.padding = Ext.util.Format.parseBox(c.padding); c.padding.height = c.padding.top + c.padding.bottom; c.padding.width = c.padding.left + c.padding.right } }, _beginRe: /^(?:begin|left|top)$/, _centerRe: /^(?:center|middle)$/, _endRe: /^(?:end|right|bottom)$/, _percentageRe: /^\s*(\d+(?:\.\d*)?)\s*[%]\s*$/, getItemSizePolicy: function (q, r) { var l = this, j = l.sizePolicy, h = l.align, g = q.flex, o = h, k = l.names, i = k.height, n = k.width, b = q[n], p = q[i], d = l._percentageRe, c = d.test(b), e = (h === "stretch"), a = (h === "stretchmax"), m = l.constrainAlign; if (!r && (e || g || c || (m && !a))) { r = l.owner.getSizeModel() } if (e) { if (!d.test(p) && r[i].shrinkWrap) { o = "stretchmax" } } else { if (!a) { if (d.test(p)) { o = "stretch" } else { if (m && !r[i].shrinkWrap) { o = "stretchmax" } else { o = "" } } } } if (g || c) { if (!r[n].shrinkWrap) { j = j.flex } } return j[o] }, flexSort: function (o, n) { var l = this.names.maxWidth, e = this.names.minWidth, m = Infinity, k = o.target, r = n.target, i = k.flex, h = r.flex, s = 0, c, p, j, d, q, g; j = k[l] || m; d = r[l] || m; c = k[e] || 0; p = r[e] || 0; q = isFinite(c) || isFinite(p); g = isFinite(j) || isFinite(d); if (q || g) { if (g) { s = j - d } if (s === 0 && q) { s = p - c } if (s === 0) { if (g) { s = h - i } else { s = i - h } } } return s }, isItemBoxParent: function (a) { return true }, isItemShrinkWrap: function (a) { return true }, roundFlex: function (a) { return Math.floor(a) }, beginCollapse: function (b) { var a = this; if (a.direction === "vertical" && b.collapsedVertical()) { b.collapseMemento.capture(["flex"]); delete b.flex } else { if (a.direction === "horizontal" && b.collapsedHorizontal()) { b.collapseMemento.capture(["flex"]); delete b.flex } } }, beginExpand: function (a) { a.collapseMemento.restore(["flex"]) }, beginLayout: function (e) { var d = this, a = d.owner, h = a.stretchMaxPartner, c = d.innerCt.dom.style, g = d.names, b = d.overflowHandler; e.boxNames = g; if (b) { b.beginLayout(e) } if (typeof h === "string") { h = Ext.getCmp(h) || a.query(h)[0] } e.stretchMaxPartner = h && e.context.getCmp(h); Ext.layout.container.Container.prototype.beginLayout.call(this, e); e.innerCtContext = e.getEl("innerCt", d); e.targetElContext = e.getEl("targetEl", d); e.ownerScrollable = a.getScrollable(); c.width = c.height = "" }, beginLayoutCycle: function (d, n) { var k = this, a = d.state, l = d.ownerScrollable, i = k.align, j = d.boxNames, m = k.pack, c = k._centerRe, e = k.overflowHandler, b = d.state.canScroll, h, g; if (e) { e.beginLayoutCycle(d, n) } Ext.layout.container.Container.prototype.beginLayoutCycle.call(this, d, n); d.parallelSizeModel = h = d[j.widthModel]; d.perpendicularSizeModel = g = d[j.heightModel]; d.boxOptions = { align: i = { stretch: i === "stretch", stretchmax: i === "stretchmax", center: c.test(i), bottom: k._endRe.test(i) }, pack: m = { center: c.test(m), end: m === "end" } }; if (l) { if (!b) { a.canScroll = { parallel: !h.shrinkWrap && l[j.getX](), perpendicular: !g.shrinkWrap && l[j.getY]() } } if (!a.actualScroll) { a.actualScroll = { parallel: false, perpendicular: false } } } if (i.stretch && g.shrinkWrap) { i.stretchmax = true; i.stretch = false } i.nostretch = !(i.stretch || i.stretchmax); if (h.shrinkWrap) { m.center = m.end = false } k.cacheFlexes(d); k.targetEl.setWidth(20000) }, cacheFlexes: function (m) { var B = this, n = m.boxNames, a = n.widthModel, h = n.heightModel, c = m.boxOptions.align.nostretch, t = 0, b = m.childItems, v = b.length, z = [], o = 0, w = 0, s = 0, l = n.minWidth, y = n.minHeight, j = B._percentageRe, x = 0, A = 0, g, q, u, k, d, e, r, p; while (v--) { q = b[v]; g = q.target; e = q[a]; if (e.calculated) { q.flex = u = g.flex; if (u) { t += u; z.push(q); o += g[l] || 0 } else { if ((k = j.exec(g[n.width]))) { q.percentageParallel = parseFloat(k[1]) / 100; ++x } } } if (e.configured) { r = g[n.width] } else { r = g[l] || 0 } s += r; d = q[h]; if (c && d.calculated) { k = j.exec(g[n.height]); q.percentagePerpendicular = parseFloat(k[1]) / 100; ++A } if (d.configured) { p = g[n.height] } else { p = g[y] || 0 } if (p > w) { w = p } } m.flexedItems = z; m.flexedMinWidth = o; m.smallestWidth = s; m.smallestHeight = w; m.totalFlex = t; m.percentageWidths = x; m.percentageHeights = A; Ext.Array.sort(z, B.flexSortFn) }, calculate: function (c) { var h = this, g = c.boxNames, a = c.state, e = a.actualScroll, j = a.needsScroll, b = a.canScroll, i = a.boxPlan || (a.boxPlan = {}), d = h.overflowHandler; i.targetSize = h.getContainerSize(c); if (b && !j) { a.needsScroll = j = { parallel: b.parallel && i.targetSize[g.width] < c.smallestWidth, perpendicular: b.perpendicular && i.targetSize[g.height] < c.smallestHeight } } if (!a.parallelDone) { a.parallelDone = h.calculateParallel(c, g, i) } if (!a.perpendicularDone) { a.perpendicularDone = h.calculatePerpendicular(c, g, i) } if (a.parallelDone && a.perpendicularDone) { if (b && !a.scrollPass) { if (j.parallel !== e.parallel || j.perpendicular !== e.perpendicular) { c.invalidate({ state: { scrollPass: true, canScroll: b, needsScroll: e } }); h.done = false; return } } h.publishInnerCtSize(c); if (h.done && c.boxOptions.align.stretchmax && !a.stretchMaxDone) { h.calculateStretchMax(c, g, i); a.stretchMaxDone = true } if (d) { d.calculate(c) } } else { h.done = false } }, calculateParallel: function (x, L, C) { var r = this, o = x.parallelSizeModel.shrinkWrap, D = L.width, h = x.childItems, t = L.beforeX, H = L.afterX, l = L.setWidth, A = h.length, w = x.flexedItems, G = w.length, q = x.boxOptions.pack, I = r.padding, b = C.targetSize, p = b[D], M = x.state, z = M.needsScroll, s = M.canScroll, B = 0, j = I[t], F = j + I[H], u = Ext.getScrollbarSize(), e = u[L.width], a = u[L.height], J, y, g, m, n, k, c, K, E, v, d; if (!o && !b[L.gotWidth]) { return false } for (J = 0; J < A; ++J) { n = h[J]; y = n.marginInfo || n.getMarginInfo(); B += y[D]; if (!n[L.widthModel].calculated) { E = n.getProp(D); F += E; if (isNaN(F)) { return false } } } F += B; if (x.percentageWidths) { v = p - B; if (isNaN(v)) { return false } for (J = 0; J < A; ++J) { n = h[J]; if (n.percentageParallel) { E = Math.ceil(v * n.percentageParallel); E = n[l](E); F += E } } } if (o) { d = 0; C.tooNarrow = false } else { d = p - F; if (z && z.perpendicular) { d -= a } C.tooNarrow = d < x.flexedMinWidth; if (C.tooNarrow && s && s.parallel) { M.actualScroll.parallel = true } } K = F; g = d; m = x.totalFlex; for (J = 0; J < G; J++) { n = w[J]; k = n.flex; c = r.roundFlex((k / m) * g); c = n[l](c); K += c; g = Math.max(0, g - c); m -= k } if (q.center) { j += g / 2; if (j < 0) { j = 0 } } else { if (q.end) { j += g } } for (J = 0; J < A; ++J) { n = h[J]; y = n.marginInfo; j += y[t]; n.setProp(L.x, j); j += y[H] + n.props[D] } K += x.targetContext.getPaddingInfo()[D]; x.state.contentWidth = K; if (z && z.perpendicular) { if (o) { K += e } x[L.hasOverflowY] = true; x.target.componentLayout[L.setWidthInDom] = true; x[L.invalidateScrollY] = Ext.isIE8 } x[L.setContentWidth](K); return true }, calculatePerpendicular: function (v, M, B) { var t = this, Q = v.state, x = Q.needsScroll, u = Q.canScroll, d = v.perpendicularSizeModel.shrinkWrap, b = B.targetSize, j = v.childItems, A = j.length, m = Math.max, l = M.height, n = M.setHeight, h = M.beforeY, s = M.y, J = t.padding, k = J[h], o = b[l] - k - J[M.afterY], G = v.boxOptions.align, p = G.stretch, q = G.stretchmax, P = G.center, O = G.bottom, I = t.constrainAlign, H = 0, D = 0, F = t.onBeforeConstrainInvalidateChild, C = t.onAfterConstrainInvalidateChild, a = Ext.getScrollbarSize().height, z, K, E, w, y, c, r, e, N, L, g; if (!d && !b[M.gotHeight]) { return false } if (p || ((P || O) && !d)) { if (isNaN(o)) { return false } } if (x && x.parallel) { if (d) { L = true } else { o -= a; B.targetSize[l] -= a } } if (p) { c = o; H = m(c, v.smallestHeight) } else { for (K = 0; K < A; K++) { r = j[K]; w = (r.marginInfo || r.getMarginInfo())[l]; if (!(g = r.percentagePerpendicular)) { E = r.getProp(l) } else { ++D; if (d) { continue } else { E = g * o - w; E = r[n](E) } } if (!d && I && r[M.heightModel].shrinkWrap && E > o) { r.invalidate({ before: F, after: C, layout: t, childHeight: o, names: M }); v.state.parallelDone = false } if (isNaN(H = m(H, E + w, r.target[M.minHeight] || 0))) { return false } } } if (L) { H += a; v[M.hasOverflowX] = true; v.target.componentLayout[M.setHeightInDom] = true; v[M.invalidateScrollX] = Ext.isIE8 } e = v.stretchMaxPartner; if (e) { v.setProp("maxChildHeight", H); N = e.childItems; if (N && N.length) { H = m(H, e.getProp("maxChildHeight")); if (isNaN(H)) { return false } } } v[M.setContentHeight](H + t.padding[l] + v.targetContext.getPaddingInfo()[l]); if (L) { H -= a } if (H > b[l] && u && u.perpendicular) { Q.actualScroll.perpendicular = true } B.maxSize = H; if (q) { c = H } else { if (P || O || D) { if (I) { c = d ? H : o } else { c = d ? H : m(o, H) } c -= v.innerCtContext.getBorderInfo()[l] } } for (K = 0; K < A; K++) { r = j[K]; w = r.marginInfo || r.getMarginInfo(); z = k + w[h]; if (p) { r[n](c - w[l]) } else { g = r.percentagePerpendicular; if (d && g) { w = r.marginInfo || r.getMarginInfo(); E = g * c - w[l]; E = r[n](E) } if (P) { y = c - r.props[l]; if (y > 0) { z = k + Math[t.alignRoundingMethod](y / 2) } } else { if (O) { z = m(0, c - z - r.props[l]) } } } r.setProp(s, z) } return true }, onBeforeConstrainInvalidateChild: function (b, a) { var c = a.names.heightModel; if (!b[c].constrainedMin) { b[c] = Ext.layout.SizeModel.calculated } }, onAfterConstrainInvalidateChild: function (b, a) { var c = a.names; b.setProp(c.beforeY, 0); if (b[c.heightModel].calculated) { b[c.setHeight](a.childHeight) } }, calculateStretchMax: function (c, k, m) { var l = this, h = k.height, n = k.width, g = c.childItems, a = g.length, p = m.maxSize, o = l.onBeforeStretchMaxInvalidateChild, e = l.onAfterStretchMaxInvalidateChild, q, j, d, b; for (d = 0; d < a; ++d) { q = g[d]; j = q.props; b = p - q.getMarginInfo()[h]; if (b !== j[h] || q[k.heightModel].constrained) { q.invalidate({ before: o, after: e, layout: l, childWidth: j[n], childHeight: b, childX: j.x, childY: j.y, names: k }) } } }, onBeforeStretchMaxInvalidateChild: function (b, a) { var c = a.names.heightModel; if (!b[c].constrainedMax) { b[c] = Ext.layout.SizeModel.calculated } }, onAfterStretchMaxInvalidateChild: function (d, c) { var e = c.names, a = c.childHeight, b = c.childWidth; d.setProp("x", c.childX); d.setProp("y", c.childY); if (d[e.heightModel].calculated) { d[e.setHeight](a) } if (d[e.widthModel].calculated) { d[e.setWidth](b) } }, completeLayout: function (b) { var j = this, i = b.invalidateScrollX, h = b.invalidateScrollY, c = j.overflowHandler, e, a, g, d, k; if (c) { c.completeLayout(b) } if (i || h) { a = j.getTarget(); e = a.dom; k = e.style; if (i) { g = a.getStyle("overflowX"); if (g === "auto") { g = k.overflowX; k.overflowX = "scroll" } else { i = false } } if (h) { d = a.getStyle("overflowY"); if (d === "auto") { d = k.overflowY; k.overflowY = "scroll" } else { h = false } } if (i || h) { e.scrollWidth; if (i) { k.overflowX = g } if (h) { k.overflowY = d } } } }, finishedLayout: function (b) { var a = this.overflowHandler; if (a) { a.finishedLayout(b) } Ext.layout.container.Container.prototype.finishedLayout.call(this, b) }, getLayoutItems: function () { var j = Ext.layout.container.Container.prototype.getLayoutItems.call(this), b = j.length, e, d, c, k, h, g, a; for (c = 0; c < b; ++c) { if ((k = j[c]).isSplitter) { continue } a = k.splitter; if (k.hidden) { if (a) { if (!a.hidden) { a.hidden = true; if (a.el) { a.el.hide() } } } continue } if (a) { g = a.collapseTarget === "next" } else { g = false } d = null; if (e && h) { if (h.hidden) { h.hidden = false; if (h.el) { h.el.show() } } if (g) { d = true } } else { if (g) { d = !e } } if (d !== null && a.hidden !== d) { a.hidden = d; if (a.el) { a.el.setVisible(!d) } } h = !g && a; e = k } if (e && h && !h.hidden) { h.hidden = true; if (h.el) { h.el.hide() } } return j }, insertSplitter: function (d, c, g, b) { var e = { xtype: "splitter", id: d.id + "-splitter", hidden: g, splitterFor: d, synthetic: true }, a = c + ((b.collapseTarget === "prev") ? 1 : 0); e[this.names.height] = "100%"; if (b) { Ext.apply(e, b) } d.splitter = this.owner.add(a, e) }, publishInnerCtSize: function (b, d) { d = d || 0; var j = this, a = b.state, i = b.boxNames, h = i.height, l = i.width, g = b.boxOptions.align, n = j.padding, k = a.boxPlan, e = k.targetSize, p = k.maxSize, m = a.needsScroll, q = b.innerCtContext, c, o; if (b.parallelSizeModel.shrinkWrap || (k.tooNarrow && a.canScroll)) { c = a.contentWidth - b.targetContext.getPaddingInfo()[l] } else { c = e[l]; if (m && m.perpendicular) { c -= Ext.getScrollbarSize()[l] } } c -= d; j.owner.tooNarrow = k.tooNarrow; if (g.stretch) { o = p } else { o = k.maxSize + n[i.beforeY] + n[i.afterY] + q.getBorderInfo()[h]; if (!b.perpendicularSizeModel.shrinkWrap && (g.center || g.bottom)) { o = Math.max(e[h], o) } } q[i.setWidth](c); q[i.setHeight](o); b.targetElContext.setWidth(b.innerCtContext.props.width - (j.vertical ? 0 : (d || 0))); if (isNaN(c + o)) { j.done = false } }, onAdd: function (d, a) { var c = this, b = c.enableSplitters && !d.isButton && d.split; Ext.layout.container.Container.prototype.onAdd.call(this, d, a); if (b) { if (b === true) { b = { collapseTarget: "next" } } else { if (Ext.isString(b)) { b = { collapseTarget: b === "before" ? "next" : "prev" } } else { b = Ext.apply({ collapseTarget: b.side === "before" ? "next" : "prev" }, b) } } c.insertSplitter(d, a, !!d.hidden, b) } }, onRemove: function (b, e) { var g = this, i = g.names, a = g.owner, h = b.splitter, c = g.overflowHandler, d; Ext.layout.container.Container.prototype.onRemove.call(this, b, e); if (h && a.contains(h)) { a.doRemove(h, true); b.splitter = null } if (c) { c.onRemove(b) } if (b.layoutMarginCap === g.id) { delete b.layoutMarginCap } if (!a.destroying && !e && b.rendered) { d = b.getEl(); if (d) { d.setStyle(i.beforeY, ""); d.setStyle(i.beforeX, ""); d.setStyle("margin", "") } } }, applyOverflowHandler: function (b, a) { var c; if (typeof b === "string") { b = { type: b } } c = b.type; if (a && a.type === b.type) { delete b.type; a.setConfig(b); return a } b.layout = this; return Ext.Factory.boxOverflow(b) }, getRenderTarget: function () { return this.targetEl }, getElementTarget: function () { return this.innerCt }, destroy: function () { var a = this; Ext.destroy(a.innerCt, a.overflowHandler); a.flexSortFn = a.innerCt = null; Ext.layout.container.Container.prototype.destroy.call(this) }, getRenderData: function () { var a = Ext.layout.container.Container.prototype.getRenderData.call(this); a.targetElCls = this.targetElCls; return a }, updateVertical: function (b) { var e = this, c = e.overflowHandler, a = e.owner, d = e._props; Ext.apply(e, b ? d.vbox : d.hbox); if (c && a && a.rendered) { c.setVertical(b) } }, _props: { hbox: { direction: "horizontal", oppositeDirection: "vertical", horizontal: true, vertical: false, names: { beforeX: "left", beforeScrollX: "left", leftCap: "Left", afterX: "right", width: "width", contentWidth: "contentWidth", minWidth: "minWidth", maxWidth: "maxWidth", widthCap: "Width", widthModel: "widthModel", widthIndex: 0, x: "x", getX: "getX", setX: "setX", scrollLeft: "scrollLeft", overflowX: "overflowX", hasOverflowX: "hasOverflowX", invalidateScrollX: "invalidateScrollX", parallelMargins: "lr", center: "middle", beforeY: "top", afterY: "bottom", height: "height", contentHeight: "contentHeight", minHeight: "minHeight", maxHeight: "maxHeight", heightCap: "Height", heightModel: "heightModel", heightIndex: 1, y: "y", getY: "getY", setY: "setY", overflowY: "overflowY", hasOverflowY: "hasOverflowY", invalidateScrollY: "invalidateScrollY", perpendicularMargins: "tb", getWidth: "getWidth", getHeight: "getHeight", setWidth: "setWidth", setHeight: "setHeight", gotWidth: "gotWidth", gotHeight: "gotHeight", setContentWidth: "setContentWidth", setContentHeight: "setContentHeight", setWidthInDom: "setWidthInDom", setHeightInDom: "setHeightInDom", getScrollLeft: "getScrollLeft", setScrollLeft: "setScrollLeft", scrollTo: "scrollTo" }, sizePolicy: { flex: { "": { readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0 }, stretch: { readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1 }, stretchmax: { readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 1 } }, "": { readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0 }, stretch: { readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1 }, stretchmax: { readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 1 } } }, vbox: { direction: "vertical", oppositeDirection: "horizontal", horizontal: false, vertical: true, names: { beforeX: "top", beforeScrollX: "top", leftCap: "Top", afterX: "bottom", width: "height", contentWidth: "contentHeight", minWidth: "minHeight", maxWidth: "maxHeight", widthCap: "Height", widthModel: "heightModel", widthIndex: 1, x: "y", getX: "getY", setX: "setY", scrollLeft: "scrollTop", overflowX: "overflowY", hasOverflowX: "hasOverflowY", invalidateScrollX: "invalidateScrollY", parallelMargins: "tb", center: "center", beforeY: "left", afterY: "right", height: "width", contentHeight: "contentWidth", minHeight: "minWidth", maxHeight: "maxWidth", heightCap: "Width", heightModel: "widthModel", heightIndex: 0, y: "x", getY: "getX", setY: "setX", overflowY: "overflowX", hasOverflowY: "hasOverflowX", invalidateScrollY: "invalidateScrollX", perpendicularMargins: "lr", getWidth: "getHeight", getHeight: "getWidth", setWidth: "setHeight", setHeight: "setWidth", gotWidth: "gotHeight", gotHeight: "gotWidth", setContentWidth: "setContentHeight", setContentHeight: "setContentWidth", setWidthInDom: "setHeightInDom", setHeightInDom: "setWidthInDom", getScrollLeft: "getScrollTop", setScrollLeft: "setScrollTop", scrollTo: "scrollTo" }, sizePolicy: { flex: { "": { readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1 }, stretch: { readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1 }, stretchmax: { readsWidth: 1, readsHeight: 0, setsWidth: 1, setsHeight: 1 } }, "": { readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0 }, stretch: { readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0 }, stretchmax: { readsWidth: 1, readsHeight: 1, setsWidth: 1, setsHeight: 0 } } } } }, 1, 0, 0, 0, ["layout.box"], 0, [Ext.layout.container, "Box", Ext.layout, "BoxLayout"], 0)); (Ext.cmd.derive("Ext.layout.container.HBox", Ext.layout.container.Box, { alternateClassName: "Ext.layout.HBoxLayout", type: "hbox", vertical: false }, 0, 0, 0, 0, ["layout.hbox"], 0, [Ext.layout.container, "HBox", Ext.layout, "HBoxLayout"], 0)); (Ext.cmd.derive("Ext.layout.container.VBox", Ext.layout.container.Box, { alternateClassName: "Ext.layout.VBoxLayout", type: "vbox", vertical: true }, 0, 0, 0, 0, ["layout.vbox"], 0, [Ext.layout.container, "VBox", Ext.layout, "VBoxLayout"], 0)); (Ext.cmd.derive("Ext.toolbar.Toolbar", Ext.container.Container, { alternateClassName: "Ext.Toolbar", isToolbar: true, baseCls: "x-toolbar", ariaRole: "toolbar", defaultType: "button", layout: undefined, vertical: undefined, enableOverflow: false, overflowHandler: null, defaultButtonUI: "default-toolbar", defaultFieldUI: "default", defaultFooterButtonUI: "default", defaultFooterFieldUI: "default", trackMenus: true, itemCls: "x-toolbar-item", statics: { shortcuts: { "-": "tbseparator", " ": "tbspacer" }, shortcutsHV: { 0: { "->": { xtype: "tbfill", height: 0 } }, 1: { "->": { xtype: "tbfill", width: 0 } } } }, initComponent: function () { var c = this, b = c.layout, a = c.vertical; if (a === undefined) { c.vertical = a = c.dock === "right" || c.dock === "left" } c.layout = b = Ext.applyIf(Ext.isString(b) ? { type: b } : b || {}, { type: a ? "vbox" : "hbox", align: a ? "stretchmax" : "middle" }); if (c.overflowHandler) { b.overflowHandler = c.overflowHandler } else { if (c.enableOverflow) { b.overflowHandler = "menu" } } if (a) { c.addClsWithUI("vertical") } if (c.ui === "footer") { c.ignoreBorderManagement = true } Ext.container.Container.prototype.initComponent.call(this) }, getRefItems: function (a) { var e = this, b = Ext.container.Container.prototype.getRefItems.apply(this, arguments), d = e.layout, c; if (a && (e.enableOverflow || (e.overflowHandler === "menu"))) { c = d.overflowHandler; if (c && c.menu) { b = b.concat(c.menu.getRefItems(a)) } } return b }, lookupComponent: function (e) { var d = arguments, a, b; if (typeof e === "string" && e[0] !== "@") { b = Ext.toolbar.Toolbar; a = b.shortcutsHV[this.vertical ? 1 : 0][e] || b.shortcuts[e]; if (typeof a === "string") { e = { xtype: a } } else { if (a) { e = Ext.apply({}, a) } else { e = { xtype: "tbtext", text: e } } } this.applyDefaults(e); d = [e] } return Ext.container.Container.prototype.lookupComponent.apply(this, d) }, onBeforeAdd: function (b) { var c = this, d = c.ui === "footer", a = d ? c.defaultFooterButtonUI : c.defaultButtonUI; if (b.isSegmentedButton) { if (b.getDefaultUI() === "default" && !b.config.hasOwnProperty("defaultUI")) { b.setDefaultUI(a) } } else { if (b.ui === "default" && !b.hasOwnProperty("ui")) { if (b.isButton) { b.ui = a } else { if (b.isFormField) { b.ui = d ? c.defaultFooterFieldUI : c.defaultFieldUI } } } } if (b instanceof Ext.toolbar.Separator) { b.setUI(c.vertical ? "vertical" : "horizontal") } Ext.container.Container.prototype.onBeforeAdd.apply(this, arguments) }, onAdd: function (a) { var b = this; if (a.needArrowKeys && b.enableFocusableContainer) { b.enableFocusableContainer = false; b.ariaRole = "group" } Ext.container.Container.prototype.onAdd.apply(this, arguments); b.trackMenu(a) }, onRemove: function (a) { Ext.container.Container.prototype.onRemove.apply(this, arguments); this.trackMenu(a, true) }, privates: { applyDefaults: function (a) { if (!Ext.isString(a)) { a = Ext.container.Container.prototype.applyDefaults.apply(this, arguments) } return a }, trackMenu: function (c, a) { var b = this; if (b.trackMenus && c.menu) { c[a ? "un" : "on"]({ mouseover: b.onButtonOver, menushow: b.onButtonMenuShow, menuhide: b.onButtonMenuHide, scope: b }) } }, getChildItemsToDisable: function () { return this.items.getRange() }, onButtonOver: function (b, c) { var a = this.activeMenuBtn; if (a && a !== b) { a.hideMenu(); b.focus(); b.showMenu(c); this.activeMenuBtn = b } }, onButtonMenuShow: function (a) { this.activeMenuBtn = a }, onButtonMenuHide: function (a) { this.activeMenuBtn = null } } }, 0, ["toolbar"], ["component", "box", "container", "toolbar"], { component: true, box: true, container: true, toolbar: true }, ["widget.toolbar"], [[Ext.util.FocusableContainer.prototype.mixinId || Ext.util.FocusableContainer.$className, Ext.util.FocusableContainer]], [Ext.toolbar, "Toolbar", Ext, "Toolbar"], 0)); (Ext.cmd.derive("Ext.dd.DragDrop", Ext.Base, { constructor: function (c, a, b) { if (c) { this.init(c, a, b) } }, id: null, config: null, dragElId: null, handleElId: null, invalidHandleTypes: null, invalidHandleIds: null, invalidHandleClasses: null, startPageX: 0, startPageY: 0, groups: null, locked: false, lock: function () { this.locked = true }, moveOnly: false, unlock: function () { this.locked = false }, isTarget: true, padding: null, _domRef: null, __ygDragDrop: true, constrainX: false, constrainY: false, minX: 0, maxX: 0, minY: 0, maxY: 0, maintainOffset: false, xTicks: null, yTicks: null, primaryButtonOnly: true, available: false, hasOuterHandles: false, triggerEvent: "mousedown", b4StartDrag: function (a, b) { }, startDrag: function (a, b) { }, b4Drag: function (a) { }, onDrag: function (a) { }, onDragEnter: function (a, b) { }, b4DragOver: function (a) { }, onDragOver: function (a, b) { }, b4DragOut: function (a) { }, onDragOut: function (a, b) { }, b4DragDrop: function (a) { }, onDragDrop: function (a, b) { }, onInvalidDrop: function (a) { }, b4EndDrag: function (a) { }, endDrag: function (a) { }, b4MouseDown: function (a) { }, onMouseDown: function (a) { }, onMouseUp: function (a) { }, onAvailable: function () { }, defaultPadding: { left: 0, right: 0, top: 0, bottom: 0 }, constrainTo: function (e, b, l) { if (Ext.isNumber(b)) { b = { left: b, right: b, top: b, bottom: b } } b = b || this.defaultPadding; var h = Ext.get(this.getEl()).getBox(), m = Ext.get(e), k = m.getScroll(), g, i = m.dom, j, d, a; if (i === document.body) { g = { x: k.left, y: k.top, width: Ext.Element.getViewportWidth(), height: Ext.Element.getViewportHeight() } } else { j = m.getXY(); g = { x: j[0], y: j[1], width: i.clientWidth, height: i.clientHeight } } d = h.y - g.y; a = h.x - g.x; this.resetConstraints(); this.setXConstraint(a - (b.left || 0), g.width - a - h.width - (b.right || 0), this.xTickSize); this.setYConstraint(d - (b.top || 0), g.height - d - h.height - (b.bottom || 0), this.yTickSize) }, getEl: function () { if (!this._domRef) { this._domRef = Ext.getDom(this.id) } return this._domRef }, getDragEl: function () { return Ext.getDom(this.dragElId) }, init: function (d, a, b) { var c = this; c.el = c.el || Ext.get(d); c.initTarget(d, a, b); Ext.get(c.id).on(c.triggerEvent, c.handleMouseDown, c); if (Ext.supports.Touch && c.triggerEvent === "longpress") { Ext.get(c.id).swallowEvent("contextmenu", true) } }, initTarget: function (c, a, b) { this.config = b || {}; this.DDMInstance = Ext.dd.DragDropManager; this.groups = {}; if (typeof c !== "string") { c = Ext.id(c) } this.id = c; this.addToGroup((a) ? a : "default"); this.handleElId = c; this.setDragElId(c); this.invalidHandleTypes = { A: "A" }; this.invalidHandleIds = {}; this.invalidHandleClasses = []; this.applyConfig(); this.handleOnAvailable() }, applyConfig: function () { this.padding = this.config.padding || [0, 0, 0, 0]; this.isTarget = (this.config.isTarget !== false); this.maintainOffset = (this.config.maintainOffset); this.primaryButtonOnly = (this.config.primaryButtonOnly !== false) }, handleOnAvailable: function () { this.available = true; this.resetConstraints(); this.onAvailable() }, setPadding: function (c, a, d, b) { if (!a && 0 !== a) { this.padding = [c, c, c, c] } else { if (!d && 0 !== d) { this.padding = [c, a, c, a] } else { this.padding = [c, a, d, b] } } }, setInitPosition: function (d, c) { var e = this.getEl(), b, a, g; if (!this.DDMInstance.verifyEl(e)) { return } b = d || 0; a = c || 0; g = Ext.fly(e).getXY(); this.initPageX = g[0] - b; this.initPageY = g[1] - a; this.lastPageX = g[0]; this.lastPageY = g[1]; this.setStartPosition(g) }, setStartPosition: function (b) { var a = b || Ext.fly(this.getEl()).getXY(); this.deltaSetXY = null; this.startPageX = a[0]; this.startPageY = a[1] }, addToGroup: function (a) { this.groups[a] = true; this.DDMInstance.regDragDrop(this, a) }, removeFromGroup: function (a) { if (this.groups[a]) { delete this.groups[a] } this.DDMInstance.removeDDFromGroup(this, a) }, setDragElId: function (a) { this.dragElId = a }, setHandleElId: function (a) { if (typeof a !== "string") { a = Ext.id(a) } this.handleElId = a; this.DDMInstance.regHandle(this.id, a) }, setOuterHandleElId: function (a) { if (typeof a !== "string") { a = Ext.id(a) } Ext.get(a).on(this.triggerEvent, this.handleMouseDown, this); this.setHandleElId(a); this.hasOuterHandles = true }, unreg: function () { var b = this, a; if (b._domRef) { a = Ext.fly(b.id); if (a) { a.un(b.triggerEvent, b.handleMouseDown, b) } } b._domRef = null; b.DDMInstance._remove(b, b.autoGroup) }, destroy: function () { this.unreg(); this.callParent() }, isLocked: function () { return (this.DDMInstance.isLocked() || this.locked) }, handleMouseDown: function (c, b) { var a = this; if ((a.primaryButtonOnly && c.button) || a.isLocked()) { return } a.DDMInstance.refreshCache(a.groups); if (a.hasOuterHandles || a.DDMInstance.isOverTarget(c.getPoint(), a)) { if (a.clickValidator(c)) { a.setStartPosition(); a.b4MouseDown(c); a.onMouseDown(c); a.DDMInstance.handleMouseDown(c, a); a.DDMInstance.stopEvent(c) } } }, clickValidator: function (b) { var a = b.getTarget(); return (this.isValidHandleChild(a) && (this.id === this.handleElId || this.DDMInstance.handleWasClicked(a, this.id))) }, addInvalidHandleType: function (a) { var b = a.toUpperCase(); this.invalidHandleTypes[b] = b }, addInvalidHandleId: function (a) { if (typeof a !== "string") { a = Ext.id(a) } this.invalidHandleIds[a] = a }, addInvalidHandleClass: function (a) { this.invalidHandleClasses.push(a) }, removeInvalidHandleType: function (a) { var b = a.toUpperCase(); delete this.invalidHandleTypes[b] }, removeInvalidHandleId: function (a) { if (typeof a !== "string") { a = Ext.id(a) } delete this.invalidHandleIds[a] }, removeInvalidHandleClass: function (b) { var d = this.invalidHandleClasses, a = d.length, c; for (c = 0; c < a; ++c) { if (d[c] === b) { delete d[c] } } }, isValidHandleChild: function (d) { var c = true, h, b, a; try { h = d.nodeName.toUpperCase() } catch (g) { h = d.nodeName } c = c && !this.invalidHandleTypes[h]; c = c && !this.invalidHandleIds[d.id]; for (b = 0, a = this.invalidHandleClasses.length; c && b < a; ++b) { c = !Ext.fly(d).hasCls(this.invalidHandleClasses[b]) } return c }, setXTicks: function (d, a) { this.xTicks = []; this.xTickSize = a; var c = {}, b; for (b = this.initPageX; b >= this.minX; b = b - a) { if (!c[b]) { this.xTicks[this.xTicks.length] = b; c[b] = true } } for (b = this.initPageX; b <= this.maxX; b = b + a) { if (!c[b]) { this.xTicks[this.xTicks.length] = b; c[b] = true } } Ext.Array.sort(this.xTicks, this.DDMInstance.numericSort) }, setYTicks: function (d, a) { this.yTicks = []; this.yTickSize = a; var c = {}, b; for (b = this.initPageY; b >= this.minY; b = b - a) { if (!c[b]) { this.yTicks[this.yTicks.length] = b; c[b] = true } } for (b = this.initPageY; b <= this.maxY; b = b + a) { if (!c[b]) { this.yTicks[this.yTicks.length] = b; c[b] = true } } Ext.Array.sort(this.yTicks, this.DDMInstance.numericSort) }, setXConstraint: function (c, b, a) { this.leftConstraint = c; this.rightConstraint = b; this.minX = this.initPageX - c; this.maxX = this.initPageX + b; if (a) { this.setXTicks(this.initPageX, a) } this.constrainX = true }, clearConstraints: function () { this.constrainX = false; this.constrainY = false; this.clearTicks() }, clearTicks: function () { this.xTicks = null; this.yTicks = null; this.xTickSize = 0; this.yTickSize = 0 }, setYConstraint: function (a, c, b) { this.topConstraint = a; this.bottomConstraint = c; this.minY = this.initPageY - a; this.maxY = this.initPageY + c; if (b) { this.setYTicks(this.initPageY, b) } this.constrainY = true }, resetConstraints: function () { if (this.initPageX || this.initPageX === 0) { var b = (this.maintainOffset) ? this.lastPageX - this.initPageX : 0, a = (this.maintainOffset) ? this.lastPageY - this.initPageY : 0; this.setInitPosition(b, a) } else { this.setInitPosition() } if (this.constrainX) { this.setXConstraint(this.leftConstraint, this.rightConstraint, this.xTickSize) } if (this.constrainY) { this.setYConstraint(this.topConstraint, this.bottomConstraint, this.yTickSize) } }, getTick: function (h, d) { if (!d) { return h } else { if (d[0] >= h) { return d[0] } else { var b, a, c, g, e; for (b = 0, a = d.length; b < a; ++b) { c = b + 1; if (d[c] && d[c] >= h) { g = h - d[b]; e = d[c] - h; return (e > g) ? d[b] : d[c] } } return d[d.length - 1] } } }, toString: function () { return ("DragDrop " + this.id) } }, 3, 0, 0, 0, 0, 0, [Ext.dd, "DragDrop"], 0)); (Ext.cmd.derive("Ext.dd.DD", Ext.dd.DragDrop, { constructor: function (c, a, b) { if (c) { this.init(c, a, b) } }, scroll: true, autoOffset: function (c, b) { var a = c - this.startPageX, d = b - this.startPageY; this.setDelta(a, d) }, setDelta: function (b, a) { this.deltaX = b; this.deltaY = a }, setDragElPos: function (c, b) { var a = this.getDragEl(); this.alignElWithMouse(a, c, b) }, alignElWithMouse: function (b, e, c) { var g = this.getTargetCoord(e, c), d = b.dom ? b : Ext.fly(b, "_dd"), l = d.getSize(), i = Ext.Element, j, a, k, h; if (!this.deltaSetXY) { j = this.cachedViewportSize = { width: i.getDocumentWidth(), height: i.getDocumentHeight() }; a = [Math.max(0, Math.min(g.x, j.width - l.width)), Math.max(0, Math.min(g.y, j.height - l.height))]; d.setXY(a); k = this.getLocalX(d); h = d.getLocalY(); this.deltaSetXY = [k - g.x, h - g.y] } else { j = this.cachedViewportSize; this.setLocalXY(d, Math.max(0, Math.min(g.x + this.deltaSetXY[0], j.width - l.width)), Math.max(0, Math.min(g.y + this.deltaSetXY[1], j.height - l.height))) } this.cachePosition(g.x, g.y); this.autoScroll(g.x, g.y, b.offsetHeight, b.offsetWidth); return g }, cachePosition: function (b, a) { if (b) { this.lastPageX = b; this.lastPageY = a } else { var c = Ext.fly(this.getEl()).getXY(); this.lastPageX = c[0]; this.lastPageY = c[1] } }, autoScroll: function (l, k, e, m) { if (this.scroll) { var n = Ext.Element.getViewportHeight(), b = Ext.Element.getViewportWidth(), p = this.DDMInstance.getScrollTop(), d = this.DDMInstance.getScrollLeft(), j = e + k, o = m + l, i = (n + p - k - this.deltaY), g = (b + d - l - this.deltaX), c = 40, a = (document.all) ? 80 : 30; if (j > n && i < c) { window.scrollTo(d, p + a) } if (k < p && p > 0 && k - p < c) { window.scrollTo(d, p - a) } if (o > b && g < c) { window.scrollTo(d + a, p) } if (l < d && d > 0 && l - d < c) { window.scrollTo(d - a, p) } } }, getTargetCoord: function (c, b) { var a = c - this.deltaX, d = b - this.deltaY; if (this.constrainX) { if (a < this.minX) { a = this.minX } if (a > this.maxX) { a = this.maxX } } if (this.constrainY) { if (d < this.minY) { d = this.minY } if (d > this.maxY) { d = this.maxY } } a = this.getTick(a, this.xTicks); d = this.getTick(d, this.yTicks); return { x: a, y: d } }, applyConfig: function () { Ext.dd.DragDrop.prototype.applyConfig.call(this); this.scroll = (this.config.scroll !== false) }, b4MouseDown: function (b) { var a = b.getXY(); this.autoOffset(a[0], a[1]) }, b4Drag: function (b) { var a = b.getXY(); this.setDragElPos(a[0], a[1]) }, toString: function () { return ("DD " + this.id) }, getLocalX: function (a) { return a.getLocalX() }, setLocalXY: function (b, a, c) { b.setLocalXY(a, c) } }, 3, 0, 0, 0, 0, 0, [Ext.dd, "DD"], 0)); (Ext.cmd.derive("Ext.dd.DDProxy", Ext.dd.DD, { statics: { dragElId: "ygddfdiv" }, constructor: function (c, a, b) { if (c) { this.init(c, a, b); this.initFrame() } }, resizeFrame: true, centerFrame: false, createFrame: function () { var b = this, a = document.body, d, c; if (!a || !a.firstChild) { Ext.defer(function () { b.createFrame() }, 50); return } d = this.getDragEl(); if (!d) { d = document.createElement("div"); d.id = this.dragElId; d.setAttribute("role", "presentation"); c = d.style; c.position = "absolute"; c.visibility = "hidden"; c.cursor = "move"; c.border = "2px solid #aaa"; c.zIndex = 999; a.insertBefore(d, a.firstChild) } }, initFrame: function () { this.createFrame() }, applyConfig: function () { Ext.dd.DD.prototype.applyConfig.call(this); this.resizeFrame = (this.config.resizeFrame !== false); this.centerFrame = (this.config.centerFrame); this.setDragElId(this.config.dragElId || Ext.dd.DDProxy.dragElId) }, showFrame: function (e, d) { var c = this, a = c.getDragEl(), b = a.style; c._resizeProxy(); if (c.centerFrame) { c.setDelta(Math.round(parseInt(b.width, 10) / 2), Math.round(parseInt(b.height, 10) / 2)) } c.setDragElPos(e, d); Ext.fly(a).show() }, _resizeProxy: function () { if (this.resizeFrame) { var a = this.getEl(); Ext.fly(this.getDragEl()).setSize(a.offsetWidth, a.offsetHeight) } }, b4MouseDown: function (c) { var b = c.getXY(), a = b[0], d = b[1]; this.autoOffset(a, d); this.setDragElPos(a, d) }, b4StartDrag: function (a, b) { this.showFrame(a, b) }, b4EndDrag: function (a) { Ext.fly(this.getDragEl()).hide() }, endDrag: function (c) { var b = this.getEl(), a = this.getDragEl(); a.style.visibility = ""; this.beforeMove(); b.style.visibility = "hidden"; Ext.dd.DDM.moveToEl(b, a); a.style.visibility = "hidden"; b.style.visibility = ""; this.afterDrag() }, beforeMove: function () { }, afterDrag: function () { }, toString: function () { return ("DDProxy " + this.id) } }, 3, 0, 0, 0, 0, 0, [Ext.dd, "DDProxy"], 0)); (Ext.cmd.derive("Ext.dd.StatusProxy", Ext.Component, { animRepair: false, childEls: ["ghost"], renderTpl: ['<div class="x-dd-drop-icon" role="presentation"></div><div id="{id}-ghost" data-ref="ghost" class="x-dd-drag-ghost" role="presentation"></div>'], repairCls: "x-dd-drag-repair", ariaRole: "presentation", skipLayout: true, alignOnScroll: false, constructor: function (a) { var b = this; a = a || {}; Ext.apply(b, { hideMode: "visibility", hidden: true, floating: true, id: b.id || Ext.id(), cls: "x-dd-drag-proxy " + this.dropNotAllowed, shadow: a.shadow || false, renderTo: Ext.getDetachedBody() }); Ext.Component.prototype.constructor.apply(this, arguments); this.dropStatus = this.dropNotAllowed }, dropAllowed: "x-dd-drop-ok", dropNotAllowed: "x-dd-drop-nodrop", setStatus: function (a) { a = a || this.dropNotAllowed; if (this.dropStatus !== a) { this.el.replaceCls(this.dropStatus, a); this.dropStatus = a } }, reset: function (b) { var c = this, a = "x-dd-drag-proxy "; c.el.replaceCls(a + c.dropAllowed, a + c.dropNotAllowed); c.dropStatus = c.dropNotAllowed; if (b) { c.ghost.setHtml("") } }, update: function (a) { if (typeof a === "string") { this.ghost.setHtml(a) } else { this.ghost.setHtml(""); a.style.margin = "0"; this.ghost.dom.appendChild(a) } var b = this.ghost.dom.firstChild; if (b) { Ext.fly(b).setStyle("float", "none") } }, getGhost: function () { return this.ghost }, hide: function (a) { Ext.Component.prototype.hide.call(this); if (a) { this.reset(true) } }, stop: function () { if (this.anim && this.anim.isAnimated && this.anim.isAnimated()) { this.anim.stop() } }, sync: function () { this.el.syncUnderlays() }, repair: function (c, d, a) { var b = this; b.callback = d; b.scope = a; if (c && b.animRepair !== false) { b.el.addCls(b.repairCls); b.el.setUnderlaysVisible(false); b.anim = b.el.animate({ duration: b.repairDuration || 500, easing: "ease-out", to: { x: c[0], y: c[1] }, stopAnimation: true, callback: b.afterRepair, scope: b }) } else { b.afterRepair() } }, afterRepair: function () { var a = this; a.hide(true); a.el.removeCls(a.repairCls); if (typeof a.callback === "function") { a.callback.call(a.scope || a) } delete a.callback; delete a.scope } }, 1, 0, ["component", "box"], { component: true, box: true }, 0, 0, [Ext.dd, "StatusProxy"], 0)); (Ext.cmd.derive("Ext.dd.DragSource", Ext.dd.DDProxy, { dropAllowed: "x-dd-drop-ok", dropNotAllowed: "x-dd-drop-nodrop", animRepair: true, repairHighlightColor: "c3daf9", constructor: function (b, a) { this.el = Ext.get(b); if (!this.dragData) { this.dragData = {} } Ext.apply(this, a); if (!this.proxy) { this.proxy = new Ext.dd.StatusProxy({ id: this.el.id + "-drag-status-proxy", animRepair: this.animRepair }) } Ext.dd.DDProxy.prototype.constructor.call(this, this.el.dom, this.ddGroup || this.group, { dragElId: this.proxy.id, resizeFrame: false, isTarget: false, scroll: this.scroll === true }); this.dragging = false }, getDragData: function (a) { return this.dragData }, onDragEnter: function (c, d) { var b = Ext.dd.DragDropManager.getDDById(d), a; this.cachedTarget = b; if (this.beforeDragEnter(b, c, d) !== false) { if (b.isNotifyTarget) { a = b.notifyEnter(this, c, this.dragData); this.proxy.setStatus(a) } else { this.proxy.setStatus(this.dropAllowed) } if (this.afterDragEnter) { this.afterDragEnter(b, c, d) } } }, beforeDragEnter: function (b, a, c) { return true }, onDragOver: function (c, d) { var b = this.cachedTarget || Ext.dd.DragDropManager.getDDById(d), a; if (this.beforeDragOver(b, c, d) !== false) { if (b.isNotifyTarget) { a = b.notifyOver(this, c, this.dragData); this.proxy.setStatus(a) } if (this.afterDragOver) { this.afterDragOver(b, c, d) } } }, beforeDragOver: function (b, a, c) { return true }, onDragOut: function (b, c) { var a = this.cachedTarget || Ext.dd.DragDropManager.getDDById(c); if (this.beforeDragOut(a, b, c) !== false) { if (a.isNotifyTarget) { a.notifyOut(this, b, this.dragData) } this.proxy.reset(); if (this.afterDragOut) { this.afterDragOut(a, b, c) } } this.cachedTarget = null }, beforeDragOut: function (b, a, c) { return true }, onDragDrop: function (b, c) { var a = this.cachedTarget || Ext.dd.DragDropManager.getDDById(c); if (this.beforeDragDrop(a, b, c) !== false) { if (a.isNotifyTarget) { if (a.notifyDrop(this, b, this.dragData) !== false) { this.onValidDrop(a, b, c) } else { this.onInvalidDrop(a, b, c) } } else { this.onValidDrop(a, b, c) } if (this.afterDragDrop) { this.afterDragDrop(a, b, c) } } delete this.cachedTarget }, beforeDragDrop: function (b, a, c) { return true }, onValidDrop: function (b, a, c) { this.hideProxy(); if (this.afterValidDrop) { this.afterValidDrop(b, a, c) } }, getRepairXY: function (b, a) { return this.el.getXY() }, onInvalidDrop: function (c, b, d) { var a = this; if (!b) { b = c; c = null; d = b.getTarget().id } if (a.beforeInvalidDrop(c, b, d) !== false) { if (a.cachedTarget) { if (a.cachedTarget.isNotifyTarget) { a.cachedTarget.notifyOut(a, b, a.dragData) } a.cacheTarget = null } a.proxy.repair(a.getRepairXY(b, a.dragData), a.afterRepair, a); if (a.afterInvalidDrop) { a.afterInvalidDrop(b, d) } } }, afterRepair: function () { var a = this; if (Ext.enableFx) { a.el.highlight(a.repairHighlightColor) } a.dragging = false }, beforeInvalidDrop: function (b, a, c) { return true }, handleMouseDown: function (b) { if (this.dragging) { return } var a = this.getDragData(b); if (a && this.onBeforeDrag(a, b) !== false) { this.dragData = a; this.proxy.stop(); Ext.dd.DDProxy.prototype.handleMouseDown.apply(this, arguments) } }, onBeforeDrag: function (a, b) { return true }, onStartDrag: Ext.emptyFn, alignElWithMouse: function () { this.proxy.ensureAttachedToBody(true); return Ext.dd.DDProxy.prototype.alignElWithMouse.apply(this, arguments) }, startDrag: function (a, b) { this.proxy.reset(); this.proxy.hidden = false; this.dragging = true; this.proxy.update(""); this.onInitDrag(a, b); this.proxy.show() }, onInitDrag: function (a, c) { var b = this.el.dom.cloneNode(true); b.id = Ext.id(); this.proxy.update(b); this.onStartDrag(a, c); return true }, getProxy: function () { return this.proxy }, hideProxy: function () { this.proxy.hide(); this.proxy.reset(true); this.dragging = false }, triggerCacheRefresh: function () { Ext.dd.DDM.refreshCache(this.groups) }, b4EndDrag: function (a) { }, endDrag: function (a) { this.onEndDrag(this.dragData, a) }, onEndDrag: function (a, b) { }, autoOffset: function (a, b) { this.setDelta(-12, -20) }, destroy: function () { Ext.destroy(this.proxy); Ext.dd.DDProxy.prototype.destroy.call(this) } }, 1, 0, 0, 0, 0, 0, [Ext.dd, "DragSource"], 0)); (Ext.cmd.derive("Ext.panel.Proxy", Ext.Base, { alternateClassName: "Ext.dd.PanelProxy", moveOnDrag: true, constructor: function (a, b) { var c = this; c.panel = a; c.id = c.panel.id + "-ddproxy"; Ext.apply(c, b) }, insertProxy: true, setStatus: Ext.emptyFn, reset: Ext.emptyFn, update: Ext.emptyFn, stop: Ext.emptyFn, sync: Ext.emptyFn, getEl: function () { return this.ghost.el }, getGhost: function () { return this.ghost }, getProxy: function () { return this.proxy }, hide: function () { var a = this; if (a.ghost) { if (a.proxy) { a.proxy.destroy(); delete a.proxy } a.panel.unghost(null, a.moveOnDrag); delete a.ghost } }, show: function () { var b = this, a; if (!b.ghost) { a = b.panel.getSize(); b.panel.el.setVisibilityMode(Ext.Element.DISPLAY); b.ghost = b.panel.ghost(); if (b.insertProxy) { b.proxy = b.panel.el.insertSibling({ role: "presentation", cls: "x-panel-dd-spacer" }); b.proxy.setSize(a) } } }, repair: function (b, c, a) { this.hide(); Ext.callback(c, a || this) }, moveProxy: function (a, b) { if (this.proxy) { a.insertBefore(this.proxy.dom, b) } } }, 1, 0, 0, 0, 0, 0, [Ext.panel, "Proxy", Ext.dd, "PanelProxy"], 0)); (Ext.cmd.derive("Ext.panel.DD", Ext.dd.DragSource, { constructor: function (b, a) { var c = this; c.panel = b; c.dragData = { panel: b }; c.panelProxy = new Ext.panel.Proxy(b, a); c.proxy = c.panelProxy.proxy; Ext.dd.DragSource.prototype.constructor.call(this, b.el, a); c.setupEl(b) }, setupEl: function (a) { var c = this, d = a.header, b = a.body; if (d) { c.setHandleElId(d.id); b = d.el } if (b) { b.setStyle("cursor", "move"); c.scroll = false } else { a.on("boxready", c.setupEl, c, { single: true }) } }, showFrame: Ext.emptyFn, startDrag: Ext.emptyFn, b4StartDrag: function (a, b) { this.panelProxy.show() }, b4MouseDown: function (c) { var b = c.getXY(), a = b[0], d = b[1]; this.autoOffset(a, d) }, onInitDrag: function (a, b) { this.onStartDrag(a, b); return true }, createFrame: Ext.emptyFn, getDragEl: function (b) { var a = this.panelProxy.ghost; if (a) { return a.el.dom } }, endDrag: function (a) { this.panelProxy.hide(); this.panel.saveState() }, autoOffset: function (a, b) { a -= this.startPageX; b -= this.startPageY; this.setDelta(a, b) }, onInvalidDrop: function (c, b, d) { var a = this; if (a.beforeInvalidDrop(c, b, d) !== false) { if (a.cachedTarget) { if (a.cachedTarget.isNotifyTarget) { a.cachedTarget.notifyOut(a, b, a.dragData) } a.cacheTarget = null } if (a.afterInvalidDrop) { a.afterInvalidDrop(b, d) } } } }, 1, 0, 0, 0, 0, 0, [Ext.panel, "DD"], 0)); (Ext.cmd.derive("Ext.layout.component.Dock", Ext.layout.component.Component, { alternateClassName: "Ext.layout.component.AbstractDock", type: "dock", horzAxisProps: { name: "horz", oppositeName: "vert", dockBegin: "left", dockEnd: "right", horizontal: true, marginBegin: "margin-left", maxSize: "maxWidth", minSize: "minWidth", pos: "x", setSize: "setWidth", shrinkWrapDock: "shrinkWrapDockWidth", size: "width", sizeModel: "widthModel" }, vertAxisProps: { name: "vert", oppositeName: "horz", dockBegin: "top", dockEnd: "bottom", horizontal: false, marginBegin: "margin-top", maxSize: "maxHeight", minSize: "minHeight", pos: "y", setSize: "setHeight", shrinkWrapDock: "shrinkWrapDockHeight", size: "height", sizeModel: "heightModel" }, initializedBorders: -1, horizontalCollapsePolicy: { width: true, x: true }, verticalCollapsePolicy: { height: true, y: true }, finishRender: function () { var b = this, c, a; Ext.layout.component.Component.prototype.finishRender.call(this); c = b.getRenderTarget(); a = b.getDockedItems(); b.finishRenderItems(c, a) }, isItemBoxParent: function (a) { return true }, isItemShrinkWrap: function (a) { return true }, noBorderClasses: ["x-docked-noborder-top", "x-docked-noborder-right", "x-docked-noborder-bottom", "x-docked-noborder-left"], noBorderClassesSides: { top: "x-docked-noborder-top", right: "x-docked-noborder-right", bottom: "x-docked-noborder-bottom", left: "x-docked-noborder-left" }, borderWidthProps: { top: "border-top-width", right: "border-right-width", bottom: "border-bottom-width", left: "border-left-width" }, _itemCls: "x-docked", handleItemBorders: function () { var m = this, a = m.owner, l, q, h = m.lastDockedItems, g = m.borders, b = a.dockedItems.generation, c = m.noBorderClassesSides, n = m.borderWidthProps, e, k, p, o, j, d = m.collapsed; if (m.initializedBorders === b || (a.border && !a.manageBodyBorders) || (a.collapsed && a.collapseMode === "mini")) { return } m.initializedBorders = b; m.collapsed = false; m.lastDockedItems = q = m.getLayoutItems(); m.collapsed = d; l = { top: [], right: [], bottom: [], left: [] }; for (e = 0, k = q.length; e < k; e++) { p = q[e]; o = p.dock; if (p.ignoreBorderManagement) { continue } if (!l[o].satisfied) { l[o].push(p); l[o].satisfied = true } if (!l.top.satisfied && o !== "bottom") { l.top.push(p) } if (!l.right.satisfied && o !== "left") { l.right.push(p) } if (!l.bottom.satisfied && o !== "top") { l.bottom.push(p) } if (!l.left.satisfied && o !== "right") { l.left.push(p) } } if (h) { for (e = 0, k = h.length; e < k; e++) { p = h[e]; if (!p.destroyed && !p.ignoreBorderManagement && !a.manageBodyBorders) { p.removeCls(m.noBorderClasses) } } } if (g) { for (j in g) { if (a.manageBodyBorders && g[j].satisfied) { a.setBodyStyle(n[j], "") } } } for (j in l) { k = l[j].length; if (!a.manageBodyBorders) { for (e = 0; e < k; e++) { l[j][e].addCls(c[j]) } if ((!l[j].satisfied && !a.bodyBorder) || a.bodyBorder === false) { a.addBodyCls(c[j]) } else { a.removeBodyCls(c[j]) } } else { if (l[j].satisfied) { a.setBodyStyle(n[j], "1px") } } } m.borders = l }, beforeLayoutCycle: function (g) { var c = this, b = c.owner, h = c.sizeModels.shrinkWrap, e = b.shrinkWrapDock, d, a; if (b.collapsed) { if (b.collapsedVertical()) { a = true; g.measureDimensions = 1 } else { d = true; g.measureDimensions = 2 } } g.collapsedVert = a; g.collapsedHorz = d; if (a) { g.heightModel = h } else { if (d) { g.widthModel = h } } e = e === true ? 3 : (e || 0); g.shrinkWrapDockHeight = (e & 1) && g.heightModel.shrinkWrap; g.shrinkWrapDockWidth = (e & 2) && g.widthModel.shrinkWrap }, beginLayout: function (d) { var l = this, c = l.owner, p = l.getLayoutItems(), b = d.context, g = p.length, k = l.lastCollapsedState, m, j, o, a, e, h, n; Ext.layout.component.Component.prototype.beginLayout.apply(this, arguments); h = c.getCollapsed(); if (h !== k && k !== undefined) { if (l.owner.collapsed) { d.isCollapsingOrExpanding = 1; c.addClsWithUI(c.collapsedCls) } else { d.isCollapsingOrExpanding = 2; c.removeClsWithUI(c.collapsedCls); d.lastCollapsedState = l.lastCollapsedState } } l.lastCollapsedState = h; d.dockedItems = m = []; for (j = 0; j < g; j++) { o = p[j]; if (o.rendered) { n = o.dock; a = b.getCmp(o); a.dockedAt = { x: 0, y: 0 }; a.offsets = e = Ext.Element.parseBox(o.offsets || 0); a.horizontal = n === "top" || n === "bottom"; e.width = e.left + e.right; e.height = e.top + e.bottom; m.push(a) } } d.bodyContext = d.getEl("body") }, beginLayoutCycle: function (b) { var e = this, l = b.dockedItems, d = l.length, a = e.owner, g = a.frameBody, k = e.lastHeightModel, c, j, h; Ext.layout.component.Component.prototype.beginLayoutCycle.apply(this, arguments); if (e.owner.manageHeight) { if (e.lastBodyDisplay) { a.body.dom.style.display = e.lastBodyDisplay = "" } } else { if (e.lastBodyDisplay !== "inline-block") { a.body.dom.style.display = e.lastBodyDisplay = "inline-block" } if (k && k.shrinkWrap && !b.heightModel.shrinkWrap) { a.body.dom.style.marginBottom = "" } } if (b.widthModel.auto) { if (b.widthModel.shrinkWrap) { a.el.setWidth(null) } a.body.setWidth(null); if (g) { g.setWidth(null) } } if (b.heightModel.auto) { a.body.setHeight(null); if (g) { g.setHeight(null) } } if (b.collapsedVert) { b.setContentHeight(0) } else { if (b.collapsedHorz) { b.setContentWidth(0) } } for (c = 0; c < d; c++) { j = l[c].target; h = j.dock; if (h === "right") { j.setLocalX(0) } else { if (h !== "left") { continue } } } }, calculate: function (d) { var l = this, c = l.measureAutoDimensions(d, d.measureDimensions), b = d.state, k = b.horzDone, e = b.vertDone, g = d.bodyContext, j, a, i, h, m; d.borderInfo || d.getBorderInfo(); d.paddingInfo || d.getPaddingInfo(); d.frameInfo || d.getFrameInfo(); g.borderInfo || g.getBorderInfo(); g.paddingInfo || g.getPaddingInfo(); if (!d.frameBorder) { if (!(j = d.framing)) { d.frameBorder = d.borderInfo; d.framePadding = d.paddingInfo } else { d.frameBorder = j.border; d.framePadding = j.padding } } a = !k && l.createAxis(d, c.contentWidth, d.widthModel, l.horzAxisProps, d.collapsedHorz); i = !e && l.createAxis(d, c.contentHeight, d.heightModel, l.vertAxisProps, d.collapsedVert); for (h = 0, m = d.dockedItems.length; m--; ++h) { if (a) { l.dockChild(d, a, m, h) } if (i) { l.dockChild(d, i, m, h) } } if (a && l.finishAxis(d, a)) { b.horzDone = k = a } if (i && l.finishAxis(d, i)) { b.vertDone = e = i } if (k && e && l.finishConstraints(d, k, e)) { l.finishPositions(d, k, e) } else { l.done = false } }, createAxis: function (p, j, e, m, d) { var u = this, t = 0, b = u.owner, g = b[m.maxSize], c = b[m.minSize] || 0, n = m.dockBegin, i = m.dockEnd, r = m.pos, l = m.size, k = g != null, o = e.shrinkWrap, a, s, q, h; if (o) { if (d) { h = 0 } else { a = p.bodyContext; h = j + a.borderInfo[l] } } else { s = p.frameBorder; q = p.framePadding; t = s[n] + q[n]; h = p.getProp(l) - (s[i] + q[i]) } return { shrinkWrap: e.shrinkWrap, sizeModel: e, initialBegin: t, begin: t, end: h, collapsed: d, horizontal: m.horizontal, ignoreFrameBegin: null, ignoreFrameEnd: null, initialSize: h - t, maxChildSize: 0, hasMinMaxConstraints: (c || k) && e.shrinkWrap, minSize: c, maxSize: k ? g : 1000000000, bodyPosProp: u.owner.manageHeight ? r : m.marginBegin, dockBegin: n, dockEnd: i, posProp: r, sizeProp: l, setSize: m.setSize, shrinkWrapDock: p[m.shrinkWrapDock], sizeModelName: m.sizeModel, dockedPixelsEnd: 0 } }, dockChild: function (b, c, l, e) { var g = this, a = b.dockedItems[c.shrinkWrap ? l : e], i = a.target, j = i.dock, d = c.sizeProp, h, k; if (i.ignoreParentFrame && b.isCollapsingOrExpanding) { a.clearMarginCache() } if (!a.marginInfo) { a.getMarginInfo() } if (j === c.dockBegin) { if (c.shrinkWrap) { h = g.dockOutwardBegin(b, a, i, c) } else { h = g.dockInwardBegin(b, a, i, c) } } else { if (j === c.dockEnd) { if (c.shrinkWrap) { h = g.dockOutwardEnd(b, a, i, c) } else { h = g.dockInwardEnd(b, a, i, c) } } else { if (c.shrinkWrapDock) { k = a.getProp(d) + a.marginInfo[d]; c.maxChildSize = Math.max(c.maxChildSize, k); h = 0 } else { h = g.dockStretch(b, a, i, c) } } } a.dockedAt[c.posProp] = h }, dockInwardBegin: function (b, a, j, d) { var g = d.begin, e = d.sizeProp, c = j.ignoreParentFrame, h, k, i; if (c) { d.ignoreFrameBegin = a; i = j.dock; h = b.frameBorder[i]; g -= h + b.framePadding[i] } if (!j.overlay) { k = a.getProp(e) + a.marginInfo[e]; d.begin += k; if (c) { d.begin -= h } } return g }, dockInwardEnd: function (e, d, c, b) { var i = b.sizeProp, a = d.getProp(i) + d.marginInfo[i], h = b.end - a, g; if (!c.overlay) { b.end = h } if (c.ignoreParentFrame) { b.ignoreFrameEnd = d; g = e.frameBorder[c.dock]; h += g + e.framePadding[c.dock]; b.end += g } return h }, dockOutwardBegin: function (e, d, c, b) { var h = b.begin, g = b.sizeProp, a; if (b.collapsed) { b.ignoreFrameBegin = b.ignoreFrameEnd = d } else { if (c.ignoreParentFrame) { b.ignoreFrameBegin = d } } if (!c.overlay) { a = d.getProp(g) + d.marginInfo[g]; h -= a; b.begin = h } return h }, dockOutwardEnd: function (e, d, c, b) { var h = b.end, g = b.sizeProp, a; a = d.getProp(g) + d.marginInfo[g]; if (b.collapsed) { b.ignoreFrameBegin = b.ignoreFrameEnd = d } else { if (c.ignoreParentFrame) { b.ignoreFrameEnd = d } } if (!c.overlay) { b.end = h + a; b.dockedPixelsEnd += a } return h }, dockStretch: function (c, b, m, d) { var n = m.dock, j = d.sizeProp, a = n === "top" || n === "bottom", i = c.frameBorder, e = b.offsets, l = c.framePadding, h = a ? "right" : "bottom", p = a ? "left" : "top", k = d.begin + e[p], g, o; if (m.stretch !== false) { o = d.end - k - e[h]; if (m.ignoreParentFrame) { k -= l[p] + i[p]; o += l[j] + i[j] } g = b.marginInfo; o -= g[j]; b[d.setSize](o) } return k }, finishAxis: function (m, e) { if (isNaN(e.maxChildSize)) { return false } var d = e.begin, p = e.end - d, h = e.collapsed, w = e.setSize, k = e.dockBegin, u = e.dockEnd, o = m.framePadding, r = m.frameBorder, g = r[k], s = m.framing, n = s && s[k], b = h ? 0 : o[k], j = e.sizeProp, t = e.ignoreFrameBegin, q = e.ignoreFrameEnd, a = m.bodyContext, l = Math.max(g + b - n, 0), c, x, v, i; if (e.shrinkWrap) { x = e.initialSize; if (s) { v = -d + g + b; c = v - n - l } else { c = -d; v = c + b } if (!h) { p += o[j] } if (t) { v -= g; c -= g; t.dockedAt[e.posProp] -= b } else { p += g } if (h) { } else { if (q) { q.dockedAt[e.posProp] += o[u] } else { p += r[u] } } e.size = p; if (!e.horizontal && !this.owner.manageHeight) { i = false } } else { if (s) { v = 0; c = d - n - l } else { v = -g; c = d - b - g } x = p } e.delta = v; a[w](x, i); a.setProp(e.bodyPosProp, c); return !isNaN(p) }, beforeInvalidateShrinkWrapDock: function (c, b) { var a = b.axis.sizeModelName; if (!c[a].constrainedMin) { c[a] = Ext.layout.SizeModel.calculated } }, afterInvalidateShrinkWrapDock: function (d, a) { var b = a.axis, c = a.layout, e; if (d[b.sizeModelName].calculated) { e = c.dockStretch(a.ownerContext, d, d.target, b); d.setProp(b.posProp, b.delta + e) } }, finishConstraints: function (k, c, p) { var s = this, r = s.sizeModels, o = c.shrinkWrap, q = p.shrinkWrap, a = s.owner, i, m, n, g, h, l, b, d, e, j; if (o) { l = c.size; b = c.collapsed ? 0 : c.minSize; d = c.maxSize; e = c.maxChildSize; j = Math.max(l, e); if (j > d) { h = r.constrainedMax; n = d } else { if (j < b) { h = r.constrainedMin; n = b } else { if (l < e) { h = r.constrainedDock; a.dockConstrainedWidth = n = e } else { n = l } } } } if (q) { l = p.size; b = p.collapsed ? 0 : p.minSize; d = p.maxSize; e = p.maxChildSize; j = Math.max(l, e + l - p.initialSize); if (j > d) { g = r.constrainedMax; m = d } else { if (j < b) { g = r.constrainedMin; m = b } else { if (l < e) { g = r.constrainedDock; a.dockConstrainedHeight = m = e } else { if (!k.collapsedVert && !a.manageHeight) { i = false; k.bodyContext.setProp("margin-bottom", p.dockedPixelsEnd) } m = l } } } } if (h || g) { if (h && g && h.constrainedMax && g.constrainedByMin) { k.invalidate({ widthModel: h }); return false } if (!k.widthModel.calculatedFromShrinkWrap && !k.heightModel.calculatedFromShrinkWrap) { k.invalidate({ widthModel: h, heightModel: g }); return false } } else { s.invalidateAxes(k, c, p) } if (o) { k.setWidth(n); if (h) { k.widthModel = h } } if (q) { k.setHeight(m, i); if (g) { k.heightModel = g } } return true }, invalidateAxes: function (g, a, l) { var p = this.beforeInvalidateShrinkWrapDock, b = this.afterInvalidateShrinkWrapDock, e = a.end - a.begin, s = l.initialSize, c = a.shrinkWrapDock && a.maxChildSize <= e, m = l.shrinkWrapDock && l.maxChildSize <= s, q, n, k, d, r, o, h, j; if (c || m) { if (m) { l.begin = l.initialBegin; l.end = l.begin + l.initialSize } q = g.dockedItems; for (k = 0, n = q.length; k < n; ++k) { d = q[k]; o = d.horizontal; h = null; if (c && o) { j = a.sizeProp; r = e; h = a } else { if (m && !o) { j = l.sizeProp; r = s; h = l } } if (h) { r -= d.getMarginInfo()[j]; if (r !== d.props[j]) { d.invalidate({ before: p, after: b, axis: h, ownerContext: g, layout: this }) } } } } }, finishPositions: function (d, a, h) { var j = d.dockedItems, c = j.length, g = a.delta, e = h.delta, i, b; for (i = 0; i < c; ++i) { b = j[i]; b.setProp("x", g + b.dockedAt.x); b.setProp("y", e + b.dockedAt.y) } }, finishedLayout: function (b) { var a = this, c = b.target; Ext.layout.component.Component.prototype.finishedLayout.apply(this, arguments); if (!b.animatePolicy) { if (b.isCollapsingOrExpanding === 1) { c.afterCollapse(false) } else { if (b.isCollapsingOrExpanding === 2) { c.afterExpand(false) } } } }, getAnimatePolicy: function (c) { var b = this, a, d; if (c.isCollapsingOrExpanding === 1) { a = b.lastCollapsedState } else { if (c.isCollapsingOrExpanding === 2) { a = c.lastCollapsedState } } if (a === "left" || a === "right") { d = b.horizontalCollapsePolicy } else { if (a === "top" || a === "bottom") { d = b.verticalCollapsePolicy } } return d }, getDockedItems: function (c, n) { var j = this, e = (c === "visual"), k = e ? Ext.ComponentQuery.query("[rendered]", j.owner.dockedItems.items) : j.owner.dockedItems.items, h = k && k.length && c !== false, b, m, l, g, d, a; if (n == null) { l = h && !e ? k.slice() : k } else { l = []; for (g = 0, a = k.length; g < a; ++g) { m = k[g].dock; d = (m === "top" || m === "left"); if (n ? d : !d) { l.push(k[g]) } } h = h && l.length } if (h) { b = (c = c || "render") === "render"; Ext.Array.sort(l, function (o, i) { var p, q; if (b && ((p = j.owner.dockOrder[o.dock]) !== (q = j.owner.dockOrder[i.dock]))) { if (!(p + q)) { return p - q } } p = j.getItemWeight(o, c); q = j.getItemWeight(i, c); if ((p !== undefined) && (q !== undefined)) { return p - q } return 0 }) } return l || [] }, getItemWeight: function (b, a) { var c = b.weight || this.owner.defaultDockWeights[b.dock]; return c[a] || c }, getLayoutItems: function () { var e = this, b, g, d, c, a; if (e.owner.collapsed) { a = e.owner.getCollapsedDockedItems() } else { b = e.getDockedItems("visual"); g = b.length; a = []; for (c = 0; c < g; c++) { d = b[c]; if (!d.hidden) { a.push(d) } } } return a }, measureContentWidth: function (a) { var b = a.bodyContext; return b.el.getWidth() - b.getBorderInfo().width }, measureContentHeight: function (a) { var b = a.bodyContext; return b.el.getHeight() - b.getBorderInfo().height }, redoLayout: function (c) { var b = this, a = b.owner; if (c.isCollapsingOrExpanding === 1) { if (a.reExpander) { a.reExpander.el.show() } a.addClsWithUI(a.collapsedCls); c.redo(true) } else { if (c.isCollapsingOrExpanding === 2) { a.removeClsWithUI(a.collapsedCls); c.bodyContext.redo() } } }, getRenderTarget: function () { return this.owner.bodyWrap }, renderChildren: function () { var b = this, a = b.getDockedItems(), c = b.getRenderTarget(); b.handleItemBorders(); b.renderItems(a, c) }, renderItems: function (m, z) { var y = this, a = y.owner, e = {}, v = m.length, l = a.body.dom, g = a.bodyWrap.dom, b = !!a.frameSize, u = a.bodyContainer, d, r, c, x, t, k, o, j, q, h, p, s, w, n; if (v) { for (s = 0; s < v; s++) { x = m[s]; e[x.id] = x; if (x.dockToEl) { c = true } } d = y.getRenderTarget().dom.childNodes; r = d.length; o = 0; for (s = 0; s < r; ++s) { t = d[s]; k = t === l; if (k) { j = s; break } if (e[t.id]) { ++o } } j -= o; if (c) { k = false; o = 0; d = a.el.dom.childNodes; r = d.length; for (s = 0; s < r; s++) { t = d[s]; if (b) { k = t === g || t === u; if (!k && Ext.fly(t).contains(g)) { k = true; a.bodyContainer = t } } else { k = t === g } if (k) { h = s; break } if (e[t.id]) { ++o } } h -= o } q = p = 0; for (s = 0; s < v; s++) { x = m[s]; if (x.dockToEl) { n = a.el; w = h + p++; if (x.dock === "right" || x.dock === "bottom") { w++; if (b) { w++ } } else { if (b && w > 0) { w-- } } } else { n = z; w = j + q++; if (x.dock === "right" || x.dock === "bottom") { w++ } } if (!x.rendered) { y.renderItem(x, n, w) } else { if (!y.isValidParent(x, n, w)) { y.moveItem(x, n, w) } } } } }, undoLayout: function (c) { var b = this, a = b.owner; if (c.isCollapsingOrExpanding === 1) { if (a.reExpander) { a.reExpander.el.hide() } a.removeClsWithUI(a.collapsedCls); c.undo(true) } else { if (c.isCollapsingOrExpanding === 2) { a.addClsWithUI(a.collapsedCls); c.bodyContext.undo() } } }, sizePolicy: { nostretch: { setsWidth: 0, setsHeight: 0 }, horz: { shrinkWrap: { setsWidth: 1, setsHeight: 0, readsWidth: 1 }, stretch: { setsWidth: 1, setsHeight: 0 } }, vert: { shrinkWrap: { setsWidth: 0, setsHeight: 1, readsHeight: 1 }, stretch: { setsWidth: 0, setsHeight: 1 } }, stretchV: { setsWidth: 0, setsHeight: 1 }, autoStretchH: { readsWidth: 1, setsWidth: 1, setsHeight: 0 }, autoStretchV: { readsHeight: 1, setsWidth: 0, setsHeight: 1 } }, getItemSizePolicy: function (d, g) { var c = this, h = c.sizePolicy, e = c.owner.shrinkWrapDock, b, a; if (d.stretch === false) { return h.nostretch } b = d.dock; a = (b === "left" || b === "right"); e = e === true ? 3 : (e || 0); if (a) { h = h.vert; e = e & 1 } else { h = h.horz; e = e & 2 } if (e) { if (!g) { g = c.owner.getSizeModel() } if (g[a ? "height" : "width"].shrinkWrap) { return h.shrinkWrap } } return h.stretch }, configureItem: function (a, b) { Ext.layout.component.Component.prototype.configureItem.apply(this, arguments); a.addCls(this._itemCls); if (!a.ignoreBorderManagement) { a.addClsWithUI(this.getDockCls(a.dock)) } }, getDockCls: function (a) { return "docked-" + a }, afterRemove: function (a) { var b; Ext.layout.component.Component.prototype.afterRemove.apply(this, arguments); a.removeCls(this._itemCls); if (!a.ignoreBorderManagement) { a.removeClsWithUI(this.getDockCls(a.dock)) } b = a.el.dom; if (!a.destroying && b) { b.parentNode.removeChild(b) } this.childrenChanged = true }, borderCollapseMap: {}, getBorderCollapseTable: function () { var d = this, g = d.borderCollapseMap, a = d.owner, b = a.baseCls, e = a.ui, c; g = g[b] || (g[b] = {}); c = g[e]; if (!c) { b += "-" + e + "-outer-border-"; g[e] = c = [0, b + "l", b + "b", b + "bl", b + "r", b + "rl", b + "rb", b + "rbl", b + "t", b + "tl", b + "tb", b + "tbl", b + "tr", b + "trl", b + "trb", b + "trbl"] } return c } }, 0, 0, 0, 0, ["layout.dock"], 0, [Ext.layout.component, "Dock", Ext.layout.component, "AbstractDock"], 0)); (Ext.cmd.derive("Ext.util.Memento", Ext.Base, (function () { function d(i, h, j, g) { i[g ? g + j : j] = h[j] } function c(h, g, i) { delete h[i] } function e(k, j, l, i) { var g = i ? i + l : l, h = k[g]; if (h || k.hasOwnProperty(g)) { a(j, l, h) } } function a(h, i, g) { if (Ext.isDefined(g)) { h[i] = g } else { delete h[i] } } function b(h, m, l, i, j) { if (m) { if (Ext.isArray(i)) { var k, g = i.length; for (k = 0; k < g; k++) { h(m, l, i[k], j) } } else { h(m, l, i, j) } } } return { data: null, target: null, constructor: function (h, g) { this.data = {}; if (h) { this.target = h; if (g) { this.capture(g) } } }, capture: function (g, j, i) { var h = this; b(d, h.data || (h.data = {}), j || h.target, g, i) }, remove: function (g) { b(c, this.data, null, g) }, restore: function (h, g, j, i) { b(e, this.data, j || this.target, h, i); if (g !== false) { this.remove(h) } }, restoreAll: function (g, k) { var i = this, h = k || this.target, j = i.data, l; g = g !== false; for (l in j) { if (j.hasOwnProperty(l)) { a(h, l, j[l]); if (g) { delete j[l] } } } } } }()), 1, 0, 0, 0, 0, 0, [Ext.util, "Memento"], 0)); (Ext.cmd.derive("Ext.container.DockingContainer", Ext.Base, { isDockingContainer: true, defaultDockWeights: { top: { render: 1, visual: 1 }, left: { render: 3, visual: 5 }, right: { render: 5, visual: 7 }, bottom: { render: 7, visual: 3 } }, dockOrder: { top: -1, left: -1, right: 1, bottom: 1 }, horizontalDocks: 0, addDocked: function (g, k) { var j = this, b = j.rendered, c = 0, l = j.dockedItems, d = l.getCount(), e, h, m, a; g = j.prepareItems(g); a = g.length; if (b) { Ext.suspendLayouts() } if (k === undefined) { k = d } else { k = Math.min(k, d) } for (; c < a; c++) { m = g[c]; m.dock = m.dock || "top"; if (m.dock === "left" || m.dock === "right") { j.horizontalDocks++ } e = k + c; l.insert(e, m); h = !!m.instancedCmp; delete m.instancedCmp; m.onAdded(j, e, h); delete m.$initParent; if (j.onDockedAdd !== Ext.emptyFn) { j.onDockedAdd(m) } if (j.hasListeners.dockedadd) { j.fireEvent("dockedadd", j, m, e) } } if (j.rendered) { j.updateLayout(); Ext.resumeLayouts(true) } return g }, destroyDockedItems: function () { var a = this.dockedItems, b; if (a) { while ((b = a.first())) { this.removeDocked(b, true) } } }, doRenderDockedItems: function (d, h, i) { var g = h.$comp, e = g.componentLayout, c = g.tabGuard && g.lookupTpl("tabGuardTpl"), b, a; if (e.getDockedItems) { b = e.getDockedItems("render", !i); a = b && e.getItemsRenderTree(b); if (a) { Ext.DomHelper.generateMarkup(a, d) } } }, getDockedComponent: function (a) { if (Ext.isObject(a)) { a = a.getItemId() } return this.dockedItems.get(a) }, getDockedItems: function (a, c) { var b = this.getComponentLayout().getDockedItems("render", c); if (a && b.length) { b = Ext.ComponentQuery.query(a, b) } return b }, getDockingRefItems: function (b, e) { var a = b && "*,* *", d = this.getDockedItems(a, true), c; d.push.apply(d, e); c = this.getDockedItems(a, false); d.push.apply(d, c); return d }, initDockingItems: function () { var b = this, a = b.dockedItems; if (!a || !a.isMixedCollection) { b.dockedItems = new Ext.util.ItemCollection(); if (a) { b.addDocked(a) } } }, insertDocked: function (b, a) { this.addDocked(a, b) }, onDockedAdd: Ext.emptyFn, onDockedRemove: Ext.emptyFn, removeDocked: function (e, b) { var d = this, c, a; b = b === true || (b !== false && d.autoDestroy); if (!d.dockedItems.contains(e)) { return e } if (e.dock === "left" || e.dock === "right") { d.horizontalDocks-- } c = d.componentLayout; a = c && d.rendered; if (a) { c.onRemove(e) } d.dockedItems.remove(e); e.onRemoved(e.destroying || b); d.onDockedRemove(e); if (b) { e.destroy() } else { if (a) { c.afterRemove(e) } } if (d.hasListeners.dockedremove) { d.fireEvent("dockedremove", d, e) } if (!d.destroying) { d.updateLayout() } return e }, moveDocked: function (c, a) { var b = this; if (b.rendered) { Ext.suspendLayouts() } b.removeDocked(c, false); c.dock = a; b.addDocked(c); if (b.rendered) { if (c.frame) { Ext.getDetachedBody().appendChild(c.el); c.updateFrame() } Ext.resumeLayouts(true) } }, setupDockingRenderTpl: function (a) { a.renderDockedItems = this.doRenderDockedItems } }, 0, 0, 0, 0, 0, 0, [Ext.container, "DockingContainer"], 0)); (Ext.cmd.derive("Ext.panel.Panel", Ext.container.Container, { alternateClassName: "Ext.Panel", childEls: ["bodyWrap", "body"], renderTpl: ['<tpl if="headingText">', '<div id="{id}-headingEl" data-ref="headingEl" role="heading"', ' class="', "x-", 'hidden-clip" style="height:0">', "{headingText}", "</div>", "</tpl>", "<tpl if=\"hasTabGuard\">{% this.renderTabGuard(out, values, 'before'); %}</tpl>", '<div id="{id}-bodyWrap" data-ref="bodyWrap" class="{baseCls}-bodyWrap"', '<tpl if="bodyWrapAriaAttributes">', '<tpl foreach="bodyWrapAriaAttributes"> {$}="{.}"</tpl>', "<tpl else>", ' role="presentation"', "</tpl>", ">", "{% this.renderDockedItems(out,values,0); %}", '<div id="{id}-body" data-ref="body" class="{baseCls}-body<tpl if="bodyCls"> {bodyCls}</tpl>', ' {baseCls}-body-{ui}<tpl if="uiCls">', '<tpl for="uiCls"> {parent.baseCls}-body-{parent.ui}-{.}</tpl>', '</tpl>{childElCls}"', '<tpl if="bodyAriaAttributes">', '<tpl foreach="bodyAriaAttributes"> {$}="{.}"</tpl>', "<tpl else>", ' role="presentation"', "</tpl>", '<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>', "{%this.renderContainer(out,values);%}", "</div>", "{% this.renderDockedItems(out,values,1); %}", "</div>", "<tpl if=\"hasTabGuard\">{% this.renderTabGuard(out, values, 'after'); %}</tpl>"], headerPosition: "top", iconAlign: "left", titleAlign: "left", titleRotation: "default", beforeRenderConfig: { glyph: null, headerPosition: null, icon: null, iconAlign: null, iconCls: null, title: null, titleAlign: null, titleRotation: null }, animCollapse: Ext.enableFx, border: true, closable: false, closeAction: "destroy", closeToolText: "Close panel", collapsed: false, collapsedCls: "collapsed", collapseFirst: true, collapsible: undefined, collapseToolText: "Collapse panel", expandToolText: "Expand panel", constrain: false, constrainHeader: false, dockedItems: null, tbar: null, bbar: null, fbar: null, lbar: null, rbar: null, buttons: null, floatable: true, frame: false, frameHeader: true, hideCollapseTool: false, manageHeight: true, maskElement: "el", minButtonWidth: 75, preventHeader: false, shrinkWrapDock: false, titleCollapse: undefined, baseCls: "x-panel", bodyPosProps: { x: "x", y: "y" }, componentLayout: "dock", contentPaddingProperty: "bodyPadding", emptyArray: [], isPanel: true, defaultBindProperty: "title", addBodyCls: function (b) { var c = this, a = c.rendered ? c.body : c.getProtoBody(); a.addCls(b); return c }, addTool: function (e) { if (!Ext.isArray(e)) { e = [e] } var d = this, h = d.header, a = e.length, g = d.tools, c, b; if (!h || !h.isHeader) { h = null; if (!g) { d.tools = g = [] } } for (c = 0; c < a; c++) { b = e[c]; b.toolOwner = d; if (h) { h.addTool(b) } else { g.push(b) } } d.updateHeader() }, addTools: Ext.emptyFn, getClosable: function () { return this.closable }, setClosable: function (b) { var c = this, a = c.tab; b = !!b; if (c.closable !== b) { c.closable = b; if (a) { a.setClosable(b) } } }, setCollapsible: function (c) { var b = this, d = b.collapsible, a = b.collapseTool; b.collapsible = c; if (c && !d) { b.updateCollapseTool(); a = b.collapseTool; if (a) { a.show() } } else { if (!c && d) { if (a) { a.hide() } } } }, addUIClsToElement: function (b) { var c = this, a = Ext.container.Container.prototype.addUIClsToElement.apply(this, arguments); c.addBodyCls(["x-" + b, c.baseCls + "-body-" + b, c.baseCls + "-body-" + c.ui + "-" + b]); return a }, afterCollapse: function (b) { var a = this, c = a.ownerLayout; a.isCollapsingOrExpanding = 0; a.updateCollapseTool(); if (b) { a.removeCls("x-animating-size") } if (c) { c.afterCollapse(a, b) } a.setHiddenDocked(); a.fireEvent("collapse", a) }, afterExpand: function (b) { var a = this, c = a.ownerLayout; a.isCollapsingOrExpanding = 0; a.updateCollapseTool(); if (b) { a.removeCls("x-animating-size") } if (c) { c.afterExpand(a, b) } a.fireEvent("expand", a); a.fireHierarchyEvent("expand") }, doDestroy: function () { var a = this; Ext.destroy(a.placeholder, a.ghostPanel, a.dd, a.accordionHeaderKeyNav, a.accordionBodyKeyNav, a.defaultButtonKeyNav); a.destroyDockedItems(); Ext.container.Container.prototype.doDestroy.call(this) }, beforeRender: function () { var b = this, a; b.getProtoBody(); Ext.container.Container.prototype.beforeRender.call(this); b.initTools(); if (!(b.preventHeader || (b.header === false)) || b.isViewportBorderChild) { b.updateHeader() } b.afterHeaderInit = true; if (b.collapsed) { if (b.isPlaceHolderCollapse()) { if (!b.hidden) { b.setHiddenState(true); b.preventCollapseFire = true; b.placeholderCollapse(); delete b.preventCollapseFire; a = b.collapsed; b.collapsed = false } } else { b.beginCollapse(); b.addClsWithUI(b.collapsedCls) } } if (a) { b.collapsed = a } }, getMemento: function (a) { var b = this; if (a && typeof a === "string") { a += "Memento"; return b[a] || (b[a] = new Ext.util.Memento(b)) } }, beginCollapse: function () { var e = this, c = e.lastBox, h = e.rendered, b = e.getMemento("collapse"), d = e.getSizeModel(), g = e.header, a; b.capture(["height", "minHeight", "width", "minWidth"]); if (c) { b.capture(e.restoreDimension(), c, "last.") } if (e.collapsedVertical()) { if (d.width.shrinkWrap) { e.width = h ? e.getWidth() : e.width || e.minWidth || 100 } delete e.height; e.minHeight = 0 } else { if (e.collapsedHorizontal()) { if (d.height.shrinkWrap) { e.height = h ? e.getHeight() : e.height || e.minHeight || 100 } delete e.width; e.minWidth = 0 } } if (e.ownerCt) { e.ownerCt.getLayout().beginCollapse(e) } if (!e.isPlaceHolderCollapse() && g !== false) { if (g === (a = e.getReExpander())) { g.collapseImmune = true; g.getInherited().collapseImmune = true; g.addClsWithUI(e.getHeaderCollapsedClasses(g)); if (g.rendered) { g.updateFrame() } } else { if (a.el) { a.el.show(); a.hidden = false } } } if (e.resizer) { e.resizer.disable() } if (e.rendered) { e.ariaEl.dom.setAttribute("aria-expanded", false); if (e.isAccordionPanel) { e.body.dom.setAttribute("aria-hidden", true) } } }, beginDrag: function () { if (this.floatingDescendants) { this.floatingDescendants.hide() } }, beginExpand: function () { var e = this, d = e.lastBox, c = e.getMemento("collapse"), a = e.restoreDimension(), g = e.header, b; if (c) { c.restore(["minHeight", "minWidth", a]); if (d) { c.restore(a, true, d, "last.") } } if (e.ownerCt) { e.ownerCt.getLayout().beginExpand(e) } if (!e.isPlaceHolderCollapse() && g !== false) { if (g === (b = e.getReExpander())) { delete g.collapseImmune; delete g.getInherited().collapseImmune; g.removeClsWithUI(e.getHeaderCollapsedClasses(g)); if (g.rendered) { g.expanding = true; g.updateFrame(); delete g.expanding } } else { b.hidden = true; b.el.hide() } } if (e.resizer) { e.resizer.enable() } if (e.rendered) { e.ariaEl.dom.setAttribute("aria-expanded", true); if (e.isAccordionPanel) { e.body.dom.setAttribute("aria-hidden", false) } } }, bridgeToolbars: function () { var a = this, h = [], g = a.minButtonWidth, d, c, b; function e(i, l, k, j) { if (Ext.isArray(i)) { i = { xtype: "toolbar", items: i } } else { if (!i.isComponent) { i = Ext.apply({}, i) } } if (!i.xtype) { i.xtype = "toolbar" } i.dock = l; if (j) { i.enableFocusableContainer = false } if (k) { i.layout = Ext.applyIf(i.layout || {}, { pack: { left: "start", center: "center" }[a.buttonAlign] || "end" }) } return i } if (a.tbar) { h.push(e(a.tbar, "top")); a.tbar = null } if (a.bbar) { h.push(e(a.bbar, "bottom")); a.bbar = null } if (a.buttons) { a.fbar = a.buttons; a.buttons = null; b = true } if (a.fbar) { d = e(a.fbar, "bottom", true, b); d.ui = "footer"; if (g) { c = d.defaults; d.defaults = function (k) { var l = c || {}, j = !k.xtype || k.isButton, i; if (!j) { i = Ext.ClassManager.getByAlias("widget." + k.xtype); if (i) { j = i.prototype.isButton } } if (j && !("minWidth" in l)) { l = Ext.apply({ minWidth: g }, l) } return l } } h.push(d); a.fbar = null } if (a.lbar) { h.push(e(a.lbar, "left")); a.lbar = null } if (a.rbar) { h.push(e(a.rbar, "right")); a.rbar = null } if (a.dockedItems) { if (a.dockedItems.isMixedCollection) { a.addDocked(h) } else { if (!Ext.isArray(a.dockedItems)) { a.dockedItems = [a.dockedItems] } a.dockedItems = a.dockedItems.concat(h) } } else { a.dockedItems = h } }, close: function () { if (this.fireEvent("beforeclose", this) !== false) { this.doClose() } }, collapse: function (e, a) { var d = this, g = e || d.collapseDirection, b = d.ownerCt, c = d.ownerLayout, h = d.rendered; if (d.isCollapsingOrExpanding) { return d } if (arguments.length < 2) { a = d.animCollapse } if (d.collapsed || d.fireEvent("beforecollapse", d, e, a) === false) { return d } if (c && c.onBeforeComponentCollapse) { if (c.onBeforeComponentCollapse(d) === false) { return d } } if (h && b && d.isPlaceHolderCollapse()) { return d.placeholderCollapse(e, a) } d.collapsed = g; if (h) { d.beginCollapse() } d.getInherited().collapsed = true; d.fireHierarchyEvent("collapse"); if (h) { d.doCollapseExpand(1, a) } return d }, collapsedHorizontal: function () { var a = this.getCollapsed(); return a === "left" || a === "right" }, collapsedVertical: function () { var a = this.getCollapsed(); return a === "top" || a === "bottom" }, convertCollapseDir: function (a) { return a.substr(0, 1) }, createGhost: function (a) { var b = this, d = b.header, c = b.frame && !b.alwaysFramed; return { xtype: "panel", hidden: false, header: d ? { titleAlign: d.getTitleAlign() } : null, ui: c ? b.ui.replace(/-framed$/, "") : b.ui, id: b.id + "-ghost", renderTo: Ext.getBody(), resizable: false, draggable: false, closable: false, focusable: false, floating: true, alignOnScroll: false, shadow: false, frame: c, shim: b.shim, alwaysFramed: b.alwaysFramed, overlapHeader: b.overlapHeader, headerPosition: b.getHeaderPosition(), titleRotation: b.getTitleRotation(), baseCls: b.baseCls, getRefOwner: function () { return b.getRefOwner() }, cls: b.baseCls + "-ghost " + (a || "") } }, createReExpander: function (g, b) { var d = this, i = g === "left", h = g === "right", e = i || h, a = d.ownerCt, c = d.header, j = Ext.apply({ hideMode: "offsets", title: d.getTitle(), titleAlign: d.getTitleAlign(), vertical: e, textCls: d.headerTextCls, icon: d.getIcon(), iconCls: d.getIconCls(), iconAlign: d.getIconAlign(), glyph: d.getGlyph(), baseCls: d.self.prototype.baseCls + "-header", ui: d.ui, frame: d.frame && d.frameHeader, ignoreParentFrame: d.frame || d.overlapHeader, ignoreBorderManagement: d.frame || d.ignoreHeaderBorderManagement, indicateDrag: d.draggable, collapseImmune: true, ariaRole: d.ariaRole, preventRefocus: true, ownerCt: (a && d.collapseMode === "placeholder") ? a : d, ownerLayout: d.componentLayout, forceOrientation: true, margin: d.margin, defaultFocus: "tool[isDefaultExpandTool]" }, b); if (d.collapseMode === "mini") { if (e) { j.width = 1 } else { j.height = 1 } } if (c) { Ext.apply(j, { enableFocusableContainer: c.enableFocusableContainer, activeChildTabIndex: c.activeChildTabIndex, inactiveChildTabIndex: c.inactiveChildTabIndex, allowFocusingDisabledChildren: c.allowFocusingDisabledChildren }) } if (!d.hideCollapseTool) { if (i || (h && d.isPlaceHolderCollapse())) { j.titlePosition = 1 } j.tools = [{ xtype: "tool", type: "expand-" + d.getOppositeDirection(g), isDefaultExpandTool: true, uiCls: ["top"], handler: d.toggleCollapse, scope: d, tooltip: d.expandToolText }] } j = new Ext.panel.Header(j); j.addClsWithUI(d.getHeaderCollapsedClasses(j)); j.expandTool = j.down("tool[isDefaultExpandTool=true]"); return j }, doClose: function () { this.fireEvent("close", this); this[this.closeAction]() }, doCollapseExpand: function (a, b) { var d = this, c = d.animCollapse, e = d.ownerLayout; d.animCollapse = b; d.isCollapsingOrExpanding = a; if (b) { d.addCls("x-animating-size") } if (e && !b) { e.onContentChange(d) } else { d.updateLayout({ isRoot: true }) } d.animCollapse = c; return d }, endDrag: function () { if (this.floatingDescendants) { this.floatingDescendants.show() } }, expand: function (a) { var c = this, b = c.ownerLayout, d = c.rendered; if (c.isCollapsingOrExpanding) { return c } if (!arguments.length) { a = c.animCollapse } if (!c.collapsed && !c.floatedFromCollapse) { return c } if (c.fireEvent("beforeexpand", c, a) === false) { return c } if (b && b.onBeforeComponentExpand) { if (b.onBeforeComponentExpand(c) === false) { return c } } delete c.getInherited().collapsed; if (d && c.isPlaceHolderCollapse()) { return c.placeholderExpand(a) } c.restoreHiddenDocked(); if (d) { c.beginExpand() } c.collapsed = false; if (c.rendered) { c.doCollapseExpand(2, a) } return c }, findReExpander: function (h) { var g = this, j = Ext.Component, e = g.dockedItems.items, a = e.length, b, d; if (g.collapseMode === "mini") { return } switch (h) { case j.DIRECTION_TOP: case j.DIRECTION_BOTTOM: for (d = 0; d < a; d++) { b = e[d]; if (!b.hidden) { if (b.isHeader && (!b.dock || b.dock === "top" || b.dock === "bottom")) { return b } } } break; case j.DIRECTION_LEFT: case j.DIRECTION_RIGHT: for (d = 0; d < a; d++) { b = e[d]; if (!b.hidden) { if (b.isHeader && (b.dock === "left" || b.dock === "right")) { return b } } } break; default: throw ("Panel#findReExpander must be passed a valid collapseDirection") } }, floatCollapsedPanel: function () { var i = this, j = i.placeholder, a = i.splitter, h = Ext.util.Region.from(j.getBox(false, true)), e = Ext.panel.Panel.floatCls, c = i.collapsed, k = i.ownerCt || i, b, d, g = { mouseleave: i.onMouseLeaveFloated, mouseenter: i.onMouseEnterFloated, scope: i, destroyable: true }; if (i.isSliding) { return } if (i.el.hasCls(e)) { i.slideOutFloatedPanel(); return } i.isSliding = true; j.el.hide(); j.hidden = true; i.el.show(); i.setHiddenState(false); i.collapsed = false; k.updateLayout(); j.el.show(); j.hidden = false; i.el.hide(); i.setHiddenState(true); i.collapsed = c; k.updateLayout(); d = i.getBox(false, true); if (i.fireEvent("beginfloat", i) === false) { return } i.slideOutTask = i.slideOutTask || new Ext.util.DelayedTask(i.slideOutFloatedPanel, i); i.pointerLeaveListener = Ext.getDoc().on({ mousedown: i.onFloatedPointerEvent, mousemove: i.onFloatedPointerEvent, scope: i, destroyable: true }); if (!i.placeholderListener) { i.placeholderListener = j.on({ resize: i.onPlaceholderResize, scope: i, destroyable: true }) } i.phHoverListeners = j.el.on(g); i.elHoverListeners = i.el.on(g); i.el.addCls(e); i.floated = c; if (i.collapseTool) { i.collapseTool.el.hide() } if (a) { h = h.union(a.getBox(false, true)) } switch (i.collapsed) { case "top": i.width = h.width; i.setLocalXY(d.x, d.y + h.height); break; case "right": i.height = h.height; i.setLocalXY(d.x - h.width, d.y); break; case "bottom": i.width = h.width; i.setLocalXY(d.x, d.y - h.height); break; case "left": i.height = h.height; i.setLocalXY(d.x + h.width, d.y); break }b = i.convertCollapseDir(i.collapsed); i.floatedFromCollapse = i.collapsed; i.collapsed = false; i.setHiddenState(false); i.el.slideIn(b, { preserveScroll: true, duration: Ext.Number.from(i.animCollapse, Ext.fx.Anim.prototype.duration), listeners: { afteranimate: function () { i.isSliding = false; i.fireEvent("endfloat", i); i.fireEvent("float", i) } } }) }, onFloatedPointerEvent: function (b) { var a = this; if (a.owns(b) || a.placeholder.owns(b) || (a.splitter && a.splitter.owns(b)) || (a.floatCollapsedPanel && a.el.getRegion().contains(b.getPoint()))) { a.slideOutTask.cancel() } else { a.slideOutTask.delay(500) } }, onMouseEnterFloated: function (a) { this.slideOutTask.cancel() }, onMouseLeaveFloated: function (b) { var a = b.getRelatedTarget(); if (a && (this.owns(a) || this.placeholder.owns(a))) { return } this.slideOutTask.delay(500) }, onPlaceholderResize: function (g, c, a) { var b = this, e = b.splitter, d = b.getBox(false, true), h = Ext.util.Region.from(g.getBox(false, true)); if (e) { h = h.union(e.getBox(false, true)) } switch (b.floated) { case "top": b.width = c; b.setLocalY(h.y + h.height); break; case "right": b.height = a; b.setLocalX(h.x - d.width); break; case "bottom": b.width = c; b.setLocalY(h.y - d.height); break; case "left": b.height = a; b.setLocalX(h.x + h.width); break }b.updateLayout({ isRoot: true }) }, getAnimationProps: function () { var b = this, a; a = Ext.container.Container.prototype.getAnimationProps.call(this); if (typeof b.animCollapseDuration === "number") { a.duration = b.animCollapseDuration } else { if (typeof b.animCollapse === "number") { a.duration = b.animCollapse } } return a }, getCollapsed: function () { var a = this; if (a.collapsed === true) { return a.collapseDirection } return a.collapsed }, getCollapsedDockedItems: function () { var a = this; return a.header === false || a.collapseMode === "placeholder" ? a.emptyArray : [a.getReExpander()] }, getComponent: function (a) { var b = Ext.container.Container.prototype.getComponent.apply(this, arguments); if (b === undefined && !Ext.isNumber(a)) { b = this.getDockedComponent(a) } return b }, getHeader: function () { return this.header }, getHeaderCollapsedClasses: function (d) { var b = this, c = b.collapsedCls, a; a = [c, c + "-" + d.getDockName()]; if (b.border && (!b.frame || (b.frame && Ext.supports.CSS3BorderRadius))) { a.push(c + "-border-" + d.getDockName()) } return a }, getOppositeDirection: function (a) { var b = Ext.Component; switch (a) { case b.DIRECTION_TOP: return b.DIRECTION_BOTTOM; case b.DIRECTION_RIGHT: return b.DIRECTION_LEFT; case b.DIRECTION_BOTTOM: return b.DIRECTION_TOP; case b.DIRECTION_LEFT: return b.DIRECTION_RIGHT } }, getPlaceholder: function (e) { var d = this, h = e || d.collapseDirection, c = null, g = d.placeholder, b = d.floatable, a = d.titleCollapse; if (!g) { if (b || (d.collapsible && a)) { c = { click: { fn: function (j, i) { if (!g.expandTool.el.dom.contains(arguments[1])) { d[(!a && b) ? "floatCollapsedPanel" : "toggleCollapse"]() } }, element: "el", scope: d } } } d.placeholder = g = Ext.widget(d.createReExpander(h, { id: d.id + "-placeholder", listeners: c })) } if (!g.placeholderFor) { if (!g.isComponent) { d.placeholder = g = d.lookupComponent(g) } Ext.applyIf(g, { margin: d.margin, placeholderFor: d, synthetic: true }); g.addCls(["x-region-collapsed-placeholder", "x-region-collapsed-" + h + "-placeholder", d.collapsedCls]) } return g }, getProtoBody: function () { var b = this, a = b.protoBody; if (!a) { b.protoBody = a = new Ext.util.ProtoElement({ cls: b.bodyCls, style: b.bodyStyle, clsProp: "bodyCls", styleProp: "bodyStyle", styleIsText: true }) } return a }, getReExpander: function (e) { var d = this, g = e || d.collapseDirection, b = d.reExpander || d.findReExpander(g), a = d.titleCollapse, c = null; d.expandDirection = d.getOppositeDirection(g); if (!b) { if (a) { c = { click: { fn: d.toggleCollapse, element: "el", scope: d } } } d.reExpander = b = d.createReExpander(g, { dock: g, cls: "x-docked " + d.baseCls + "-" + d.ui + "-collapsed", isCollapsedExpander: true, listeners: c }); d.dockedItems.insert(0, b) } return b }, getRefItems: function (b) { var c = this.placeholder, a; if (c) { a = [c]; if (b && c.getRefItems) { a.push.apply(a, c.getRefItems(b)) } } else { a = [] } a.push.apply(a, this.getDockingRefItems(b, Ext.container.Container.prototype.getRefItems.call(this, b))); return a }, getState: function () { var a = this, c = Ext.container.Container.prototype.getState.call(this) || {}, g = a.collapsed, b = a.floated, e, d; if (b) { a.collapsed = b } c = a.addPropertyToState(c, "collapsed"); if (b) { a.collapsed = g } if (a.getCollapsed()) { e = a.getMemento("collapse").data; c = a.addPropertyToState(c, "collapsed", e); d = a.isPlaceHolderCollapse(); if (a.collapsedVertical()) { if (d) { c = a.addPropertyToState(c, "height"); delete c.width } else { delete c.height; if (e) { c = a.addPropertyToState(c, "height", e.height) } } } else { if (d) { c = a.addPropertyToState(c, "width"); delete c.height } else { delete c.width; if (e) { c = a.addPropertyToState(c, "width", e.width) } } } } return c }, applyState: function (c) { var b = this, a = {}, d; if (c) { d = c.collapsed; if (d) { a = b.getMemento("collapse"); Ext.Object.merge(a.data, d); c.collapsed = true } Ext.container.Container.prototype.applyState.apply(this, arguments) } }, ghost: function (n) { var j = this, a = j.el, b = j.ghostPanel, e = j.getBox(), d = j.header, l, g, k, m, h, c; if (!b) { j.ghostPanel = b = Ext.widget(j.createGhost(n)); b.el.dom.removeAttribute("tabIndex") } else { b.el.show() } b.setHiddenState(false); b.floatParent = j.floatParent; if (d && !j.preventHeader) { l = b.header; l.suspendLayouts(); g = l.query("tool"); for (c = g.length; c--;) { l.remove(g[c]) } l.setTitlePosition(0); b.addTool(j.ghostTools()); b.setTitle(j.getTitle()); l.setTitlePosition(d.titlePosition); m = j.getIconCls(); if (m) { b.setIconCls(m) } else { k = j.getIcon(); if (k) { b.setIcon(k) } else { h = j.getGlyph(); if (h) { b.setGlyph(h) } } } l.addCls("x-header-ghost"); l.resumeLayouts(true) } b.setPagePosition(e.x, e.y); b.setSize(e.width, e.height); j.elVisMode = a.getVisibilityMode(); a.setVisibilityMode(Ext.Element.CLIP); a.hide(); return b }, ghostTools: function () { var e = [], g = this.header, d = g ? g.query("tool[hidden=false]") : [], c, a, b; if (d.length) { c = 0; a = d.length; for (; c < a; c++) { b = d[c]; e.push({ type: b.type, tooltip: b.tooltip }) } } else { e = [{ type: "placeholder" }] } return e }, initBodyBorder: function () { var a = this; if (a.frame && a.bodyBorder) { if (!Ext.isNumber(a.bodyBorder)) { a.bodyBorder = 1 } a.getProtoBody().setStyle("border-width", this.unitizeBox(a.bodyBorder)) } }, initBodyStyles: function () { var b = this, a = b.getProtoBody(); if (b.bodyPadding !== undefined) { if (b.layout.managePadding) { a.setStyle("padding", 0) } else { a.setStyle("padding", this.unitizeBox((b.bodyPadding === true) ? 5 : b.bodyPadding)) } } b.initBodyBorder() }, initBorderProps: function () { var a = this; if (a.frame && a.border && a.bodyBorder === undefined) { a.bodyBorder = false } if (a.frame && a.border && (a.bodyBorder === false || a.bodyBorder === 0)) { a.manageBodyBorders = true } }, initComponent: function () { var a = this; if (a.collapsible) { a.addStateEvents(["expand", "collapse"]) } if (a.unstyled) { a.setUI("plain") } if (a.frame) { a.setUI(a.ui + "-framed") } a.bridgeToolbars(); a.initBorderProps(); Ext.container.Container.prototype.initComponent.call(this); a.collapseDirection = a.collapseDirection || a.getHeaderPosition() || Ext.Component.DIRECTION_TOP; if (typeof a.animCollapse === "number") { a.animCollapseDuration = a.animCollapse } a.hiddenOnCollapse = new Ext.dom.CompositeElement() }, initItems: function () { Ext.container.Container.prototype.initItems.call(this); this.initDockingItems() }, initRenderData: function () { var a = this, c = a.bodyWrapAriaRole, d = a.bodyAriaRole, b; b = Ext.container.Container.prototype.initRenderData.call(this); a.initBodyStyles(); a.protoBody.writeTo(b); delete a.protoBody; if (a.headingText) { b.headingText = a.headingText; a.addChildEl("headingEl") } if (c) { b.bodyWrapAriaAttributes = { role: c }; if (!a.ariaStaticRoles[c] && a.bodyWrapAriaRenderAttributes) { Ext.apply(b.bodyWrapAriaAttributes, a.bodyWrapAriaRenderAttributes) } } if (d) { b.bodyAriaAttributes = { role: d }; if (!a.ariaStaticRoles[d] && a.bodyAriaRenderAttributes) { Ext.apply(b.bodyAriaAttributes, a.bodyAriaRenderAttributes) } } return b }, calculateConstrainedPosition: function (g, b, e, a) { var h = this, i = h.header, d, c; if (h.constrainHeader) { d = i.lastBox; if (a) { if (!i.vertical) { a = [a[0], d ? d.height : a[1]] } else { a = [d ? d.width : a[0], a[1]] } } else { if (d) { a = [d.width, d.height] } } c = h.floatParent; g = g || h.constrainTo || (c ? c.getTargetEl() : null) || h.container || h.el.parent() } return Ext.container.Container.prototype.calculateConstrainedPosition.call(this, g, b, e, a) }, initTools: function () { var c = this, e = c.tools, b, d, a; c.tools = []; for (b = e && e.length; b;) { --b; c.tools[b] = a = e[b]; a.toolOwner = c } if (c.collapsible && !(c.hideCollapseTool || c.header === false || c.preventHeader)) { c.updateCollapseTool(); if (c.collapseFirst) { c.tools.unshift(c.collapseTool) } } c.addTools(); if (c.pinnable) { c.initPinnable() } if (c.closable) { c.addClsWithUI("closable"); d = { xtype: "tool", type: "close", scope: c, handler: c.close, tooltip: c.closeToolText }; if (c.isAccordionPanel || c.disableCloseToolFocus) { d.focusable = false; d.ariaRole = "presentation" } c.addTool(d) } if (c.collapseTool && !c.collapseFirst) { c.addTool(c.collapseTool) } }, isLayoutRoot: function () { if (this.floatedFromCollapse) { return true } return Ext.container.Container.prototype.isLayoutRoot.call(this) }, isPlaceHolderCollapse: function () { return this.collapseMode === "placeholder" }, isVisible: function (a) { var b = this; if (b.collapsed && b.placeholder) { return b.placeholder.isVisible(a) } return Ext.container.Container.prototype.isVisible.apply(this, arguments) }, onBoxReady: function () { var a = this, b; Ext.container.Container.prototype.onBoxReady.apply(this, arguments); if (a.collapsed) { a.setHiddenDocked() } if (a.isAccordionPanel) { a.ariaEl = a.header.titleCmp.el; a.ariaEl.dom.setAttribute("aria-expanded", !a.collapsed); a.ariaEl.dom.setAttribute("aria-controls", a.body.id); a.body.dom.setAttribute("aria-labelledby", a.header.titleCmp.id); a.body.dom.setAttribute("aria-hidden", !!a.collapsed); a.accordionHeaderKeyNav = new Ext.util.KeyNav({ target: a.header.titleCmp.el, scope: a, left: a.navigateAccordionHeader, right: a.navigateAccordionHeader, up: a.navigateAccordionHeader, down: a.navigateAccordionHeader, home: a.navigateAccordionHeader, end: a.navigateAccordionHeader, space: a.toggleCollapse, enter: a.toggleCollapse, del: { alt: true, fn: a.maybeClose } }); a.accordionBodyKeyNav = new Ext.util.KeyNav({ target: a.body, scope: a, up: { ctrl: true, fn: a.navigateAccordionBody } }) } if (a.defaultButton) { b = a.defaultButtonTarget ? a[a.defaultButtonTarget] : a.body; a.defaultButtonKeyNav = new Ext.util.KeyNav({ target: b, scope: a, defaultEventAction: "stopEvent", enter: a.fireDefaultButton }) } }, onHide: function (e, b, c) { var d = this, a = d.dd; if (d.floatedFromCollapse) { d.slideOutFloatedPanel(true) } if (d.draggable && a) { a.endDrag() } if (d.collapsed && d.placeholder) { if (d.splitter) { Ext.suspendLayouts(); d.splitter.hide(); Ext.resumeLayouts() } d.placeholder.hide() } else { Ext.container.Container.prototype.onHide.call(this, e, b, c) } }, onRemoved: function (b) { var a = this; if (a.placeholder && !b) { a.ownerCt.remove(a.placeholder, false) } Ext.container.Container.prototype.onRemoved.apply(this, arguments) }, onShow: function () { var a = this; if (a.collapsed && a.isPlaceHolderCollapse()) { if (a.splitter) { Ext.suspendLayouts(); a.splitter.show(); Ext.resumeLayouts() } a.setHiddenState(true); a.placeholderCollapse() } else { Ext.container.Container.prototype.onShow.apply(this, arguments) } }, placeholderCollapse: function (g, a) { var e = this, b = e.ownerCt, j = g || e.collapseDirection, d = Ext.panel.Panel.floatCls, c = e.collapseTool, h = e.getPlaceholder(j), i; if (Ext.Component.layoutSuspendCount || e.isLayoutSuspended()) { a = false } e.fireEvent("beginfloat", e); e.isCollapsingOrExpanding = 1; e.setHiddenState(true); e.collapsed = j; if (h.rendered) { if (h.el.dom.parentNode !== e.el.dom.parentNode) { e.el.dom.parentNode.insertBefore(h.el.dom, e.el.dom) } h.hidden = false; h.setHiddenState(false); h.el.show(); b.updateLayout() } else { b.insert(b.items.indexOf(e), h) } if (e.rendered) { e.focusPlaceholderExpandTool = e.focusPlaceHolder = false; if (c && Ext.ComponentManager.getActiveComponent() === c) { e.focusPlaceholderExpandTool = true } else { if (e.containsFocus) { e.focusPlaceHolder = true } } e.el.setVisibilityMode(e.placeholderCollapseHideMode); if (a) { e.el.addCls(d); h.el.hide(); i = e.convertCollapseDir(j); e.el.slideOut(i, { preserveScroll: true, duration: Ext.Number.from(a, Ext.fx.Anim.prototype.duration), listeners: { scope: e, afteranimate: function () { var k = this, l = k.placeholder.el; k.el.removeCls(d); l.show(); if (k.ownerCt) { l.setStyle("display", "none"); l.slideIn(i, { easing: "linear", duration: 100, listeners: { afteranimate: k.doPlaceholderCollapse, scope: k } }) } else { k.doPlaceholderCollapse() } } } }) } else { e.el.hide(); e.doPlaceholderCollapse() } } else { e.isCollapsingOrExpanding = 0; if (!e.preventCollapseFire) { e.fireEvent("collapse", e) } } return e }, doPlaceholderCollapse: function () { var a = this, c = a.placeholder, d = c.expandTool, b; if (a.focusPlaceholderExpandTool && d) { d.focus() } else { if (a.focusPlaceHolder) { c.focus() } } a.focusPlaceholderExpandTool = false; c.setHiddenState(false); if (c.rendered) { b = c.ariaEl.dom; b.setAttribute("aria-hidden", false); b.setAttribute("aria-expanded", false) } b = a.ariaEl.dom; b.setAttribute("aria-hidden", true); b.setAttribute("aria-expanded", false); a.isCollapsingOrExpanding = 0; a.fireEvent("collapse", a); a.fireEvent("endfloat", a) }, placeholderExpand: function (c) { var e = this, h = e.collapsed, i = e.placeholder.expandTool, d = Ext.panel.Panel.floatCls, b = e.ownerLayout ? e.ownerLayout.centerRegion : null, g, a; if (Ext.Component.layoutSuspendCount) { c = false } if (e.floatedFromCollapse) { a = e.getPosition(true); e.slideOutFloatedPanelBegin(); e.slideOutFloatedPanelEnd(); e.floated = false } if (i && Ext.ComponentManager.getActiveComponent() === i) { e.focusHeaderCollapseTool = true; i._ariaRole = i.ariaEl.dom.getAttribute("role"); i._ariaLabel = i.ariaEl.dom.getAttribute("aria-label"); i.ariaEl.dom.setAttribute("role", "presentation"); i.ariaEl.dom.removeAttribute("aria-label") } if (c) { Ext.suspendLayouts(); e.placeholder.hide(); e.el.show(); e.collapsed = false; e.setHiddenState(false); if (b && !a) { b.hidden = true } Ext.resumeLayouts(true); b.hidden = false; if (!e.floatedFromCollapse) { e.fireEvent("beginfloat", e) } e.el.addCls(d); e.isCollapsingOrExpanding = 2; if (a) { g = e.getXY(); e.setLocalXY(a[0], a[1]); e.setXY([g[0], g[1]], { duration: Ext.Number.from(c, Ext.fx.Anim.prototype.duration), listeners: { scope: e, afteranimate: function () { var j = this; j.el.removeCls(d); j.isCollapsingOrExpanding = 0; j.fireEvent("expand", j); j.fireEvent("endfloat", j) } } }) } else { e.el.hide(); e.placeholder.el.show(); e.placeholder.hidden = false; e.setHiddenState(false); e.el.slideIn(e.convertCollapseDir(h), { preserveScroll: true, duration: Ext.Number.from(c, Ext.fx.Anim.prototype.duration), listeners: { afteranimate: e.doPlaceholderExpand, scope: e } }) } } else { e.floated = e.collapsed = false; e.doPlaceholderExpand(true) } return e }, doPlaceholderExpand: function (b) { b = b === true; var c = this, d = c.placeholder, a = c.collapseTool, e = d.expandTool; if (b) { Ext.suspendLayouts(); c.show() } c.el.removeCls(Ext.panel.Panel.floatCls); d.hide(); if (b) { Ext.resumeLayouts(true) } else { c.updateLayout() } if (c.focusHeaderCollapseTool && a) { a.focus() } c.focusHeaderCollapseTool = false; d.ariaEl.dom.setAttribute("aria-expanded", true); c.ariaEl.dom.setAttribute("aria-expanded", true); if (e && e._ariaRole) { e.ariaEl.dom.setAttribute("role", e._ariaRole); e.ariaEl.dom.setAttribute("aria-label", e._ariaLabel); e._ariaRole = e._ariaLabel = null } c.isCollapsingOrExpanding = 0; c.fireEvent("expand", c); c.fireEvent("endfloat", c) }, remove: function (b, a) { var c = this.dockedItems; if (c && c.contains(b)) { this.removeDocked(b, a) } else { Ext.container.Container.prototype.remove.call(this, b, a) } return b }, removeBodyCls: function (b) { var c = this, a = c.rendered ? c.body : c.getProtoBody(); a.removeCls(b); return c }, removeUIClsFromElement: function (b) { var c = this, a = Ext.container.Container.prototype.removeUIClsFromElement.apply(this, arguments); c.removeBodyCls(["x-" + b, c.baseCls + "-body-" + b, c.baseCls + "-body-" + c.ui + "-" + b]); return a }, restoreDimension: function () { var a = this.collapseDirection; return (a === "top" || a === "bottom") ? "height" : "width" }, restoreHiddenDocked: function () { this.setDockedItemsVisibility(this.hiddenOnCollapse, true) }, setBodyStyle: function (b, d) { var c = this, a = c.rendered ? c.body : c.getProtoBody(); if (Ext.isFunction(b)) { b = b() } if (arguments.length === 1) { if (Ext.isString(b)) { b = Ext.Element.parseStyles(b) } a.setStyle(b) } else { a.setStyle(b, d) } return c }, setBorder: function (a, c) { if (c) { return } var b = this, d = b.header; if (!a) { a = 0 } else { if (a === true) { a = "1px" } else { a = b.unitizeBox(a) } } if (d) { if (d.isHeader) { d.setBorder(a) } else { d.border = a } } if (b.rendered && b.bodyBorder !== false) { b.body.setStyle("border-width", a) } b.updateLayout(); b.border = a }, setCollapsed: function (a) { this[a ? "collapse" : "expand"]() }, setDockedItemsVisibility: function (g, c) { var j = this, d = j.getDockedItems(), a = d.length, e = 0, h, b; if (j.header !== false) { b = j.getReExpander() } for (; e < a; e++) { h = d[e]; if (h && h !== b && h.el) { g.add(h.el) } } g.setStyle("visibility", c ? "" : "hidden"); g.clear() }, setGlyph: function (c) { var b = this, a = b.glyph, e = b.header, d = b.placeholder; if (c !== a) { b.glyph = c; if (e) { if (e.isHeader) { e.setGlyph(c) } else { e.glyph = c } } else { if (b.rendered || b.afterHeaderInit) { b.updateHeader() } } if (d && d.setGlyph) { d.setGlyph(c) } b.fireEvent("glyphchange", b, c, a) } }, setIcon: function (a) { var b = this, c = b.icon, e = b.header, d = b.placeholder; if (a !== c) { b.icon = a; if (e) { if (e.isHeader) { e.setIcon(a) } else { e.icon = a } } else { if (b.rendered || b.afterHeaderInit) { b.updateHeader() } } if (d && d.setIcon) { d.setIcon(a) } b.fireEvent("iconchange", b, a, c) } }, setIconCls: function (b) { var c = this, a = c.iconCls, e = c.header, d = c.placeholder; if (b !== a) { c.iconCls = b; if (e) { if (e.isHeader) { e.setIconCls(b) } else { e.iconCls = b } } else { if (c.rendered || c.afterHeaderInit) { c.updateHeader() } } if (d && d.setIconCls) { d.setIconCls(b) } c.fireEvent("iconclschange", c, b, a) } }, setTitle: function (e) { var c = this, b = c.title, g = c.header, a = c.reExpander, d = c.placeholder; if (e !== b) { c.title = e; if (g) { if (g.isHeader) { g.setTitle(e) } } else { if (c.rendered || c.afterHeaderInit) { c.updateHeader() } } if (c.headingEl) { c.headingEl.setHtml(e) } if (a) { a.setTitle(e) } if (d && d.setTitle) { d.setTitle(e) } c.fireEvent("titlechange", c, e, b) } }, setHiddenDocked: function () { var b = this, a = new Ext.dom.CompositeElement(); b.hiddenOnCollapse.add(b.body); a.add(b.body); b.setDockedItemsVisibility(a, false) }, setUI: function (b) { var a = this; Ext.container.Container.prototype.setUI.apply(this, arguments); if (a.header && a.header.rendered) { a.header.setUI(b) } }, toggleCollapse: function () { return (this.collapsed || this.floatedFromCollapse) ? this.expand() : this.collapse() }, updateCollapseTool: function () { var b = this, a = b.collapseTool, c; if (!a && b.collapsible) { b.collapseDirection = b.collapseDirection || b.getHeaderPosition() || "top"; c = { xtype: "tool", handler: b.toggleCollapse, scope: b }; if (b.isAccordionPanel) { c.focusable = false; c.ariaRole = "presentation" } b.collapseTool = b.expandTool = a = Ext.widget(c) } if (a) { if (b.collapsed && !b.isPlaceHolderCollapse()) { a.setType("expand-" + b.getOppositeDirection(b.collapseDirection)); a.setTooltip(b.expandToolText) } else { a.setType("collapse-" + b.collapseDirection); a.setTooltip(b.collapseToolText) } } }, navigateAccordionHeader: function (d) { var b = this, a, c; a = d.getKey(); switch (a) { case d.UP: case d.LEFT: c = b.findAccordionSibling("prev"); break; case d.DOWN: case d.RIGHT: c = b.findAccordionSibling("next"); break; case d.HOME: c = b.findAccordionSibling("first"); break; case d.END: c = b.findAccordionSibling("last"); break; case d.DELETE: c = b.findAccordionSibling("prev") || b.findAccordionSibling("next"); if (!c) { d.doNotClose = true } break }d.stopEvent(); if (c && c !== b) { c.header.titleCmp.focus() } }, navigateAccordionBody: function (b) { var a; if (b.getKey() === b.UP) { a = this } b.stopEvent(); if (a) { a.header.titleCmp.focus() } }, findAccordionSibling: function (d, e) { var c = this, a = "[isAccordionPanel]", b; switch (d) { case "prev": b = c.prev(a); if (!b) { if (c.accordionWrapOver) { b = c.ownerCt.child(a + ":last") } else { if (e) { b = c } } } break; case "next": b = c.next(a); if (!b) { if (c.accordionWrapOver) { b = c.ownerCt.child(a + ":first") } else { if (e) { b = c } } } break; case "first": b = c.ownerCt.child(a + ":first"); break; case "last": b = c.ownerCt.child(a + ":last"); break }return b }, fireDefaultButton: function (c) { var b = this, d, a; d = b.lookupReferenceHolder(false) || b; a = d.lookupReference(b.defaultButton); if (a && a.click) { a.click(c); c.stopEvent(); return false } }, maybeClose: function (b) { var a = this; if (a.closable) { a.navigateAccordionHeader(b); if (!b.doNotClose) { a.close() } } }, canFocus: function (a, b) { if (this.collapsed) { return !!(this.placeholder && this.placeholder.canFocus(a, b)) } return this.mixins.focusable.canFocus.call(this, a, b) }, focus: function () { var a = this, b = a.placeholder; if (a.collapsed && b && b.canFocus()) { b.focus.apply(b, arguments) } else { Ext.container.Container.prototype.focus.apply(this, arguments) } }, onFocusEnter: function (c) { var b = this, a = b.ariaEl.dom; Ext.container.Container.prototype.onFocusEnter.call(this, c); if (b.isAccordionPanel && a) { a.setAttribute("aria-selected", true) } }, onFocusLeave: function (c) { var b = this, a = b.ariaEl.dom; Ext.container.Container.prototype.onFocusLeave.call(this, c); if (b.isAccordionPanel && a) { a.setAttribute("aria-selected", "false") } }, updateHeaderPosition: function (a) { var b = this.header; if (b && b.isHeader) { b.setDock(a) } }, updateIconAlign: function (b) { var a = this.header; if (a && a.isHeader) { a.setIconAlign(b) } }, updateTitleAlign: function (b) { var a = this.header; if (a && a.isHeader) { a.setTitleAlign(b) } }, updateTitleRotation: function (a) { var b = this.header; if (b && b.isHeader) { b.setTitleRotation(a) } }, unghost: function (c, a, b) { var g = this, e = g.el, d = g.ghostPanel; if (!d) { return } e.show(); e.setVisibilityMode(g.elVisMode); if (c !== false) { if (a !== false) { g.setPagePosition(d.getXY()) } } else { e.hide() } d.el.hide(); d.setHiddenState(true) }, updateHeader: function (a) { var j = this, e = j.header, m = j.getTitle(), h = j.tools, l = j.getIcon(), k = j.getGlyph(), o = j.getIconCls(), d = k || l || o, i = j.ariaEl.dom, g = j.getHeaderPosition(), c = g === "left" || g === "right", n, b; if (Ext.isObject(e) || (e !== false && (a || (m || d) || (h && h.length) || (j.collapsible && !j.titleCollapse)))) { if (e && e.isHeader) { e.dockToEl = true; e.show() } else { e = j.header = Ext.widget(Ext.merge({ xtype: "header", title: m, titleAlign: j.getTitleAlign(), vertical: c, dock: j.getHeaderPosition() || "top", dockToEl: true, titleRotation: j.getTitleRotation(), textCls: j.headerTextCls, iconCls: o, iconAlign: j.getIconAlign(), icon: l, glyph: k, baseCls: j.baseCls + "-header", tools: h, ui: j.ui, id: j.id + "_header", overCls: j.headerOverCls, indicateDrag: j.draggable, frame: (j.frame || j.alwaysFramed) && j.frameHeader, ignoreParentFrame: j.frame || j.overlapHeader, ignoreBorderManagement: j.frame || j.ignoreHeaderBorderManagement, isAccordionHeader: j.isAccordionPanel, ownerCt: j, synthetic: true, listeners: j.collapsible && j.titleCollapse ? { click: j.toggleCollapse, scope: j } : null }, j.header)); j.addDocked(e, 0) } if (j.isAccordionPanel) { if (i) { i.setAttribute("aria-labelledby", e.id + "-title"); i.removeAttribute("aria-label") } else { b = j.ariaRenderAttributes || (j.ariaRenderAttributes = {}); b["aria-labelledby"] = e.id + "-title"; delete b["aria-label"] } } else { if (m) { if (j.ariaRole !== "tabpanel") { if (i) { i.setAttribute("aria-labelledby", e.id + "-title-textEl"); i.removeAttribute("aria-label") } else { b = j.ariaRenderAttributes || (j.ariaRenderAttributes = {}); b["aria-labelledby"] = e.id + "-title-textEl"; delete b["aria-label"] } } } else { if (j.ariaRenderAttributes) { delete j.ariaRenderAttributes["aria-label"] } } } } else { if (e) { e.hide() } m = Ext.util.Format.stripTags(m); if (i) { if (!i.hasAttribute("aria-labelledby")) { if (m) { i.setAttribute("aria-label", m) } else { i.removeAttribute("aria-label") } } } else { b = j.ariaRenderAttributes || (j.ariaRenderAttributes = {}); if (!b["aria-labelledby"]) { if (m) { b["aria-label"] = m } else { delete b["aria-label"] } } } } if (j.isViewportBorderChild && !j.hasOwnProperty("ariaRole")) { j.ariaRole = "region" } if (m && j.ariaRole === "region") { n = j.headingEl; if (n) { n.setHtml(m) } else { if (j.rendered) { j.headingEl = Ext.dom.Helper.insertFirst(j.el, { tag: "div", id: j.id + "-headingEl", role: "heading", "class": "x-hidden-clip", style: "height:0", html: m }, true); i.removeAttribute("aria-label"); i.setAttribute("aria-labelledby", j.id + "-headingEl") } else { j.headingText = j.title; b = j.ariaRenderAttributes || (j.ariaRenderAttributes = {}); b["aria-labelledby"] = j.id + "-headingEl"; delete b["aria-label"] } } } else { if (j.headingEl) { j.headingEl.destroy(); j.headingEl = null } } }, statics: { floatCls: "x-border-region-slide-in" }, privates: { addUIToElement: function () { var a = this; Ext.container.Container.prototype.addUIToElement.apply(this, arguments); a.addBodyCls(a.baseCls + "-body-" + a.ui) }, applyTargetCls: function (a) { this.getProtoBody().addCls(a) }, getDefaultContentTarget: function () { return this.body }, getTargetEl: function () { var a = this; return a.body || a.protoBody || a.frameBody || a.el }, initDraggable: function () { var a = this; if (a.simpleDrag) { a.initSimpleDraggable() } else { a.dd = new Ext.panel.DD(a, Ext.isBoolean(a.draggable) ? null : a.draggable) } }, initResizable: function (a) { Ext.container.Container.prototype.initResizable.call(this, a); if (this.collapsed) { this.resizer.disable() } }, initSimpleDraggable: function () { var b = this, a = b.draggable; if (!b.header && !a.delegate) { b.updateHeader(true) } if (b.header || a.delegate) { a = Ext.apply({ el: b.el, delegate: b.header && b.header.el }, a); if (b.constrain || b.constrainHeader) { a.constrain = b.constrain; a.constrainDelegate = b.constrainHeader; a.constrainTo = b.constrainTo || b.container } a = b.dd = new Ext.util.ComponentDragger(b, a); b.relayEvents(a, ["dragstart", "drag", "dragend"]) } }, removeUIFromElement: function () { var a = this; Ext.container.Container.prototype.removeUIFromElement.apply(this, arguments); a.removeBodyCls(a.baseCls + "-body-" + a.ui) }, setupRenderTpl: function (a) { Ext.container.Container.prototype.setupRenderTpl.apply(this, arguments); this.setupDockingRenderTpl(a) }, slideOutFloatedPanel: function (b) { var d = this, g = d.el, e, a, c = function () { d.slideOutFloatedPanelEnd(); d.el.removeCls("x-border-region-slide-in"); d.fireEvent("endfloat", d) }; if (d.isSliding || d.destroyed) { return } d.isSliding = true; d.floated = false; d.slideOutFloatedPanelBegin(); if (b) { g.hide(); return c() } if (typeof d.collapsed === "string") { e = d.convertCollapseDir(d.collapsed) } d.fireEvent("beginfloat", d); g.slideOut(e, { preserveScroll: true, duration: Ext.Number.from(d.animCollapse, Ext.fx.Anim.prototype.duration), listeners: { afteranimate: c } }); if (this.containsFocus) { a = this.findFocusTarget(); if (a) { a.focus() } } }, slideOutFloatedPanelBegin: function () { var b = this, c = b.placeholder.el, a = b.el, d = b.bodyMousedownListener; b.collapsed = b.floatedFromCollapse; b.setHiddenState(true); b.floatedFromCollapse = null; Ext.destroy(b.pointerLeaveListener, b.phHoverListeners, b.elHoverListeners); if (d) { b.bodyMousedownListener = d.destroy() } }, slideOutFloatedPanelEnd: function (a) { var b = this; if (b.collapseTool) { b.collapseTool.el.show() } b.slideOutTask.cancel(); b.isSliding = false; if (!a) { b.fireEvent("unfloat", b) } } } }, 0, ["panel"], ["component", "box", "container", "panel"], { component: true, box: true, container: true, panel: true }, ["widget.panel"], [["docking", Ext.container.DockingContainer]], [Ext.panel, "Panel", Ext, "Panel"], function () { var a = this.prototype; a.animCollapse = Ext.enableFx; a.placeholderCollapseHideMode = Ext.Element.VISIBILITY })); (Ext.cmd.derive("Ext.layout.container.Table", Ext.layout.container.Container, { alternateClassName: "Ext.layout.TableLayout", type: "table", createsInnerCt: true, targetCls: "x-table-layout-ct", tableCls: "x-table-layout", cellCls: "x-table-layout-cell", childEls: ["table", "tbody"], tableAttrs: null, getItemSizePolicy: function (a) { return this.autoSizePolicy }, initInheritedState: function (b, a) { a.inShrinkWrapTable = true }, getLayoutItems: function () { var g = this, b = [], c = Ext.layout.container.Container.prototype.getLayoutItems.call(this), a = c.length, e, d; for (d = 0; d < a; d++) { e = c[d]; if (!e.hidden) { b.push(e) } } return b }, getHiddenItems: function () { var b = [], c = this.owner.items.items, a = c.length, d, e; for (d = 0; d < a; ++d) { e = c[d]; if (e.rendered && e.hidden) { b.push(e) } } return b }, renderChildren: function () { var j = this, h = j.getLayoutItems(), e = j.tbody.dom, p = e.rows, g = h.length, c = j.getHiddenItems(), o, m, b, a, n, l, k, d; o = j.calculateCells(h); for (d = 0; d < g; d++) { m = o[d]; b = m.rowIdx; a = m.cellIdx; n = h[d]; l = p[b]; if (!l) { l = e.insertRow(b); if (j.trAttrs) { l.set(j.trAttrs) } } k = Ext.get(l.cells[a] || l.insertCell(a)); if (!n.rendered) { j.renderItem(n, k, 0) } else { if (!j.isValidParent(n, k, b, a, e)) { j.moveItem(n, k, 0) } } if (j.tdAttrs) { k.set(j.tdAttrs) } if (n.tdAttrs) { k.set(n.tdAttrs) } k.set({ colSpan: n.colspan || 1, rowSpan: n.rowspan || 1, cls: j.cellCls + " " + (n.cellCls || "") }); if (!o[d + 1] || o[d + 1].rowIdx !== b) { a++; while (l.cells[a]) { l.deleteCell(a) } } } b++; while (e.rows[b]) { e.deleteRow(b) } for (d = 0, g = c.length; d < g; ++d) { j.ensureInDocument(c[d].getEl()) } }, ensureInDocument: function (a) { var b = a.dom.parentNode; while (b) { if (b.tagName.toUpperCase() === "BODY") { return } b = b.parentNode } Ext.getDetachedBody().appendChild(a) }, calculate: function (g) { if (!g.hasDomProp("containerChildrenSizeDone")) { this.done = false } else { var c = g.targetContext, b = g.widthModel.shrinkWrap, a = g.heightModel.shrinkWrap, h = a || b, d = h && this.table.dom, e = h && c.getPaddingInfo(); if (b) { g.setContentWidth(d.offsetWidth + e.width, true) } if (a) { g.setContentHeight(d.offsetHeight + e.height, true) } } }, calculateCells: function (k) { var m = [], b = 0, e = 0, a = 0, g = this.columns || Infinity, n = [], h = k.length, l, d, c; for (d = 0; d < h; d++) { l = k[d]; while (e >= g || n[e] > 0) { if (e >= g) { e = 0; a = 0; b++; for (c = 0; c < g; c++) { if (n[c] > 0) { n[c]-- } } } else { e++ } } m.push({ rowIdx: b, cellIdx: a }); for (c = l.colspan || 1; c; --c) { n[e] = l.rowspan || 1; ++e } ++a } return m }, getRenderTree: function () { var j = this, g = j.getLayoutItems(), o = [], p = Ext.apply({ tag: "table", id: j.owner.id + "-table", "data-ref": "table", role: "presentation", cls: j.tableCls, cellspacing: 0, cellpadding: 0, cn: { tag: "tbody", id: j.owner.id + "-tbody", "data-ref": "tbody", role: "presentation", cn: o } }, j.tableAttrs), c = j.tdAttrs, d, e = g.length, n, l, h, b, a, k, m; m = j.calculateCells(g); for (d = 0; d < e; d++) { n = g[d]; l = m[d]; b = l.rowIdx; a = l.cellIdx; h = o[b]; if (!h) { h = o[b] = { tag: "tr", role: "presentation", cn: [] }; if (j.trAttrs) { Ext.apply(h, j.trAttrs) } } k = h.cn[a] = { tag: "td", role: "presentation" }; if (c) { Ext.apply(k, c) } Ext.apply(k, { colSpan: n.colspan || 1, rowSpan: n.rowspan || 1, cls: j.cellCls + " " + (n.cellCls || "") }); j.configureItem(n); k.cn = n.getRenderTree() } return p }, isValidParent: function (c, d, b, a) { if (arguments.length === 3) { return this.table.isAncestor(c.el) } return c.el.dom.parentNode === this.tbody.dom.rows[b].cells[a] } }, 0, 0, 0, 0, ["layout.table"], 0, [Ext.layout.container, "Table", Ext.layout, "TableLayout"], 0)); (Ext.cmd.derive("Ext.container.ButtonGroup", Ext.panel.Panel, { alternateClassName: "Ext.ButtonGroup", baseCls: "x-btn-group", layout: { type: "table" }, defaultType: "button", frame: true, frameHeader: false, titleAlign: "center", noTitleCls: "notitle", bodyAriaRole: "toolbar", focusableContainerEl: "body", initComponent: function () { var a = this, b = a.columns; if (b) { a.layout = Ext.apply({}, { columns: b }, a.layout) } if (!a.title) { a.addClsWithUI(a.noTitleCls) } Ext.panel.Panel.prototype.initComponent.call(this) }, onBeforeAdd: function (a) { if (a.isButton) { if (this.defaultButtonUI && a.ui === "default" && !a.hasOwnProperty("ui")) { a.ui = this.defaultButtonUI } else { a.ui = a.ui + "-toolbar" } } Ext.panel.Panel.prototype.onBeforeAdd.apply(this, arguments) }, beforeRender: function () { var b = this, a; Ext.panel.Panel.prototype.beforeRender.call(this); if (b.afterHeaderInit && !b.header && b.title) { a = b.bodyAriaRenderAttributes || (b.bodyAriaRenderAttributes = {}); a["aria-label"] = b.title } }, updateHeader: function (d) { var c = this, a = c.body, e, b; Ext.panel.Panel.prototype.updateHeader.call(this, d); e = c.header; if (e) { if (a) { a.dom.setAttribute("aria-labelledby", e.id + "-title-textEl"); a.dom.removeAttribute("aria-label") } else { b = c.bodyAriaRenderAttributes || (c.bodyAriaRenderAttributes = {}); b["aria-labelledby"] = e.id + "-title-textEl"; delete b["aria-label"] } } else { if (c.title) { if (a) { a.dom.setAttribute("aria-label", c.title); a.dom.removeAttribute("aria-labelledby") } else { b = c.bodyAriaRenderAttributes || (c.bodyAriaRenderAttributes = {}); b["aria-label"] = c.title; delete b["aria-labelledby"] } } } }, privates: { applyDefaults: function (a) { if (!Ext.isString(a)) { a = Ext.panel.Panel.prototype.applyDefaults.apply(this, arguments) } return a } } }, 0, ["buttongroup"], ["component", "box", "container", "panel", "buttongroup"], { component: true, box: true, container: true, panel: true, buttongroup: true }, ["widget.buttongroup"], [[Ext.util.FocusableContainer.prototype.mixinId || Ext.util.FocusableContainer.$className, Ext.util.FocusableContainer]], [Ext.container, "ButtonGroup", Ext, "ButtonGroup"], 0)); (Ext.cmd.derive("Ext.container.Monitor", Ext.Base, { target: null, selector: "", scope: null, addHandler: null, removeHandler: null, invalidateHandler: null, clearPropertiesOnDestroy: false, clearPrototypeOnDestroy: false, disabled: 0, constructor: function (a) { Ext.apply(this, a) }, destroy: function () { this.unbind(); this.callParent() }, bind: function (b) { var a = this; a.target = b; b.on("beforedestroy", a.disable, a); a.onContainerAdd(b) }, unbind: function () { var a = this, b = a.target; if (b && !b.destroyed) { a.onContainerRemove(b, b); b.un("beforedestroy", a.disable, a) } a.items = Ext.destroy(a.items) }, disable: function () { ++this.disabled }, enable: function () { if (this.disabled > 0) { --this.disabled } }, handleAdd: function (b, a) { if (!this.disabled) { if (Ext.ComponentQuery.is(a, this.selector)) { this.onItemAdd(a.ownerCt, a) } if (a.isQueryable) { this.onContainerAdd(a) } } }, onItemAdd: function (c, b) { var e = this, a = e.items, d = e.addHandler; if (!e.disabled) { if (d) { d.call(e.scope || b, b) } if (a) { a.add(b) } } b.clearPropertiesOnDestroy = b.clearPrototypeOnDestroy = false }, onItemRemove: function (c, b) { var e = this, a = e.items, d = e.removeHandler; if (!e.disabled) { if (d) { d.call(e.scope || b, b) } if (a) { a.remove(b) } } }, onContainerAdd: function (e, g) { var h = this, c, a, d, b; if (e.isContainer) { e.on({ scope: h, add: h.handleAdd, dockedadd: h.handleAdd, remove: h.handleRemove, dockedremove: h.handleRemove }) } if (g !== true) { c = e.query(h.selector); for (d = 0, a = c.length; d < a; ++d) { b = c[d]; h.onItemAdd(b.ownerCt, b) } } c = e.query(">container"); for (d = 0, a = c.length; d < a; ++d) { h.onContainerAdd(c[d], true) } e.clearPropertiesOnDestroy = e.clearPrototypeOnDestroy = false }, handleRemove: function (b, a) { var c = this; if (!c.disabled) { if (Ext.ComponentQuery.is(a, c.selector)) { c.onItemRemove(b, a) } if (a.isQueryable) { c.onContainerRemove(b, a) } } }, onContainerRemove: function (e, c) { var h = this, b, d, a, g; if (!c.destroyed && c.isContainer) { h.removeCtListeners(c); if (!c.destroying) { b = c.query(h.selector); for (d = 0, a = b.length; d < a; ++d) { g = b[d]; h.onItemRemove(g.ownerCt, g) } b = c.query("container"); for (d = 0, a = b.length; d < a; ++d) { h.removeCtListeners(b[d]) } } } h.invalidateItems(true) }, removeCtListeners: function (a) { var b = this; a.un({ scope: b, add: b.handleAdd, dockedadd: b.handleAdd, remove: b.handleRemove, dockedremove: b.handleRemove }) }, getItems: function () { var b = this, a = b.items; if (!a) { a = b.items = new Ext.util.MixedCollection(); a.addAll(b.target.query(b.selector)) } return a }, invalidateItems: function (c) { var b = this, a = b.invalidateHandler; if (c && a) { a.call(b.scope || b, b) } b.items = Ext.destroy(b.items) } }, 1, 0, 0, 0, 0, 0, [Ext.container, "Monitor"], 0)); (Ext.cmd.derive("Ext.plugin.Responsive", Ext.mixin.Responsive, { id: "responsive", isPlugin: true, constructor: function (a) { var d = this, b = a.cmp, e = Ext.apply({ responsiveConfig: b.responsiveConfig, responsiveFormulas: b.responsiveFormulas }, a); delete e.cmp; d.cmp = b; d.initConfig(e); if (d.transformed) { b.setConfig(d.transformed); d.transformed = null } }, init: Ext.emptyFn, privates: { transformInstanceConfig: function (c) { var b = Ext.mixin.Responsive.prototype.transformInstanceConfig.call(this, c); if (b.ptype) { b = Ext.apply({}, b); delete b.ptype } this.transformed = b; var a = Ext.apply({}, c); delete a.ptype; delete a.responsiveConfig; delete a.responsiveFormulas; return a }, updateResponsiveState: function () { var a = this.getResponsiveState(); this.cmp.setConfig(a) } } }, 1, 0, 0, 0, ["plugin.responsive"], 0, [Ext.plugin, "Responsive"], 0)); (Ext.cmd.derive("Ext.plugin.Viewport", Ext.plugin.Responsive, { setCmp: function (a) { this.cmp = a; if (a && !a.isViewport) { this.decorate(a); if (a.renderConfigs) { a.flushRenderConfigs() } a.setupViewport() } }, statics: { decorate: function (a) { Ext.applyIf(a.prototype || a, { ariaRole: "application", viewportCls: "x-viewport" }); Ext.override(a, { isViewport: true, preserveElOnDestroy: true, initComponent: function () { this.callParent(); this.setupViewport() }, getSizeModel: function () { var b = Ext.layout.SizeModel.configured; return b.pairsByHeightOrdinal[b.ordinal] }, handleViewportResize: function () { var e = this, c = Ext.dom.Element, d = c.getViewportWidth(), b = c.getViewportHeight(); if (d !== e.width || b !== e.height) { e.setSize(d, b) } }, setupViewport: function () { var c = this, b = document.body; if (!b.id) { b.id = c.id } b.setAttribute("data-componentid", c.id); if (!c.ariaStaticRoles[c.ariaRole]) { b.setAttribute("role", c.ariaRole) } b = c.el = Ext.getBody(); Ext.fly(document.documentElement).addCls(c.viewportCls); b.setHeight = b.setWidth = Ext.emptyFn; b.dom.scroll = "no"; c.allowDomMove = false; c.renderTo = b; if (Ext.supports.Touch) { c.addMeta("apple-mobile-web-app-capable", "yes") } Ext.getScrollbarSize(); c.width = c.height = undefined; c.initialViewportHeight = Ext.Element.getViewportHeight(); c.initialViewportWidth = Ext.Element.getViewportWidth() }, afterLayout: function (b) { if (Ext.supports.Touch) { document.body.scrollTop = 0 } this.callParent([b]) }, onRender: function () { var c = this, d = c.getOverflowEl(), b = Ext.getBody(); c.callParent(arguments); Ext.setViewportScroller(c.getScrollable() || { x: false, y: false, element: b }); if (c.getOverflowEl() !== b) { b.setStyle("overflow", "hidden") } c.width = c.initialViewportWidth; c.height = c.initialViewportHeight; c.initialViewportWidth = c.initialViewportHeight = null }, initInheritedState: function (d, c) { var e = this, b = Ext.rootInheritedState; if (d !== b) { e.initInheritedState(e.inheritedState = b, e.inheritedStateInner = Ext.Object.chain(b)) } else { e.callParent([d, c]) } }, doDestroy: function () { var d = this, b = Ext.rootInheritedState, c; for (c in b) { if (c !== "rtl") { delete b[c] } } d.removeUIFromElement(); d.el.removeCls(d.baseCls); Ext.fly(document.body.parentNode).removeCls(d.viewportCls); d.callParent() }, addMeta: function (b, c) { var d = document.createElement("meta"); d.setAttribute("name", b); d.setAttribute("content", c); Ext.getHead().appendChild(d) }, privates: { applyTargetCls: function (c) { var b = this.el; if (b === this.getTargetEl()) { this.el.addCls(c) } else { this.callParent([c]) } }, disableTabbing: function () { var b = this.el; if (b) { b.saveTabbableState({ skipSelf: true }) } }, enableTabbing: function () { var b = this.el; if (b) { b.restoreTabbableState(true) } } } }) } }, privates: { updateResponsiveState: function () { this.cmp.handleViewportResize(); Ext.plugin.Responsive.prototype.updateResponsiveState.call(this) } } }, 0, 0, 0, 0, ["plugin.viewport"], 0, [Ext.plugin, "Viewport"], function (a) { a.prototype.decorate = a.decorate })); (Ext.cmd.derive("Ext.container.Viewport", Ext.container.Container, { alternateClassName: "Ext.Viewport", ariaRole: "application", privates: { updateResponsiveState: function () { this.handleViewportResize(); this.mixins.responsive.updateResponsiveState.call(this) } } }, 0, ["viewport"], ["component", "box", "container", "viewport"], { component: true, box: true, container: true, viewport: true }, ["widget.viewport"], [[Ext.mixin.Responsive.prototype.mixinId || Ext.mixin.Responsive.$className, Ext.mixin.Responsive]], [Ext.container, "Viewport", Ext, "Viewport"], function () { Ext.plugin.Viewport.decorate(this) })); (Ext.cmd.derive("Ext.layout.container.Anchor", Ext.layout.container.Auto, { alternateClassName: "Ext.layout.AnchorLayout", type: "anchor", defaultAnchor: "100%", parseAnchorRE: /^(r|right|b|bottom)$/i, manageOverflow: true, setsItemSize: true, beginLayoutCycle: function (g) { var e = this, d = 0, j, a, h, b, c; Ext.layout.container.Auto.prototype.beginLayoutCycle.apply(this, arguments); h = g.childItems; c = h.length; for (b = 0; b < c; ++b) { a = h[b]; j = a.target.anchorSpec; if (j) { if (a.widthModel.calculated && j.right) { d |= 1 } if (a.heightModel.calculated && j.bottom) { d |= 2 } if (d === 3) { break } } } g.anchorDimensions = d }, calculateItems: function (h, a) { var q = this, l = h.childItems, g = l.length, o = a.gotHeight, j = a.gotWidth, e = a.height, c = a.width, b = (j ? 1 : 0) | (o ? 2 : 0), p = h.anchorDimensions, m, s, n, r, k, d; if (!p) { return true } for (k = 0; k < g; k++) { s = l[k]; n = s.getMarginInfo(); m = s.target.anchorSpec; if (j && s.widthModel.calculated) { d = m.right(c) - n.width; d = q.adjustWidthAnchor(d, s); s.setWidth(d) } if (o && s.heightModel.calculated) { r = m.bottom(e) - n.height; r = q.adjustHeightAnchor(r, s); s.setHeight(r) } } return (b & p) === p }, anchorFactory: { offset: function (a) { return function (b) { return b + a } }, ratio: function (a) { return function (b) { return Math.floor(b * a) } }, standard: function (a) { return function (b) { return b - a } } }, parseAnchor: function (c, g, b) { if (c && c !== "none") { var d = this.anchorFactory, e; if (this.parseAnchorRE.test(c)) { return d.standard(b - g) } if (c.indexOf("%") !== -1) { return d.ratio(parseFloat(c.replace("%", "")) * 0.01) } e = parseInt(c, 10); if (!isNaN(e)) { return d.offset(e) } } return null }, adjustWidthAnchor: function (b, a) { return b }, adjustHeightAnchor: function (b, a) { return b }, configureItem: function (g) { var e = this, a = e.owner, d = g.anchor, b, c, h; Ext.layout.container.Auto.prototype.configureItem.apply(this, arguments); if (!g.anchor && g.items && !Ext.isNumber(g.width)) { g.anchor = d = e.defaultAnchor } if (a.anchorSize) { if (typeof a.anchorSize === "number") { c = a.anchorSize } else { c = a.anchorSize.width; h = a.anchorSize.height } } else { c = a.initialConfig.width; h = a.initialConfig.height } if (d) { b = d.split(" "); g.anchorSpec = { right: e.parseAnchor(b[0], g.initialConfig.width, c), bottom: e.parseAnchor(b[1], g.initialConfig.height, h) } } }, sizePolicy: { $: { readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0 }, b: { readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1 }, r: { $: { readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0 }, b: { readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1 } } }, getItemSizePolicy: function (c) { var e = c.anchorSpec, a = "$", d = this.sizePolicy, b; if (e) { b = this.owner.getSizeModel(); if (e.right && !b.width.shrinkWrap) { d = d.r } if (e.bottom && !b.height.shrinkWrap) { a = "b" } } return d[a] } }, 0, 0, 0, 0, ["layout.anchor"], 0, [Ext.layout.container, "Anchor", Ext.layout, "AnchorLayout"], 0)); (Ext.cmd.derive("Ext.dashboard.Panel", Ext.panel.Panel, { cls: "x-dashboard-panel", anchor: "100%", layout: "fit", frame: true, closable: true, collapsible: true, animCollapse: true, titleCollapse: true, stateful: true, draggable: { moveOnDrag: false }, animateClose: true, loadMask: true, loadMessage: "Loading...", minHeight: 90, resizable: true, resizeHandles: "s", doClose: function () { var a = this; if (a.animateClose) { if (!a.closing) { a.closing = true; a.el.animate({ opacity: 0, callback: a.finishClose, scope: a }) } } else { a.finishClose() } }, finishClose: function () { var b = this, a = b.closeAction; b.closing = false; b.fireEvent("close", b); Ext.suspendLayouts(); b[a](); Ext.resumeLayouts(true); if (a === "hide") { b.el.setOpacity(1) } }, afterRender: function () { Ext.panel.Panel.prototype.afterRender.call(this); if (this.loading) { this.onViewBeforeLoad() } }, getLoadMask: function () { var c = this, b = c.rendered && c.loadMask, a; if (b && !b.isComponent) { a = { target: c }; if (b === true) { b = a } else { Ext.apply(a, b) } c.loadMask = b = Ext.ComponentManager.create(a, "loadmask") } return b || null }, onAdd: function (a) { Ext.panel.Panel.prototype.onAdd.apply(this, arguments); a.on({ beforeload: "onViewBeforeLoad", load: "onViewLoaded", scope: this }) }, onViewBeforeLoad: function () { this.loading = true; var a = this.getLoadMask(); if (a) { a.show() } }, onViewLoaded: function () { this.loading = false; var b = this.getLoadMask(); if (b) { b.hide() } var a = this.items.getAt(0); if (a.getTitle) { var c = a.getTitle(); if (c) { this.setTitle(c) } } }, setBox: function (a) { this.setSize(a.width, a.height) }, getState: function () { var a = this, b = Ext.panel.Panel.prototype.getState.call(this) || {}; if (!b.collapsed) { a.addPropertyToState(b, "height", a.rendered ? a.getHeight() : a.height || a.minHeight || 100) } return b } }, 0, ["dashboard-panel"], ["component", "box", "container", "panel", "dashboard-panel"], { component: true, box: true, container: true, panel: true, "dashboard-panel": true }, ["widget.dashboard-panel"], 0, [Ext.dashboard, "Panel"], 0)); (Ext.cmd.derive("Ext.dashboard.Column", Ext.container.Container, { layout: "anchor", isDashboardColumn: true, defaultType: "dashboard-panel", cls: "x-dashboard-column", synthetic: true, onRemove: function (k, h) { var j = this, d = j.ownerCt, c, a, b, e = 0, g; if (d && j.items.getCount() === 0) { c = Ext.Array.filter(d.query(">" + j.xtype + "[rowIndex=" + j.rowIndex + "]"), function (i) { return i !== j }); a = c.length; if (!j.destroying && !j.destroyed) { d.remove(j); if (a === 1) { c[0].columnWidth = 1 } else { for (g = 0; g < a; g++) { e += c[g].columnWidth || 0 } for (g = 0; g < a; g++) { b = c[g].columnWidth; c[g].columnWidth = Math.floor(b / e * 100) / 100 } } if (h) { d.updateLayout() } } } } }, 0, ["dashboard-column"], ["component", "box", "container", "dashboard-column"], { component: true, box: true, container: true, "dashboard-column": true }, ["widget.dashboard-column"], 0, [Ext.dashboard, "Column"], 0)); (Ext.cmd.derive("Ext.layout.container.Column", Ext.layout.container.Auto, { alternateClassName: "Ext.layout.ColumnLayout", type: "column", itemCls: "x-column", targetCls: "x-column-layout-ct", clearSide: "left", columnWidthSizePolicy: { readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0 }, createsInnerCt: true, manageOverflow: true, setsItemSize: true, needsItemSize: true, isItemShrinkWrap: function (a) { return true }, getItemSizePolicy: function (a, b) { if (a.columnWidth) { if (!b) { b = this.owner.getSizeModel() } if (!b.width.shrinkWrap) { return this.columnWidthSizePolicy } } return this.autoSizePolicy }, calculateItems: function (d, a) { var p = this, n = p.columnCount, e = d.targetContext, o = d.childItems, l = o.length, b = 0, g = a.gotWidth, j, q, h, c, k, m; if (g === false) { e.domBlock(p, "width"); j = true } else { if (g) { q = a.width } else { return true } } for (h = 0; h < l; ++h) { c = o[h]; if (n) { if (h % n) { c.setProp("clear", null) } else { c.setProp("clear", p.clearSide) } } k = c.getMarginInfo().width; if (!c.widthModel.calculated) { m = c.getProp("width"); if (typeof m !== "number") { c.block(p, "width"); j = true } b += m + k } } if (!j) { q = (q < b) ? 0 : q - b; for (h = 0; h < l; ++h) { c = o[h]; if (c.widthModel.calculated) { k = c.marginInfo.width; m = c.target.columnWidth; m = Math.floor(m * q) - k; m = c.setWidth(m); b += m + k } } d.setContentWidth(b + d.paddingContext.getPaddingInfo().width) } return !j } }, 0, 0, 0, 0, ["layout.column"], 0, [Ext.layout.container, "Column", Ext.layout, "ColumnLayout"], 0)); (Ext.cmd.derive("Ext.dd.DragTracker", Ext.Base, { active: false, trackOver: false, tolerance: 5, autoStart: false, constructor: function (a) { var b = this; Ext.apply(b, a); b.dragRegion = new Ext.util.Region(0, 0, 0, 0); if (b.el) { b.initEl(b.el) } b.mixins.observable.constructor.call(b); if (b.disabled) { b.disable() } if (Ext.supports.Touch) { Ext.getWin().on({ touchstart: "onWindowTouchStart", scope: b, capture: true }) } }, initEl: function (b) { var c = this, a = c.delegate, e, d; c.el = b = Ext.get(b); b.addCls("x-unselectable"); if (a && a.isElement) { c.handle = a } c.delegate = c.handle ? undefined : c.delegate; if (Ext.supports.Touch) { e = Ext.ComponentManager.fromElement(b); d = e && e.getScrollable(); if (d) { e = d.getElement(); if (c.handle && !e.contains(c.handle)) { d = false } else { if (c.delegate && !e.down(c.delegate)) { d = false } else { d = d.getX() || d.getY() } } } } if (!c.handle) { c.handle = b } c.handleListeners = { scope: c, delegate: c.delegate, dragstart: c.onDragStart }; if (d) { c.handleListeners.longpress = c.onMouseDown; c.handleListeners.mousedown = { fn: c.onMouseDown, delegate: c.delegate, translate: false }; c.handleListeners.contextmenu = function (g) { g.stopEvent() } } else { c.handleListeners.mousedown = c.onMouseDown } if (!Ext.supports.TouchEvents && (c.trackOver || c.overCls)) { Ext.apply(c.handleListeners, { mouseover: c.onMouseOver, mouseout: c.onMouseOut }) } c.mon(c.handle, c.handleListeners); c.keyNav = new Ext.util.KeyNav({ target: b, up: c.onResizeKeyDown, left: c.onResizeKeyDown, right: c.onResizeKeyDown, down: c.onResizeKeyDown, scope: c }) }, disable: function () { this.disabled = true }, enable: function () { this.disabled = false }, destroy: function () { var a = this; a.endDrag({}); a.el = a.handle = a.onBeforeStart = a.onStart = a.onDrag = a.onEnd = a.onCancel = null; a.callParent() }, onWindowTouchStart: function (a) { if (this.mouseIsDown) { this.onMouseUp(a) } }, onMouseOver: function (k, j) { var g = this, h, d, c, a, b; if (!g.disabled) { if (k.within(k.target, true, true) || g.delegate) { h = g.handleCls; g.mouseIsOut = false; if (h) { for (c = 0, a = g.handleEls.length; c < a; c++) { d = g.handleEls[c]; b = d.delegateCls; if (!b) { b = d.delegateCls = [h, "-", d.region, "-over"].join("") } d.addCls([b, g.overCls]) } } g.fireEvent("mouseover", g, k, g.delegate ? k.getTarget(g.delegate, j) : g.handle) } } }, onMouseOut: function (g) { var d = this, c, b, a; if (d.mouseIsDown) { d.mouseIsOut = true } else { if (d.handleCls) { for (b = 0, a = d.handleEls.length; b < a; b++) { c = d.handleEls[b]; c.removeCls([c.delegateCls, d.overCls]) } } d.fireEvent("mouseout", d, g) } }, onMouseDown: function (d, c) { var b = this, a = d.parentEvent || d; if (b.disabled || a.dragTracked) { return } b.dragTarget = b.delegate ? c : b.handle.dom; b.startXY = b.lastXY = d.getXY(); b.startRegion = Ext.fly(b.dragTarget).getRegion(); if (b.fireEvent("mousedown", b, d) === false || b.fireEvent("beforedragstart", b, d) === false || b.onBeforeStart(d) === false) { return } b.mouseIsDown = true; a.dragTracked = true; b.el.setCapture(); d.stopPropagation(); if (b.preventDefault !== false || d.pointerType === "touch") { d.preventDefault() } Ext.getDoc().on({ scope: b, capture: true, mouseup: b.onMouseUp, mousemove: b.onMouseMove, selectstart: b.stopSelect }); b.dragEnded = false; if (!b.tolerance) { b.triggerStart() } else { if (b.autoStart) { b.timer = Ext.defer(b.triggerStart, b.autoStart === true ? 1000 : b.autoStart, b, [d]) } } }, onMouseMove: function (g, d) { var b = this, c = g.getXY(), a = b.startXY; g.stopPropagation(); if (b.preventDefault !== false) { g.preventDefault() } if (b.dragEnded) { return } b.lastXY = c; if (!b.active) { if (Math.max(Math.abs(a[0] - c[0]), Math.abs(a[1] - c[1])) > b.tolerance) { b.triggerStart(g) } else { return } } if (b.fireEvent("mousemove", b, g) === false) { b.onMouseUp(g) } else { b.onDrag(g); b.fireEvent("drag", b, g) } }, onMouseUp: function (b) { var a = this; a.mouseIsDown = false; if (a.mouseIsOut) { a.mouseIsOut = false; a.onMouseOut(b) } if (a.preventDefault !== false) { b.preventDefault() } if (Ext.isIE && document.releaseCapture) { document.releaseCapture() } a.fireEvent("mouseup", a, b); a.endDrag(b) }, endDrag: function (c) { var b = this, a = b.active; Ext.getDoc().un({ mousemove: b.onMouseMove, mouseup: b.onMouseUp, selectstart: b.stopSelect, capture: true, scope: b }); b.clearStart(); b.active = false; b.dragEnded = true; if (a) { b.onEnd(c); b.fireEvent("dragend", b, c) } else { b.onCancel(c) } b._constrainRegion = null }, triggerStart: function (b) { var a = this; a.clearStart(); a.active = true; a.onStart(b); a.fireEvent("dragstart", a, b) }, clearStart: function () { var a = this.timer; if (a) { clearTimeout(a); this.timer = null } }, stopSelect: function (a) { a.stopEvent(); return false }, onBeforeStart: function (a) { }, onStart: function (a) { }, onDrag: function (a) { }, onCancel: function (a) { }, onEnd: function (a) { }, getDragTarget: function () { return this.dragTarget }, getDragCt: function () { return this.el }, getConstrainRegion: function () { var a = this; if (a.constrainTo) { if (a.constrainTo instanceof Ext.util.Region) { return a.constrainTo } if (!a._constrainRegion) { a._constrainRegion = Ext.fly(a.constrainTo).getViewRegion() } } else { if (!a._constrainRegion) { a._constrainRegion = a.getDragCt().getViewRegion() } } return a._constrainRegion }, getXY: function (a) { return a ? this.constrainModes[a](this, this.lastXY) : this.lastXY }, getOffset: function (c) { var b = this.getXY(c), a = this.startXY; return [b[0] - a[0], b[1] - a[1]] }, onDragStart: function (a) { a.stopPropagation() }, constrainModes: { point: function (b, d) { var c = b.dragRegion, a = b.getConstrainRegion(); if (!a) { return d } c.x = c.left = c[0] = c.right = d[0]; c.y = c.top = c[1] = c.bottom = d[1]; c.constrainTo(a); return [c.left, c.top] }, dragTarget: function (c, g) { var b = c.startXY, e = c.startRegion.copy(), a = c.getConstrainRegion(), d; if (!a) { return g } e.translateBy(g[0] - b[0], g[1] - b[1]); if (e.right > a.right) { g[0] += d = (a.right - e.right); e.left += d } if (e.left < a.left) { g[0] += (a.left - e.left) } if (e.bottom > a.bottom) { g[1] += d = (a.bottom - e.bottom); e.top += d } if (e.top < a.top) { g[1] += (a.top - e.top) } return g } } }, 1, 0, 0, 0, 0, [["observable", Ext.util.Observable]], [Ext.dd, "DragTracker"], 0)); (Ext.cmd.derive("Ext.resizer.SplitterTracker", Ext.dd.DragTracker, { enabled: true, overlayCls: "x-resizable-overlay", createDragOverlay: function () { var a, b = Ext.dom.Element; a = this.overlay = Ext.getBody().createChild({ role: "presentation", cls: this.overlayCls, html: "&#160;" }); a.unselectable(); a.setSize(b.getDocumentWidth(), b.getDocumentHeight()); a.show() }, getPrevCmp: function () { var a = this.getSplitter(); return a.previousSibling(":not([hidden])") }, getNextCmp: function () { var a = this.getSplitter(); return a.nextSibling(":not([hidden])") }, onBeforeStart: function (i) { var d = this, g = d.getPrevCmp(), a = d.getNextCmp(), c = d.getSplitter().collapseEl, h = i.getTarget(), b; if (!g || !a) { return false } if (c && h === c.dom) { return false } if (a.collapsed || g.collapsed) { return false } d.prevBox = g.getEl().getBox(); d.nextBox = a.getEl().getBox(); d.constrainTo = b = d.calculateConstrainRegion(); if (!b) { return false } return b }, onMouseDown: function (b, a) { Ext.dd.DragTracker.prototype.onMouseDown.call(this, b, a); if (this.mouseIsDown && this.getSplitter().el.dom === a) { Ext.dom.Element.maskIframes() } }, onMouseUp: function (a) { Ext.dd.DragTracker.prototype.onMouseUp.call(this, a); Ext.dom.Element.unmaskIframes() }, onStart: function (b) { var a = this.getSplitter(); this.createDragOverlay(); a.addCls(a.baseCls + "-active") }, onResizeKeyDown: function (g) { var b = this, d = b.getSplitter(), a = g.getKey(), c = d.orientation === "vertical" ? 0 : 1, i = a === g.UP || a === g.LEFT ? -1 : 1, h; if (!b.active && b.onBeforeStart(g)) { Ext.fly(g.target).on("keyup", b.onResizeKeyUp, b); b.triggerStart(g); b.onMouseDown(g); b.startXY = d.getXY(); b.lastKeyDownXY = Ext.Array.slice(b.startXY); h = b.easing = new Ext.fx.easing.Linear(); h.setStartTime(Ext.Date.now()); h.setStartValue(1); h.setEndValue(4); h.setDuration(2000) } if (b.active) { b.lastKeyDownXY[c] = Math.round(b.lastKeyDownXY[c] + (i * b.easing.getValue())); b.lastXY = b.lastKeyDownXY; d.setXY(b.getXY("dragTarget")) } }, onResizeKeyUp: function (a) { this.onMouseUp(a) }, calculateConstrainRegion: function () { var h = this, a = h.getSplitter(), i = a.getWidth(), j = a.defaultSplitMin, b = a.orientation, e = h.prevBox, k = h.getPrevCmp(), c = h.nextBox, g = h.getNextCmp(), m, l, d; if (b === "vertical") { d = { prevCmp: k, nextCmp: g, prevBox: e, nextBox: c, defaultMin: j, splitWidth: i }; m = new Ext.util.Region(e.y, h.getVertPrevConstrainRight(d), e.bottom, h.getVertPrevConstrainLeft(d)); l = new Ext.util.Region(c.y, h.getVertNextConstrainRight(d), c.bottom, h.getVertNextConstrainLeft(d)) } else { m = new Ext.util.Region(e.y + (k.minHeight || j), e.right, (k.maxHeight ? e.y + k.maxHeight : c.bottom - (g.minHeight || j)) + i, e.x); l = new Ext.util.Region((g.maxHeight ? c.bottom - g.maxHeight : e.y + (k.minHeight || j)) - i, c.right, c.bottom - (g.minHeight || j), c.x) } return m.intersect(l) }, performResize: function (n, h) { var p = this, a = p.getSplitter(), j = a.orientation, q = p.getPrevCmp(), o = p.getNextCmp(), b = a.ownerCt, l = b.query(">[flex]"), m = l.length, c = j === "vertical", k = 0, g = c ? "width" : "height", d = 0, r, s; for (; k < m; k++) { r = l[k]; s = c ? r.getWidth() : r.getHeight(); d += s; r.flex = s } h = c ? h[0] : h[1]; if (q) { s = p.prevBox[g] + h; if (q.flex) { q.flex = s } else { q[g] = s } } if (o) { s = p.nextBox[g] - h; if (o.flex) { o.flex = s } else { o[g] = s } } b.updateLayout() }, endDrag: function () { var a = this; if (a.overlay) { a.overlay.destroy(); delete a.overlay } Ext.dd.DragTracker.prototype.endDrag.apply(this, arguments) }, onEnd: function (c) { var a = this, b = a.getSplitter(); b.removeCls(b.baseCls + "-active"); a.performResize(c, a.getResizeOffset()) }, onDrag: function (g) { var c = this, h = c.getOffset("dragTarget"), d = c.getSplitter(), b = d.getEl(), a = d.orientation; if (a === "vertical") { b.setX(c.startRegion.left + h[0]) } else { b.setY(c.startRegion.top + h[1]) } }, getSplitter: function () { return this.splitter }, getVertPrevConstrainRight: function (a) { return (a.prevCmp.maxWidth ? a.prevBox.x + a.prevCmp.maxWidth : a.nextBox.right - (a.nextCmp.minWidth || a.defaultMin)) + a.splitWidth }, getVertPrevConstrainLeft: function (a) { return a.prevBox.x + (a.prevCmp.minWidth || a.defaultMin) }, getVertNextConstrainRight: function (a) { return a.nextBox.right - (a.nextCmp.minWidth || a.defaultMin) }, getVertNextConstrainLeft: function (a) { return (a.nextCmp.maxWidth ? a.nextBox.right - a.nextCmp.maxWidth : a.prevBox.x + (a.prevBox.minWidth || a.defaultMin)) - a.splitWidth }, getResizeOffset: function () { return this.getOffset("dragTarget") } }, 0, 0, 0, 0, 0, 0, [Ext.resizer, "SplitterTracker"], 0)); (Ext.cmd.derive("Ext.layout.container.ColumnSplitterTracker", Ext.resizer.SplitterTracker, { onStart: function (a) { Ext.apply(this.getSplitter().el.dom.style, { top: 0, left: 0 }); Ext.resizer.SplitterTracker.prototype.onStart.apply(this, arguments) }, endDrag: function () { var a = this; Ext.resizer.SplitterTracker.prototype.endDrag.apply(this, arguments); a.getSplitter().el.dom.style.left = 0 }, performResize: function (g, d) { var j = this, m = j.getPrevCmp(), i = j.getNextCmp(), b = j.getSplitter(), c = b.ownerCt, l = d[0], k, a, h; if (m && i) { m.width = k = j.prevBox.width + l; i.width = a = j.nextBox.width - l; h = (m.columnWidth + i.columnWidth) / (k + a); m.columnWidth = k * h; i.columnWidth = a * h } c.updateLayout() } }, 0, 0, 0, 0, 0, 0, [Ext.layout.container, "ColumnSplitterTracker"], 0)); (Ext.cmd.derive("Ext.layout.container.ColumnSplitter", Ext.resizer.Splitter, { isSplitter: true, synthetic: true, cls: "x-splitter-vertical", orientation: "vertical", collapseDirection: "left", trackerClass: "Ext.layout.container.ColumnSplitterTracker", width: 7, height: 1, getTrackerConfig: function () { var a = Ext.resizer.Splitter.prototype.getTrackerConfig.call(this); a.xclass = this.trackerClass; return a } }, 0, ["columnsplitter"], ["component", "box", "splitter", "columnsplitter"], { component: true, box: true, splitter: true, columnsplitter: true }, ["widget.columnsplitter"], 0, [Ext.layout.container, "ColumnSplitter"], 0)); (Ext.cmd.derive("Ext.layout.container.Dashboard", Ext.layout.container.Column, { type: "dashboard", firstColumnCls: "x-dashboard-column-first", lastColumnCls: "x-dashboard-column-last", getSplitterConfig: function () { return { xtype: "columnsplitter" } }, getColumns: function (a) { var b = Ext.Array; return b.filter(b.from(a), function (c) { return c.target && c.target.isSplitter !== true }) }, beginLayout: function (e) { var n = this; Ext.layout.container.Column.prototype.beginLayout.call(this, e); var k = e.childItems, q = (e.rows = []), d = k.length, l = 2, h = 0, r = 0, p = n.owner.getMaxColumns(), c, j, g, o, a, m, b; for (j = 0; j < d; ++j) { m = (c = k[j]).target; a = m && m.isSplitter; h += (a ? 0 : 1); b = a ? 0 : m.columnWidth || 1; if (l + b > 1 || (p && (h > p))) { if (g) { g.orphan = 1; g.el.setHeight(0) } l = 0; h = 1; if (q.length) { r = q.length - 1; n.syncFirstLast(n.getColumns(q[r].items)) } q.push(o = { index: q.length, items: [], maxHeight: 0 }) } l += b; o.items.push(c); c.row = o; m.rowIndex = o.index; if (a) { c.el.setHeight(1) } g = c } if (q.length) { n.syncFirstLast(n.getColumns(q[q.length - 1].items)) } }, beforeLayoutCycle: function (c) { var b = this, a = b.owner.items; if (b.splitterGen !== a.generation) { b.syncSplitters(); b.splitterGen = a.generation } Ext.layout.container.Column.prototype.beforeLayoutCycle.apply(this, arguments) }, finishedLayout: function (e) { var b = e.childItems, a = b.length, d, j, c, g, h; Ext.layout.container.Column.prototype.finishedLayout.call(this, e); for (c = 0; c < a; c += 2) { g = (j = b[c]).target; d = g.lastBox; h = j.row; h.maxHeight = Math.max(h.maxHeight, d.height); g.width = d.width } for (c = 1; c < a; c += 2) { g = (j = b[c]).target; if (!j.orphan) { g.el.setHeight(j.row.maxHeight) } } }, syncSplitters: function () { var h = this, a = h.owner, b = a.items.items, c = b.length, e = true, d = false, g, i; while (c-- > 0) { g = b[c]; if (d) { if (g.isSplitter) { d = false } else { if (e) { e = false; a.suspendLayouts() } i = a.add(c + 1, h.getSplitterConfig()) } } else { if (g.isSplitter) { if (e) { e = false; a.suspendLayouts() } a.remove(g) } else { d = true } } } while (b.length && (g = b[0]).isSplitter) { if (e) { e = false; a.suspendLayouts() } a.remove(g) } if (!e) { a.resumeLayouts() } }, syncFirstLast: function (e) { var g = this, b = g.firstColumnCls, j = g.lastColumnCls, d, a = [b, j], c, k, h; e = Ext.Array.from(e); d = e.length; for (c = 0; c < d; ++c) { k = e[c].target; h = (c === d - 1); if (!c) { if (h) { k.addCls(a) } else { k.addCls(b); k.removeCls(j) } } else { if (h) { k.addCls(j); k.removeCls(b) } else { k.removeCls(a) } } } } }, 0, 0, 0, 0, ["layout.dashboard"], 0, [Ext.layout.container, "Dashboard"], 0)); (Ext.cmd.derive("Ext.dd.DDTarget", Ext.dd.DragDrop, { constructor: function (c, a, b) { if (c) { this.initTarget(c, a, b) } }, getDragEl: Ext.emptyFn, isValidHandleChild: Ext.emptyFn, startDrag: Ext.emptyFn, endDrag: Ext.emptyFn, onDrag: Ext.emptyFn, onDragDrop: Ext.emptyFn, onDragEnter: Ext.emptyFn, onDragOut: Ext.emptyFn, onDragOver: Ext.emptyFn, onInvalidDrop: Ext.emptyFn, onMouseDown: Ext.emptyFn, onMouseUp: Ext.emptyFn, setXConstraint: Ext.emptyFn, setYConstraint: Ext.emptyFn, resetConstraints: Ext.emptyFn, clearConstraints: Ext.emptyFn, clearTicks: Ext.emptyFn, setInitPosition: Ext.emptyFn, setDragElId: Ext.emptyFn, setHandleElId: Ext.emptyFn, setOuterHandleElId: Ext.emptyFn, addInvalidHandleClass: Ext.emptyFn, addInvalidHandleId: Ext.emptyFn, addInvalidHandleType: Ext.emptyFn, removeInvalidHandleClass: Ext.emptyFn, removeInvalidHandleId: Ext.emptyFn, removeInvalidHandleType: Ext.emptyFn, toString: function () { return ("DDTarget " + this.id) } }, 3, 0, 0, 0, 0, 0, [Ext.dd, "DDTarget"], 0)); (Ext.cmd.derive("Ext.dd.ScrollManager", Ext.Base, { singleton: true, dirTrans: { up: -1, left: -1, down: 1, right: 1 }, constructor: function () { var a = Ext.dd.DragDropManager; a.fireEvents = Ext.Function.createSequence(a.fireEvents, this.onFire, this); a.stopDrag = Ext.Function.createSequence(a.stopDrag, this.onStop, this); this.doScroll = this.doScroll.bind(this); this.ddmInstance = a; this.els = {}; this.dragEl = null; this.proc = {} }, onStop: function (a) { var b = Ext.dd.ScrollManager; b.dragEl = null; b.clearProc() }, triggerRefresh: function () { if (this.ddmInstance.dragCurrent) { this.ddmInstance.refreshCache(this.ddmInstance.dragCurrent.groups) } }, doScroll: function () { var g = this; if (g.ddmInstance.dragCurrent) { var a = g.proc, e = a.el, c = a.component, h = a.el.ddScrollConfig, i = h && h.increment ? h.increment : g.increment, b = h && "animate" in h ? h.animate : g.animate, d = function () { g.triggerRefresh() }; if (b) { if (b === true) { b = { callback: d } } else { b.callback = b.callback ? Ext.Function.createSequence(b.callback, d) : d } } if (c) { i = i * g.dirTrans[a.dir]; if (a.dir === "up" || a.dir === "down") { c.scrollBy(0, i, b) } else { c.scrollBy(i, 0, b) } } else { e.scroll(a.dir, i, b) } if (!b) { d() } } }, clearProc: function () { var a = this.proc; if (a.id) { clearInterval(a.id) } a.id = 0; a.el = null; a.dir = "" }, startProc: function (c, b) { var d = this, a = d.proc, g, e; d.clearProc(); a.el = c; a.dir = b; g = c.ddScrollConfig ? c.ddScrollConfig.ddGroup : undefined; e = (c.ddScrollConfig && c.ddScrollConfig.frequency) ? c.ddScrollConfig.frequency : d.frequency; if (g === undefined || d.ddmInstance.dragCurrent.ddGroup === g) { a.id = Ext.interval(d.doScroll, e) } }, onFire: function (h, k) { var j = this, l, i, d, a, b, g, c; if (k || !j.ddmInstance.dragCurrent) { return } if (!j.dragEl || j.dragEl !== j.ddmInstance.dragCurrent) { j.dragEl = j.ddmInstance.dragCurrent; j.refreshCache() } l = h.getPoint(); i = j.proc; d = j.els; for (a in d) { b = d[a]; g = b._region; c = b.ddScrollConfig || j; if (g && g.contains(l) && b.isScrollable()) { if (g.bottom - l.y <= c.vthresh) { if (i.el !== b) { j.startProc(b, "down") } return } else { if (g.right - l.x <= c.hthresh) { if (i.el !== b) { j.startProc(b, "right") } return } else { if (l.y - g.top <= c.vthresh) { if (i.el !== b) { j.startProc(b, "up") } return } else { if (l.x - g.left <= c.hthresh) { if (i.el !== b) { j.startProc(b, "left") } return } } } } } } j.clearProc() }, register: function (c) { if (Ext.isArray(c)) { for (var b = 0, a = c.length; b < a; b++) { this.register(c[b]) } } else { c = Ext.get(c); this.els[c.id] = c } }, unregister: function (c) { if (Ext.isArray(c)) { for (var b = 0, a = c.length; b < a; b++) { this.unregister(c[b]) } } else { c = Ext.get(c); delete this.els[c.id] } }, vthresh: 25 * (window.devicePixelRatio || 1), hthresh: 25 * (window.devicePixelRatio || 1), increment: 100, frequency: 500, animate: true, animDuration: 0.4, ddGroup: undefined, refreshCache: function () { var a = this.els, b; for (b in a) { if (typeof a[b] === "object") { a[b]._region = a[b].getRegion() } } } }, 1, 0, 0, 0, 0, 0, [Ext.dd, "ScrollManager"], 0)); (Ext.cmd.derive("Ext.dd.DropTarget", Ext.dd.DDTarget, { constructor: function (b, a) { this.el = Ext.get(b); Ext.apply(this, a); if (this.containerScroll) { Ext.dd.ScrollManager.register(this.el) } Ext.dd.DDTarget.prototype.constructor.call(this, this.el.dom, this.ddGroup || this.group, { isTarget: true }) }, containerScroll: false, dropAllowed: "x-dd-drop-ok", dropNotAllowed: "x-dd-drop-nodrop", isTarget: true, isNotifyTarget: true, notifyEnter: function (a, c, b) { if (this.overClass) { this.el.addCls(this.overClass) } return this.dropAllowed }, notifyOver: function (a, c, b) { return this.dropAllowed }, notifyOut: function (a, c, b) { if (this.overClass) { this.el.removeCls(this.overClass) } }, notifyDrop: function (a, c, b) { if (this.overClass) { this.el.removeCls(this.overClass) } return false }, destroy: function () { if (this.containerScroll) { Ext.dd.ScrollManager.unregister(this.el) } Ext.dd.DDTarget.prototype.destroy.call(this) } }, 1, 0, 0, 0, 0, 0, [Ext.dd, "DropTarget"], 0)); (Ext.cmd.derive("Ext.dashboard.DropZone", Ext.dd.DropTarget, { ddScrollConfig: { vthresh: 75, hthresh: -1, animate: true, increment: 200 }, containerScroll: true, overClass: "x-dashboard-dd-over", constructor: function (b, a) { this.dashboard = b; b.body.ddScrollConfig = this.ddScrollConfig; Ext.dd.DropTarget.prototype.constructor.call(this, b.body, a) }, getOverEvent: function (A, v, C) { var p = this.dashboard, b = p.body, o = p.items.items, c = b.getBox(), g = o.length, d = v.getXY(), l = d[0] - c.x + b.getScrollLeft(), j = d[1] - c.y + b.getScrollTop(), r = { columnIndex: 0, column: null, dashboard: p, above: null, extensible: false, beforeAfter: 0, data: C, panel: C.panel, rawEvent: v, source: A, status: this.dropAllowed }, n, B, s, q, z, m, u, a, h; for (s = 0; s < g; s += 2) { z = o[s]; m = z.lastBox.width; if (o[s + 1]) { m += o[s + 1].lastBox.width } if (v.within(z.el)) { r.columnIndex = s; r.column = z; r.extensible = this.isRowExtensible(z.rowIndex); n = Math.min(80, m * 0.2); r.beforeAfter = n = (r.extensible && ((l < n) ? -1 : ((l > m - n) ? 1 : 0))); if (!n || !r.extensible) { a = z.items.items; for (q = 0, u = a.length; q < u; ++q) { h = a[q]; B = h.el.getHeight(); if (j < B / 2) { r.above = h; break } j -= B } } break } l -= m } return r }, notifyOver: function (p, i, h) { var m = this, n = m.dashboard, j = m.getOverEvent(p, i, h), c = j.column && j.column.el, l = p.proxy, b, d = j.above, g, a = 0, o, k = n.hasListeners; h.lastOver = j; if ((!k.validatedrop || n.fireEvent("validatedrop", j) !== false) && (!k.beforedragover || n.fireEvent("beforedragover", j) !== false)) { b = p.panelProxy.getProxy(); l.getProxy().setWidth("auto"); if (c) { a = g = c.getWidth(); if (j.beforeAfter) { p.panelProxy.moveProxy(c.dom, c.dom.firstChild); a = g / 2; b.setWidth(a) } else { if (d) { p.panelProxy.moveProxy(d.el.dom.parentNode, d.el.dom) } else { p.panelProxy.moveProxy(c.dom, null) } b.setWidth("auto") } if (a) { } b.setStyle({ "float": "none", clear: "none", "margin-left": (j.beforeAfter > 0) ? (g - a - c.getPadding("lr")) + "px" : "", "margin-top": "7px" }) } else { o = n.body.getPadding("lr"); b.setStyle({ "float": "left", clear: "left", margin: "0 7px 0 7px" }); b.setWidth(n.body.getWidth() - o); p.panelProxy.moveProxy(n.body.dom.firstChild.firstChild, null) } this.scrollPos = n.body.getScroll(); if (k.dragover) { n.fireEvent("dragover", j) } } return j.status }, isRowExtensible: function (d) { var c = this, b = c.dashboard, a = b.getMaxColumns() || 1; return Ext.Array.from(b.query(">dashboard-column[rowIndex=" + d + "]")).length < a }, notifyDrop: function (p, h, c) { Ext.dd.DropTarget.prototype.notifyDrop.apply(this, arguments); var l = this.dashboard, i = c.lastOver, a = i.panel, m = a.ownerCt, d = i.column, k = d ? i.beforeAfter : 1, g = m.items.indexOf(a), o = d ? (i.above ? d.items.indexOf(i.above) : d.items.getCount()) : 0, n, b, j = l.hasListeners; if (m === d) { if (m.items.getCount() === 1) { return } if (!k) { if (g < o) { --o } if (g === o) { return } } } if ((j.validatedrop && l.fireEvent("validatedrop", i) === false) || (j.beforedrop && l.fireEvent("beforedrop", i) === false)) { return } Ext.suspendLayouts(); a.isMoving = true; if (k) { n = l.items.indexOf(d); if (n < 0) { n = l.items.getCount() } else { if (k > 0) { ++n } } b = l.createColumn(); if (d) { b.columnWidth = d.columnWidth = d.columnWidth / 2; delete d.width } else { b.columnWidth = 1 } d = l.insert(n, b); o = 0 } a.el.dom.style.display = ""; d.insert(o, a); a.isMoving = false; d.updateLayout(); Ext.resumeLayouts(true); if (j.drop) { l.fireEvent("drop", i) } } }, 1, 0, 0, 0, 0, 0, [Ext.dashboard, "DropZone"], 0)); (Ext.cmd.derive("Ext.dashboard.Part", Ext.Base, { factoryConfig: { type: "part" }, isPart: true, _lastId: 0, config: { id: null, dashboard: null, viewTemplate: { collapsed: "{collapsed}", columnIndex: "{columnIndex}", id: "{id}", title: "{title}", height: "{height}" } }, viewTemplateOptions: { excludeProperties: { bind: 1 } }, valueRe: /^[{][a-z]*[}]$/i, constructor: function (a) { this.initConfig(a) }, applyViewTemplate: function (a) { return Ext.util.ObjectTemplate.create(a, this.viewTemplateOptions) }, displayForm: function (a, b, d, c) { d.call(c || this, {}) }, createView: function (b) { var d = this, c = d.getViewTemplate(), a = c.apply(b); a.dashboard = d.getDashboard(); a.part = d; a._partConfig = b; return a } }, 1, 0, 0, 0, ["part.part"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable], [Ext.mixin.Identifiable.prototype.mixinId || Ext.mixin.Identifiable.$className, Ext.mixin.Identifiable]], [Ext.dashboard, "Part"], 0)); (Ext.cmd.derive("Ext.dashboard.Dashboard", Ext.panel.Panel, { isDashboard: true, cls: "x-dashboard", bodyCls: "x-dashboard-body", defaultType: "dashboard-column", scrollable: true, layout: null, stateful: false, idSeed: 1, config: { parts: null }, renderConfig: { maxColumns: 4 }, initComponent: function () { var a = this; if (!a.layout) { a.layout = { type: "dashboard" } } Ext.panel.Panel.prototype.initComponent.call(this) }, applyParts: function (b, c) { if (!c) { c = new Ext.util.Collection({ decoder: Ext.Factory.part }) } var d, a; for (d in b) { a = b[d]; if (Ext.isString(a)) { a = { type: a } } a.id = d; a.dashboard = this; c.add(a) } return c }, getPart: function (a) { var b = this.getParts(); return b.getByKey(a) }, addNew: function (c, b, e) { var d = this, a = d.getPart(c); a.displayForm(null, null, function (g) { g.type = c; d.addView(g, b, e) }) }, addView: function (k, e, i) { var h = this, g = h.query("dashboard-column"), c = g.length, d = e || 0, j = k.id ? k : h.createView(k), a = h.columnWidths, b; if (!c) { b = h.add(0, h.createColumn({ columnWidth: (Ext.isArray(a) ? a[0] : 1) })); g = [b]; c = 1 } if (d >= c) { d = c - 1; i = 1 } if (!i) { b = g[d]; if (b) { return b.add(j) } } if (i > 0) { ++d } b = h.createColumn(); if (a) { b.columnWidth = a[d] || (a[d] = 1) } if (!b.items) { b.items = [] } b.items.push(j); b = h.add(b); return b.items.first() }, createColumn: function (a) { var b = this.cycleLayout; return Ext.apply({ items: [], bubbleEvents: ["add", "remove", "childmove", "resize"], listeners: { remove: this.onRemoveItem, expand: b, collapse: b, scope: this } }, a) }, createView: function (c) { var e = this, d = c.type, b = e.getPart(d), a = b.createView(c); if (!a.id) { a.id = e.id + "_" + d + (e.idSeed++) } a.bubbleEvents = Ext.Array.from(a.bubbleEvents).concat(["expand", "collapse"]); a.stateful = e.stateful; return a }, initEvents: function () { Ext.panel.Panel.prototype.initEvents.call(this); this.dd = new Ext.dashboard.DropZone(this, this.dropConfig) }, cycleLayout: function () { this.updateLayout() }, doDestroy: function () { if (this.dd) { Ext.destroy(this.dd) } Ext.panel.Panel.prototype.doDestroy.call(this) }, applyState: function (g) { delete g.items; var e = this; Ext.panel.Panel.prototype.applyState.call(this, g); var b = g.columnWidths, a = e.items.items, d = a.length, c, h; if (b) { h = b.length; e.columnWidths = []; for (c = 0; c < d; ++c) { e.columnWidths.push(a[c].columnWidth = (c < h) ? b[c] : (1 / d)) } } }, getState: function () { var g = this, b = [], a = g.items.items, h = Ext.panel.Panel.prototype.getState.call(this) || {}, e = a.length, c, d; for (c = 0; c < e; ++c) { if (!(d = a[c]).isSplitter) { b.push(d.columnWidth) } } h.columnWidths = b; h.idSeed = g.idSeed; h.items = g.serializeItems(); g.columnWidths = b; return h }, initItems: function () { var b = this, a = b.defaultContent, c; if (b.stateful) { c = Ext.state.Manager.get(b.getStateId()); a = (c && c.items) || a } if (!b.items && a) { b.items = b.deserializeItems(a) } Ext.panel.Panel.prototype.initItems.call(this) }, deserializeItems: function (g) { var k = this, c = g.length, e = [], a = k.columnWidths, n = k.getMaxColumns(), d, j, b, h, m, l; for (h = 0; h < c; ++h) { l = g[h]; j = Math.min(l.columnIndex || 0, n - 1); delete l.columnIndex; if (!(d = e[j])) { e[j] = d = k.createColumn(); b = a && a[j]; if (b) { d.columnWidth = b } } m = k.createView(l); d.items.push(m) } for (h = 0, c = e.length; h < c; ++h) { d = e[h]; if (!d.columnWidth) { d.columnWidth = 1 / c } } return e }, serializeItem: function (a) { return Ext.apply({ type: a.part.id, id: a.id, columnIndex: a.columnIndex }, a._partConfig) }, serializeItems: function () { var n = this, m = n.items.items, b = m.length, l = [], h = 0, a, g, e, o, d, c; for (e = 0; e < b; ++e) { o = m[e]; if (!o.isSplitter) { g = o.items.items; for (d = 0, c = g.length; d < c; ++d) { a = g[d]; a.columnIndex = h; l.push(n.serializeItem(a)) } ++h } } return l }, onRemoveItem: function (a, b) { if (b.stateful && !b.isMoving) { Ext.state.Manager.clear(b.getStateId()) } } }, 0, ["dashboard"], ["component", "box", "container", "panel", "dashboard"], { component: true, box: true, container: true, panel: true, dashboard: true }, ["widget.dashboard"], 0, [Ext.dashboard, "Dashboard"], 0)); (Ext.cmd.derive("Ext.dd.DragZone", Ext.dd.DragSource, { constructor: function (c, b) { var d = this, a; Ext.dd.DragSource.prototype.constructor.call(this, c, b); a = d.containerScroll; if (a) { c = d.scrollEl || c; c = Ext.get(c); if (Ext.isObject(a)) { c.ddScrollConfig = a } Ext.dd.ScrollManager.register(c) } }, getDragData: function (a) { return Ext.dd.Registry.getHandleFromEvent(a) }, onInitDrag: function (a, b) { this.proxy.update(this.dragData.ddel.cloneNode(true)); this.onStartDrag(a, b); return true }, getRepairXY: function (a) { return Ext.fly(this.dragData.ddel).getXY() }, destroy: function () { if (this.containerScroll) { Ext.dd.ScrollManager.unregister(this.scrollEl || this.el) } Ext.dd.DragSource.prototype.destroy.call(this) } }, 1, 0, 0, 0, 0, 0, [Ext.dd, "DragZone"], 0)); (Ext.cmd.derive("Ext.dd.Registry", Ext.Base, { singleton: true, constructor: function () { this.elements = {}; this.handles = {}; this.autoIdSeed = 0 }, getId: function (b, a) { if (typeof b === "string") { return b } var c = b.id; if (!c && a !== false) { c = "extdd-" + (++this.autoIdSeed); b.id = c } return c }, register: function (d, e) { e = e || {}; if (typeof d === "string") { d = document.getElementById(d) } e.ddel = d; this.elements[this.getId(d)] = e; if (e.isHandle !== false) { this.handles[e.ddel.id] = e } if (e.handles) { var c = e.handles, b, a; for (b = 0, a = c.length; b < a; b++) { this.handles[this.getId(c[b])] = e } } }, unregister: function (d) { var g = this.getId(d, false), e = this.elements[g], c, b, a; if (e) { delete this.elements[g]; if (e.handles) { c = e.handles; for (b = 0, a = c.length; b < a; b++) { delete this.handles[this.getId(c[b], false)] } } } }, getHandle: function (a) { if (typeof a !== "string") { a = a.id } return this.handles[a] }, getHandleFromEvent: function (b) { var a = b.getTarget(); return a ? this.handles[a.id] : null }, getTarget: function (a) { if (typeof a !== "string") { a = a.id } return this.elements[a] }, getTargetFromEvent: function (b) { var a = b.getTarget(); return a ? this.elements[a.id] || this.handles[a.id] : null } }, 1, 0, 0, 0, 0, 0, [Ext.dd, "Registry"], 0)); (Ext.cmd.derive("Ext.dd.DropZone", Ext.dd.DropTarget, { getTargetFromEvent: function (a) { return Ext.dd.Registry.getTargetFromEvent(a) }, onNodeEnter: function (d, a, c, b) { }, onNodeOver: function (d, a, c, b) { return this.dropAllowed }, onNodeOut: function (d, a, c, b) { }, onNodeDrop: function (d, a, c, b) { return false }, onContainerOver: function (a, c, b) { return this.dropNotAllowed }, onContainerDrop: function (a, c, b) { return false }, notifyEnter: function (a, c, b) { Ext.dd.DropTarget.prototype.notifyEnter.call(this, a, c, b); return this.dropNotAllowed }, notifyOver: function (a, d, c) { var b = this, g = b.getTargetFromEvent(d); if (!g) { if (b.lastOverNode) { b.onNodeOut(b.lastOverNode, a, d, c); b.lastOverNode = null } return b.onContainerOver(a, d, c) } if (b.lastOverNode !== g) { if (b.lastOverNode) { b.onNodeOut(b.lastOverNode, a, d, c) } b.onNodeEnter(g, a, d, c); b.lastOverNode = g } return b.onNodeOver(g, a, d, c) }, notifyOut: function (a, c, b) { Ext.dd.DropTarget.prototype.notifyOut.call(this, a, c, b); if (this.lastOverNode) { this.onNodeOut(this.lastOverNode, a, c, b); this.lastOverNode = null } }, notifyDrop: function (b, g, d) { var c = this, h = c.getTargetFromEvent(g), a = h ? c.onNodeDrop(h, b, g, d) : c.onContainerDrop(b, g, d); if (c.lastOverNode) { c.onNodeOut(c.lastOverNode, b, g, d); c.lastOverNode = null } return a }, triggerCacheRefresh: function () { Ext.dd.DDM.refreshCache(this.groups) } }, 0, 0, 0, 0, 0, 0, [Ext.dd, "DropZone"], 0)); (Ext.cmd.derive("Ext.dom.Layer", Ext.Element, { alternateClassName: "Ext.Layer", isLayer: true, constructor: function (c, h) { c = c || {}; var k = this, j = Ext.DomHelper, i = c.parentEl, g = i ? Ext.getDom(i) : document.body, a = c.hideMode, m = "x-" + (c.fixed ? "fixed-layer" : "layer"), d, b, e, l; if (h) { d = Ext.getDom(h); if (!d.parentNode) { g.appendChild(d) } } if (!d) { d = j.append(g, c.dh || { tag: "div", cls: m }) } if (c.id) { d.id = c.id } b = d.id; if (b) { e = Ext.cache[b]; if (e) { delete Ext.cache[b]; e.dom = null } } Ext.dom.Element.prototype.constructor.call(this, d); if (h) { k.addCls(m) } if (c.preventSync) { k.preventSync = true } if (c.cls) { k.addCls(c.cls) } k.constrain = c.constrain !== false; if (a) { k.setVisibilityMode(Ext.Element[a.toUpperCase()]) } else { if (c.useDisplay) { k.setVisibilityMode(Ext.Element.DISPLAY) } else { k.setVisibilityMode(Ext.Element.VISIBILITY) } } if (c.shadow) { k.shadowOffset = c.shadowOffset || 4; l = { offset: k.shadowOffset, fixed: c.fixed }; if (c.shadow !== true) { l.mode = c.shadow } k.enableShadow(l) } else { k.shadowOffset = 0 } if (c.shim) { k.enableShim({ fixed: c.fixed }) } if (c.hidden === true) { k.hide() } else { if (c.hidden === false) { k.show() } } } }, 1, 0, 0, 0, 0, 0, [Ext.dom, "Layer", Ext, "Layer"], 0)); (Ext.cmd.derive("Ext.event.publisher.MouseEnterLeave", Ext.event.publisher.Dom, { type: "mouseEnterLeave" }, 0, 0, 0, 0, 0, 0, [Ext.event.publisher, "MouseEnterLeave"], function (a) { var b = { mouseover: "mouseenter", mouseout: "mouseleave" }; if (!Ext.supports.MouseEnterLeave) { a.override({ handledDomEvents: ["mouseover", "mouseout"], handledEvents: ["mouseenter", "mouseleave"], publishDelegatedDomEvent: function (j) { var i, c, k, g, d, h; j = this.callParent([j]); i = j.getTarget(); c = j.getRelatedTarget(); if (c && Ext.fly(i).contains(c)) { return } k = i.id; if (k) { g = Ext.cache[k]; if (g) { d = b[j.type]; j = j.chain({ type: d }); if (g.hasListeners[d]) { h = g.events[d]; if (h) { h = h.directs; if (h) { j.setCurrentTarget(g.dom); h.fire(j, j.target) } } } } } } }) } a.instance = new a() })); (Ext.cmd.derive("Ext.flash.Component", Ext.Component, { alternateClassName: "Ext.FlashComponent", flashVersion: "9.0.115", backgroundColor: "#ffffff", wmode: "opaque", swfWidth: "100%", swfHeight: "100%", expressInstall: false, renderTpl: ['<div id="{swfId}" role="application"></div>'], initComponent: function () { Ext.Component.prototype.initComponent.call(this) }, beforeRender: function () { Ext.Component.prototype.beforeRender.call(this); Ext.applyIf(this.renderData, { swfId: this.getSwfId() }) }, afterRender: function () { var b = this, a = Ext.apply({}, b.flashParams), c = Ext.apply({}, b.flashVars); Ext.Component.prototype.afterRender.call(this); a = Ext.apply({ allowScriptAccess: "always", bgcolor: b.backgroundColor, wmode: b.wmode }, a); c = Ext.apply({ allowedDomain: document.location.hostname }, c); new swfobject.embedSWF(b.url, b.getSwfId(), b.swfWidth, b.swfHeight, b.flashVersion, b.expressInstall ? b.statics.EXPRESS_INSTALL_URL : undefined, c, a, b.flashAttributes, b.swfCallback.bind(b)) }, swfCallback: function (b) { var a = this; if (b.success) { a.swf = Ext.get(b.ref); a.onSuccess(); a.fireEvent("success", a) } else { a.onFailure(); a.fireEvent("failure", a) } }, getSwfId: function () { return this.swfId || (this.swfId = "extswf" + this.getAutoId()) }, onSuccess: function () { this.swf.setStyle("visibility", "inherit") }, onFailure: Ext.emptyFn, doDestroy: function () { var b = this, a = b.swf; if (a) { swfobject.removeSWF(b.getSwfId()); b.swf = Ext.destroy(a) } Ext.Component.prototype.doDestroy.call(this) }, statics: { EXPRESS_INSTALL_URL: "http://swfobject.googlecode.com/svn/trunk/swfobject/expressInstall.swf" } }, 0, ["flash"], ["component", "box", "flash"], { component: true, box: true, flash: true }, ["widget.flash"], 0, [Ext.flash, "Component", Ext, "FlashComponent"], 0)); (Ext.cmd.derive("Ext.form.action.Action", Ext.Base, { alternateClassName: "Ext.form.Action", submitEmptyText: true, constructor: function (a) { if (a) { Ext.apply(this, a) } var b = a.params; if (Ext.isString(b)) { this.params = Ext.Object.fromQueryString(b) } }, run: Ext.emptyFn, onFailure: function (a) { var c = this.form, b = c && !c.destroying && !c.destroyed; this.response = a; this.failureType = Ext.form.action.Action.CONNECT_FAILURE; if (b) { c.afterAction(this, false) } }, processResponse: function (a) { this.response = a; if (!a.responseText && !a.responseXML) { return true } return (this.result = this.handleResponse(a)) }, getUrl: function () { return this.url || this.form.url }, getMethod: function () { return (this.method || this.form.method || "POST").toUpperCase() }, getParams: function () { return Ext.apply({}, this.params, this.form.baseParams) }, createCallback: function () { var a = this; return { success: a.onSuccess, failure: a.onFailure, scope: a, timeout: (a.timeout || a.form.timeout) * 1000 } }, statics: { CLIENT_INVALID: "client", SERVER_INVALID: "server", CONNECT_FAILURE: "connect", LOAD_FAILURE: "load" } }, 1, 0, 0, 0, 0, 0, [Ext.form.action, "Action", Ext.form, "Action"], 0)); (Ext.cmd.derive("Ext.form.action.Load", Ext.form.action.Action, { alternateClassName: "Ext.form.Action.Load", type: "load", run: function () { Ext.Ajax.request(Ext.apply(this.createCallback(), { method: this.getMethod(), url: this.getUrl(), headers: this.headers, params: this.getParams() })) }, onSuccess: function (b) { var a = this.processResponse(b), d = this.form, c = d && !d.destroying && !d.destroyed; if (a === true || !a.success || !a.data) { this.failureType = Ext.form.action.Action.LOAD_FAILURE; if (c) { d.afterAction(this, false) } return } if (c) { d.clearInvalid(); d.setValues(a.data); d.afterAction(this, true) } }, handleResponse: function (c) { var a = this.form.reader, b, d; if (a) { b = a.read(c); d = b.records && b.records[0] ? b.records[0].data : null; return { success: b.success, data: d } } return Ext.decode(c.responseText) } }, 0, 0, 0, 0, ["formaction.load"], 0, [Ext.form.action, "Load", Ext.form.Action, "Load"], 0)); (Ext.cmd.derive("Ext.form.action.Submit", Ext.form.action.Action, { alternateClassName: "Ext.form.Action.Submit", type: "submit", run: function () { var b = this, a = b.form; if (b.clientValidation === false || a.isValid()) { b.doSubmit() } else { b.failureType = Ext.form.action.Action.CLIENT_INVALID; a.afterAction(b, false) } }, doSubmit: function () { var d = this, b = Ext.apply(d.createCallback(), { url: d.getUrl(), method: d.getMethod(), headers: d.headers }), c = d.form, e = d.jsonSubmit || c.jsonSubmit, a = e ? "jsonData" : "params", g; if (c.hasUpload()) { g = d.buildForm(); b.form = g.formEl; b.isUpload = true } else { b[a] = d.getParams(e) } Ext.Ajax.request(b); if (g) { d.cleanup(g) } }, cleanup: function (h) { var e = h.formEl, d = h.uploadEls, b = h.uploadFields, a = b.length, c, g; for (c = 0; c < a; ++c) { g = b[c]; if (!g.clearOnSubmit) { g.restoreInput(d[c]) } } if (e) { Ext.removeNode(e) } }, getParams: function (d) { var c = false, b = Ext.form.action.Action.prototype.getParams.call(this), a = this.form.getValues(c, c, this.submitEmptyText !== c, d, true); return Ext.apply({}, a, b) }, buildForm: function () { var k = this, n = [], l, s, h = k.form, d = k.getParams(), c = [], a = [], g = h.getFields().items, e, j = g.length, m, r, p, q, o, b; for (e = 0; e < j; ++e) { m = g[e]; if (m.isFileUpload()) { c.push(m) } } for (r in d) { if (d.hasOwnProperty(r)) { p = d[r]; if (Ext.isArray(p)) { o = p.length; for (q = 0; q < o; q++) { n.push(k.getFieldConfig(r, p[q])) } } else { n.push(k.getFieldConfig(r, p)) } } } l = { tag: "form", role: "presentation", action: k.getUrl(), method: k.getMethod(), target: k.target ? (Ext.isString(k.target) ? k.target : Ext.fly(k.target).dom.name) : "_self", style: "display:none", cn: n }; if (c.length) { l.encoding = l.enctype = "multipart/form-data" } s = Ext.DomHelper.append(Ext.getBody(), l); j = c.length; for (e = 0; e < j; ++e) { b = c[e].extractFileInput(); s.appendChild(b); a.push(b) } return { formEl: s, uploadFields: c, uploadEls: a } }, getFieldConfig: function (a, b) { return { tag: "input", type: "hidden", name: a, value: Ext.String.htmlEncode(b) } }, onSuccess: function (b) { var d = this.form, c = d && !d.destroying && !d.destroyed, e = true, a = this.processResponse(b); if (a !== true && !a.success) { if (a.errors && c) { d.markInvalid(a.errors) } this.failureType = Ext.form.action.Action.SERVER_INVALID; e = false } if (c) { d.afterAction(this, e) } }, handleResponse: function (d) { var a = this.form, c = a.errorReader, g, l, h, j, b, m; if (c) { g = c.read(d); b = g.records; l = []; if (b) { for (h = 0, j = b.length; h < j; h++) { l[h] = b[h].data } } if (l.length < 1) { l = null } m = { success: g.success, errors: l } } else { try { m = Ext.decode(d.responseText) } catch (k) { m = { success: false, errors: [] } } } return m } }, 0, 0, 0, 0, ["formaction.submit"], 0, [Ext.form.action, "Submit", Ext.form.Action, "Submit"], 0)); (Ext.cmd.derive("Ext.form.action.StandardSubmit", Ext.form.action.Submit, { doSubmit: function () { var a = this.buildForm(); a.formEl.submit(); this.cleanup(a) } }, 0, 0, 0, 0, ["formaction.standardsubmit"], 0, [Ext.form.action, "StandardSubmit"], 0)); (Ext.cmd.derive("Ext.util.ComponentDragger", Ext.dd.DragTracker, { autoStart: 500, constructor: function (a, b) { this.comp = a; this.initialConstrainTo = b.constrainTo; Ext.dd.DragTracker.prototype.constructor.call(this, b) }, onStart: function (c) { var b = this, a = b.comp; b.dragTarget = b.el; b.startRegion = b.el.getRegion(); b.startPosition = a.getXY(); if (a.ghost && !a.liveDrag) { b.proxy = a.ghost() } if (b.constrain || b.constrainDelegate) { b.constrainTo = b.calculateConstrainRegion() } if (a.beginDrag) { a.beginDrag() } if (a.el.shim) { Ext.dom.Element.maskIframes() } }, calculateConstrainRegion: function () { var i = this, g = i.comp, h = i.initialConstrainTo || i.comp.el.dom.parentNode, e = g.constraintInsets, k, b, d, c = i.proxy ? i.proxy.el : g.el, j = c.shadow, a = (j && !i.constrainDelegate && g.constrainShadow && !j.disabled) ? j.getShadowSize() : 0; if (!(h instanceof Ext.util.Region)) { k = Ext.fly(h); h = k.getConstrainRegion() } else { h = h.copy() } if (e) { e = Ext.isObject(e) ? e : Ext.Element.parseBox(e); h.adjust(e.top, e.right, e.bottom, e.left) } if (a) { h.adjust(a[0], -a[1], -a[2], a[3]) } if (i.constrainDelegate) { b = Ext.fly(i.handle).getRegion(); d = c.getRegion(); h.adjust(d.top - b.top, d.right - b.right, d.bottom - b.bottom, d.left - b.left) } return h }, onDrag: function (c) { var b = this, a = (b.proxy && !b.comp.liveDrag) ? b.proxy : b.comp, d = b.getOffset(b.constrain || b.constrainDelegate ? "dragTarget" : null); a.setPagePosition(b.startPosition[0] + d[0], b.startPosition[1] + d[1]) }, onEnd: function (b) { var a = this.comp; if (a.destroyed || a.destroying) { return } if (this.proxy && !a.liveDrag) { a.unghost() } if (a.endDrag) { a.endDrag() } if (a.el.shim) { Ext.dom.Element.unmaskIframes() } } }, 1, 0, 0, 0, 0, 0, [Ext.util, "ComponentDragger"], 0)); (Ext.cmd.derive("Ext.window.Window", Ext.panel.Panel, { alternateClassName: "Ext.Window", baseCls: "x-window", resizable: true, draggable: true, constrain: false, constrainHeader: false, plain: false, minimizable: false, maximizable: false, minHeight: 50, minWidth: 50, expandOnShow: true, collapsible: false, closable: true, hidden: true, autoRender: true, hideMode: "offsets", floating: true, alignOnScroll: false, itemCls: "x-window-item", overlapHeader: true, ignoreHeaderBorderManagement: true, alwaysFramed: true, isRootCfg: { isRoot: true }, isWindow: true, ariaRole: "dialog", focusable: true, tabGuard: true, closeToolText: "Close dialog", keyMap: { scope: "this", ESC: "onEsc" }, maskClickAction: "focus", disableCloseToolFocus: true, initComponent: function () { var a = this; a.frame = false; Ext.panel.Panel.prototype.initComponent.call(this); if (a.plain) { a.addClsWithUI("plain") } a.addStateEvents(["maximize", "restore", "resize", "dragend"]) }, getElConfig: function () { var b = this, a; a = Ext.panel.Panel.prototype.getElConfig.call(this); a.tabIndex = -1; return a }, getFocusEl: function () { return this.getDefaultFocus() || this.el }, getState: function () { var b = this, d = Ext.panel.Panel.prototype.getState.call(this) || {}, a = !!b.maximized, c = b.ghostBox, e; d.maximized = a; if (a) { e = b.restorePos } else { if (c) { e = [c.x, c.y] } else { e = b.getPosition(true) } } Ext.apply(d, { size: a ? b.restoreSize : b.getSize(), pos: e }); return d }, applyState: function (b) { var a = this; if (b) { a.maximized = b.maximized; if (a.maximized) { a.hasSavedRestore = true; a.restoreSize = b.size; a.restorePos = b.pos } else { Ext.apply(a, { width: b.size.width, height: b.size.height, x: b.pos[0], y: b.pos[1] }) } } }, onRender: function (b, a) { var c = this; Ext.panel.Panel.prototype.onRender.apply(this, arguments); if (c.header) { c.header.on({ scope: c, click: c.onHeaderClick }) } if (c.maximizable) { c.header.on({ scope: c, dblclick: c.toggleMaximize }) } }, afterRender: function () { var a = this, b = a.header; if (a.maximized) { a.maximized = false; a.maximize(null, true); if (b) { b.removeCls(b.indicateDragCls) } } Ext.panel.Panel.prototype.afterRender.call(this); a.initTabGuards() }, onEsc: function (a) { a.stopEvent(); this.close() }, doDestroy: function () { var a = this; if (a.rendered) { Ext.un("resize", a.onWindowResize, a); delete a.animateTarget; a.hide() } Ext.panel.Panel.prototype.doDestroy.call(this) }, addTools: function () { var a = this, b = []; Ext.panel.Panel.prototype.addTools.call(this); if (a.minimizable) { b.push({ type: "minimize", handler: "minimize", scope: a }) } if (a.maximizable) { b.push({ type: "maximize", handler: "toggleMaximize", scope: a }) } if (b.length) { a.addTool(b) } }, addTool: function (b) { var a = this; Ext.panel.Panel.prototype.addTool.call(this, b); if (a.rendered && a.tabGuard) { a.initTabGuards() } }, add: function () { var b = this, a; a = Ext.panel.Panel.prototype.add.apply(this, arguments); if (b.rendered && b.tabGuard) { b.initTabGuards() } return a }, remove: function () { var b = this, a; a = Ext.panel.Panel.prototype.remove.apply(this, arguments); if (b.rendered && b.tabGuard) { b.initTabGuards() } return a }, addDocked: function () { var b = this, a; a = Ext.panel.Panel.prototype.addDocked.apply(this, arguments); if (b.rendered && b.tabGuard) { b.initTabGuards() } return a }, removeDocked: function () { var b = this, a; a = Ext.panel.Panel.prototype.removeDocked.apply(this, arguments); if (b.rendered && b.tabGuard) { b.initTabGuards() } return a }, onShow: function () { var a = this; Ext.panel.Panel.prototype.onShow.apply(this, arguments); if (a.expandOnShow) { a.expand(false) } a.syncMonitorWindowResize(); if (a.rendered && a.tabGuard) { a.initTabGuards() } }, doClose: function () { var a = this; if (a.hidden) { a.fireEvent("close", a); if (a.closeAction === "destroy" && !a.destroying && !a.destroyed) { a.destroy() } } else { a.hide(a.animateTarget, a.doClose, a) } }, afterHide: function () { var a = this; a.syncMonitorWindowResize(); Ext.panel.Panel.prototype.afterHide.apply(this, arguments); if (a.rendered && a.tabGuard) { a.initTabGuards() } }, onWindowResize: function () { var b = this, a; if (!b.destroyed) { if (b.maximized) { b.fitContainer() } else { a = b.getSizeModel(); if (a.width.natural || a.height.natural) { b.updateLayout() } b.doConstrain() } } }, minimize: function () { this.fireEvent("minimize", this); return this }, resumeHeaderLayout: function (a) { this.header.resumeLayouts(a ? this.isRootCfg : null) }, afterCollapse: function () { var a = this, c = a.header, b = a.tools; if (c && a.maximizable) { c.suspendLayouts(); b.maximize.hide(); this.resumeHeaderLayout(true) } if (a.resizer) { a.resizer.disable() } Ext.panel.Panel.prototype.afterCollapse.apply(this, arguments) }, afterExpand: function () { var a = this, d = a.header, b = a.tools, c; if (d) { d.suspendLayouts(); if (a.maximizable) { b.maximize.show(); c = true } this.resumeHeaderLayout(c) } if (a.resizer) { a.resizer.enable() } Ext.panel.Panel.prototype.afterExpand.apply(this, arguments) }, maximize: function (b, g) { var i = this, d = i.header, e = i.tools, a = i.width, j = i.height, h, c; if (!i.maximized && !i.maximizing) { i.maximizing = true; i.expand(false); if (!i.hasSavedRestore) { h = i.restoreSize = { width: a ? a : null, height: j ? j : null }; if (g) { i.restorePos = [i.x || 0, i.y || 0] } else { i.restorePos = i.getPosition() } } if (d) { d.suspendLayouts(); if (e.maximize) { e.maximize.setType("restore") } if (i.collapseTool) { i.collapseTool.hide(); c = true } i.resumeHeaderLayout(c) } i.el.disableShadow(); if (i.dd) { i.dd.disable(); if (d) { d.removeCls(d.indicateDragCls) } } if (i.resizer) { i.resizer.disable() } i.el.addCls("x-window-maximized"); i.container.addCls("x-window-maximized-ct"); i.syncMonitorWindowResize(); i.fitContainer(b = (b || !!i.animateTarget) ? { callback: function () { i.maximizing = false; i.maximized = true; if (!g) { i.fireEvent("maximize", i) } } } : null); if (!b) { i.maximizing = false; i.maximized = true; if (!g) { i.fireEvent("maximize", i) } } } return i }, restore: function (b) { var c = this, d = c.tools, g = c.header, a = c.restoreSize, e; if (c.maximized) { c.hasSavedRestore = null; c.removeCls("x-window-maximized"); if (g) { g.suspendLayouts(); if (d.maximize) { d.maximize.setType("maximize") } if (c.collapseTool) { c.collapseTool.show(); e = true } c.resumeHeaderLayout(e) } a.x = c.restorePos[0]; a.y = c.restorePos[1]; c.setBox(a, b = (b || !!c.animateTarget) ? { callback: function () { c.el.enableShadow(null, true); c.maximized = false; c.fireEvent("restore", c) } } : null); c.restorePos = c.restoreSize = null; if (c.dd) { c.dd.enable(); if (g) { g.addCls(g.indicateDragCls) } } if (c.resizer) { c.resizer.enable() } c.container.removeCls("x-window-maximized-ct"); c.syncMonitorWindowResize(); if (!b) { c.el.enableShadow(null, true); c.maximized = false; c.fireEvent("restore", c) } } return c }, syncMonitorWindowResize: function () { var b = this, c = b._monitoringResize, d = b.monitorResize || b.constrain || b.constrainHeader || b.maximized, a = b.hidden || b.destroying || b.destroyed; if (d && !a) { if (!c) { Ext.on("resize", b.onWindowResize, b, { buffer: 1 }); b._monitoringResize = true } } else { if (c) { Ext.un("resize", b.onWindowResize, b); b._monitoringResize = false } } }, toggleMaximize: function () { return this[this.maximized ? "restore" : "maximize"]() }, createGhost: function () { var a = Ext.panel.Panel.prototype.createGhost.apply(this, arguments); a.xtype = "window"; a.focusOnToFront = false; return a }, getDefaultFocus: function () { var c = this, b, d = c.defaultFocus, a; if (d !== undefined) { if (Ext.isNumber(d)) { b = c.query("button")[d] } else { if (Ext.isString(d)) { a = d; if (Ext.validIdRe.test(a)) { b = c.down(Ext.makeIdSelector(a)) } if (!b) { b = c.down(a) } } else { if (d.focus) { b = d } } } } return b }, privates: { initDraggable: function () { this.initSimpleDraggable() }, onHeaderClick: function (c, b) { var a; if (c.el.contains(b.getTarget())) { a = this.getDefaultFocus(); if (a) { a.focus() } } }, initResizable: function (a) { var b = this; Ext.panel.Panel.prototype.initResizable.call(this, a); if (b.maximized || b.maximizing) { b.resizer.disable() } }, initSimpleDraggable: function () { var b = this, a; Ext.panel.Panel.prototype.initSimpleDraggable.call(this); a = b.dd; if (a && b.maximized || b.maximizing) { a.disable() } }, onTabGuardFocusEnter: function (h, i) { var j = this, b = j.el, d = j.tabGuardBeforeEl, c = j.tabGuardAfterEl, k = h.relatedTarget, a, g, l; a = b.findTabbableElements({ skipSelf: true }); if (a[0] === d.dom) { a.shift() } if (a[a.length - 1] === c.dom) { a.pop() } if (a.length === 0) { l = b } else { if (k === b.dom) { g = i === d.dom } else { if (b.contains(k)) { g = !!h.forwardTab } else { g = i === d.dom } } } l = l || (g ? a[0] : a[a.length - 1]); if (l) { l.focus() } } } }, 0, ["window"], ["component", "box", "container", "panel", "window"], { component: true, box: true, container: true, panel: true, window: true }, ["widget.window"], 0, [Ext.window, "Window", Ext, "Window"], 0)); (Ext.cmd.derive("Ext.form.Labelable", Ext.Mixin, { isLabelable: true, mixinConfig: { id: "labelable", on: { beforeRender: "beforeLabelRender", onRender: "onLabelRender" } }, config: { childEls: ["labelEl", "bodyEl", "errorEl", "errorWrapEl", "ariaErrorEl", "ariaStatusEl", "ariaHelpEl", "labelTextEl"] }, labelableRenderTpl: ["{beforeLabelTpl}", '<label id="{id}-labelEl" data-ref="labelEl" class="{labelCls} {labelCls}-{ui} {labelClsExtra} ', '{childElCls} {unselectableCls}" style="{labelStyle}"', '<tpl if="inputId && !skipLabelForAttribute"> for="{inputId}"</tpl>', " {labelAttrTpl}>", '<span class="{labelInnerCls} {labelInnerCls}-{ui}" style="{labelInnerStyle}">', "{beforeLabelTextTpl}", '<span id="{id}-labelTextEl" data-ref="labelTextEl" class="{labelTextCls}">', '<tpl if="fieldLabel">{fieldLabel}', '<tpl if="labelSeparator">{labelSeparator}</tpl>', "</tpl>", "</span>", "{afterLabelTextTpl}", "</span>", "</label>", "{afterLabelTpl}", '<div id="{id}-bodyEl" data-ref="bodyEl" role="presentation"', ' class="{baseBodyCls} {baseBodyCls}-{ui}<tpl if="fieldBodyCls">', ' {fieldBodyCls} {fieldBodyCls}-{ui}</tpl> {growCls} {extraFieldBodyCls}"', '<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>', "{beforeBodyEl}", "{beforeSubTpl}", "{[values.$comp.getSubTplMarkup(values)]}", "{afterSubTpl}", "{afterBodyEl}", '<tpl if="renderAriaElements">', '<tpl if="ariaHelp">', '<span id="{id}-ariaHelpEl" data-ref="ariaHelpEl"', ' class="x-hidden-offsets">', "{ariaHelp}", "</span>", "</tpl>", '<span id="{id}-ariaStatusEl" data-ref="ariaStatusEl" aria-hidden="true"', ' class="x-hidden-offsets">', "{ariaStatus}", "</span>", '<span id="{id}-ariaErrorEl" data-ref="ariaErrorEl" aria-hidden="true" aria-live="assertive"', ' class="x-hidden-clip">', "</span>", "</tpl>", "</div>", '<tpl if="renderError">', '<div id="{id}-errorWrapEl" data-ref="errorWrapEl" class="{errorWrapCls} {errorWrapCls}-{ui}', ' {errorWrapExtraCls}" style="{errorWrapStyle}">', '<div role="presentation" id="{id}-errorEl" data-ref="errorEl" ', 'class="{errorMsgCls} {invalidMsgCls} {invalidMsgCls}-{ui}" ', 'data-anchorTarget="{tipAnchorTarget}">', "</div>", "</div>", "</tpl>", { disableFormats: true }], activeErrorsTpl: undefined, htmlActiveErrorsTpl: ['<tpl if="errors && errors.length">', '<ul class="{listCls}">', '<tpl for="errors"><li>{.}</li></tpl>', "</ul>", "</tpl>"], plaintextActiveErrorsTpl: ['<tpl if="errors && errors.length">', '<tpl for="errors"><tpl if="xindex &gt; 1">\n</tpl>{.}</tpl>', "</tpl>"], ariaActiveErrorsTpl: ['<tpl if="errors && errors.length">', '<tpl for="errors" between=". ">{.}</tpl>', "</tpl>"], isFieldLabelable: true, formItemCls: "x-form-item", labelCls: "x-form-item-label", topLabelCls: "x-form-item-label-top", rightLabelCls: "x-form-item-label-right", labelInnerCls: "x-form-item-label-inner", labelTextCls: "x-form-item-label-text", topLabelSideErrorCls: "x-form-item-label-top-side-error", errorMsgCls: "x-form-error-msg", errorWrapCls: "x-form-error-wrap", errorWrapSideCls: "x-form-error-wrap-side", errorWrapUnderCls: "x-form-error-wrap-under", errorWrapUnderSideLabelCls: "x-form-error-wrap-under-side-label", baseBodyCls: "x-form-item-body", invalidIconCls: "x-form-invalid-icon", invalidUnderCls: "x-form-invalid-under", noLabelCls: "x-form-item-no-label", fieldBodyCls: "", extraFieldBodyCls: "", invalidCls: "x-form-invalid", fieldLabel: undefined, labelAlign: "left", labelWidth: 100, labelPad: 5, labelSeparator: ":", hideLabel: false, hideEmptyLabel: true, preventMark: false, autoFitErrors: true, msgTarget: "qtip", msgTargets: { qtip: 1, title: 1, under: 1, side: 1, none: 1 }, noWrap: true, ariaHelp: undefined, ariaErrorText: "Input error. {0}.", labelableInsertions: ["beforeBodyEl", "afterBodyEl", "beforeLabelTpl", "afterLabelTpl", "beforeSubTpl", "afterSubTpl", "beforeLabelTextTpl", "afterLabelTextTpl", "labelAttrTpl"], statics: { initTip: function () { var b = this.tip, a, c; if (b) { return } a = { id: "ext-form-error-tip", ui: "form-invalid" }; if (Ext.supports.Touch) { a.dismissDelay = 0; a.anchor = "top"; a.showDelay = 0; a.showOnTap = true; a.listeners = { beforeshow: function () { this.minWidth = Ext.fly(this.activeTarget.el).getWidth() } } } b = this.tip = Ext.create("Ext.tip.QuickTip", a); c = Ext.apply({}, b.tagConfig); c.attribute = "errorqtip"; b.setTagConfig(c) }, destroyTip: function () { this.tip = Ext.destroy(this.tip) } }, initLabelable: function () { var a = this, b = a.padding; if (b) { a.padding = undefined; a.extraMargins = Ext.Element.parseBox(b) } if (Ext.isIE8) { a.restoreDisplay = Ext.Function.createDelayed(a.doRestoreDisplay, 0, a) } if (!a.activeErrorsTpl) { if (a.msgTarget === "title") { a.activeErrorsTpl = a.plaintextActiveErrorsTpl } else { a.activeErrorsTpl = a.htmlActiveErrorsTpl } } a.addCls([a.formItemCls, a.formItemCls + "-" + a.ui]); a.lastActiveError = ""; a.enableBubble("errorchange") }, trimLabelSeparator: function () { var c = this, d = c.labelSeparator, a = c.fieldLabel || "", b = a.substr(a.length - 1); return b === d ? a.slice(0, -1) : a }, getFieldLabel: function () { return this.trimLabelSeparator() }, setFieldLabel: function (d) { d = d || ""; var e = this, g = e.labelSeparator, c = e.labelEl, b = e.errorWrapEl, i = (e.labelAlign !== "top"), a = e.noLabelCls, h = e.errorWrapUnderSideLabelCls; e.fieldLabel = d; if (e.rendered) { if (Ext.isEmpty(d) && e.hideEmptyLabel) { e.addCls(a); if (i && b) { b.removeCls(h) } } else { if (g) { d = e.trimLabelSeparator() + g } e.labelTextEl.dom.innerHTML = d; e.removeCls(a); if (i && b) { b.addCls(h) } } e.updateLayout() } }, setHideLabel: function (a) { var b = this; if (a !== b.hideLabel) { b.hideLabel = a; if (b.rendered) { b[a ? "addCls" : "removeCls"](b.noLabelCls); b.updateLayout() } } }, setHideEmptyLabel: function (a) { var c = this, b; if (a !== c.hideEmptyLabel) { c.hideEmptyLabel = a; if (c.rendered && !c.hideLabel) { b = a && !c.getFieldLabel(); c[b ? "addCls" : "removeCls"](c.noLabelCls); c.updateLayout() } } }, getInsertionRenderData: function (d, e) { var b = e.length, a, c; while (b--) { a = e[b]; c = this[a]; if (c) { if (typeof c !== "string") { if (!c.isTemplate) { c = Ext.XTemplate.getTpl(this, a) } c = c.apply(d) } } d[a] = c || "" } return d }, getLabelableRenderData: function () { var p = this, s = p.labelAlign, e = (s === "top"), m = (s === "right"), j = (p.msgTarget === "side"), g = (p.msgTarget === "under"), r = p.errorMsgCls, h = p.labelPad, o = p.labelWidth, b = p.labelClsExtra || "", i = j ? p.errorWrapSideCls : p.errorWrapUnderCls, a = "", l = "", d = p.hasVisibleLabel(), n = p.autoFitErrors, k = p.defaultBodyWidth, c, q; if (e) { b += " " + p.topLabelCls; if (h) { l = "padding-bottom:" + h + "px;" } if (j && !n) { b += " " + p.topLabelSideErrorCls } } else { if (m) { b += " " + p.rightLabelCls } if (h) { a += p.getHorizontalPaddingStyle() + h + "px;" } a += "width:" + (o + (h ? h : 0)) + "px;"; l = "width:" + o + "px" } if (d) { if (!e && g) { i += " " + p.errorWrapUnderSideLabelCls } } if (k) { c = "min-width:" + k + "px;max-width:" + k + "px;" } q = { id: p.id, inputId: p.getInputId(), labelCls: p.labelCls, labelClsExtra: b, labelStyle: a + (p.labelStyle || ""), labelInnerStyle: l, labelInnerCls: p.labelInnerCls, labelTextCls: p.labelTextCls, skipLabelForAttribute: !!p.skipLabelForAttribute, unselectableCls: Ext.Element.unselectableCls, bodyStyle: c, baseBodyCls: p.baseBodyCls, fieldBodyCls: p.fieldBodyCls, extraFieldBodyCls: p.extraFieldBodyCls, errorWrapCls: p.errorWrapCls, errorWrapExtraCls: i, renderError: j || g, invalidMsgCls: j ? p.invalidIconCls : g ? p.invalidUnderCls : "", errorMsgCls: r, growCls: p.grow ? p.growCls : "", tipAnchorTarget: p.id + "-inputEl", errorWrapStyle: (j && !n) ? "visibility:hidden" : "display:none", fieldLabel: p.getFieldLabel(), labelSeparator: p.labelSeparator, renderAriaElements: !!p.renderAriaElements, ariaStatus: "" }; if (p.ariaHelp) { q.ariaHelp = Ext.String.htmlEncode(p.ariaHelp) } p.getInsertionRenderData(q, p.labelableInsertions); return q }, getHorizontalPaddingStyle: function () { return "padding-right:" }, beforeLabelRender: function () { var a = this; a.setFieldDefaults(a.getInherited().fieldDefaults); if (a.ownerLayout) { a.addCls("x-" + a.ownerLayout.type + "-form-item") } if (!a.hasVisibleLabel()) { a.addCls(a.noLabelCls) } }, onLabelRender: function () { var d = this, c = {}, g = Ext.Element, a = d.errorWrapEl, e, b; if (a) { a.setVisibilityMode((d.msgTarget === "side" && !d.autoFitErrors) ? g.VISIBILITY : g.DISPLAY) } if (d.extraMargins) { e = d.el.getMargin(); for (b in e) { if (e.hasOwnProperty(b)) { c["margin-" + b] = (e[b] + d.extraMargins[b]) + "px" } } d.el.setStyle(c) } }, hasVisibleLabel: function () { if (this.hideLabel) { return false } return !(this.hideEmptyLabel && !this.getFieldLabel()) }, getSubTplMarkup: function () { return "" }, getInputId: function () { return "" }, getActiveError: function () { return this.activeError || "" }, hasActiveError: function () { return !!this.getActiveError() }, setActiveError: function (a) { this.setActiveErrors(a) }, getActiveErrors: function () { return this.activeErrors || [] }, setActiveErrors: function (l) { var i = this, k = i.errorWrapEl, g = i.msgTarget, e = g === "side", n = g === "qtip", o = i.ariaErrorEl, c, b, h, m, j, a, d; l = Ext.Array.from(l); h = i.lookupTpl("activeErrorsTpl"); i.activeErrors = l; b = i.activeError = h.apply({ fieldLabel: i.fieldLabel, errors: l, listCls: "x-list-plain" }); i.renderActiveError(); if (i.rendered) { c = i.getActionEl(); if (e) { i.errorEl.dom.setAttribute("data-errorqtip", b) } else { if (n) { c.dom.setAttribute("data-errorqtip", b) } else { if (g === "title") { c.dom.setAttribute("title", b) } } } if (g !== "title" && o) { j = i.lookupTpl("ariaActiveErrorsTpl"); a = j.apply({ errors: l }); d = Ext.String.formatEncode(i.ariaErrorText, a, i.fieldLabel); if (o.dom.innerHTML !== d) { o.dom.innerHTML = d } i.ariaStatusEl.dom.innerHTML = Ext.String.htmlEncode(a) } if (e || n) { Ext.form.Labelable.initTip() } if (!i.msgTargets[g]) { m = Ext.get(g); if (m) { m.dom.innerHTML = b } } } if (k) { k.setVisible(l.length > 0); if (e && i.autoFitErrors) { i.labelEl.addCls(i.topLabelSideErrorCls) } i.updateLayout() } }, unsetActiveError: function () { var g = this, b = g.errorWrapEl, e = g.ariaErrorEl, c = g.msgTarget, a = g.restoreDisplay, d, h; if (g.hasActiveError()) { delete g.activeError; delete g.activeErrors; g.renderActiveError(); if (g.rendered) { d = g.getActionEl(); if (c === "qtip") { d.dom.removeAttribute("data-errorqtip") } else { if (c === "title") { d.dom.removeAttribute("title") } } if (c !== "title" && e) { e.dom.innerHTML = g.ariaStatusEl.dom.innerHTML = "" } if (!g.msgTargets[c]) { h = Ext.get(c); if (h) { h.dom.innerHTML = "" } } if (b) { b.hide(); if (c === "side" && g.autoFitErrors) { g.labelEl.removeCls(g.topLabelSideErrorCls) } g.updateLayout(); if (a) { g.el.dom.style.display = "block"; g.restoreDisplay() } } } } }, doRestoreDisplay: function () { var a = this.el; if (a && a.dom) { a.dom.style.display = "" } }, renderActiveError: function () { var c = this, b = c.getActiveError(), a = !!b; if (b !== c.lastActiveError) { c.lastActiveError = b; c.fireEvent("errorchange", c, b) } if (c.rendered && !c.destroyed && !c.preventMark) { c.toggleInvalidCls(a); if (c.errorEl) { c.errorEl.dom.innerHTML = b } } }, toggleInvalidCls: function (a) { this.el[a ? "addCls" : "removeCls"](this.invalidCls) }, setFieldDefaults: function (b) { var a; for (a in b) { if (!this.hasOwnProperty(a)) { this[a] = b[a] } } } }, 0, 0, 0, 0, 0, 0, [Ext.form, "Labelable"], function () { if (Ext.supports.Touch) { this.prototype.msgTarget = "side" } })); (Ext.cmd.derive("Ext.form.field.Field", Ext.Base, { mixinId: "field", isFormField: true, config: { validation: null, validationField: null }, disabled: false, submitValue: true, validateOnChange: true, valuePublishEvent: "change", suspendCheckChange: 0, dirty: false, initField: function () { var d = this, c = d.valuePublishEvent, a, b; d.initValue(); if (Ext.isString(c)) { d.on(c, d.publishValue, d) } else { for (b = 0, a = c.length; b < a; ++b) { d.on(c[b], d.publishValue, d) } } }, initValue: function () { var a = this; if ("value" in a) { a.suspendCheckChange++; a.setValue(a.value); a.suspendCheckChange-- } a.initialValue = a.originalValue = a.lastValue = a.getValue() }, cleanupField: function () { delete this._ownerRecord }, getFieldIdentifier: function () { return this.isEditorComponent ? this.dataIndex : this.name }, getName: function () { return this.name }, getValue: function () { return this.value }, setValue: function (b) { var a = this; a.value = b; a.checkChange(); return a }, isEqual: function (b, a) { return String(b) === String(a) }, isEqualAsString: function (b, a) { return String(Ext.valueFrom(b, "")) === String(Ext.valueFrom(a, "")) }, getSubmitData: function () { var a = this, b = null; if (!a.disabled && a.submitValue) { b = {}; b[a.getName()] = "" + a.getValue() } return b }, getModelData: function (a, b) { var c = this, d = null; if (!c.disabled && (c.submitValue || !b)) { d = {}; d[c.getFieldIdentifier()] = c.getValue() } return d }, reset: function () { var a = this; a.beforeReset(); a.setValue(a.originalValue); a.clearInvalid(); delete a.wasValid }, beforeReset: Ext.emptyFn, resetOriginalValue: function () { this.originalValue = this.getValue(); this.checkDirty() }, checkChange: function () { var c = this, b, a; if (!c.suspendCheckChange && !c.destroying && !c.destroyed) { b = c.getValue(); a = c.lastValue; if (c.didValueChange(b, a)) { c.lastValue = b; c.fireEvent("change", c, b, a); c.onChange(b, a) } } }, didValueChange: function (b, a) { return !this.isEqual(b, a) }, onChange: function (a) { var b = this; if (b.validateOnChange) { b.validate() } b.checkDirty() }, publishValue: function () { var a = this; if (a.rendered && !a.getErrors().length) { a.publishState("value", a.getValue()) } }, isDirty: function () { var a = this; return !a.disabled && !a.isEqual(a.getValue(), a.originalValue) }, checkDirty: function () { var a = this, b = a.isDirty(); if (b !== a.wasDirty) { a.dirty = b; a.fireEvent("dirtychange", a, b); a.onDirtyChange(b); a.wasDirty = b } }, onDirtyChange: Ext.emptyFn, getErrors: function (d) { var e = [], c = this.getValidationField(), b = this.getValidation(), a; if (c) { a = c.validate(d, null, null, this._ownerRecord); if (a !== true) { e.push(a) } } if (b && b !== true) { e.push(b) } return e }, isValid: function () { var a = this; return a.disabled || Ext.isEmpty(a.getErrors()) }, validate: function () { return this.checkValidityChange(this.isValid()) }, checkValidityChange: function (b) { var a = this; if (b !== a.wasValid) { a.wasValid = b; a.fireEvent("validitychange", a, b) } return b }, setValidationField: function (b, a) { (arguments.callee.$previous || Ext.Base.prototype.setValidationField).call(this, b); this._ownerRecord = a }, batchChanges: function (a) { try { this.suspendCheckChange++; a() } finally { this.suspendCheckChange-- } this.checkChange() }, isFileUpload: function () { return false }, extractFileInput: function () { return null }, markInvalid: Ext.emptyFn, clearInvalid: Ext.emptyFn, updateValidation: function (a, b) { if (b) { this.validate() } }, privates: { resetToInitialValue: function () { var b = this, a = b.originalValue; b.originalValue = b.initialValue; b.reset(); b.originalValue = a } } }, 0, 0, 0, 0, 0, 0, [Ext.form.field, "Field"], 0)); (Ext.cmd.derive("Ext.form.field.Base", Ext.Component, { alternateClassName: ["Ext.form.Field", "Ext.form.BaseField"], focusable: true, shrinkWrap: true, fieldSubTpl: ['<input id="{id}" data-ref="inputEl" type="{type}" {inputAttrTpl}', ' size="1"', '<tpl if="name"> name="{name}"</tpl>', '<tpl if="value"> value="{[Ext.util.Format.htmlEncode(values.value)]}"</tpl>', '<tpl if="placeholder"> placeholder="{placeholder}"</tpl>', '{%if (values.maxLength !== undefined){%} maxlength="{maxLength}"{%}%}', '<tpl if="readOnly"> readonly="readonly"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="tabIdx != null"> tabindex="{tabIdx}"</tpl>', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', "<tpl if=\"ariaEl == 'inputEl'\">", '<tpl foreach="ariaElAttributes"> {$}="{.}"</tpl>', "</tpl>", '<tpl foreach="inputElAriaAttributes"> {$}="{.}"</tpl>', ' class="{fieldCls} {typeCls} {typeCls}-{ui} {editableCls} {inputCls}" autocomplete="off"/>', { disableFormats: true }], defaultBindProperty: "value", autoEl: { role: "presentation" }, subTplInsertions: ["inputAttrTpl"], childEls: ["inputEl"], inputType: "text", isTextInput: true, invalidText: "The value in this field is invalid", fieldCls: "x-form-field", focusCls: "form-focus", dirtyCls: "x-form-dirty", checkChangeEvents: Ext.isIE && (!document.documentMode || document.documentMode <= 9) ? ["change", "propertychange", "keyup"] : ["change", "input", "textInput", "keyup", "dragdrop"], ignoreChangeRe: /data\-errorqtip|style\.|className/, checkChangeBuffer: 50, liquidLayout: true, readOnly: false, readOnlyCls: "x-form-readonly", validateOnBlur: true, hasFocus: false, baseCls: "x-field", fieldBodyCls: "x-field-body", maskOnDisable: false, stretchInputElFixed: true, ariaEl: "inputEl", renderAriaElements: true, initComponent: function () { var a = this; Ext.Component.prototype.initComponent.call(this); a.subTplData = a.subTplData || {}; a.initLabelable(); a.initField(); a.initDefaultName(); if (a.readOnly) { a.addCls(a.readOnlyCls) } a.addCls("x-form-type-" + a.inputType); if (a.format && a.formatText && !a.ariaHelp) { a.ariaHelp = Ext.String.format(a.formatText, a.format) } }, initDefaultName: function () { var a = this; if (!a.name) { a.name = a.getInputId() } }, getInputId: function () { return this.inputId || (this.inputId = this.id + "-inputEl") }, getSubTplData: function (d) { var g = this, i = g.id, e = g.inputType, b = g.getInputId(), h, c, a; h = Ext.apply({ ui: g.ui, id: b, cmpId: i, name: g.name || b, disabled: g.disabled, readOnly: g.readOnly, value: g.getRawValue(), type: e, fieldCls: g.fieldCls, fieldStyle: g.getFieldStyle(), childElCls: d.childElCls, tabIdx: g.tabIndex, inputCls: g.inputCls, typeCls: "x-form-" + (g.isTextInput ? "text" : e), ariaEl: g.ariaEl }, g.subTplData); if (g.ariaRole) { c = {}; if (!g.ariaStaticRoles[g.ariaRole]) { c["aria-hidden"] = !!g.hidden; c["aria-disabled"] = !!g.disabled; a = { "aria-invalid": false, "aria-readonly": !!g.readOnly }; if (g.ariaLabel) { c["aria-label"] = Ext.String.htmlEncode(g.ariaLabel) } c = Ext.apply(c, g.getAriaAttributes()); if (!c["aria-describedby"]) { if (g.ariaHelp) { a["aria-describedby"] = i + "-ariaStatusEl " + i + "-ariaHelpEl" } else { a["aria-describedby"] = i + "-ariaStatusEl" } } h.inputElAriaAttributes = a } if (g.ariaRole !== "native") { c.role = g.ariaRole } if (g.ariaLabel) { c["aria-label"] = g.ariaLabel } if (g.format && g.formatText && !h.title) { c.title = Ext.String.formatEncode(g.formatText, g.format) } h.ariaElAttributes = c } g.getInsertionRenderData(h, g.subTplInsertions); return h }, getSubTplMarkup: function (b) { var c = this, d = c.getSubTplData(b), e = c.lookupTpl("preSubTpl"), g = c.lookupTpl("postSubTpl"), a = ""; if (e) { a += e.apply(d) } a += c.lookupTpl("fieldSubTpl").apply(d); if (g) { a += g.apply(d) } return a }, initRenderData: function () { return Ext.applyIf(Ext.Component.prototype.initRenderData.call(this), this.getLabelableRenderData()) }, setFieldStyle: function (a) { var b = this, c = b.inputEl; if (c) { c.applyStyles(a) } b.fieldStyle = a }, getFieldStyle: function () { var a = this.fieldStyle; return Ext.isObject(a) ? Ext.DomHelper.generateStyles(a, null, true) : a || "" }, onRender: function () { this.callParent(arguments); this.mixins.labelable.self.initTip(); this.renderActiveError() }, beforeBlur: function (a) { if (this.validateOnBlur) { this.validate() } }, onFocusLeave: function (a) { Ext.Component.prototype.onFocusLeave.call(this, a); this.completeEdit() }, completeEdit: Ext.emptyFn, isFileUpload: function () { return this.inputType === "file" }, getSubmitData: function () { var a = this, b = null, c; if (!a.disabled && a.submitValue) { c = a.getSubmitValue(); if (c !== null) { b = {}; b[a.getName()] = c } } return b }, getSubmitValue: function () { return this.processRawValue(this.getRawValue()) }, getRawValue: function () { var b = this, a = (b.inputEl ? b.inputEl.getValue() : Ext.valueFrom(b.rawValue, "")); b.rawValue = a; return a }, setRawValue: function (c) { var a = this, b = a.rawValue; if (!a.transformRawValue.$nullFn) { c = a.transformRawValue(c) } c = Ext.valueFrom(c, ""); if (b === undefined || b !== c) { a.rawValue = c; if (a.inputEl) { a.bindChangeEvents(false); a.inputEl.dom.value = c; a.bindChangeEvents(true) } } if (a.rendered && a.reference) { a.publishState("rawValue", c) } return c }, transformRawValue: Ext.identityFn, valueToRaw: function (a) { return "" + Ext.valueFrom(a, "") }, rawToValue: Ext.identityFn, processRawValue: Ext.identityFn, getValue: function () { var a = this, b = a.rawToValue(a.processRawValue(a.getRawValue())); a.value = b; return b }, setValue: function (b) { var a = this; a.setRawValue(a.valueToRaw(b)); return a.mixins.field.setValue.call(a, b) }, onBoxReady: function () { var a = this; Ext.Component.prototype.onBoxReady.apply(this, arguments); if (a.setReadOnlyOnBoxReady) { a.setReadOnly(a.readOnly) } }, onDisable: function () { var a = this, b = a.inputEl; Ext.Component.prototype.onDisable.call(this); if (b) { b.dom.disabled = true; if (a.hasActiveError()) { a.clearInvalid(); a.hadErrorOnDisable = true } } if (a.wasValid === false) { a.checkValidityChange(true) } }, onEnable: function () { var b = this, c = b.inputEl, d = b.preventMark, a; Ext.Component.prototype.onEnable.call(this); if (c) { c.dom.disabled = false } if (b.wasValid !== undefined) { b.forceValidation = true; b.preventMark = !b.hadErrorOnDisable; a = b.isValid(); b.forceValidation = false; b.preventMark = d; b.checkValidityChange(a) } delete b.hadErrorOnDisable }, setReadOnly: function (d) { var b = this, c = b.inputEl, a = b.readOnly; d = !!d; b[d ? "addCls" : "removeCls"](b.readOnlyCls); b.readOnly = d; if (c) { c.dom.readOnly = d; c.dom.setAttribute("aria-readonly", d) } else { if (b.rendering) { b.setReadOnlyOnBoxReady = true } } if (d !== a) { b.fireEvent("writeablechange", b, d) } }, fireKey: function (b, a) { if (b.isSpecialKey()) { this.fireEvent("specialkey", this, b, a) } }, initEvents: function () { var e = this, h = e.inputEl, g = e.onFieldMutation, c = e.checkChangeEvents, a = c.length, b, d; if (h) { e.mon(h, Ext.supports.SpecialKeyDownRepeat ? "keydown" : "keypress", e.fireKey, e); for (b = 0; b < a; ++b) { d = c[b]; if (d === "propertychange") { e.usesPropertychange = true } if (d === "textInput") { e.usesTextInput = true } e.mon(h, d, g, e) } } Ext.Component.prototype.initEvents.call(this) }, onFieldMutation: function (a) { if (!this.readOnly && !(a.type === "propertychange" && this.ignoreChangeRe.test(a.browserEvent.propertyName))) { this.startCheckChangeTask() } }, startCheckChangeTask: function () { var b = this, a = b.checkChangeTask; if (!a) { b.checkChangeTask = a = new Ext.util.DelayedTask(b.doCheckChangeTask, b) } if (!b.bindNotifyListener) { b.bindNotifyListener = Ext.on("beforebindnotify", b.onBeforeNotify, b, { destroyable: true }) } a.delay(b.checkChangeBuffer) }, doCheckChangeTask: function () { var a = this.bindNotifyListener; if (a) { a.destroy(); this.bindNotifyListener = null } this.checkChange() }, publishValue: function () { var a = this; if (a.rendered && !a.getErrors().length) { a.publishState("value", a.getValue()) } }, onDirtyChange: function (b) { var a = this; a[b ? "addCls" : "removeCls"](a.dirtyCls); if (a.rendered && a.reference) { a.publishState("dirty", b) } }, isValid: function () { var b = this, a = b.disabled, c = b.forceValidation || !a; return c ? b.validateValue(b.processRawValue(b.getRawValue())) : a }, validateValue: function (b) { var a = this, d = a.getErrors(b), c = Ext.isEmpty(d); if (!a.preventMark) { if (c) { a.clearInvalid() } else { a.markInvalid(d) } } return c }, markInvalid: function (d) { var b = this, a = b.getActiveError(), c; b.setActiveErrors(Ext.Array.from(d)); c = b.getActiveError(); if (a !== c) { b.setError(c); if (!b.ariaStaticRoles[b.ariaRole] && b.inputEl) { b.inputEl.dom.setAttribute("aria-invalid", true) } } }, clearInvalid: function () { var b = this, a = b.hasActiveError(); delete b.hadErrorOnDisable; b.unsetActiveError(); if (a) { b.setError(""); if (!b.ariaStaticRoles[b.ariaRole] && b.inputEl) { b.inputEl.dom.setAttribute("aria-invalid", false) } } }, setError: function (a) { var c = this, b = c.msgTarget, d; if (c.rendered) { if (b === "title" || b === "qtip") { d = b === "qtip" ? "data-errorqtip" : "title"; c.getActionEl().dom.setAttribute(d, a || "") } else { c.updateLayout() } } }, renderActiveError: function () { var c = this, b = c.hasActiveError(), a = c.invalidCls + "-field"; if (c.inputEl) { c.inputEl[b ? "addCls" : "removeCls"]([a, a + "-" + c.ui]) } c.mixins.labelable.renderActiveError.call(c) }, doDestroy: function () { var b = this, a = b.checkChangeTask; if (a) { a.cancel() } Ext.destroy(b.bindNotifyListener); b.cleanupField(); Ext.Component.prototype.doDestroy.call(this) }, privates: { applyBind: function (g, c) { var b = this, a = c && c.value, e, d; e = Ext.Component.prototype.applyBind.call(this, g, c); if (e) { d = e.value; b.hasBindingValue = !!d; if (d !== a && b.getInherited().modelValidation) { b.updateValueBinding(e) } } return e }, applyRenderSelectors: function () { var a = this; Ext.Component.prototype.applyRenderSelectors.call(this); if (!a.inputEl) { a.inputEl = a.el.getById(a.getInputId()) } }, bindChangeEvents: function (b) { var c = b ? "resumeEvent" : "suspendEvent", a = this.inputEl; if (this.usesPropertychange) { a[c]("propertychange") } if (this.usesTextInput) { a[c]("textInput") } }, getActionEl: function () { return this.inputEl || this.el }, getFocusEl: function () { return this.inputEl }, initRenderTpl: function () { var a = this; if (!a.hasOwnProperty("renderTpl")) { a.renderTpl = a.lookupTpl("labelableRenderTpl") } return Ext.Component.prototype.initRenderTpl.call(this) }, onBeforeNotify: function () { this.checkChangeTask.cancel(); this.checkChange() }, updateValueBinding: function (d) { var c = this, b = d.value, a = d.$fieldBinding; if (a) { a.destroy(); d.$fieldBinding = null } if (b && b.bindValidationField) { c.fieldBinding = b.bindValidationField("setValidationField", c) } } }, deprecated: { "5": { methods: { doComponentLayout: function () { this.bindChangeEvents(false); this.callParent(arguments); this.bindChangeEvents(true) } } } } }, 0, ["field"], ["component", "box", "field"], { component: true, box: true, field: true }, ["widget.field"], [[Ext.form.Labelable.prototype.mixinId || Ext.form.Labelable.$className, Ext.form.Labelable], [Ext.form.field.Field.prototype.mixinId || Ext.form.field.Field.$className, Ext.form.field.Field]], [Ext.form.field, "Base", Ext.form, "Field", Ext.form, "BaseField"], 0)); (Ext.cmd.derive("Ext.form.field.VTypes", Ext.Base, (function () { var c = /^[a-zA-Z_]+$/, d = /^[a-zA-Z0-9_]+$/, b = /^(")?(?:[^\."\s])(?:(?:[\.])?(?:[\w\-!#$%&'*+/=?^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/, a = /(((^https?)|(^ftp)):\/\/((([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*)|(localhost|LOCALHOST))\/?)/i; return { singleton: true, alternateClassName: "Ext.form.VTypes", email: function (e) { return b.test(e) }, emailText: 'This field should be an e-mail address in the format "user@example.com"', emailMask: /[\w.\-@'"!#$%&'*+/=?^_`{|}~]/i, url: function (e) { return a.test(e) }, urlText: 'This field should be a URL in the format "http://www.example.com"', alpha: function (e) { return c.test(e) }, alphaText: "This field should only contain letters and _", alphaMask: /[a-z_]/i, alphanum: function (e) { return d.test(e) }, alphanumText: "This field should only contain letters, numbers and _", alphanumMask: /[a-z0-9_]/i } }()), 0, 0, 0, 0, 0, 0, [Ext.form.field, "VTypes", Ext.form, "VTypes"], 0)); (Ext.cmd.derive("Ext.form.trigger.Trigger", Ext.Base, { factoryConfig: { defaultType: "trigger" }, repeatClick: false, hidden: false, hideOnReadOnly: undefined, tooltip: null, weight: 0, preventMouseDown: true, focusOnMousedown: false, baseCls: "x-form-trigger", focusCls: "x-form-trigger-focus", overCls: "x-form-trigger-over", clickCls: "x-form-trigger-click", validIdRe: Ext.validIdRe, renderTpl: ['<div id="{triggerId}" class="{baseCls} {baseCls}-{ui} {cls} {cls}-{ui} {extraCls} ', '{childElCls}"<tpl if="triggerStyle"> style="{triggerStyle}"</tpl>', '<tpl if="ariaRole"> role="{ariaRole}"<tpl else> role="presentation"</tpl>', ">", "{[values.$trigger.renderBody(values)]}", "</div>"], statics: { weightComparator: function (a, b) { return a.weight - b.weight } }, constructor: function (b) { var c = this, a; Ext.apply(c, b); if (c.compat4Mode) { a = c.cls; c.focusCls = [c.focusCls, a + "-focus"]; c.overCls = [c.overCls, a + "-over"]; c.clickCls = [c.clickCls, a + "-click"] } }, afterFieldRender: function () { var a = this, b = a.tooltip; a.initEvents(); if (b) { a.tooltip = null; a.setTooltip(b) } }, destroy: function () { var a = this; a.clickRepeater = a.el = Ext.destroy(a.clickRepeater, a.el); a.callParent() }, getBodyRenderData: Ext.emptyFn, getEl: function () { return this.el || null }, getStateEl: function () { return this.el }, hide: function () { var b = this, a = b.el; b.hidden = true; if (a) { a.hide() } }, initEvents: function () { var d = this, a = d.isFieldEnabled, c = d.getStateEl(), b = d.el; c.addClsOnOver(d.overCls, a, d); c.addClsOnClick(d.clickCls, a, d); if (d.repeatClick) { d.clickRepeater = new Ext.util.ClickRepeater(b, { preventDefault: true, handler: d.onClick, listeners: { mousedown: d.onClickRepeaterMouseDown, mouseup: d.onClickRepeaterMouseUp, scope: d }, scope: d }) } else { d.field.mon(b, { click: d.onClick, mousedown: d.onMouseDown, scope: d }) } }, isFieldEnabled: function () { return !this.field.disabled }, isVisible: function () { var a = this, c = a.field, b = false; if (a.hidden || !c || !a.rendered || a.destroyed) { b = true } return !b }, onClick: function () { var c = this, a = arguments, g = c.clickRepeater ? a[1] : a[0], b = c.handler, d = c.field; if (b && !d.readOnly && c.isFieldEnabled()) { Ext.callback(c.handler, c.scope, [d, c, g], 0, d) } }, resolveListenerScope: function (a) { return this.field.resolveSatelliteListenerScope(this, a) }, onMouseDown: function (a) { if (a.pointerType !== "touch" && (!this.field.containsFocus || this.focusOnMousedown)) { this.field.focus() } if (this.preventMouseDown) { a.preventDefault() } }, onClickRepeaterMouseDown: function (b, a) { if (!a.parentEvent || a.parentEvent.type === "mousedown") { this.field.inputEl.focus() } a.preventDefault() }, onClickRepeaterMouseUp: function (c) { var a = this, b = a.field; Ext.callback(a.endHandler, a.scope, [b, a, c], 0, b) }, onFieldBlur: function () { this.getStateEl().removeCls(this.focusCls) }, onFieldFocus: function () { this.getStateEl().addCls(this.focusCls) }, onFieldRender: function () { var b = this, a = b.el = b.field.triggerWrap.selectNode("#" + b.domId, false); a.setVisibilityMode(Ext.Element.DISPLAY); b.rendered = true }, renderBody: function (b) { var a = this, c = a.bodyTpl; Ext.apply(b, a.getBodyRenderData()); return c ? Ext.XTemplate.getTpl(a, "bodyTpl").apply(b) : "" }, renderTrigger: function (a) { var c = this, b = c.width, d = c.hidden ? "display:none;" : ""; if (b) { d += "width:" + b } return Ext.XTemplate.getTpl(c, "renderTpl").apply({ $trigger: c, fieldData: a, ui: a.ui, childElCls: a.childElCls, triggerId: c.domId = c.field.id + "-trigger-" + c.id, cls: c.cls, triggerStyle: d, extraCls: c.extraCls, baseCls: c.baseCls, ariaRole: c.ariaRole }) }, setHidden: function (a) { if (a !== this.hidden) { this[a ? "hide" : "show"]() } }, setTooltip: function (c) { var b = this, a = b.el, d = b.tooltip; if (c !== d) { b.tooltip = c; if (a) { a.dom.setAttribute("data-qtip", Ext.htmlEncode(c)) } } }, setVisible: function (a) { this.setHidden(!a) }, show: function () { var b = this, a = b.el; b.hidden = false; if (a) { a.show() } } }, 1, 0, 0, 0, ["trigger.trigger"], [[Ext.mixin.Factoryable.prototype.mixinId || Ext.mixin.Factoryable.$className, Ext.mixin.Factoryable]], [Ext.form.trigger, "Trigger"], 0)); (Ext.cmd.derive("Ext.form.field.Text", Ext.form.field.Base, { alternateClassName: ["Ext.form.TextField", "Ext.form.Text"], config: { hideTrigger: false, triggers: undefined }, renderConfig: { editable: true }, growMin: 30, growMax: 800, growAppend: "W", allowBlank: true, validateBlank: false, allowOnlyWhitespace: true, minLength: 0, maxLength: Number.MAX_VALUE, minLengthText: "The minimum length for this field is {0}", maxLengthText: "The maximum length for this field is {0}", blankText: "This field is required", regexText: "", emptyText: "", emptyCls: "x-form-empty-field", placeholderCoverCls: "x-placeholder-label", requiredCls: "x-form-required-field", ariaRole: "textbox", repeatTriggerClick: false, triggerWrapCls: "x-form-trigger-wrap", triggerWrapFocusCls: "x-form-trigger-wrap-focus", triggerWrapInvalidCls: "x-form-trigger-wrap-invalid", fieldBodyCls: "x-form-text-field-body", inputWrapCls: "x-form-text-wrap", inputWrapFocusCls: "x-form-text-wrap-focus", inputWrapInvalidCls: "x-form-text-wrap-invalid", growCls: "x-form-text-grow", emptyClsElements: null, needArrowKeys: true, squashMouseUp: { mouseup: function (a) { if (this.selectOnFocus) { this.inputEl.dom.select() } }, translate: false, single: true, preventDefault: true }, childEls: ["triggerWrap", "inputWrap", "placeholderLabel"], preSubTpl: ['<div id="{cmpId}-triggerWrap" data-ref="triggerWrap"', "<tpl if=\"ariaEl == 'triggerWrap'\">", '<tpl foreach="ariaElAttributes"> {$}="{.}"</tpl>', "<tpl else>", ' role="presentation"', "</tpl>", ' class="{triggerWrapCls} {triggerWrapCls}-{ui}">', '<div id={cmpId}-inputWrap data-ref="inputWrap"', ' role="presentation" class="{inputWrapCls} {inputWrapCls}-{ui}">'], postSubTpl: ['<tpl if="!Ext.supports.Placeholder">', '<label id="{cmpId}-placeholderLabel" data-ref="placeholderLabel" for="{id}" class="{placeholderCoverCls} {placeholderCoverCls}-{ui}">{placeholder}</label>', "</tpl>", "</div>", '<tpl for="triggers">{[values.renderTrigger(parent)]}</tpl>', "</div>"], initComponent: function () { var b = this, a = b.emptyCls; if (b.allowOnlyWhitespace === false) { b.allowBlank = false } if (b.size) { b.defaultBodyWidth = b.size * 6.5 + 20 } if (!b.onTrigger1Click) { b.onTrigger1Click = b.onTriggerClick } Ext.form.field.Base.prototype.initComponent.call(this); if (b.readOnly) { b.setReadOnly(b.readOnly) } b.fieldFocusCls = b.baseCls + "-focus"; b.emptyUICls = a + " " + a + "-" + b.ui; b.addStateEvents("change") }, initEvents: function () { var b = this, a = b.inputEl; Ext.form.field.Base.prototype.initEvents.call(this); if (b.selectOnFocus || b.emptyText) { b.mon(a, "mousedown", b.onMouseDown, b) } if (b.maskRe || (b.vtype && b.disableKeyFilter !== true && (b.maskRe = Ext.form.field.VTypes[b.vtype + "Mask"]))) { b.mon(a, "keypress", b.filterKeys, b) } if (b.enableKeyEvents) { b.mon(a, { scope: b, keyup: b.onKeyUp, keydown: b.onKeyDown, keypress: b.onKeyPress }) } }, isEqual: function (b, a) { return this.isEqualAsString(b, a) }, onChange: function (b, a) { Ext.form.field.Base.prototype.onChange.call(this, b, a); this.autoSize() }, getSubTplData: function (c) { var d = this, g = d.getRawValue(), i = d.emptyText && g.length < 1, a = d.maxLength, h, e, b; if (d.enforceMaxLength) { if (a === Number.MAX_VALUE) { a = undefined } } else { a = undefined } if (d.emptyText) { h = d.emptyText } e = Ext.apply(Ext.form.field.Base.prototype.getSubTplData.call(this, c), { triggerWrapCls: d.triggerWrapCls, inputWrapCls: d.inputWrapCls, placeholderCoverCls: d.placeholderCoverCls, triggers: d.orderedTriggers, maxLength: a, readOnly: !d.editable || d.readOnly, placeholder: h, value: g, fieldCls: d.fieldCls + (d.allowBlank ? "" : " " + d.requiredCls) + (i ? " " + d.emptyUICls : "") }); b = e.inputElAriaAttributes; if (b) { b["aria-required"] = !d.allowBlank } return e }, onRender: function () { var b = this, a = b.getTriggers(), c = [], d; if (Ext.supports.FixedTableWidthBug) { b.el._needsTableWidthFix = true } (arguments.callee.$previous || Ext.form.field.Base.prototype.onRender).call(this); if (a) { this.invokeTriggers("onFieldRender"); for (d in a) { c.push(a[d].el) } b.triggerEl = b.triggerCell = new Ext.CompositeElement(c, true) } b.inputCell = b.inputWrap }, afterRender: function () { var a = this; a.autoSize(); Ext.form.field.Base.prototype.afterRender.call(this); a.invokeTriggers("afterFieldRender"); a.emptyClsElements = [a.inputEl] }, onMouseDown: function () { if (!this.hasFocus) { this.squashMouseUp.scope = this; Ext.getDoc().on(this.squashMouseUp) } }, applyTriggers: function (h) { var j = this, c = j.getHideTrigger(), l = j.readOnly, m = j.orderedTriggers = [], k = j.repeatTriggerClick, b, g, d, a, e; if (!h) { h = {}; if (j.triggerCls && !j.trigger1Cls) { j.trigger1Cls = j.triggerCls } for (e = 1; (a = j["trigger" + e + "Cls"]); e++) { h["trigger" + e] = { cls: a, extraCls: "x-trigger-index-" + e, handler: "onTrigger" + e + "Click", compat4Mode: true, scope: j } } } for (b in h) { if (h.hasOwnProperty(b)) { g = h[b]; g.field = j; g.id = b; if ((l && g.hideOnReadOnly !== false) || (c && g.hidden !== false)) { g.hidden = true } if (k && (g.repeatClick !== false)) { g.repeatClick = true } d = h[b] = Ext.form.trigger.Trigger.create(g); m.push(d) } } Ext.Array.sort(m, Ext.form.trigger.Trigger.weightComparator); return h }, invokeTriggers: function (a, c) { var e = this, d = e.getTriggers(), g, b; if (d) { for (g in d) { if (d.hasOwnProperty(g)) { b = d[g]; b[a].apply(b, c || []) } } } }, getTrigger: function (a) { return this.getTriggers()[a] }, updateHideTrigger: function (a) { this.invokeTriggers(a ? "hide" : "show") }, updateEditable: function (a, b) { this.setReadOnlyAttr(!a || this.readOnly) }, setReadOnly: function (g) { var d = this, c = d.getTriggers(), b = d.getHideTrigger(), a, e; g = !!g; Ext.form.field.Base.prototype.setReadOnly.call(this, g); if (d.rendered) { d.setReadOnlyAttr(g || !d.editable) } if (c) { for (e in c) { a = c[e]; if (a.hideOnReadOnly === true || (a.hideOnReadOnly !== false && !b)) { a.setVisible(!g) } } } }, setReadOnlyAttr: function (d) { var b = this, a = "readonly", c = b.inputEl.dom; if (d) { c.setAttribute(a, a) } else { c.removeAttribute(a) } if (!b.ariaStaticRoles[b.ariaRole]) { b.inputEl.dom.setAttribute("aria-readonly", !!d) } }, processRawValue: function (c) { var b = this, e = b.stripCharsRe, a, d; if (e) { if (!e.global) { a = "g"; a += (e.ignoreCase) ? "i" : ""; a += (e.multiline) ? "m" : ""; e = new RegExp(e.source, a) } d = c.replace(e, ""); if (d !== c) { b.setRawValue(d); if (b.lastValue === c) { b.lastValue = d } c = d } } return c }, onDisable: function () { Ext.form.field.Base.prototype.onDisable.call(this); if (Ext.isIE) { this.inputEl.dom.unselectable = "on" } }, onEnable: function () { Ext.form.field.Base.prototype.onEnable.call(this); if (Ext.isIE) { this.inputEl.dom.unselectable = "" } }, onKeyDown: function (a) { this.fireEvent("keydown", this, a) }, onKeyUp: function (a) { this.fireEvent("keyup", this, a) }, onKeyPress: function (a) { this.fireEvent("keypress", this, a) }, getEmptyText: function () { return this.emptyText }, setEmptyText: function (b) { var a = this, c = a.inputEl; b = b || ""; a.emptyText = b; if (a.rendered) { if (Ext.supports.Placeholder && !a.simulatePlaceholder) { if (b) { c.dom.setAttribute("placeholder", b) } else { c.dom.removeAttribute("placeholder") } } else { a.placeholderLabel.setHtml(b) } a.refreshEmptyText() } return this }, afterFirstLayout: function () { Ext.form.field.Base.prototype.afterFirstLayout.call(this); if (Ext.isIE && this.disabled) { var a = this.inputEl; if (a) { a.dom.unselectable = "on" } } }, toggleInvalidCls: function (a) { var b = a ? "addCls" : "removeCls"; Ext.form.field.Base.prototype.toggleInvalidCls.call(this, a); this.triggerWrap[b](this.triggerWrapInvalidCls); this.inputWrap[b](this.inputWrapInvalidCls) }, onFieldMutation: function (a) { this.refreshEmptyText(); Ext.form.field.Base.prototype.onFieldMutation.call(this, a) }, refreshEmptyText: function () { var c = this, e = c.inputEl, a = c.emptyClsElements, d, g, b; if (e) { d = c.getValue(); g = !(e.dom.value || (Ext.isArray(d) && d.length)); if (c.placeholderLabel) { c.placeholderLabel.setDisplayed(g) } for (b = 0; b < a.length; b++) { a[b].toggleCls(c.emptyUICls, g) } } }, setValue: function (a) { a = Ext.form.field.Base.prototype.setValue.call(this, a); this.refreshEmptyText(); return a }, onFocus: function (c) { var b = this, a; Ext.form.field.Base.prototype.onFocus.call(this, c); Ext.asap(function () { if (!b.destroyed && document.activeElement === b.inputEl.dom) { a = b.inputEl.dom.value.length; b.selectText(b.selectOnFocus ? 0 : a, a) } }); if (b.emptyText) { b.autoSize() } b.addCls(b.fieldFocusCls); b.triggerWrap.addCls(b.triggerWrapFocusCls); b.inputWrap.addCls(b.inputWrapFocusCls); b.invokeTriggers("onFieldFocus", [c]) }, onBlur: function (b) { var a = this; Ext.form.field.Base.prototype.onBlur.call(this, b); a.removeCls(a.fieldFocusCls); a.triggerWrap.removeCls(a.triggerWrapFocusCls); a.inputWrap.removeCls(a.inputWrapFocusCls); a.invokeTriggers("onFieldBlur", [b]) }, filterKeys: function (b) { if ((b.ctrlKey && !b.altKey) || b.isSpecialKey()) { return } var a = String.fromCharCode(b.getCharCode()); if (!this.maskRe.test(a)) { b.stopEvent() } }, getState: function () { return this.addPropertyToState(Ext.form.field.Base.prototype.getState.call(this), "value") }, applyState: function (a) { Ext.form.field.Base.prototype.applyState.call(this, a); if (a.hasOwnProperty("value")) { this.setValue(a.value) } }, getErrors: function (l) { l = arguments.length ? (l == null ? "" : l) : this.processRawValue(this.getRawValue()); var g = this, j = Ext.form.field.Base.prototype.getErrors.call(this, l), a = g.validator, d = g.vtype, h = Ext.form.field.VTypes, i = g.regex, k = Ext.String.format, b, e, c; if (Ext.isFunction(a)) { b = a.call(g, l); if (b !== true) { j.push(b) } } e = g.allowOnlyWhitespace ? l : Ext.String.trim(l); if (e.length < 1) { if (!g.allowBlank) { j.push(g.blankText) } if (!g.validateBlank) { return j } c = true } if (!c && l.length < g.minLength) { j.push(k(g.minLengthText, g.minLength)) } if (l.length > g.maxLength) { j.push(k(g.maxLengthText, g.maxLength)) } if (d) { if (!h[d](l, g)) { j.push(g.vtypeText || h[d + "Text"]) } } if (i && !i.test(l)) { j.push(g.regexText || g.invalidText) } return j }, selectText: function (h, b) { var g = this, e = g.inputEl.dom, d = e.value, a = d.length, c; if (a > 0) { h = h === undefined ? 0 : Math.min(h, a); b = b === undefined ? a : Math.min(b, a); if (e.setSelectionRange) { e.setSelectionRange(h, b) } else { if (e.createTextRange) { c = e.createTextRange(); c.moveStart("character", h); c.moveEnd("character", b - a); c.select() } } } }, getGrowWidth: function () { return this.inputEl.dom.value }, autoSize: function () { var c = this, b, h, e, g, a, d; if (c.grow && c.rendered && c.getSizeModel().width.auto) { g = c.inputEl; b = c.getTriggers(); e = 0; d = Ext.util.Format.htmlEncode(c.getGrowWidth() || (c.hasFocus ? "" : c.emptyText) || ""); d += c.growAppend; for (h in b) { e += b[h].el.getWidth() } a = g.getTextWidth(d) + e + c.inputWrap.getBorderWidth("lr") + c.triggerWrap.getBorderWidth("lr"); a = Math.min(Math.max(a, c.growMin), c.growMax); c.bodyEl.setWidth(a); c.updateLayout(); c.fireEvent("autosize", c, a) } }, doDestroy: function () { var a = this; a.invokeTriggers("destroy"); Ext.destroy(a.triggerRepeater); Ext.form.field.Base.prototype.doDestroy.call(this) }, onTriggerClick: Ext.emptyFn, privates: { getTdType: function () { return "textfield" } }, deprecated: { 5: { methods: { getTriggerWidth: function () { var b = this.getTriggers(), a = 0, c; if (b && this.rendered) { for (c in b) { if (b.hasOwnProperty(c)) { a += b[c].el.getWidth() } } } return a } } } } }, 0, ["textfield"], ["component", "box", "field", "textfield"], { component: true, box: true, field: true, textfield: true }, ["widget.textfield"], 0, [Ext.form.field, "Text", Ext.form, "TextField", Ext.form, "Text"], 0)); (Ext.cmd.derive("Ext.form.field.TextArea", Ext.form.field.Text, { alternateClassName: "Ext.form.TextArea", fieldSubTpl: ['<textarea id="{id}" data-ref="inputEl" {inputAttrTpl}', '<tpl if="name"> name="{name}"</tpl>', '<tpl if="placeholder"> placeholder="{placeholder}"</tpl>', '<tpl if="maxLength !== undefined"> maxlength="{maxLength}"</tpl>', '<tpl if="readOnly"> readonly="readonly"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="tabIdx != null"> tabindex="{tabIdx}"</tpl>', ' class="{fieldCls} {typeCls} {typeCls}-{ui} {inputCls}" ', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', '<tpl foreach="ariaElAttributes"> {$}="{.}"</tpl>', '<tpl foreach="inputElAriaAttributes"> {$}="{.}"</tpl>', ' autocomplete="off">\n', '<tpl if="value">{[Ext.util.Format.htmlEncode(values.value)]}</tpl>', "</textarea>", { disableFormats: true }], growMin: 60, growMax: 1000, growAppend: "\n-", enterIsSpecial: false, preventScrollbars: false, returnRe: /\r/g, inputCls: "x-form-textarea", extraFieldBodyCls: "x-form-textarea-body", ariaAttributes: { "aria-multiline": true }, getSubTplData: function (b) { var d = this, c = d.getFieldStyle(), a = Ext.form.field.Text.prototype.getSubTplData.apply(this, arguments); if (d.grow) { if (d.preventScrollbars) { a.fieldStyle = (c || "") + ";overflow:hidden;height:" + d.growMin + "px" } } return a }, afterRender: function () { var a = this; Ext.form.field.Text.prototype.afterRender.apply(this, arguments); a.needsMaxCheck = a.enforceMaxLength && a.maxLength !== Number.MAX_VALUE && !Ext.supports.TextAreaMaxLength; if (a.needsMaxCheck) { a.inputEl.on("paste", a.onPaste, a) } }, transformRawValue: function (a) { return this.stripReturns(a) }, getValue: function () { return this.stripReturns(Ext.form.field.Text.prototype.getValue.call(this)) }, valueToRaw: function (a) { a = this.stripReturns(a); return Ext.form.field.Text.prototype.valueToRaw.call(this, a) }, stripReturns: function (a) { if (a && typeof a === "string") { a = a.replace(this.returnRe, "") } return a }, onPaste: function () { var a = this; if (!a.pasteTask) { a.pasteTask = new Ext.util.DelayedTask(a.pasteCheck, a) } a.pasteTask.delay(1) }, pasteCheck: function () { var b = this, c = b.getValue(), a = b.maxLength; if (c.length > a) { c = c.substr(0, a); b.setValue(c) } }, fireKey: function (d) { var b = this, a = d.getKey(), c; if (d.isSpecialKey() && (b.enterIsSpecial || (a !== d.ENTER || d.hasModifier()))) { b.fireEvent("specialkey", b, d) } if (a === d.ENTER) { d.stopPropagation() } if (b.needsMaxCheck && a !== d.BACKSPACE && a !== d.DELETE && !d.isNavKeyPress() && !b.isCutCopyPasteSelectAll(d, a)) { c = b.getValue(); if (c.length >= b.maxLength) { d.stopEvent() } } }, isCutCopyPasteSelectAll: function (b, a) { if (b.ctrlKey) { return a === b.A || a === b.C || a === b.V || a === b.X } return false }, autoSize: function () { var c = this, e, a, b, d; if (c.grow && c.rendered && c.getSizeModel().height.auto) { e = c.inputEl; b = e.getWidth(true); d = Ext.util.Format.htmlEncode(e.dom.value) || "&#160;"; d += c.growAppend; d = d.replace(/\n/g, "<br/>"); a = Ext.util.TextMetrics.measure(e, d, b).height + e.getPadding("tb") + c.inputWrap.getBorderWidth("tb") + c.triggerWrap.getBorderWidth("tb"); a = Math.min(Math.max(a, c.growMin), c.growMax); c.bodyEl.setHeight(a); c.updateLayout(); c.fireEvent("autosize", c, a) } }, doDestroy: function () { var a = this.pasteTask; if (a) { a.cancel() } Ext.form.field.Text.prototype.doDestroy.call(this) } }, 0, ["textarea", "textareafield"], ["component", "box", "field", "textfield", "textareafield", "textarea"], { component: true, box: true, field: true, textfield: true, textareafield: true, textarea: true }, ["widget.textarea", "widget.textareafield"], 0, [Ext.form.field, "TextArea", Ext.form, "TextArea"], 0)); (Ext.cmd.derive("Ext.window.MessageBox", Ext.window.Window, { OK: 1, YES: 2, NO: 4, CANCEL: 8, OKCANCEL: 9, YESNO: 6, YESNOCANCEL: 14, INFO: "x-message-box-info", WARNING: "x-message-box-warning", QUESTION: "x-message-box-question", ERROR: "x-message-box-error", hideMode: "offsets", closeAction: "hide", resizable: false, scrollable: true, title: "&#160;", defaultMinWidth: 250, defaultMaxWidth: 600, defaultMinHeight: 110, defaultMaxHeight: 500, minWidth: null, maxWidth: null, minHeight: null, maxHeight: null, constrain: true, cls: ["x-message-box", "x-hidden-offsets"], layout: { type: "vbox", align: "stretch" }, shrinkWrapDock: true, defaultTextHeight: 75, minProgressWidth: 250, minPromptWidth: 250, buttonText: { ok: "OK", yes: "Yes", no: "No", cancel: "Cancel" }, buttonIds: ["ok", "yes", "no", "cancel"], titleText: { confirm: "Confirm", prompt: "Prompt", wait: "Loading...", alert: "Attention" }, baseIconCls: "x-message-box-icon", ariaRole: "alertdialog", makeButton: function (a) { var b = this.buttonIds[a]; return new Ext.button.Button({ handler: this.btnCallback, itemId: b, scope: this, text: this.buttonText[b], minWidth: 75 }) }, btnCallback: function (a, c) { var b = this, d, e; if (c && c.type === "keydown" && !c.isSpecialKey()) { c.getTarget(null, null, true).on({ keyup: function (g) { b.btnCallback(a, g) }, single: true }); return } if (b.cfg.prompt || b.cfg.multiline) { if (b.cfg.multiline) { e = b.textArea } else { e = b.textField } d = e.getValue(); e.reset() } b.hide(); b.userCallback(a.itemId, d, b.cfg) }, hide: function () { var b = this, a = b.cfg ? b.cfg.cls : ""; b.progressBar.reset(); if (a) { b.removeCls(a) } Ext.window.Window.prototype.hide.apply(this, arguments) }, constructor: function (a) { var b = this; Ext.window.Window.prototype.constructor.apply(this, arguments); b.minWidth = b.defaultMinWidth = (b.minWidth || b.defaultMinWidth); b.maxWidth = b.defaultMaxWidth = (b.maxWidth || b.defaultMaxWidth); b.minHeight = b.defaultMinHeight = (b.minHeight || b.defaultMinHeight); b.maxHeight = b.defaultMaxHeight = (b.maxHeight || b.defaultMaxHeight) }, initComponent: function (a) { var e = this, b = e.id, d, c; e.title = e.title || "&#160;"; e.iconCls = e.iconCls || ""; e.topContainer = new Ext.container.Container({ layout: "hbox", padding: 10, style: { overflow: "hidden" }, items: [e.iconComponent = new Ext.Component({ cls: e.baseIconCls }), e.promptContainer = new Ext.container.Container({ flex: 1, layout: { type: "vbox", align: "stretch" }, items: [e.msg = new Ext.Component({ id: b + "-msg", cls: e.baseCls + "-text" }), e.textField = new Ext.form.field.Text({ id: b + "-textfield", enableKeyEvents: true, ariaAttributes: { "aria-labelledby": e.msg.id }, listeners: { keydown: e.onPromptKey, scope: e } }), e.textArea = new Ext.form.field.TextArea({ id: b + "-textarea", height: 75, ariaAttributes: { "aria-labelledby": e.msg.id } })] })] }); e.progressBar = new Ext.ProgressBar({ id: b + "-progressbar", margin: "0 10 10 10" }); e.items = [e.topContainer, e.progressBar]; e.msgButtons = []; for (d = 0; d < 4; d++) { c = e.makeButton(d); e.msgButtons[c.itemId] = c; e.msgButtons.push(c) } e.bottomTb = new Ext.toolbar.Toolbar({ id: b + "-toolbar", ui: "footer", dock: "bottom", enableFocusableContainer: false, ariaRole: null, layout: { pack: "center" }, items: [e.msgButtons[0], e.msgButtons[1], e.msgButtons[2], e.msgButtons[3]] }); e.dockedItems = [e.bottomTb]; e.on("close", e.onClose, e); Ext.window.Window.prototype.initComponent.call(this) }, afterRender: function () { var a = this; Ext.window.Window.prototype.afterRender.apply(this, arguments); a.textField.labelEl.dom.removeAttribute("for"); a.textArea.labelEl.dom.removeAttribute("for") }, onClose: function () { var a = this.msgButtons[3]; if (a) { this.btnCallback(a) } }, onPromptKey: function (a, c) { var b = this; if (c.keyCode === c.RETURN || c.keyCode === 10) { if (b.msgButtons.ok.isVisible()) { b.msgButtons.ok.handler.call(b, b.msgButtons.ok) } else { if (b.msgButtons.yes.isVisible()) { b.msgButtons.yes.handler.call(b, b.msgButtons.yes) } } } }, reconfigure: function (d) { var v = this, s = 0, k = true, x = v.buttonText, g = v.resizer, q = v.header, u = q && !q.isHeader, e = d && (d.message || d.msg), h = d.buttonTips, w, a, y, o, l, r, t, j, c, m, p, n, b; v.updateButtonText(); v.cfg = d = d || {}; n = d.wait; if (d.width) { o = d.width } if (d.height) { l = d.height } v.minWidth = d.minWidth || v.defaultMinWidth; v.maxWidth = d.maxWidth || v.defaultMaxWidth; v.minHeight = d.minHeight || v.defaultMinHeight; v.maxHeight = d.maxHeight || v.defaultMaxHeight; if ("maskClickAction" in d) { v.maskClickAction = d.maskClickAction } else { delete v.maskClickAction } if (g) { y = g.resizeTracker; g.minWidth = y.minWidth = v.minWidth; g.maxWidth = y.maxWidth = v.maxWidth; g.minHeight = y.minHeight = v.minHeight; g.maxHeight = y.maxHeight = v.maxHeight } delete v.defaultFocus; if (d.defaultFocus) { v.defaultFocus = d.defaultFocus } v.animateTarget = d.animateTarget || undefined; v.modal = d.modal !== false; if (d.title != null) { w = d.title } else { if (u && q.title != null) { w = q.title } else { w = v.title } } if (d.iconCls != null) { a = d.iconCls } else { if (u && q.iconCls != null) { a = q.iconCls } else { a = v.iconCls } } v.setTitle(w); v.setIconCls(a); if (Ext.isObject(d.buttons)) { v.buttonText = d.buttons; s = 0 } else { v.buttonText = d.buttonText || v.buttonText; s = Ext.isNumber(d.buttons) ? d.buttons : 0 } Ext.each(v.buttonIds, function (i) { v.msgButtons[i].setTooltip((h && h[i]) || null) }); s = s | v.updateButtonText(); v.buttonText = x; Ext.suspendLayouts(); v.width = v.height = null; if (o || l) { if (o) { v.setWidth(o) } if (l) { v.setHeight(l) } } if (!v.rendered) { v.render(Ext.getBody()) } v.closable = d.closable !== false && !n; q = v.header; if (q) { b = q.child("[type=close]"); if (b) { b.setVisible(v.closable) } if (!d.title && !v.closable && !d.iconCls) { q.hide() } else { q.show() } } v.liveDrag = !d.proxyDrag; v.userCallback = Ext.Function.bindCallback(d.callback || d.fn || Ext.emptyFn, d.scope || Ext.global); v.setIcon(d.icon); c = v.msg; if (e) { c.setHtml(e); c.show(); v.ariaEl.dom.setAttribute("aria-describedby", c.id) } else { c.hide(); v.ariaEl.dom.removeAttribute("aria-describedby") } t = v.textArea; j = v.textField; if (d.prompt || d.multiline) { v.multiline = d.multiline; if (d.multiline) { t.setValue(d.value); t.setHeight(d.defaultTextHeight || v.defaultTextHeight); t.show(); j.hide(); v.defaultFocus = t } else { j.setValue(d.value); t.hide(); j.show(); v.defaultFocus = j } v.ariaEl.dom.removeAttribute("aria-describedby") } else { t.hide(); j.hide() } m = v.progressBar; if (d.progress || n) { m.show(); v.updateProgress(0, d.progressText); v.defaultFocus = m; if (n) { m.wait(n === true ? d.waitConfig : n) } } else { m.hide() } p = v.msgButtons; for (r = 0; r < 4; r++) { if (s & Math.pow(2, r)) { if (!v.defaultFocus) { v.defaultFocus = p[r] } p[r].show(); k = false } else { p[r].hide() } } if (k) { v.bottomTb.hide() } else { v.bottomTb.show() } Ext.resumeLayouts(true) }, updateButtonText: function () { var d = this, c = d.buttonText, b = 0, e, a; for (e in c) { if (c.hasOwnProperty(e)) { a = d.msgButtons[e]; if (a) { if (d.cfg && d.cfg.buttonText) { b = b | Math.pow(2, Ext.Array.indexOf(d.buttonIds, e)) } if (a.text !== c[e]) { a.setText(c[e]) } } } } return b }, show: function (a) { var c = this, b; a = a || {}; if (Ext.Component.layoutSuspendCount) { Ext.on({ resumelayouts: function () { c.show(a) }, single: true }); return c } c.reconfigure(a); if (a.cls) { c.addCls(a.cls) } b = c.query("textfield:not([hidden]),textarea:not([hidden]),button:not([hidden])"); c.preventFocusOnActivate = !b.length; Ext.window.Window.prototype.show.call(this); return c }, onShow: function () { Ext.window.Window.prototype.onShow.apply(this, arguments); this.center() }, updateText: function (a) { this.msg.setHtml(a) }, setIcon: function (d, c, a) { var e = this, g = e.iconComponent, b = e.messageIconCls; if (b) { g.removeCls(b) } if (d) { g.show(); if (c || a) { g.setSize(c || g.getWidth(), a || g.getHeight()) } g.addCls("x-dlg-icon"); g.addCls(e.messageIconCls = d) } else { g.removeCls("x-dlg-icon"); g.hide() } return e }, updateProgress: function (c, a, b) { this.progressBar.updateProgress(c, a); if (b) { this.updateText(b) } return this }, onEsc: function () { if (this.closable !== false) { Ext.window.Window.prototype.onEsc.apply(this, arguments) } }, confirm: function (a, d, c, b) { if (Ext.isString(a)) { a = { title: a, icon: this.QUESTION, message: d, buttons: this.YESNO, callback: c, scope: b } } return this.show(a) }, prompt: function (g, d, c, b, a, e) { if (Ext.isString(g)) { g = { prompt: true, title: g, minWidth: this.minPromptWidth, message: d, buttons: this.OKCANCEL, callback: c, scope: b, multiline: a, value: e } } return this.show(g) }, wait: function (b, c, a) { if (Ext.isString(b)) { b = { title: c, message: b, closable: false, wait: true, modal: true, minWidth: this.minProgressWidth, waitConfig: a } } return this.show(b) }, alert: function (d, c, b, a) { if (Ext.isString(d)) { d = { title: d, message: c, buttons: this.OK, fn: b, scope: a, minWidth: this.minWidth } } return this.show(d) }, progress: function (c, b, a) { if (Ext.isString(c)) { c = { title: c, message: b, progress: true, progressText: a } } return this.show(c) } }, 1, ["messagebox"], ["component", "box", "container", "panel", "window", "messagebox"], { component: true, box: true, container: true, panel: true, window: true, messagebox: true }, ["widget.messagebox"], 0, [Ext.window, "MessageBox"], function (a) { Ext.onInternalReady(function () { Ext.MessageBox = Ext.Msg = new a() }) })); (Ext.cmd.derive("Ext.form.Basic", Ext.util.Observable, { alternateClassName: "Ext.form.BasicForm", taskDelay: 10, constructor: function (b, c) { var d = this, a; d.owner = b; d.fieldMonitors = { validitychange: d.checkValidityDelay, enable: d.checkValidityDelay, disable: d.checkValidityDelay, dirtychange: d.checkDirtyDelay, errorchange: d.checkErrorDelay, scope: d }; d.checkValidityTask = new Ext.util.DelayedTask(d.checkValidity, d); d.checkDirtyTask = new Ext.util.DelayedTask(d.checkDirty, d); d.checkErrorTask = new Ext.util.DelayedTask(d.checkError, d); d.monitor = new Ext.container.Monitor({ selector: "[isFormField]:not([excludeForm])", scope: d, addHandler: d.onFieldAdd, removeHandler: d.onFieldRemove, invalidateHandler: d.onMonitorInvalidate }); d.monitor.bind(b); Ext.apply(d, c); if (Ext.isString(d.paramOrder)) { d.paramOrder = d.paramOrder.split(/[\s,|]/) } a = d.reader; if (a && !a.isReader) { if (typeof a === "string") { a = { type: a } } d.reader = Ext.createByAlias("reader." + a.type, a) } a = d.errorReader; if (a && !a.isReader) { if (typeof a === "string") { a = { type: a } } d.errorReader = Ext.createByAlias("reader." + a.type, a) } Ext.util.Observable.prototype.constructor.call(this) }, initialize: function () { this.initialized = true; this.onValidityChange(!this.hasInvalidField()) }, timeout: 30, paramsAsHash: false, waitTitle: "Please Wait...", trackResetOnLoad: false, wasDirty: false, destroy: function () { var b = this, a = b.monitor; if (a) { a.unbind(); b.monitor = null } b.clearListeners(); b.checkValidityTask.cancel(); b.checkDirtyTask.cancel(); b.checkErrorTask.cancel(); b.checkValidityTask = b.checkDirtyTask = b.checkErrorTask = null; Ext.util.Observable.prototype.destroy.call(this) }, onFieldAdd: function (a) { a.on(this.fieldMonitors); this.onMonitorInvalidate() }, onFieldRemove: function (a) { a.un(this.fieldMonitors); this.onMonitorInvalidate() }, onMonitorInvalidate: function () { if (this.initialized) { this.checkValidityDelay() } }, getFields: function () { return this.monitor.getItems() }, getBoundItems: function () { var a = this._boundItems; if (!a || a.getCount() === 0) { a = this._boundItems = new Ext.util.MixedCollection(); a.addAll(this.owner.query("[formBind]")) } return a }, hasInvalidField: function () { return !!this.getFields().findBy(function (c) { var a = c.preventMark, b; c.preventMark = true; b = c.isValid(); c.preventMark = a; return !b }) }, isValid: function () { var a = this, b; Ext.suspendLayouts(); b = a.getFields().filterBy(function (c) { return !c.validate() }); Ext.resumeLayouts(true); return b.length < 1 }, checkValidity: function () { var b = this, a; if (b.destroyed) { return } a = !b.hasInvalidField(); if (a !== b.wasValid) { b.onValidityChange(a); b.fireEvent("validitychange", b, a); b.wasValid = a } }, checkValidityDelay: function () { var a = this.taskDelay; if (a) { this.checkValidityTask.delay(a) } else { this.checkValidity() } }, checkError: function () { this.fireEvent("errorchange", this) }, checkErrorDelay: function () { var a = this.taskDelay; if (a) { this.checkErrorTask.delay(a) } else { this.checkError() } }, onValidityChange: function (g) { var d = this.getBoundItems(), b, c, a, e; if (d) { b = d.items; a = b.length; for (c = 0; c < a; c++) { e = b[c]; if (e.disabled === g) { e.setDisabled(!g) } } } }, isDirty: function () { return !!this.getFields().findBy(function (a) { return a.isDirty() }) }, checkDirtyDelay: function () { var a = this.taskDelay; if (a) { this.checkDirtyTask.delay(a) } else { this.checkDirty() } }, checkDirty: function () { var b = this, a; if (b.destroyed) { return } a = this.isDirty(); if (a !== this.wasDirty) { this.fireEvent("dirtychange", this, a); this.wasDirty = a } }, hasUpload: function () { return !!this.getFields().findBy(function (a) { return a.isFileUpload() }) }, doAction: function (b, a) { if (Ext.isString(b)) { b = Ext.ClassManager.instantiateByAlias("formaction." + b, Ext.apply({}, a, { form: this })) } if (this.fireEvent("beforeaction", this, b) !== false) { this.beforeAction(b); Ext.defer(b.run, 100, b) } return this }, submit: function (a) { a = a || {}; var b = this, c; if (a.standardSubmit || b.standardSubmit) { c = "standardsubmit" } else { c = b.api ? "directsubmit" : "submit" } return b.doAction(c, a) }, load: function (a) { return this.doAction(this.api ? "directload" : "load", a) }, updateRecord: function (c) { c = c || this._record; if (!c) { return this } var b = c.self.fields, d = this.getFieldValues(), h = {}, g = 0, a = b.length, e; for (; g < a; ++g) { e = b[g].name; if (d.hasOwnProperty(e)) { h[e] = d[e] } } c.beginEdit(); c.set(h); c.endEdit(); return this }, loadRecord: function (a) { this._record = a; return this.setValues(a.getData()) }, getRecord: function () { return this._record }, beforeAction: function (c) { var g = this, b = c.waitMsg, j = "x-mask-loading", d = g.getFields().items, e, i = d.length, h, a; for (e = 0; e < i; e++) { h = d[e]; if (h.isFormField && h.syncValue) { h.syncValue() } } if (b) { a = g.waitMsgTarget; if (a === true) { g.owner.el.mask(b, j) } else { if (a) { a = g.waitMsgTarget = Ext.get(a); a.mask(b, j) } else { g.floatingAncestor = g.owner.up("[floating]"); if (g.floatingAncestor) { g.savePreventFocusOnActivate = g.floatingAncestor.preventFocusOnActivate; g.floatingAncestor.preventFocusOnActivate = true } Ext.MessageBox.wait(b, c.waitTitle || g.waitTitle) } } } }, afterAction: function (c, e) { var a = this; if (c.waitMsg) { var b = Ext.MessageBox, d = a.waitMsgTarget; if (d === true) { a.owner.el.unmask() } else { if (d) { d.unmask() } else { b.hide() } } } if (a.floatingAncestor) { a.floatingAncestor.preventFocusOnActivate = a.savePreventFocusOnActivate } if (e) { if (c.reset) { a.reset() } Ext.callback(c.success, c.scope || c, [a, c]); a.fireEvent("actioncomplete", a, c) } else { Ext.callback(c.failure, c.scope || c, [a, c]); a.fireEvent("actionfailed", a, c) } }, findField: function (a) { return this.getFields().findBy(function (b) { return b.id === a || b.name === a || b.dataIndex === a }) }, markInvalid: function (j) { var d = this, h, a, b, g, c; function i(e, l) { var k = d.findField(e); if (k) { k.markInvalid(l) } } if (Ext.isArray(j)) { a = j.length; for (h = 0; h < a; h++) { b = j[h]; i(b.id || b.field, b.msg || b.message) } } else { if (j instanceof Ext.data.ErrorCollection) { a = j.items.length; for (h = 0; h < a; h++) { b = j.items[h]; i(b.field, b.message) } } else { for (c in j) { if (j.hasOwnProperty(c)) { g = j[c]; i(c, g, j) } } } } return this }, setValues: function (b) { var d = this, a, c, g; function e(h, j) { var i = d.findField(h); if (i) { i.setValue(j); if (d.trackResetOnLoad) { i.resetOriginalValue() } } } Ext.suspendLayouts(); if (Ext.isArray(b)) { c = b.length; for (a = 0; a < c; a++) { g = b[a]; e(g.id, g.value) } } else { Ext.iterate(b, e) } Ext.resumeLayouts(true); return this }, getValues: function (j, k, o, m, c) { var n = {}, h = this.getFields().items, p = h.length, g = Ext.isArray, l, e, d, b, a, i; for (i = 0; i < p; i++) { l = h[i]; if (!k || l.isDirty()) { e = l[m ? "getModelData" : "getSubmitData"](o, c); if (Ext.isObject(e)) { for (a in e) { if (e.hasOwnProperty(a)) { d = e[a]; if (o && d === "") { d = l.emptyText || "" } if (!l.isRadio) { if (l.isCheckbox && d === null) { continue } if (n.hasOwnProperty(a)) { b = n[a]; if (!g(b)) { b = n[a] = [b] } if (g(d)) { n[a] = b.concat(d) } else { b.push(d) } } else { n[a] = d } } else { n[a] = n[a] || d } } } } } } if (j) { n = Ext.Object.toQueryString(n) } return n }, getFieldValues: function (a) { return this.getValues(false, a, false, true) }, clearInvalid: function () { Ext.suspendLayouts(); var b = this, a = b.getFields().items, c, d = a.length; for (c = 0; c < d; c++) { a[c].clearInvalid() } Ext.resumeLayouts(true); return b }, reset: function (b) { Ext.suspendLayouts(); var c = this, a = c.getFields().items, d, e = a.length; for (d = 0; d < e; d++) { a[d].reset() } Ext.resumeLayouts(true); if (b === true) { delete c._record } return c }, applyToFields: function (c) { var a = this.getFields().items, b, d = a.length; for (b = 0; b < d; b++) { Ext.apply(a[b], c) } return this }, applyIfToFields: function (c) { var a = this.getFields().items, b, d = a.length; for (b = 0; b < d; b++) { Ext.applyIf(a[b], c) } return this } }, 1, 0, 0, 0, 0, 0, [Ext.form, "Basic", Ext.form, "BasicForm"], 0)); (Ext.cmd.derive("Ext.form.FieldAncestor", Ext.Mixin, { mixinConfig: { id: "fieldAncestor", after: { initInheritedState: "initFieldInheritedState" }, before: { doDestroy: "onBeforeDestroy" } }, initFieldAncestor: function () { var a = this; a.monitor = new Ext.container.Monitor({ scope: a, selector: "[isFormField]:not([excludeForm])", addHandler: a.onChildFieldAdd, removeHandler: a.onChildFieldRemove }); a.initFieldDefaults() }, initMonitor: function () { this.monitor.bind(this) }, initFieldInheritedState: function (b) { var a = b.fieldDefaults, c = this.fieldDefaults; if (c) { if (a) { b.fieldDefaults = Ext.apply(Ext.Object.chain(a), c) } else { b.fieldDefaults = c } } }, onChildFieldAdd: function (b) { var a = this; a.mon(b, "errorchange", a.handleFieldErrorChange, a); a.mon(b, "validitychange", a.handleFieldValidityChange, a) }, onChildFieldRemove: function (b) { var a = this; a.mun(b, "errorchange", a.handleFieldErrorChange, a); a.mun(b, "validitychange", a.handleFieldValidityChange, a) }, initFieldDefaults: function () { if (!this.fieldDefaults) { this.fieldDefaults = {} } }, handleFieldValidityChange: function (c, b) { var a = this; if (c !== a) { a.fireEvent("fieldvaliditychange", a, c, b); a.onFieldValidityChange(c, b) } }, handleFieldErrorChange: function (b, a) { var c = this; if (b !== c) { c.fireEvent("fielderrorchange", c, b, a); c.onFieldErrorChange(b, a) } }, onFieldValidityChange: Ext.emptyFn, onFieldErrorChange: Ext.emptyFn, onBeforeDestroy: function () { this.monitor = Ext.destroy(this.monitor) } }, 0, 0, 0, 0, 0, 0, [Ext.form, "FieldAncestor"], 0)); (Ext.cmd.derive("Ext.layout.component.field.FieldContainer", Ext.layout.component.Auto, { type: "fieldcontainer", waitForOuterHeightInDom: true, waitForOuterWidthInDom: true, beginLayout: function (b) { var a = this.owner.containerEl; Ext.layout.component.Auto.prototype.beginLayout.call(this, b); b.hasRawContent = true; a.setStyle("width", ""); a.setStyle("height", ""); b.containerElContext = b.getEl("containerEl") }, calculateOwnerHeightFromContentHeight: function (c, b) { var a = Ext.layout.component.Auto.prototype.calculateOwnerHeightFromContentHeight.call(this, c, b); return a + this.getHeightAdjustment() }, calculateOwnerWidthFromContentWidth: function (c, b) { var a = Ext.layout.component.Auto.prototype.calculateOwnerWidthFromContentWidth.call(this, c, b); return a + this.getWidthAdjustment() }, measureContentHeight: function (a) { return a.hasDomProp("containerLayoutDone") ? Ext.layout.component.Auto.prototype.measureContentHeight.call(this, a) : NaN }, measureContentWidth: function (a) { return a.hasDomProp("containerLayoutDone") ? Ext.layout.component.Auto.prototype.measureContentWidth.call(this, a) : NaN }, publishInnerHeight: function (b, a) { a -= this.getHeightAdjustment(); b.containerElContext.setHeight(a) }, publishInnerWidth: function (b, a) { a -= this.getWidthAdjustment(); b.containerElContext.setWidth(a) }, privates: { getHeightAdjustment: function () { var a = this.owner, b = 0; if (a.labelAlign === "top" && a.hasVisibleLabel()) { b += a.labelEl.getHeight() } if (a.msgTarget === "under" && a.hasActiveError()) { b += a.errorWrapEl.getHeight() } return b + a.bodyEl.getPadding("tb") }, getWidthAdjustment: function () { var a = this.owner, b = 0; if (a.labelAlign !== "top" && a.hasVisibleLabel()) { b += (a.labelWidth + (a.labelPad || 0)) } if (a.msgTarget === "side" && a.hasActiveError()) { b += a.errorWrapEl.getWidth() } return b + a.bodyEl.getPadding("lr") } } }, 0, 0, 0, 0, ["layout.fieldcontainer"], 0, [Ext.layout.component.field, "FieldContainer"], 0)); (Ext.cmd.derive("Ext.form.FieldContainer", Ext.container.Container, { componentLayout: "fieldcontainer", componentCls: "x-form-fieldcontainer", shrinkWrap: true, autoEl: { tag: "div", role: "presentation" }, childEls: ["containerEl"], combineLabels: false, labelConnector: ", ", combineErrors: false, maskOnDisable: false, invalidCls: "", fieldSubTpl: ['<div id="{id}-containerEl" data-ref="containerEl" class="{containerElCls}"', '<tpl if="ariaAttributes">', '<tpl foreach="ariaAttributes"> {$}="{.}"</tpl>', "<tpl else>", ' role="presentation"', "</tpl>", ">", "{%this.renderContainer(out,values)%}", "</div>"], initComponent: function () { var a = this; a.initLabelable(); a.initFieldAncestor(); Ext.container.Container.prototype.initComponent.call(this); a.initMonitor() }, onAdd: function (a) { var b = this; if (a.isLabelable && Ext.isGecko && Ext.firefoxVersion < 37 && b.layout.type === "absolute" && !b.hideLabel && b.labelAlign !== "top") { a.x += (b.labelWidth + b.labelPad) } Ext.container.Container.prototype.onAdd.apply(this, arguments); if (a.isLabelable && b.combineLabels) { a.oldHideLabel = a.hideLabel; a.hideLabel = true } b.updateLabel() }, onRemove: function (a, b) { var c = this; Ext.container.Container.prototype.onRemove.apply(this, arguments); if (!b) { if (a.isLabelable && c.combineLabels) { a.hideLabel = a.oldHideLabel } c.updateLabel() } }, initRenderData: function () { var a = this, b = Ext.container.Container.prototype.initRenderData.call(this); b.containerElCls = a.containerElCls; b = Ext.applyIf(b, a.getLabelableRenderData()); if (a.labelAlign === "top" || a.msgTarget === "under") { b.extraFieldBodyCls += " x-field-container-body-vertical" } b.tipAnchorTarget = a.id + "-containerEl"; return b }, getFieldLabel: function () { var a = this.fieldLabel || ""; if (!a && this.combineLabels) { a = Ext.Array.map(this.query("[isFieldLabelable]"), function (b) { return b.getFieldLabel() }).join(this.labelConnector) } return a }, getSubTplData: function () { var a = this.initRenderData(); Ext.apply(a, this.subTplData); return a }, getSubTplMarkup: function (b) { var d = this, a = d.lookupTpl("fieldSubTpl"), c; if (!a.renderContent) { d.setupRenderTpl(a) } c = a.apply(d.getSubTplData(b)); return c }, updateLabel: function () { var b = this, a = b.labelEl; if (a) { b.setFieldLabel(b.getFieldLabel()) } }, onFieldErrorChange: function () { if (this.combineErrors) { var c = this, d = c.getActiveError(), b = Ext.Array.filter(c.query("[isFormField]"), function (e) { return e.hasActiveError() }), a = c.getCombinedErrors(b); if (a) { c.setActiveErrors(a) } else { c.unsetActiveError() } if (d !== c.getActiveError()) { c.updateLayout() } } }, getCombinedErrors: function (e) { var k = [], c, l = e.length, i, d, j, b, g, h; for (c = 0; c < l; c++) { i = e[c]; d = i.getActiveErrors(); b = d.length; for (j = 0; j < b; j++) { g = d[j]; h = i.getFieldLabel(); k.push((h ? h + ": " : "") + g) } } return k }, privates: { applyTargetCls: function (b) { var a = this.containerElCls; this.containerElCls = a ? a + " " + b : b }, getTargetEl: function () { return this.containerEl }, initRenderTpl: function () { var a = this; if (!a.hasOwnProperty("renderTpl")) { a.renderTpl = a.lookupTpl("labelableRenderTpl") } return Ext.container.Container.prototype.initRenderTpl.call(this) } } }, 0, ["fieldcontainer"], ["component", "box", "container", "fieldcontainer"], { c